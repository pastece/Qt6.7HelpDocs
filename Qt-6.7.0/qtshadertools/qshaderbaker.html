<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qshaderbaker.cpp -->
  <meta name="description" content="Compiles a GLSL/Vulkan shader into SPIR-V, translates into other shading languages, and gathers reflection metadata.">
  <title>QShaderBaker Class | Shader Tools 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtshadertools-index.html" translate="no">Shader Tools</a></li>
<li>QShaderBaker</li>
<li id="buildversion"><a href="qtshadertools-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#typical-workflow">Typical Workflow</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QShaderBaker Class</h1>
<!-- $$$QShaderBaker-brief -->
<p>Compiles a GLSL/Vulkan shader into SPIR-V, translates into other shading languages, and gathers reflection metadata. <a href="#details">More...</a></p>
<!-- @@@QShaderBaker -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QShaderBaker&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
</table></div>
<ul>
<li><a href="qshaderbaker-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#GeneratedShader-typedef" translate="no">GeneratedShader</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#SpirvOption-enum" translate="no">SpirvOptions</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#QShaderBaker" translate="no">QShaderBaker</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#dtor.QShaderBaker" translate="no">~QShaderBaker</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShader </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#bake" translate="no">bake</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#errorMessage" translate="no">errorMessage</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setBatchableVertexShaderExtraInputLocation" translate="no">setBatchableVertexShaderExtraInputLocation</a></b>(int <i>location</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setBreakOnShaderTranslationError" translate="no">setBreakOnShaderTranslationError</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setGeneratedShaderVariants" translate="no">setGeneratedShaderVariants</a></b>(const QList&lt;QShader::Variant&gt; &amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setGeneratedShaders" translate="no">setGeneratedShaders</a></b>(const QList&lt;QShaderBaker::GeneratedShader&gt; &amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setMultiViewCount" translate="no">setMultiViewCount</a></b>(int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setPerTargetCompilation" translate="no">setPerTargetCompilation</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setPreamble" translate="no">setPreamble</a></b>(const QByteArray &amp;<i>preamble</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setSourceDevice" translate="no">setSourceDevice</a></b>(QIODevice *<i>device</i>, QShader::Stage <i>stage</i>, const QString &amp;<i>fileName</i> = QString())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setSourceFileName" translate="no">setSourceFileName</a></b>(const QString &amp;<i>fileName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setSourceFileName-1" translate="no">setSourceFileName</a></b>(const QString &amp;<i>fileName</i>, QShader::Stage <i>stage</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setSourceString" translate="no">setSourceString</a></b>(const QByteArray &amp;<i>sourceString</i>, QShader::Stage <i>stage</i>, const QString &amp;<i>fileName</i> = QString())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setTessellationMode" translate="no">setTessellationMode</a></b>(QShaderDescription::TessellationMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshaderbaker.html#setTessellationOutputVertexCount" translate="no">setTessellationOutputVertexCount</a></b>(int <i>count</i>)</td></tr>
</table></div>
<!-- $$$QShaderBaker-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<div class="admonition warning">
<p><b>Warning: </b>QShaderBaker, just like the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> family of classes in the Qt Gui module, including <a href="../qtgui/qshader.html" translate="no">QShader</a> and <a href="../qtgui/qshaderdescription.html" translate="no">QShaderDescription</a>, offers limited compatibility guarantees. There are no source or binary compatibility guarantees for these classes, meaning the API is only guaranteed to work with the Qt version the application was developed against. Source incompatible changes are however aimed to be kept at a minimum and will only be made in minor releases (6.7, 6.8, and so on). To use this class in an application, link to <code translate="no">Qt::ShaderToolsPrivate</code> (if using CMake), and include the headers with the <code translate="no">rhi</code> prefix, for example <code translate="no">#include &lt;rhi/qshaderbaker.h&gt;</code>.</p>
</div>
<p>QShaderBaker takes a graphics (vertex, fragment, etc.) or compute shader, and produces multiple - either source or bytecode - variants of it, together with reflection information. The results are represented by a <a href="../qtgui/qshader.html" translate="no">QShader</a> instance, which also provides simple and fast serialization and deserialization.</p>
<div class="admonition note">
<p><b>Note: </b>Applications and libraries are recommended to avoid using this class directly. Rather, all Qt users are encouraged to rely on offline compilation by invoking the <code translate="no">qsb</code> command-line tool at build time via CMake. The <code translate="no">qsb</code> tool uses QShaderBaker and writes the serialized version of the generated <a href="../qtgui/qshader.html" translate="no">QShader</a> into a file. The usage of this class should be restricted to cases where run time compilation cannot be avoided, such as when working with user-provided or dynamically generated shader source strings.</p>
</div>
<p>The input format is always assumed to be Vulkan-flavored GLSL at the moment. See the <a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt" translate="no">GL_KHR_vulkan_glsl specification</a> for an overview, keeping in mind that the Qt Shader Tools module is meant to be used in combination with the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> classes from Qt Rendering Hardware Interface module, and therefore a number of concepts and constructs (push constants, storage buffers, subpasses, etc.) are not applicable at the moment. Additional options may be introduced in the future, for example, by enabling <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl" translate="no">HLSL</a> as a source format, once HLSL to SPIR-V compilation is deemed suitable.</p>
<p>The reflection metadata is retrievable from the resulting <a href="../qtgui/qshader.html" translate="no">QShader</a> by calling <a href="../qtgui/qshader.html#description" translate="no">QShader::description</a>(). This is essential when having to discover what set of vertex inputs and shader resources a shader expects, and what the layouts of those are, as many modern graphics APIs offer no built-in shader reflection capabilities.</p>
<h4 id="typical-workflow">Typical Workflow</h4>
<p>Let's assume an application has a vertex and fragment shader like the following:</p>
<p>Vertex shader:</p>
<pre class="cpp" translate="no">
 #version 440

 layout(location = 0) in vec4 position;
 layout(location = 1) in vec3 color;
 layout(location = 0) out vec3 v_color;

 layout(std140, binding = 0) uniform buf {
     mat4 mvp;
     float opacity;
 };

 void main()
 {
     v_color = color;
     gl_Position = mvp * position;
 }
</pre>
<p>Fragment shader:</p>
<pre class="cpp" translate="no">
 #version 440

 layout(location = 0) in vec3 v_color;
 layout(location = 0) out vec4 fragColor;

 layout(std140, binding = 0) uniform buf {
     mat4 mvp;
     float opacity;
 };

 void main()
 {
     fragColor = vec4(v_color * opacity, opacity);
 }
</pre>
<p>To get <a href="../qtgui/qshader.html" translate="no">QShader</a> instances that can be passed as-is to a <a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a>, there are two options: doing the shader pack generation off line, or at run time.</p>
<p>The former involves running the <code translate="no">qsb</code> tool:</p>
<pre class="cpp plain" translate="no">
 qsb --glsl &quot;100 es,120&quot; --hlsl 50 --msl 12 color.vert -o color.vert.qsb
 qsb --glsl &quot;100 es,120&quot; --hlsl 50 --msl 12 color.frag -o color.frag.qsb
</pre>
<p>The example uses the translation targets as appropriate for <a href="../qtgui/qrhi.html" translate="no">QRhi</a>. This means GLSL/ES 100, GLSL 120, HLSL Shader Model 5.0, and Metal Shading Language 1.2.</p>
<p>Note how the command line options correspond to what can be specified via <a href="qshaderbaker.html#setGeneratedShaders" translate="no">setGeneratedShaders</a>(). Once the resulting files are available, they can be shipped with the application (typically embedded into the executable the the Qt Resource System), and can be loaded and passed to <a href="../qtgui/qshader.html#fromSerialized" translate="no">QShader::fromSerialized</a>() at run time.</p>
<p>While not shown here, <code translate="no">qsb</code> can do more: it is also able to invoke <code translate="no">fxc</code> on Windows or the appropriate XCode tools on macOS to compile the generated HLSL or Metal shader code into bytecode and include the compiled versions in the <a href="../qtgui/qshader.html" translate="no">QShader</a>. After a baked shader pack is written into a file, its contents can be examined by running <code translate="no">qsb -d</code> on it. Run <code translate="no">qsb</code> with <code translate="no">--help</code> for more information.</p>
<p>The alternative approach is to perform the same at run time. This involves creating a QShaderBaker instance, calling <a href="qshaderbaker.html#setSourceFileName" translate="no">setSourceFileName</a>(), and then setting up the translation targets via <a href="qshaderbaker.html#setGeneratedShaders" translate="no">setGeneratedShaders</a>():</p>
<pre class="cpp plain" translate="no">
 baker.setGeneratedShaderVariants({ QShader::StandardShader });
 QList&lt;QShaderBaker::GeneratedShader&gt; targets;
 targets.append({ QShader::SpirvShader, QShaderVersion(100) });
 targets.append({ QShader::GlslShader, QShaderVersion(100, QShaderVersion::GlslEs) });
 targets.append({ QShader::SpirvShader, QShaderVersion(120) });
 targets.append({ QShader::HlslShader, QShaderVersion(50) });
 targets.append({ QShader::MslShader, QShaderVersion(12) });
 baker.setGeneratedShaders(targets);
 QShader shaders = baker.bake();
 if (!shaders.isValid())
     qWarning() &lt;&lt; baker.errorMessage();
</pre>
</div>
<p><b>See also </b><a href="../qtgui/qshader.html" translate="no">QShader</a>.</p>
<!-- @@@QShaderBaker -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$GeneratedShader -->
<h3 class="fn" translate="no" id="GeneratedShader-typedef">QShaderBaker::<span class="name">GeneratedShader</span></h3>
<p>Synonym for <a href="../qtcore/qpair-qtcore-proxy.html#QPair-typedef" translate="no">QPair</a>&lt;<a href="../qtgui/qshader.html#Source-enum" translate="no">QShader::Source</a>, <a href="../qtgui/qshaderversion.html" translate="no">QShaderVersion</a>&gt;.</p>
<!-- @@@GeneratedShader -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QShaderBaker[overload1]$$$QShaderBaker -->
<h3 class="fn" translate="no" id="QShaderBaker">QShaderBaker::<span class="name">QShaderBaker</span>()</h3>
<p>Constructs a new QShaderBaker.</p>
<!-- @@@QShaderBaker -->
<!-- $$$~QShaderBaker[overload1]$$$~QShaderBaker -->
<h3 class="fn" translate="no" id="dtor.QShaderBaker"><code class="details extra" translate="no">[noexcept]</code> QShaderBaker::<span class="name">~QShaderBaker</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QShaderBaker -->
<!-- $$$bake[overload1]$$$bake -->
<h3 class="fn" translate="no" id="bake"><span class="type"><a href="../qtgui/qshader.html" translate="no">QShader</a></span> QShaderBaker::<span class="name">bake</span>()</h3>
<p>Runs the compilation and translation process.</p>
<p>Returns a <a href="../qtgui/qshader.html" translate="no">QShader</a> instance. To check if the process was successful, call <a href="../qtgui/qshader.html#isValid" translate="no">QShader::isValid</a>(). When that indicates <code translate="no">false</code>, call <a href="qshaderbaker.html#errorMessage" translate="no">errorMessage</a>() to retrieve the log.</p>
<p>This is an expensive operation. When calling this from applications, it can be advisable to do it on a separate thread.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qshaderbaker.html" translate="no">QShaderBaker</a> instances are reusable: after calling bake(), the same instance can be used with different inputs again. However, a <a href="qshaderbaker.html" translate="no">QShaderBaker</a> instance should only be used on one single thread during its lifetime.</p>
</div>
<!-- @@@bake -->
<!-- $$$errorMessage[overload1]$$$errorMessage -->
<h3 class="fn" translate="no" id="errorMessage"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QShaderBaker::<span class="name">errorMessage</span>() const</h3>
<p>Returns the error message from the last <a href="qshaderbaker.html#bake" translate="no">bake</a>() run, or an empty string if there was no error.</p>
<div class="admonition note">
<p><b>Note: </b>Errors include file read errors, compilation, and translation failures. Not requesting any targets or variants does not count as an error even though the resulting <a href="../qtgui/qshader.html" translate="no">QShader</a> is invalid.</p>
</div>
<!-- @@@errorMessage -->
<!-- $$$setBatchableVertexShaderExtraInputLocation[overload1]$$$setBatchableVertexShaderExtraInputLocationint -->
<h3 class="fn" translate="no" id="setBatchableVertexShaderExtraInputLocation"><span class="type">void</span> QShaderBaker::<span class="name">setBatchableVertexShaderExtraInputLocation</span>(<span class="type">int</span> <i>location</i>)</h3>
<p>When generating a <a href="../qtgui/qshader.html#Variant-enum" translate="no">QShader::BatchableVertexShader</a> variant, <i translate="no">location</i> specifies the input location for the inserted vertex input. The value is by default 7 and needs to be overridden only if the vertex shader already uses input location 7.</p>
<!-- @@@setBatchableVertexShaderExtraInputLocation -->
<!-- $$$setBreakOnShaderTranslationError[overload1]$$$setBreakOnShaderTranslationErrorbool -->
<h3 class="fn" translate="no" id="setBreakOnShaderTranslationError"><span class="type">void</span> QShaderBaker::<span class="name">setBreakOnShaderTranslationError</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Controls the behavior when shader translation (from SPIR-V to GLSL/HLSL/MSL) fails. By default this setting is true, which will cause <a href="qshaderbaker.html#bake" translate="no">bake</a>() to return with an error if a requested shader cannot be generated. If that is not desired, and the intention is to generate what we can but silently skip the rest, then set <i translate="no">enable</i> to false.</p>
<p>Targeting multiple GLSL versions can lead to errors when a feature is not translatable to a given version. For example, attempting to translate a shader using textureSize() to GLSL ES 100 would fail the entire <a href="qshaderbaker.html#bake" translate="no">bake</a>() call with the error message &quot;textureSize is not supported in ESSL 100&quot;. If it is acceptable to not have a GLSL ES 100 shader in the result, even though it was requested, then setting this flag to false makes <a href="qshaderbaker.html#bake" translate="no">bake</a>() to succeed.</p>
<!-- @@@setBreakOnShaderTranslationError -->
<!-- $$$setGeneratedShaderVariants[overload1]$$$setGeneratedShaderVariantsconstQList<QShader::Variant>& -->
<h3 class="fn" translate="no" id="setGeneratedShaderVariants"><span class="type">void</span> QShaderBaker::<span class="name">setGeneratedShaderVariants</span>(const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtgui/qshader.html#Variant-enum" translate="no">QShader::Variant</a></span>&gt; &amp;<i>v</i>)</h3>
<p>Specifies which shader variants are generated. Each shader version can have multiple variants in the resulting <a href="../qtgui/qshader.html" translate="no">QShader</a>.</p>
<p>In most cases <i translate="no">v</i> contains a single entry, <a href="../qtgui/qshader.html#Variant-enum" translate="no">QShader::StandardShader</a>.</p>
<div class="admonition note">
<p><b>Note: </b>when no variants are set, the resulting <a href="../qtgui/qshader.html" translate="no">QShader</a> will be empty and thus invalid.</p>
</div>
<!-- @@@setGeneratedShaderVariants -->
<!-- $$$setGeneratedShaders[overload1]$$$setGeneratedShadersconstQList<QShaderBaker::GeneratedShader>& -->
<h3 class="fn" translate="no" id="setGeneratedShaders"><span class="type">void</span> QShaderBaker::<span class="name">setGeneratedShaders</span>(const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qshaderbaker.html#GeneratedShader-typedef" translate="no">QShaderBaker::GeneratedShader</a></span>&gt; &amp;<i>v</i>)</h3>
<p>Specifies what kind of shaders to compile or translate to. Nothing is generated by default so calling this function before <a href="qshaderbaker.html#bake" translate="no">bake</a>() is mandatory</p>
<div class="admonition note">
<p><b>Note: </b>when this function is not called or <i translate="no">v</i> is empty or contains only invalid entries, the resulting <a href="../qtgui/qshader.html" translate="no">QShader</a> will be empty and thus invalid.</p>
</div>
<p>For example, the minimal possible baking target is SPIR-V, without any additional translations to other languages. To request this, do:</p>
<pre class="cpp plain" translate="no">
 baker.setGeneratedShaders({ QShader::SpirvShader, QShaderVersion(100) });
</pre>
<div class="admonition note">
<p><b>Note: </b><a href="qshaderbaker.html" translate="no">QShaderBaker</a> only handles the SPIR-V and human-readable source targets. Further compilation into API-specific intermediate formats, such as <a href="../qtgui/qshader.html#Source-enum" translate="no">QShader::DxbcShader</a> or <a href="../qtgui/qshader.html#Source-enum" translate="no">QShader::MetalLibShader</a> is implemented by the <code translate="no">qsb</code> command-line tool, and is not part of the <a href="qshaderbaker.html" translate="no">QShaderBaker</a> runtime API.</p>
</div>
<!-- @@@setGeneratedShaders -->
<!-- $$$setMultiViewCount[overload1]$$$setMultiViewCountint -->
<h3 class="fn" translate="no" id="setMultiViewCount"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">void</span> QShaderBaker::<span class="name">setMultiViewCount</span>(<span class="type">int</span> <i>count</i>)</h3>
<p>When transpiling shaders using multiview (e.g. a vertex shader using gl_ViewIndex for a renderer relying on GL_OVR_multiview2, VK_KHR_multiview, etc.), for some of the targets it is necessary to declare the number of views in the shader. This is not done in the Vulkan-style GLSL code, and is not relevant for targets such as SPIR-V or HLSL, but is required for OpenGL and GLSL, and so the value has to be provided as additional metadata.</p>
<p>By default the value is 0, which disables injecting the <code translate="no">num_views</code> statement. Setting 1 is not useful since that is the default <code translate="no">num_views</code> regardless. Therefore <i translate="no">count</i> should be &gt;= 2 to make an effect. When set to, for example, 2, the generated GLSL shader will contain a <code translate="no">layout(num_views = 2) in;</code> statement.</p>
<p>Setting a <i translate="no">count</i> of 2 or greater also injects some preprocessor statements: <code translate="no">QSHADER_VIEW_COUNT</code> is set to <i translate="no">count</i>, whereas the <code translate="no">GL_EXT_multiview</code> extension is enabled automatically. Therefore, setting the appropriate <i translate="no">count</i> can be relevant with other types of shaders as well, e.g. when sharing a uniform buffer between the vertex and fragment shader and both shaders have to be able to write something like <code translate="no">#if QSHADER_VIEW_COUNT &gt;= 2</code>.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@setMultiViewCount -->
<!-- $$$setPerTargetCompilation[overload1]$$$setPerTargetCompilationbool -->
<h3 class="fn" translate="no" id="setPerTargetCompilation"><span class="type">void</span> QShaderBaker::<span class="name">setPerTargetCompilation</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Sets per-target compilation to <i translate="no">enable</i>. By default this is disabled, meaning that the Vulkan/GLSL source is compiled to SPIR-V once per variant. (so once by default, twice if it is a vertex shader and the Batchable variant as requested as well). The resulting SPIR-V is then translated to the various target languages (GLSL, HLSL, MSL).</p>
<p>In per-target compilation mode, there is a separate GLSL to SPIR-V compilation step for each target, meaning for each GLSL/HLSL/MSL version requested via <a href="qshaderbaker.html#setGeneratedShaders" translate="no">setGeneratedShaders</a>(). The input source is the same, but with target-specific preprocessor defines inserted. This is significantly more time consuming, but allows applications to provide a single shader and use <code translate="no">#ifdef</code> blocks to differentiate. When this mode is disabled, the only way to achieve the same is to provide multiple versions of the shader file, process each separately, ship {.qsb} files for each, and choose the right file based on run time logic.</p>
<p>The following macros will be automatically defined in this mode. Note that the macros are always tied to shading languages, not graphics APIs.</p>
<ul>
<li><code translate="no">QSHADER_SPIRV</code> - defined when targeting SPIR-V (to be consumed, typically, by Vulkan).</li>
<li><code translate="no">QSHADER_SPIRV_VERSION</code> - the targeted SPIR-V version number, such as <code translate="no">100</code>.</li>
<li><code translate="no">QSHADER_GLSL</code> - defined when targeting GLSL or GLSL ES (to be consumed, typically, by OpenGL or OpenGL ES)</li>
<li><code translate="no">QSHADER_GLSL_VERSION</code> - the targeted GLSL or GLSL ES version number, such as <code translate="no">100</code>, <code translate="no">300</code>, or <code translate="no">330</code>.</li>
<li><code translate="no">QSHADER_GLSL_ES</code> - defined only when targeting GLSL ES</li>
<li><code translate="no">QSHADER_HLSL</code> - defined when targeting HLSL (to be consumed, typically, by Direct 3D)</li>
<li><code translate="no">QSHADER_HLSL_VERSION</code> - the targeted HLSL shader model version, such as <code translate="no">50</code></li>
<li><code translate="no">QSHADER_MSL</code> - defined when targeting the Metal Shading Language (to be consumed, typically, by Metal)</li>
<li><code translate="no">QSHADER_MSL_VERSION</code> - the targeted MSL version, such as <code translate="no">12</code> or <code translate="no">20</code>.</li>
</ul>
<p>This allows writing shader code like the following.</p>
<pre class="cpp plain" translate="no">
 #if QSHADER_HLSL || QSHADER_MSL
 vec2 uv = vec2(uv_coord.x, 1.0 - uv_coord.y);
 #else
 vec2 uv = uv_coord;
 #endif
</pre>
<div class="admonition note">
<p><b>Note: </b>Version numbers follow the GLSL-inspired <a href="../qtgui/qshaderversion.html" translate="no">QShaderVersion</a> syntax and thus are a single integer always.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>There is only one <a href="../qtgui/qshaderdescription.html" translate="no">QShaderDescription</a> per <a href="../qtgui/qshader.html" translate="no">QShader</a>, no matter how many individual targets there are. Therefore members of uniform blocks, vertex inputs, etc. must not be made conditional using the macros described above.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>Be aware of the differences between the concepts of graphics APIs and shading languages. <a href="qshaderbaker.html" translate="no">QShaderBaker</a> and the related tools work strictly with the concept of shading languages, ignoring how the results are consumed afterwards. Therefore, if the higher layers in the Qt graphics stack one day start using SPIR-V also for an API other than Vulkan, the assumption that QSHADER_SPIRV implies Vulkan will no longer hold.</p>
</div>
<!-- @@@setPerTargetCompilation -->
<!-- $$$setPreamble[overload1]$$$setPreambleconstQByteArray& -->
<h3 class="fn" translate="no" id="setPreamble"><span class="type">void</span> QShaderBaker::<span class="name">setPreamble</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>preamble</i>)</h3>
<p>Specifies a custom <i translate="no">preamble</i> that is processed before the normal shader code.</p>
<p>This is more than just prepending to the source string: the validity of the GLSL version directive, which is required to be placed before everything else, is not affected. Line numbers in the reported error messages also remain unchanged, ignoring the contents given in the <i translate="no">preamble</i>.</p>
<p>One use case for preambles is to transparently insert dynamically generated <code translate="no">#define</code> statements.</p>
<!-- @@@setPreamble -->
<!-- $$$setSourceDevice[overload1]$$$setSourceDeviceQIODevice*QShader::StageconstQString& -->
<h3 class="fn" translate="no" id="setSourceDevice"><span class="type">void</span> QShaderBaker::<span class="name">setSourceDevice</span>(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span> *<i>device</i>, <span class="type"><a href="../qtgui/qshader.html#Stage-enum" translate="no">QShader::Stage</a></span> <i>stage</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>fileName</i> = QString())</h3>
<p>Sets the source <i translate="no">device</i>. This allows using any <a href="../qtcore/qiodevice.html" translate="no">QIODevice</a> instead of just files. <i translate="no">stage</i> specifies the shader stage, while the optional <i translate="no">fileName</i> contains a filename that is used in the error messages.</p>
<!-- @@@setSourceDevice -->
<!-- $$$setSourceFileName[overload1]$$$setSourceFileNameconstQString& -->
<h3 class="fn" translate="no" id="setSourceFileName"><span class="type">void</span> QShaderBaker::<span class="name">setSourceFileName</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>fileName</i>)</h3>
<p>Sets the name of the shader source file to <i translate="no">fileName</i>. This is the file that will be read when calling <a href="qshaderbaker.html#bake" translate="no">bake</a>(). The shader stage is deduced automatically from the file extension. When this is not desired or not possible, use the overload with the stage argument instead.</p>
<p>The supported file extensions are:</p>
<ul>
<li><code translate="no">.vert</code> - vertex shader</li>
<li><code translate="no">.frag</code> - fragment (pixel) shader</li>
<li><code translate="no">.tesc</code> - tessellation control (hull) shader</li>
<li><code translate="no">.tese</code> - tessellation evaluation (domain) shader</li>
<li><code translate="no">.geom</code> - geometry shader</li>
<li><code translate="no">.comp</code> - compute shader</li>
</ul>
<!-- @@@setSourceFileName -->
<!-- $$$setSourceFileName$$$setSourceFileNameconstQString&QShader::Stage -->
<h3 class="fn" translate="no" id="setSourceFileName-1"><span class="type">void</span> QShaderBaker::<span class="name">setSourceFileName</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>fileName</i>, <span class="type"><a href="../qtgui/qshader.html#Stage-enum" translate="no">QShader::Stage</a></span> <i>stage</i>)</h3>
<p>Sets the name of the shader source file to <i translate="no">fileName</i>. This is the file that will be read when calling <a href="qshaderbaker.html#bake" translate="no">bake</a>(). The shader stage is specified by <i translate="no">stage</i>.</p>
<!-- @@@setSourceFileName -->
<!-- $$$setSourceString[overload1]$$$setSourceStringconstQByteArray&QShader::StageconstQString& -->
<h3 class="fn" translate="no" id="setSourceString"><span class="type">void</span> QShaderBaker::<span class="name">setSourceString</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>sourceString</i>, <span class="type"><a href="../qtgui/qshader.html#Stage-enum" translate="no">QShader::Stage</a></span> <i>stage</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>fileName</i> = QString())</h3>
<p>Sets the input shader <i translate="no">sourceString</i>. <i translate="no">stage</i> specified the shader stage, while the optional <i translate="no">fileName</i> contains a filename that is used in the error messages.</p>
<!-- @@@setSourceString -->
<!-- $$$setTessellationMode[overload1]$$$setTessellationModeQShaderDescription::TessellationMode -->
<h3 class="fn" translate="no" id="setTessellationMode"><span class="type">void</span> QShaderBaker::<span class="name">setTessellationMode</span>(<span class="type"><a href="../qtgui/qshaderdescription.html#TessellationMode-enum" translate="no">QShaderDescription::TessellationMode</a></span> <i>mode</i>)</h3>
<p>When generating MSL shader code for a tessellation control shader, the tessellation <i translate="no">mode</i> (triangles or quads) must be known upfront. In GLSL this is declared in the tessellation evaluation shader typically, but for Metal it must be known also when generating the compute shader from the tessellation control shader.</p>
<p>When not set, the default is triangles.</p>
<!-- @@@setTessellationMode -->
<!-- $$$setTessellationOutputVertexCount[overload1]$$$setTessellationOutputVertexCountint -->
<h3 class="fn" translate="no" id="setTessellationOutputVertexCount"><span class="type">void</span> QShaderBaker::<span class="name">setTessellationOutputVertexCount</span>(<span class="type">int</span> <i>count</i>)</h3>
<p>When generating MSL shader code for a tessellation evaluation shader, the output vertex <i translate="no">count</i> of the tessellation control shader must be known upfront. in GLSL this would be declared in the tessellation control shader typically, but for Metal it must be known also when generating the vertex shader from the teselation evaluation shader.</p>
<p>When not set, the default value is 3.</p>
<!-- @@@setTessellationOutputVertexCount -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
