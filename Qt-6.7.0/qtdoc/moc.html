<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- moc.qdoc -->
  <title>Using the Meta-Object Compiler (moc) | Qt 6.7</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="index.html" translate="no">Qt 6.7</a></li>
<li>Using the Meta-Object Compiler (moc)</li>
<li id="buildversion">Qt 6.7.0 Reference Documentation</li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#usage">Usage</a></li>
<li class="level1"><a href="#writing-make-rules-for-invoking-moc">Writing Make Rules for Invoking <code translate="no">moc</code></a></li>
<li class="level1"><a href="#command-line-options">Command-Line Options</a></li>
<li class="level1"><a href="#diagnostics">Diagnostics</a></li>
<li class="level1"><a href="#build-systems">Build Systems</a></li>
<li class="level2"><a href="#including-header-moc-files">Including header moc files</a></li>
<li class="level1"><a href="#limitations">Limitations</a></li>
<li class="level2"><a href="#multiple-inheritance-requires-qobject-to-be-first">Multiple Inheritance Requires QObject to Be First</a></li>
<li class="level2"><a href="#function-pointers-cannot-be-signal-or-slot-parameters">Function Pointers Cannot Be Signal or Slot Parameters</a></li>
<li class="level2"><a href="#enums-and-typedefs-must-be-fully-qualified-for-signal-and-slot-parameters">Enums and Typedefs Must Be Fully Qualified for Signal and Slot Parameters</a></li>
<li class="level2"><a href="#nested-classes-cannot-have-signals-or-slots">Nested Classes Cannot Have Signals or Slots</a></li>
<li class="level2"><a href="#signal-slot-return-types-cannot-be-references">Signal/Slot return types cannot be references</a></li>
<li class="level2"><a href="#only-signals-and-slots-may-appear-in-the-keyword-signals-keyword-and-keyword-slots-keyword-sections-of-a-class">Only Signals and Slots May Appear in the <code translate="no">signals</code> and <code translate="no">slots</code> Sections of a Class</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Using the Meta-Object Compiler (moc)</h1>
<!-- $$$moc.html-description -->
<div class="descr" id="details">
<p>The Meta-Object Compiler, <code translate="no">moc</code>, is the program that handles <a href="../qtcore/metaobjects.html" translate="no">Qt's C++ extensions</a>.</p>
<p>The <code translate="no">moc</code> tool reads a C++ header file. If it finds one or more class declarations that contain the <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro, it produces a C++ source file containing the meta-object code for those classes. Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system.</p>
<p>The C++ source file generated by <code translate="no">moc</code> must be compiled and linked with the implementation of the class.</p>
<p>Both <a href="../qmake/qmake-manual.html" translate="no">qmake</a> and <a href="../qtcmake/cmake-manual.html" translate="no">CMake</a> generate makefiles with build rules that will invoke <code translate="no">moc</code> accordingly, so you will not need to use the <code translate="no">moc</code> directly. <code translate="no">qmake</code> will add these build rules by default, whereas with CMake, you can use the <a href="https://cmake.org/cmake/help/latest/manual/cmake-qt.7.html#automoc" translate="no">AUTOMOC</a> property to handle <code translate="no">moc</code> automatically. For more background information on <code translate="no">moc</code>, see <a href="why-moc.html" translate="no">Why Does Qt Use Moc for Signals and Slots?</a></p>
<h2 id="usage">Usage</h2>
<p><code translate="no">moc</code> is typically used with an input file containing class declarations like this:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     MyClass(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>);
     <span class="operator">~</span>MyClass();

 <span class="keyword">signals</span>:
     <span class="type">void</span> mySignal();

 <span class="keyword">public</span> <span class="keyword">slots</span>:
     <span class="type">void</span> mySlot();
 };
</pre>
<p>In addition to the signals and slots shown above, <code translate="no">moc</code> also implements object properties as in the next example. The <a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a>() macro declares an object property, while <a href="../qtcore/qobject.html#Q_ENUM" translate="no">Q_ENUM</a>() declares a list of enumeration types within the class to be usable inside the <a href="../qtcore/properties.html" translate="no">property system</a>.</p>
<p>In the following example, we declare a property of the enumeration type <code translate="no">Priority</code> that is also called <code translate="no">priority</code> and has a get function <code translate="no">priority()</code> and a set function <code translate="no">setPriority()</code>.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(Priority priority READ priority WRITE setPriority)

 <span class="keyword">public</span>:
     <span class="keyword">enum</span> Priority { High<span class="operator">,</span> Low<span class="operator">,</span> VeryHigh<span class="operator">,</span> VeryLow };
     Q_ENUM(Priority)

     MyClass(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>);
     <span class="operator">~</span>MyClass();

     <span class="type">void</span> setPriority(Priority priority) { m_priority <span class="operator">=</span> priority; }
     Priority priority() <span class="keyword">const</span> { <span class="keyword">return</span> m_priority; }

 <span class="keyword">private</span>:
     Priority m_priority;
 };
</pre>
<p>The <a href="../qtcore/qobject.html#Q_FLAG" translate="no">Q_FLAG</a>() macro declares enums that are to be used as flags, i.e. OR'd together. Another macro, <a href="../qtcore/qobject.html#Q_CLASSINFO" translate="no">Q_CLASSINFO</a>(), allows you to attach additional name/value pairs to the class's meta-object:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_CLASSINFO(<span class="string">&quot;Author&quot;</span><span class="operator">,</span> <span class="string">&quot;Oscar Peterson&quot;</span>)
     Q_CLASSINFO(<span class="string">&quot;Status&quot;</span><span class="operator">,</span> <span class="string">&quot;Active&quot;</span>)

 <span class="keyword">public</span>:
     MyClass(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>);
     <span class="operator">~</span>MyClass();
 };
</pre>
<p>The output produced by <code translate="no">moc</code> must be compiled and linked, just like the other C++ code in your program; otherwise, the build will fail in the final link phase. If you use <code translate="no">qmake</code>, this is done automatically. Whenever <code translate="no">qmake</code> is run, it parses the project's header files and generates make rules to invoke <code translate="no">moc</code> for those files that contain a <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro. Similarly, when setting <a href="https://cmake.org/cmake/help/latest/manual/cmake-qt.7.html#automoc" translate="no">AUTOMOC</a> to <code translate="no">ON</code>, CMake will scan the header and source files at build time and invoke <code translate="no">moc</code> accordingly.</p>
<p>If the class declaration is found in the file <code translate="no">myclass.h</code>, the moc output should be put in a file called <code translate="no">moc_myclass.cpp</code>. This file should then be compiled as usual, resulting in an object file, e.g., <code translate="no">moc_myclass.obj</code> on Windows. This object should then be included in the list of object files that are linked together in the final building phase of the program.</p>
<h2 id="writing-make-rules-for-invoking-moc">Writing Make Rules for Invoking <code translate="no">moc</code></h2>
<p>For anything but the simplest test programs, it is recommended that you automate running the <code translate="no">moc</code>. By adding some rules to your program's makefile, <code translate="no">make</code> can take care of running moc when necessary and handling the moc output.</p>
<p>You can use <a href="../qtcmake/cmake-manual.html" translate="no">CMake</a> or <a href="../qmake/qmake-manual.html" translate="no">qmake</a> to generate makefiles that does all the necessary <code translate="no">moc</code> handling.</p>
<p>If you want to create your makefiles yourself, here are some tips on how to include moc handling.</p>
<p>For <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> class declarations in header files, here is a useful makefile rule if you only use GNU make:</p>
<pre class="cpp" translate="no">
 moc_<span class="operator">%</span><span class="operator">.</span>cpp: <span class="operator">%</span><span class="operator">.</span>h
         moc $(DEFINES) $(INCPATH) $<span class="operator">&lt;</span> <span class="operator">-</span>o $@
</pre>
<p>If you want to write portably, you can use individual rules of the following form:</p>
<pre class="cpp" translate="no">
 moc_foo<span class="operator">.</span>cpp: foo<span class="operator">.</span>h
         moc $(DEFINES) $(INCPATH) $<span class="operator">&lt;</span> <span class="operator">-</span>o $@
</pre>
<p>You must also remember to add <code translate="no">moc_foo.cpp</code> to your <code translate="no">SOURCES</code> (substitute your favorite name) variable and <code translate="no">moc_foo.o</code> or <code translate="no">moc_foo.obj</code> to your <code translate="no">OBJECTS</code> variable.</p>
<p>Both examples assume that <code translate="no">$(DEFINES)</code> and <code translate="no">$(INCPATH)</code> expand to the define and include path options that are passed to the C++ compiler. These are required by <code translate="no">moc</code> to preprocess the source files.</p>
<p>While we prefer to name our C++ source files <code translate="no">.cpp</code>, you can use any other extension, such as <code translate="no">.C</code>, <code translate="no">.cc</code>, <code translate="no">.CC</code>, <code translate="no">.cxx</code>, and <code translate="no">.c++</code>, if you prefer.</p>
<p>For <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> class declarations in implementation (<code translate="no">.cpp</code>) files, we suggest a makefile rule like this:</p>
<pre class="cpp" translate="no">
 foo<span class="operator">.</span>o: foo<span class="operator">.</span>moc

 foo<span class="operator">.</span>moc: foo<span class="operator">.</span>cpp
         moc $(DEFINES) $(INCPATH) <span class="operator">-</span>i $<span class="operator">&lt;</span> <span class="operator">-</span>o $@
</pre>
<p>This guarantees that make will run the moc before it compiles <code translate="no">foo.cpp</code>. You can then put</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &quot;foo.moc&quot;</span>
</pre>
<p>at the end of <code translate="no">foo.cpp</code>, where all the classes declared in that file are fully known.</p>
<h2 id="command-line-options">Command-Line Options</h2>
<p>Here are the command-line options supported by the moc:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Option</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td ><code translate="no">-D&lt;macro&gt;[=&lt;def&gt;]</code></td><td >Define macro, with optional definition.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">-E</code></td><td >Preprocess only; do not generate meta-object code.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">-f[&lt;file&gt;]</code></td><td >Force the generation of an <code translate="no">#include</code> statement in the output. This is the default for header files whose extension starts with <code translate="no">H</code> or <code translate="no">h</code>. This option is useful if you have header files that do not follow the standard naming conventions. The <code translate="no">&lt;file&gt;</code> part is optional.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">-Fdir</code></td><td >macOS. Add the framework directory <code translate="no">dir</code> to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by -I options and are scanned in a left-to-right order (see the manpage for gcc). Normally, use -F /Library/Frameworks/</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">-h</code></td><td >Display the usage and the list of options.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">-i</code></td><td >Do not generate an <code translate="no">#include</code> statement in the output. This may be used to run the moc on a C++ file containing one or more class declarations. You should then <code translate="no">#include</code> the meta-object code in the <code translate="no">.cpp</code> file.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">-I&lt;dir&gt;</code></td><td >Add dir to the include path for header files.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">-M&lt;key=value&gt;</code></td><td >Append additional meta data to plugins. If a class has <a href="../qtcore/qtplugin.html#Q_PLUGIN_METADATA" translate="no">Q_PLUGIN_METADATA</a> specified, the key-value pair will be added to its meta data. This will end up in the Json object that gets resolved for the plugin at run time (accessible from <a href="../qtcore/qpluginloader.html" translate="no">QPluginLoader</a>). This argument is typically used for tagging static plugins with information resolved by the build system.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">-nw</code></td><td >Do not generate any warnings. (Not recommended.)</td></tr>
<tr valign="top" class="even"><td ><code translate="no">-o&lt;file&gt;</code></td><td >Write output to <code translate="no">&lt;file&gt;</code> rather than to standard output.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">-p&lt;path&gt;</code></td><td >Makes the moc prepend <code translate="no">&lt;path&gt;/</code> to the file name in the generated <code translate="no">#include</code> statement.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">-U&lt;macro&gt;</code></td><td >Undefine macro.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">@&lt;file&gt;</code></td><td >Read additional command-line options from <code translate="no">&lt;file&gt;</code>. Each line of the file is treated as a single option. Empty lines are ignored. Note that this option is not supported within the options file itself (i.e. an options file can't &quot;include&quot; another file).</td></tr>
<tr valign="top" class="even"><td ><code translate="no">-v</code></td><td >Display <code translate="no">moc</code>'s version number.</td></tr>
</table></div>
<p>You can explicitly tell the moc not to parse parts of a header file. <code translate="no">moc</code> defines the preprocessor symbol <code translate="no">Q_MOC_RUN</code>. Any code surrounded by</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#ifndef Q_MOC_RUN</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="preprocessor">#endif</span>
</pre>
<p>is skipped by the <code translate="no">moc</code>.</p>
<h2 id="diagnostics">Diagnostics</h2>
<p><code translate="no">moc</code> will warn you about a number of dangerous or illegal constructs in the <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> class declarations.</p>
<p>If you get linkage errors in the final building phase of your program, saying that <code translate="no">YourClass::className()</code> is undefined or that <code translate="no">YourClass</code> lacks a vtable, something has been done wrong. Most often, you have forgotten to compile or <code translate="no">#include</code> the moc-generated C++ code, or (in the former case) include that object file in the link command. If you use <code translate="no">qmake</code>, try rerunning it to update your makefile. This should do the trick.</p>
<h2 id="build-systems">Build Systems</h2>
<h3 id="including-header-moc-files">Including header moc files</h3>
<p>qmake and CMake behave differently with regards to including header moc files.</p>
<p>To illustrate this with an example, suppose that you have two headers with corresponding source files: <code translate="no">a.h</code>, <code translate="no">a.cpp</code>, <code translate="no">b.h</code>, and <code translate="no">b.cpp</code>. Each header has a <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro:</p>
<pre class="cpp" translate="no">
 <span class="comment">// a.h</span>
 <span class="keyword">class</span> A : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT

     <span class="keyword">public</span>:
         <span class="comment">// ...</span>
 };
</pre>
<pre class="cpp" translate="no">
 <span class="comment">// a.cpp</span>
 <span class="preprocessor">#include &quot;a.h&quot;</span>

 <span class="comment">// ...</span>

 <span class="preprocessor">#include &quot;moc_a.cpp&quot;</span>
</pre>
<pre class="cpp" translate="no">
 <span class="comment">// b.h</span>
 <span class="keyword">class</span> B : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT

     <span class="keyword">public</span>:
         <span class="comment">// ...</span>
 };
</pre>
<pre class="cpp" translate="no">
 <span class="comment">// b.cpp</span>
 <span class="preprocessor">#include &quot;b.h&quot;</span>

 <span class="comment">// ...</span>

 <span class="preprocessor">#include &quot;moc_b.cpp&quot;</span>
</pre>
<p>With qmake, if you don't include the moc-generated file (<code translate="no">moc_a.cpp</code>/<code translate="no">moc_b.cpp</code>), <code translate="no">a.cpp</code>, <code translate="no">b.cpp</code>, <code translate="no">moc_a.cpp</code>, and <code translate="no">moc_b.cpp</code> will be compiled separately. This can result in slower builds. If you include the moc generated files, only a.cpp and b.cpp will need to be compiled, as the moc generated code is included in those files.</p>
<p>With CMake, if you don't include the files, an single additional file is generated by moc (let's call it <code translate="no">cmake.cpp</code> for the sake of the example). <code translate="no">cmake.cpp</code> would include both <code translate="no">moc_a.cpp</code> and <code translate="no">moc_b.cpp</code>. Including the moc-generated file is still allowed with CMake, but it's not necessary.</p>
<p>For more information on CMake's moc support regarding this topic, see <a href="https://cmake.org/cmake/help/latest/prop_tgt/AUTOMOC.html#including-header-moc-files-in-sources" translate="no">Including header moc files in sources</a>.</p>
<h2 id="limitations">Limitations</h2>
<p><code translate="no">moc</code> does not handle all of C++. The main problem is that class templates cannot have the <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro. Here is an example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> SomeTemplate<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> : <span class="keyword">public</span> <span class="type"><a href="../qtwidgets/qframe.html" translate="no">QFrame</a></span>
 {
     Q_OBJECT
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

 <span class="keyword">signals</span>:
     <span class="type">void</span> mySignal(<span class="type">int</span>);
 };
</pre>
<p>The following constructs are illegal. All of them have alternatives which we think are usually better, so removing these limitations is not a high priority for us.</p>
<h3 id="multiple-inheritance-requires-qobject-to-be-first">Multiple Inheritance Requires QObject to Be First</h3>
<p>If you are using multiple inheritance, <code translate="no">moc</code> assumes that the first inherited class is a subclass of <a href="../qtcore/qobject.html" translate="no">QObject</a>. Also, be sure that only the first inherited class is a <a href="../qtcore/qobject.html" translate="no">QObject</a>.</p>
<pre class="cpp" translate="no">
 <span class="comment">// correct</span>
 <span class="keyword">class</span> SomeClass : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">,</span> <span class="keyword">public</span> OtherClass
 {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 };
</pre>
<p>Virtual inheritance with <a href="../qtcore/qobject.html" translate="no">QObject</a> is <i>not</i> supported.</p>
<h3 id="function-pointers-cannot-be-signal-or-slot-parameters">Function Pointers Cannot Be Signal or Slot Parameters</h3>
<p>In most cases where you would consider using function pointers as signal or slot parameters, we think inheritance is a better alternative. Here is an example of illegal syntax:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> SomeClass : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span> <span class="keyword">slots</span>:
     <span class="type">void</span> apply(<span class="type">void</span> (<span class="operator">*</span>apply)(List <span class="operator">*</span><span class="operator">,</span> <span class="type">void</span> <span class="operator">*</span>)<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>); <span class="comment">// WRONG</span>
 };
</pre>
<p>You can work around this restriction like this:</p>
<pre class="cpp" translate="no">
 <span class="keyword">typedef</span> <span class="type">void</span> (<span class="operator">*</span>ApplyFunction)(List <span class="operator">*</span><span class="operator">,</span> <span class="type">void</span> <span class="operator">*</span>);

 <span class="keyword">class</span> SomeClass : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span> <span class="keyword">slots</span>:
     <span class="type">void</span> apply(ApplyFunction<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>);
 };
</pre>
<p>It may sometimes be even better to replace the function pointer with inheritance and virtual functions.</p>
<h3 id="enums-and-typedefs-must-be-fully-qualified-for-signal-and-slot-parameters">Enums and Typedefs Must Be Fully Qualified for Signal and Slot Parameters</h3>
<p>When checking the signatures of its arguments, <a href="../qtcore/qobject.html#connect" translate="no">QObject::connect</a>() compares the data types literally. Thus, <a href="../qtcore/qt.html#AlignmentFlag-enum" translate="no">Alignment</a> and <a href="../qtcore/qt.html#AlignmentFlag-enum" translate="no">Qt::Alignment</a> are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT

     <span class="keyword">enum</span> Error {
         ConnectionRefused<span class="operator">,</span>
         RemoteHostClosed<span class="operator">,</span>
         UnknownError
     };

 <span class="keyword">signals</span>:
     <span class="type">void</span> stateChanged(MyClass<span class="operator">::</span>Error error);
 };
</pre>
<h3 id="nested-classes-cannot-have-signals-or-slots">Nested Classes Cannot Have Signals or Slots</h3>
<p>Here's an example of the offending construct:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> A
 {
 <span class="keyword">public</span>:
     <span class="keyword">class</span> B
     {
         Q_OBJECT

     <span class="keyword">public</span> <span class="keyword">slots</span>:   <span class="comment">// WRONG</span>
         <span class="type">void</span> b();
     };
 };
</pre>
<h3 id="signal-slot-return-types-cannot-be-references">Signal/Slot return types cannot be references</h3>
<p>Signals and slots can have return types, but signals or slots returning references will be treated as returning void.</p>
<h3 id="only-signals-and-slots-may-appear-in-the-keyword-signals-keyword-and-keyword-slots-keyword-sections-of-a-class">Only Signals and Slots May Appear in the <code translate="no">signals</code> and <code translate="no">slots</code> Sections of a Class</h3>
<p><code translate="no">moc</code> will complain if you try to put other constructs in the <code translate="no">signals</code> or <code translate="no">slots</code> sections of a class than signals and slots.</p>
</div>
<p><b>See also </b><a href="../qtcore/metaobjects.html" translate="no">Meta-Object System</a>, <a href="../qtcore/signalsandslots.html" translate="no">Signals and Slots</a>, and <a href="../qtcore/properties.html" translate="no">Qt's Property System</a>.</p>
<!-- @@@moc.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
