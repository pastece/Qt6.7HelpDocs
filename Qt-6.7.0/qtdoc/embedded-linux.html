<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- emb-linux.qdoc -->
  <meta name="description" content="Provides information about Embedded Linux support in Qt.">
  <title>Qt for Embedded Linux | Qt 6.7</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="index.html" translate="no">Qt 6.7</a></li>
<li>Qt for Embedded Linux</li>
<li id="buildversion">Qt 6.7.0 Reference Documentation</li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#platform-plugins-for-embedded-linux-devices">Platform plugins for embedded Linux devices</a></li>
<li class="level2"><a href="#eglfs">EGLFS</a></li>
<li class="level2"><a href="#vkkhrdisplay">VkKhrDisplay</a></li>
<li class="level2"><a href="#linuxfb">LinuxFB</a></li>
<li class="level1"><a href="#display-output">Display output</a></li>
<li class="level2"><a href="#eglfs-with-the-eglfs-kms-backend">EGLFS with the eglfs_kms backend</a></li>
<li class="level2"><a href="#advanced-eglfs-kms-features">Advanced eglfs_kms features</a></li>
<li class="level2"><a href="#eglfs-with-an-eglfs-kms-egldevice-backend">EGLFS with an eglfs_kms_egldevice backend</a></li>
<li class="level2"><a href="#touch-input-in-systems-with-multiple-screens-on-kms-drm">Touch input in systems with multiple screens on KMS/DRM</a></li>
<li class="level2"><a href="#eglfs-with-other-backends">EGLFS with other backends</a></li>
<li class="level1"><a href="#video-memory">Video memory</a></li>
<li class="level2"><a href="#linuxfb">linuxfb</a></li>
<li class="level1"><a href="#unix-signal-handlers">Unix signal handlers</a></li>
<li class="level1"><a href="#fonts">Fonts</a></li>
<li class="level1"><a href="#platform-plugins-for-windowing-systems-on-embedded-linux-devices">Platform plugins for windowing systems on embedded Linux devices</a></li>
<li class="level2"><a href="#xcb">XCB</a></li>
<li class="level2"><a href="#wayland">Wayland</a></li>
<li class="level1"><a href="#performance-enhancement-guidelines">Performance enhancement guidelines</a></li>
<li class="level2"><a href="#use-hardware-rendering-where-possible">Use hardware rendering where possible</a></li>
<li class="level2"><a href="#follow-the-best-practices-for-qt-quick">Follow the best practices for Qt Quick</a></li>
<li class="level2"><a href="#use-images-textures-and-shader-effects-instead-of-the-canvas-qml-type">Use images/textures and shader effects instead of the Canvas QML type</a></li>
<li class="level2"><a href="#use-qt-quick-instead-of-qt-widgets">Use Qt Quick instead of Qt Widgets</a></li>
<li class="level2"><a href="#choose-a-resolution-appropriate-for-your-ui-size">Choose a resolution appropriate for your UI size</a></li>
<li class="level2"><a href="#use-a-qml-window-type-as-your-application-s-root-element">Use a QML Window type as your application's root element</a></li>
<li class="level1"><a href="#related-topics">Related topics</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Qt for Embedded Linux</h1>
<!-- $$$embedded-linux.html-description -->
<div class="descr" id="details">
<h2 id="platform-plugins-for-embedded-linux-devices">Platform plugins for embedded Linux devices</h2>
<p>On Embedded Linux systems, there are multiple platform plugins that you can use: EGLFS, VkKhrDisplay, LinuxFB, or Wayland. The availability of these plugins depends on how Qt is configured. Of these, Wayland requires the presence of a compositor, and provides a full windowing system supporting multiple windows, similarly to X11 or Windows. The others work without any windowing system, meaning the Qt application is in full control of the rendering and output. They typically support one fullscreen Qt &quot;window&quot; per screen.</p>
<p>EGLFS is the default plugin on many boards. If it's not suitable, use the <code translate="no">QT_QPA_PLATFORM</code> environment variable to request another plugin. Alternatively, for quick tests, use the <code translate="no">-platform</code> command-line argument with the same syntax.</p>
<div class="admonition note">
<p><b>Note: </b>As of Qt 5.0, Qt no longer has its own window system (QWS) implementation. For single-process use cases, the <a href="../qtplatformintegration/qpa.html" translate="no">Qt Platform Abstraction</a> is a superior solution; multi-process use cases are supported through <a href="../qtwaylandcompositor/qtwaylandcompositor-index.html" translate="no">Wayland</a>.</p>
</div>
<p>See <a href="configure-linux-device.html" translate="no">Configure an Embedded Linux Device</a> for an overview of configuring Qt for cross-compilation using an Embedded Linux toolchain.</p>
<span id="embedded-eglfs"></span><h3 id="eglfs">EGLFS</h3>
<p><a href="http://www.khronos.org/egl" translate="no">EGL</a> is an interface between OpenGL and the native windowing system. Qt can use EGL for context and surface management, however the API contains no platform-specifics. Creating a <i>native window</i>, which won't necessarily be an actual window on the screen, must still be done by platform-specific means. This is why we need the board or GPU-specific adaptation code. Typically, these adaptations are provided as:</p>
<ul>
<li><i>EGLFS hooks</i> &ndash; a single source file compiled into the platform plugin</li>
<li><i>EGL device integration</i> &ndash; dynamically loaded plugins</li>
</ul>
<p>EGLFS is a platform plugin for running Qt applications on top of EGL and OpenGL ES 2.0, without an actual windowing system like X11 or Wayland. It is the recommended plugin for modern Embedded Linux devices that include a GPU.</p>
<p>In addition to Qt Quick and native OpenGL applications, EGLFS supports software-rendered windows, like <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>, too. For <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>, the widgets' contents are rendered using the CPU into images, which are then uploaded into textures and composited by the plugin.</p>
<p>EGLFS forces the first top-level window - either a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> or a <a href="../qtquick/qquickview.html" translate="no">QQuickView</a> - to become fullscreen. This window is also chosen to be the <i>root</i> widget window into which all other top-level widgets are composited. For example, dialogs, popup menus, or combo boxes. This behavior is necessary because with EGLFS there is always exactly one native window and one EGL window surface; these belong to the widget or window that is created first. This approach works well when there is a main window that exists for the application's lifetime and all other widgets are either not top-levels or are created afterward, once the main window is shown.</p>
<p>There are further restrictions for OpenGL-based windows. EGLFS supports a single fullscreen GL window (as of Qt 5.3), like OpenGL-based <a href="../qtgui/qwindow.html" translate="no">QWindow</a>, a <a href="../qtquick/qquickview.html" translate="no">QQuickView</a>, or a <a href="../qtopengl/qopenglwidget.html" translate="no">QOpenGLWidget</a>. Opening additional OpenGL windows or mixing such windows with <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>-based content isn't supported; Qt terminates the application with an error message.</p>
<p>Furthermore, APIs designed for desktop platforms or environments with a windowing system, such as <a href="../qtgui/dnd.html" translate="no">Drag and Drop</a>, are not supported on EGLFS.</p>
<h4 id="environment-variables-used-by-eglfs">Environment variables used by EGLFS</h4>
<p>If necessary, <code translate="no">eglfs</code> can be configured using the following environment variables:</p>
<div class="table"><table class="generic" width="100%">
 <thead><tr class="qt-style"><th >Environment Variable</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td ><code translate="no">QT_QPA_EGLFS_INTEGRATION</code></td><td >In addition to the compiled-in <i>hooks</i>, it is also possible to use dynamically loaded plugins to provide device or vendor-specific adaptation. This environment variable enforces a specific plugin. For example, setting it to <i>eglfs_kms</i> uses the KMS/DRM backend. This is only an option when no static or compiled-in hooks were specified in the device makespecs. In practice, the traditional compiled-in hooks are rarely used, almost all backends are now migrated to plugins. The device makespecs still contain a relevant, though optional, <code translate="no">EGLFS_DEVICE_INTEGRATION</code> entry: the name of the preferred backend for that particular device. Avoid setting this environment variable if there is more than one plugin present on the target system. In a desktop environment, the KMS or X11 backends are prioritized, depending on the presence of the <code translate="no">DISPLAY</code> environment variable.<div class="admonition note">
<p><b>Note: </b>On some boards a special value of <code translate="no">none</code> is used instead of an actual plugin. This indicates that no special integration is necessary to use EGL with the framebuffer; no plugins must be loaded.</p>
</div>
</td></tr>
<tr valign="top" class="even"><td ><code translate="no">QT_QPA_EGLFS_PHYSICAL_WIDTH</code> and <code translate="no">QT_QPA_EGLFS_PHYSICAL_HEIGHT</code></td><td >Specifies the physical screen's width and height in millimeters. Note that since Qt 6 the physical screen size is no longer used to determine logical dpi.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">QT_QPA_EGLFS_ROTATION</code></td><td >Specifies the rotation applied to software-rendered content in <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>-based applications. Supported values are 180, 90, and -90. This variable does not apply to OpenGL-based windows, including Qt Quick. Qt Quick applications can apply transformations in their QML scene instead. The standard <code translate="no">eglfs</code> mouse cursor always takes the value into account, with an appropriately positioned and rotated pointer image, regardless of the application type. However, special cursor implementations, such as the KMS/DRM backend's hardware cursor, may not support rotation.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">QT_QPA_EGLFS_FORCEVSYNC</code></td><td >When set, <code translate="no">eglfs</code> requests <code translate="no">FBIO_WAITFORVSYNC</code> on the framebuffer device after each call to eglSwapBuffers(). This variable is only relevant for backends relying on the legacy Linux <code translate="no">fbdev</code> subsystem. Normally, with a default swap interval of 1, Qt assumes that calling eglSwapBuffers() takes care of vsync; if it doesn't (for example, due to driver bugs), try setting <code translate="no">QT_QPA_EGLFS_FORCEVSYNC</code> to a non-zero value.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">QT_QPA_EGLFS_FORCE888</code></td><td >When set, the red, green, and blue color channel sizes are ignored when <code translate="no">eglfs</code> creates a new context, window or off-screen surface. Instead, the plugin requests a configuration with 8 bits per channel. This can be helpful on devices where configurations with less than 32 or 24 bits per pixel (for example, 5-6-5 or 4-4-4) are chosen by default despite knowing they are not ideal, for example, due to banding effects. Instead of changing application code, this variable provides a shortcut to force 24 or 32 bpp configurations.</td></tr>
</table></div>
<p>Additionally, the following less commonly used variables are available:</p>
<div class="table"><table class="generic" width="100%">
 <thead><tr class="qt-style"><th >Environment Variable</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td ><code translate="no">QT_QPA_EGLFS_FB</code></td><td >Overrides the framebuffer device. The default is <code translate="no">/dev/fb0</code>. On most embedded platforms this variable isn't very relevant because the framebuffer is used only to query settings like the display dimensions. However, on certain devices, this variable provides the ability to specify which display to use in multiple display setups, similar to the <code translate="no">fb</code> parameter in LinuxFB.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">QT_QPA_EGLFS_WIDTH</code> and <code translate="no">QT_QPA_EGLFS_HEIGHT</code></td><td >Contains the screen's width and height in pixels. While <code translate="no">eglfs</code> tries to determine the dimensions from the framebuffer device <i>/dev/fb0</i>, this doesn't always work. It may be necessary to manually specify the sizes.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">QT_QPA_EGLFS_DEPTH</code></td><td >Overrides the color depth for the screen. On platforms where the framebuffer device <i>/dev/fb0</i> is not available or the query is not successful, a default of <code translate="no">32</code> is used. Use this variable to override any such defaults.<div class="admonition note">
<p><b>Note: </b>This variable only affects the color depth value reported by <a href="../qtgui/qscreen.html" translate="no">QScreen</a>. It has no connection to EGL configurations and the color depth used for OpenGL rendering.</p>
</div>
</td></tr>
<tr valign="top" class="even"><td ><code translate="no">QT_QPA_EGLFS_SWAPINTERVAL</code></td><td >By default, a swap interval of <code translate="no">1</code> is requested. This variable enables synchronizing to the display's vertical refresh. Use this variable to override the swap interval's value. For instance, passing 0 disables blocking on swap, resulting in running as fast as possible without any synchronization.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">QT_QPA_EGLFS_DEBUG</code></td><td >When set, some debugging information is printed on the debug output. For example, the input <a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a> and the properties of the chosen EGL configuration are printed while creating a new context. When used together with Qt Quick's <code translate="no">QSG_INFO</code> variable, you can get useful information for troubleshooting issues related to the EGL configuration.</td></tr>
</table></div>
<h4 id="logging">Logging</h4>
<p>In addition to <code translate="no">QT_QPA_EGLFS_DEBUG</code>, <code translate="no">eglfs</code> also supports Qt's modern categorized logging system. The following logging categories are available:</p>
<ul>
<li><code translate="no">qt.qpa.egldeviceintegration</code> &ndash; Enables logging for dynamically loaded backends. Use this category to check what backend is in use.</li>
<li><code translate="no">qt.qpa.input</code> &ndash; Enables debug output both from the <code translate="no">evdev</code> and <code translate="no">libinput</code> input handlers. Use this category to check if a given input device was recognized and opened.</li>
<li><code translate="no">qt.qpa.eglfs.kms</code> &ndash; Enables verbose logging in the KMS/DRM backend.</li>
</ul>
<p>After running <code translate="no">configure</code>, make sure to inspect its output. This is the easiest, quickest way to identify whether you have the necessary EGLFS backend, libudev, or libinput enabled. In short, if there's an undesired &quot;no&quot; in your <code translate="no">configure</code> output, run:</p>
<pre class="cpp" translate="no">
 <span class="operator">.</span><span class="operator">/</span>configure <span class="operator">-</span>v
</pre>
<p>to turn on the verbose output, so that you can see the compiler and linker invocations for each configure test.</p>
<div class="admonition note">
<p><b>Note: </b>If you encounter errors about missing headers, libraries, or seemingly cryptic linker failures, often, they are a sign of an incomplete or broken sysroot and isn't related to Qt.</p>
</div>
<p>As an example, when targeting the Raspberry Pi with the Broadcom proprietary graphics drivers, the output should contain something like the following:</p>
<pre class="cpp plain" translate="no">
 QPA backends:
 EGLFS ................................ yes
 EGLFS details:
   EGLFS i.Mx6 ........................ no
   EGLFS i.Mx6 Wayland ................ no
   EGLFS EGLDevice .................... no
   EGLFS GBM .......................... no
   EGLFS Mali ......................... no
   EGLFS Raspberry Pi ................. yes
   EGL on X11 ......................... no
</pre>
<p>If this is not the case, it's not advisable to proceed further with the build since accelerated graphics won't be functional without the Raspberry Pi-specific backend, even if the rest of Qt compiles successfully.</p>
<h3 id="vkkhrdisplay">VkKhrDisplay</h3>
<p>While EGLFS only supports OpenGL (ES), VkKhrDisplay is an <b>experimental</b> platform plugin that supports rendering with the <a href="https://www.vulkan.org/" translate="no">Vulkan</a> API. To enumerate displays and set up rendering, it relies on the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_display.html" translate="no">VK_KHR_display</a> family of extensions. Note that it is not given that a Vulkan implementation within a graphics stack supports this functionality. Currently this platform plugin has been verified and tested with <a href="https://docs.mesa3d.org/drivers/v3d.html" translate="no">Mesa and V3DV</a> running on a Raspberry Pi 4.</p>
<p>This platform plugin does not support OpenGL or any software rendering. Attempting to show a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>-based user interface will therefore fail. The only supported <a href="../qtgui/qwindow.html" translate="no">QWindow</a> surface type is <a href="../qtgui/qsurface.html#SurfaceType-enum" translate="no">QSurface::VulkanSurface</a>. For Qt Quick applications this implies that Vulkan-based rendering must be enforced either by setting <code translate="no">QSG_RHI_BACKEND=vulkan</code> in the environment, or by calling <a href="../qtquick/qquickwindow.html#setGraphicsApi" translate="no">QQuickWindow::setGraphicsApi</a>(<a href="../qtquick/qsgrendererinterface.html#GraphicsApi-enum" translate="no">QSGRendererInterface::Vulkan</a>); early on before creating a <a href="../qtquick/qquickwindow.html" translate="no">QQuickWindow</a> or <a href="../qtquick/qquickview.html" translate="no">QQuickView</a>.</p>
<p>To use this platform plugin, run the application with <code translate="no">-platform vkkhrdisplay</code> or set <code translate="no">QT_QPA_PLATFORM</code> to <code translate="no">vkkhrdisplay</code>. The plugin is built only when Qt is configured with Vulkan support.</p>
<p>Advanced EGLFS-style configuration (e.g. the JSON configuration file) or outputting to multiple screens from the same application are not currently implemented. Applications can however choose the screen to use via environment variables.</p>
<p>To determine the index values, check the logs printed on the debug output by the plugin. Currently these logs are uncategorized (printed via <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>) since inspecting them is essential in most cases, in order to ensure the plugin picks the appropriate display and mode.</p>
<ul>
<li><code translate="no">QT_VK_DISPLAY_INDEX</code> - When set, the display with the given index is used.</li>
<li><code translate="no">QT_VK_MODE_INDEX</code> - When set, the mode with the given index is used.</li>
<li><code translate="no">QT_VK_PHYSICAL_DEVICE_INDEX</code> - When set, the Vulkan physical device with the given index is used. This will not be relevant in most cases on embedded. Note that this variable is also used by the rest of the Qt graphics stack.</li>
</ul>
<p>Input (keyboard, mouse, touch) handling is similar to EGLFS, supporting <code translate="no">evdev</code>, <code translate="no">libinput</code>, and <code translate="no">tslib</code>. There is no mouse cursor rendering implemented, however. This is because there is no concept of a hardware cursor in this environment, and rendering a cursor with Vulkan within the platform plugin, similarly to what EGLFS does with OpenGL, is problematic for multiple reasons. Therefore this platform plugin is not well suited for mouse-based input at the moment.</p>
<p>The related environment variables are:</p>
<ul>
<li><code translate="no">QT_QPA_DISABLE_INPUT</code> - Disables keyboard/mouse/touch input.</li>
<li><code translate="no">QT_QPA_NO_LIBINPUT</code> - Prefers the evdev-based input handlers even when <a href="https://www.freedesktop.org/wiki/Software/libinput/" translate="no">libinput</a> is available.</li>
<li><code translate="no">QT_QPA_TSLIB</code> - Requests using the legacy <a href="http://www.tslib.org/" translate="no">tslib</a> library.</li>
</ul>
<h3 id="linuxfb">LinuxFB</h3>
<p>This plugin writes directly to the framebuffer via Linux's fbdev subsystem. Only software-rendered content is supported. Note that on some setups the display performance is expected to be limited. To use Qt Quick applications with this platform plugin, the <code translate="no">software</code> scenegraph backend must be used, either by setting <code translate="no">QT_QUICK_BACKEND=software</code> in the environment, or by calling <a href="../qtquick/qquickwindow.html#setGraphicsApi" translate="no">setGraphicsApi</a>() with <a href="../qtquick/qsgrendererinterface.html#GraphicsApi-enum" translate="no">QSGRendererInterface::Software</a>. <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> applications, or <a href="../qtgui/qwindow.html" translate="no">QWindow</a> with a surface type of <a href="../qtgui/qsurface.html#SurfaceType-enum" translate="no">QSurface::RasterSurface</a>, are supported, but this does not include special widgets such as <a href="../qtopengl/qopenglwidget.html" translate="no">QOpenGLWidget</a>.</p>
<p>As fbdev is being deprecated in the Linux kernel, DRM dumb buffer support is also available. To use it, set the <code translate="no">QT_QPA_FB_DRM</code> environment variable to a non-zero value. When set, provided that dumb buffers are supported by your system, legacy framebuffer devices like <code translate="no">/dev/fb0</code> won't be accessed. Instead, the rendering is set up via the DRM APIs, similar to the <code translate="no">eglfs_kms</code> backend in EGLFS. The output is double-buffered and page flipped, providing proper vsync for software-rendered content as well.</p>
<div class="admonition note">
<p><b>Note: </b>When dumb buffers are in use, none of the options described below are applicable since properties like physical and logical screen sizes are all queried automatically.</p>
</div>
<h4 id="specifying-additional-settings">Specifying additional settings</h4>
<p>The <code translate="no">linuxfb</code> plugin allows you to specify additional settings via the <code translate="no">QT_QPA_PLATFORM</code> environment variable or <code translate="no">-platform</code> command-line option. For example, <code translate="no">QT_QPA_PLATFORM=linuxfb:fb=/dev/fb1</code> specifies that the framebuffer device <code translate="no">/dev/fb1</code> must be used instead of the default <code translate="no">fb0</code>. To specify multiple settings, separate the mwith a colon (:).</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Settings</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td ><code translate="no">fb=/dev/fbN</code></td><td >Specifies the framebuffer devices. On multiple display setups, this setting allows you to run the application on different displays. Currently, there's no way to use multiple framebuffers from one Qt application.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">size=</code><i>&lt;width&gt;</i><code translate="no">x</code><i>&lt;height&gt;</i></td><td >Specifies the screen size in pixels. The plugin tries to query the display dimensions, both physical and logical, from the framebuffer device. However, this query may not always lead to proper results; it may be necessary to specify the values explicitly.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">mmsize=</code><i>&lt;width&gt;</i><code translate="no">x</code><i>&lt;height&gt;</i></td><td >Specifies the physical width and height in millimeters.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">offset=</code><i>&lt;width&gt;</i><code translate="no">x</code><i>&lt;height&gt;</i></td><td >Specifies the top-left corner of the screen offset in pixels. The default position is at <code translate="no">(0, 0)</code>.</td></tr>
<tr valign="top" class="odd"><td ><code translate="no">nographicsmodeswitch</code></td><td >Specifies not to switch the virtual terminal to graphics mode (<code translate="no">KD_GRAPHICS</code>). Typically, <i>enabling</i> graphics mode disables the blinking cursor and screen blanking. However, when this parameter is set, those two features are also skipped.</td></tr>
<tr valign="top" class="even"><td ><code translate="no">tty=/dev/ttyN</code></td><td >Overrides the virtual console. Only used when <code translate="no">nographicsmodeswitch</code> isn't set.</td></tr>
</table></div>
<p>As of Qt 5.9, the behavior of EGLFS and LinuxFB has been synchronized, with regards to the window sizing policy: the first top-level window is forced to cover the entire screen, with both platform plugins. If this is not desired, set the <code translate="no">QT_QPA_FB_FORCE_FULLSCREEN</code> environment variable to <code translate="no">0</code> to restore the behavior from earlier Qt versions.</p>
<h2 id="display-output">Display output</h2>
<p>The level of support to target one or more displays from one single Qt application varies between the platform plugins. Support often depends on the device and its graphics stack.</p>
<h3 id="eglfs-with-the-eglfs-kms-backend">EGLFS with the eglfs_kms backend</h3>
<p>When the KMS/DRM backend is in use, EGLFS reports all available screens in <a href="../qtgui/qguiapplication.html#screens" translate="no">QGuiApplication::screens</a>(). Applications can target different screens with different windows via <a href="../qtgui/qwindow.html#setScreen" translate="no">QWindow::setScreen</a>().</p>
<div class="admonition note">
<p><b>Note: </b>The restriction of one single fullscreen window per screen still applies. Changing screens after making the <a href="../qtgui/qwindow.html" translate="no">QWindow</a> visible isn't supported either. Therefore, it's essential that embedded applications make all the necessary <a href="../qtgui/qwindow.html#setScreen" translate="no">QWindow::setScreen</a>() calls before calling <a href="../qtgui/qwindow.html#show" translate="no">QWindow::show</a>().</p>
</div>
<p>When you start developing on a given embedded device, often it's necessary to verify the behavior of the device and drivers, and that the connected displays are working as they should. One easy way is to use the <b>hellowindow</b> example. Launching it with the <code translate="no">-platform eglfs --multiscreen --timeout</code> arguments shows a rotating Qt logo on each connected screen for a few seconds.</p>
<h4 id="custom-configuration">Custom configuration</h4>
<p>The KMS/DRM backend also supports custom configurations via a JSON file. To enable this, set the <code translate="no">QT_QPA_EGLFS_KMS_CONFIG</code> environment variable to the name of the file. You can also embed this file into the application via the Qt resource system.</p>
<p>Most of these configuration options apply to all KMS/DRM-based backends, regardless of the buffer management technology (GBM or EGLStreams).</p>
<p>Here's an example configuration:</p>
<pre class="cpp plain" translate="no">
 {
   &quot;device&quot;: &quot;/dev/dri/card1&quot;,
   &quot;hwcursor&quot;: false,
   &quot;pbuffers&quot;: true,
   &quot;outputs&quot;: [
     {
       &quot;name&quot;: &quot;VGA1&quot;,
       &quot;mode&quot;: &quot;off&quot;
     },
     {
       &quot;name&quot;: &quot;HDMI1&quot;,
       &quot;mode&quot;: &quot;1024x768&quot;
     }
   ]
 }
</pre>
<p>Here we configure the specified device so that:</p>
<ul>
<li>It won't use the hardware cursor (falls back to rendering the mouse cursor via OpenGL; by default hardware cursors are enabled as they're more efficient).</li>
<li>It backs <a href="../qtgui/qoffscreensurface.html" translate="no">QOffscreenSurface</a> with standard EGL pbuffer surfaces (by default this is disabled and a gbm surface is used instead).</li>
<li>Output on the VGA connector is disabled, while HDMI is active with a resolution of 1024x768.</li>
</ul>
<p>Additionally, such a configuration also disables looking for a device via <code translate="no">libudev</code>; instead the specified device is used.</p>
<p>When <code translate="no">mode</code> is not defined, the system's preferred mode is chosen. The accepted values for <code translate="no">mode</code> are: <code translate="no">off</code>, <code translate="no">current</code>, <code translate="no">preferred</code>, <code translate="no">skip</code>, width<code translate="no">x</code>height, width<code translate="no">x</code>height<code translate="no">@</code>vrefresh, or a modeline string.</p>
<p>Specifying <code translate="no">current</code> chooses a mode with a resolution that matches the current one. Because mode-setting is done only when the desired mode is actually different from the active one (unless forced via the <code translate="no">QT_QPA_EGLFS_ALWAYS_SET_MODE</code> environment variable), this value is useful to preserve the current mode and any content in the planes not touched by Qt.</p>
<p><code translate="no">skip</code> causes the connector for the output to be ignored as if it were disconnected. <code translate="no">off</code> is similar, but it changes the mode and turns off the display.</p>
<h4 id="default-behavior">Default behavior</h4>
<p>By default, all screens reported by the DRM layer are treated as one big virtual desktop. The mouse cursor implementation takes this into account and moves across the screens as expected. Although not recommended, you can disable the virtual desktop by setting <code translate="no">separateScreens</code> to <code translate="no">false</code> in the configuration.</p>
<p>By default, the virtual desktop is formed left to right, based on the order of connectors as reported by the system. To change this, set <code translate="no">virtualIndex</code> to a value starting from 0.</p>
<p>For example, the following configuration uses the preferred resolution but ensures that the left side of the virtual desktop is the screen connected to the HDMI port; while the right side is the screen connected to the DisplayPort:</p>
<pre class="cpp plain" translate="no">
 {
   &quot;device&quot;: &quot;drm-nvdc&quot;,
   &quot;outputs&quot;: [
     {
       &quot;name&quot;: &quot;HDMI1&quot;,
       &quot;virtualIndex&quot;: 0
     },
     {
       &quot;name&quot;: &quot;DP1&quot;,
       &quot;virtualIndex&quot;: 1
     }
   ]
 }
</pre>
<p>The order of elements in the array is not relevant. Outputs with unspecified virtual indices are placed after the others, with the original order in the DRM connector list preserved.</p>
<p>To create a vertical desktop space (that is, to stack top to bottom instead of left to right), add a <code translate="no">virtualDesktopLayout</code> property after <code translate="no">device</code> with the value of <code translate="no">vertical</code>.</p>
<div class="admonition warning">
<p><b>Warning: </b>It's recommended that all screens in the virtual desktop use the same resolution, otherwise elements like the mouse cursor may behave in unexpected ways when entering areas that only exist on one given screen.</p>
</div>
<p>When <code translate="no">virtualIndex</code> is not sufficient, the <code translate="no">virtualPos</code> property can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following code snippet places a second HDMI-based screen below the first one:</p>
<pre class="cpp plain" translate="no">
 {
    ...
   &quot;outputs&quot;: [
     ...
     {
       &quot;name&quot;: &quot;HDMI2&quot;,
       &quot;virtualPos&quot;: &quot;0, 1080&quot;
     }
   ]
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>Avoid such configurations when mouse support is desired. The mouse cursor's behavior may be unexpected with non-linear layouts. Touch should present no issues.</p>
</div>
<h4 id="automatic-physic-screen-size-querying">Automatic physic screen size querying</h4>
<p>In some cases, the automatic querying of the physical screen size via DRM may fail. Normally the <code translate="no">QT_QPA_EGLFS_PHYSICAL_WIDTH</code> and <code translate="no">QT_QPA_EGLFS_PHYSICAL_HEIGHT</code> environment variable would be used to provide the missing values. This is not suitable anymore when multiple screens are present. Instead, use the <code translate="no">physicalWidth</code> and <code translate="no">physicalHeight</code> properties in the <code translate="no">outputs</code> list to specify the sizes in millimeters.</p>
<div class="admonition note">
<p><b>Note: </b>Different physical sizes and thus differing logical DPIs are discouraged because it may lead to unexpected issues due to some graphics stack components not knowing about multiple screens and relying solely on the first screen's values.</p>
</div>
<h4 id="active-outputs-and-qscreen-instances">Active outputs and QScreen instances</h4>
<p>Each active output from the <code translate="no">outputs</code> array corresponds to one <a href="../qtgui/qscreen.html" translate="no">QScreen</a> instance reported from <a href="../qtgui/qguiapplication.html#screens" translate="no">QGuiApplication::screens</a>(). By default, the primary screen that <a href="../qtgui/qguiapplication.html#primaryScreen-prop" translate="no">QGuiApplication::primaryScreen</a>() reports is the screen that is registered first. If you're not using <code translate="no">virtualIndex</code>, this means the decision is based on the DRM connector order. To override this, set the <code translate="no">primary</code> property to <code translate="no">true</code> on the desired entry in the <code translate="no">outputs</code> list.</p>
<p>For example, to ensure the screen corresponding to the VGA output is the primary even when the system happens to report the HDMI one first, do the following:</p>
<pre class="cpp plain" translate="no">
 {
   &quot;device&quot;: &quot;/dev/dri/card0&quot;,
   &quot;outputs&quot;: [
       { &quot;name&quot;: &quot;HDMI1&quot; },
       { &quot;name&quot;: &quot;VGA1&quot;, &quot;mode&quot;: &quot;1280x720&quot;, &quot;primary&quot;: true },
       { &quot;name&quot;: &quot;LVDS1&quot;, &quot;mode&quot;: &quot;off&quot; }
   ]
 }
</pre>
<p>For troubleshooting, it might be useful to enable debug logs from the KMS/DRM backend. To do this, enable the <code translate="no">qt.qpa.eglfs.kms</code> categorized logging rule.</p>
<div class="admonition note">
<p><b>Note: </b>In an embedded environment, virtual desktops are more limited compared to a full windowing system. Windows overlapping multiple screens, non-fullscreen windows, and moving windows between screens, should be avoided and may not function as expected.</p>
</div>
<h4 id="a-common-use-case">A common use case</h4>
<p>The most common and best supported use case for a multi-screen setup is to open a dedicated <a href="../qtquick/qquickwindow.html" translate="no">QQuickWindow</a> or <a href="../qtquick/qquickview.html" translate="no">QQuickView</a> for each screen. With the default <code translate="no">threaded</code> render loop of the Qt Quick scenegraph, each of these windows will get its own dedicated render thread. This is good because the threads can be throttled independently based on vsync, and will not interfere with each other. With the <code translate="no">basic</code> loop, this can get problematic, causing animations to degrade.</p>
<p>For example, discovering all connected screens and creating a <a href="../qtquick/qquickview.html" translate="no">QQuickView</a> for each of them can be done like this:</p>
<pre class="cpp plain" translate="no">
 int main(int argc, char **argv)
 {
     QGuiApplication app(argc, argv);

     QVector&lt;QQuickView *&gt; views;
     for (QScreen *screen : app.screens()) {
         QQuickView *view = new QQuickView;
         view-&gt;setScreen(screen);
         view-&gt;setResizeMode(QQuickView::SizeRootObjectToView);
         view-&gt;setSource(QUrl(&quot;qrc:/main.qml&quot;));
         QObject::connect(view-&gt;engine(), &amp;QQmlEngine::quit, qGuiApp, &amp;QCoreApplication::quit);
         views.append(view);
         view-&gt;showFullScreen();
     }

     int result = app.exec();

     qDeleteAll(views);
     return result;
 }
</pre>
<h3 id="advanced-eglfs-kms-features">Advanced eglfs_kms features</h3>
<h4 id="cloning-mirroring">Cloning (mirroring)</h4>
<p>Screen cloning (mirroring) is supported. This is enabled via the <code translate="no">clones</code> property:</p>
<pre class="cpp plain" translate="no">
 {
   &quot;device&quot;: &quot;/dev/dri/card0&quot;,
   &quot;outputs&quot;: [
       { &quot;name&quot;: &quot;HDMI1&quot;, &quot;mode&quot;: &quot;1920x1080&quot; },
       { &quot;name&quot;: &quot;DP1&quot;, &quot;mode&quot;: &quot;1920x1080&quot;, &quot;clones&quot;: &quot;HDMI1&quot; }
  ]
 }
</pre>
<p>In this case, the content on the display connected via DisplayPort will be the same as on the HDMI one. This is ensured by scanning out the same buffer on both.</p>
<p>However, this feature can only work if the resolutions are the same, there are no incompatibilities when it comes to accepted buffer formats, and the application doesn't have any output on the <a href="../qtgui/qscreen.html" translate="no">QScreen</a> associated with a clone destination. In practice, the latter means that no <a href="../qtgui/qwindow.html" translate="no">QWindow</a> associated with the <a href="../qtgui/qscreen.html" translate="no">QScreen</a> in question - DP1 in the example - must ever perform a <a href="../qtgui/qopenglcontext.html#swapBuffers" translate="no">QOpenGLContext::swapBuffers</a>() operation. It's up to the configuration and the application to ensure these.</p>
<h4 id="headless-mode-using-drm-render">Headless mode using DRM render</h4>
<p>Headless mode via DRM render nodes is supported. This allows performing GPU compute (OpenGL compute shaders, OpenCL) or off-screen OpenGL rendering without needing DRM master privileges. In this mode, applications can function even when there is already another process outputting to the screen.</p>
<p>Just switching <code translate="no">device</code> from <code translate="no">/dev/dri/card0</code> to <code translate="no">/dev/dri/renderD128</code> is futile on its own since there are a number of operations that cannot be performed in headless mode. Therefore, this must be combined with a <code translate="no">headless</code> property, for example:</p>
<pre class="cpp plain" translate="no">
 {
     &quot;device&quot;: &quot;/dev/dri/renderD128&quot;,
     &quot;headless&quot;: &quot;1024x768&quot;
 }
</pre>
<p>Keep in mind that windows are still sized to match the - now virtual - screen size, hence the need for specifying a size in the <code translate="no">headless</code> property. There is also a lack of vsync-based throttling.</p>
<p>Once enabled, applications have two typical choices to perform off-screen rendering in headless mode:</p>
<p>Use an ordinary window, such as a <a href="../qtopengl/qopenglwindow.html" translate="no">QOpenGLWindow</a> subclass, targeting the window's default framebuffer, meaning a <code translate="no">gbm_surface</code> in practice:</p>
<pre class="cpp plain" translate="no">
 MyOpenGLWindow w;
 w.show(); // will not actually show up on screen
 w.grabFramebuffer().save(&quot;output.png&quot;);
</pre>
<p>Or the typical offscreen approach with an extra FBO:</p>
<pre class="cpp plain" translate="no">
 QOffscreenSurface s;
 s.setFormat(ctx.format());
 s.create();
 ctx.makeCurrent(&amp;s);
 QOpenGLFramebufferObject fbo(1024, 768);
 fbo.bind();
 ctx.functions()-&gt;glClearColor(1, 0, 0, 1);
 ctx.functions()-&gt;glClear(GL_COLOR_BUFFER_BIT);
 fbo.toImage().save(&quot;output.png&quot;);
 ctx.doneCurrent();
</pre>
<h4 id="drm-api-selection">DRM API selection</h4>
<p>KMS/DRM can be used with two different DRM APIs which are <i>legacy</i> and <i>atomic</i>. The main benefit of DRM atomic API is to allow several DRM plane updates within the same renderloop, whereas legacy API would require one plane update per vsync.</p>
<p>Atomic API is useful when your application needs to blend content into overlays keeping all the updates within the same vsync. Still not all devices support this API and it could be unavailable on some older devices. KMS backend will by default use the legacy API, but you can enable the DRM atomic API with <code translate="no">QT_QPA_EGLFS_KMS_ATOMIC</code> environment variable set to 1.</p>
<p>Using a smaller framebuffer than screen resolution can also be useful. This is possible with DRM atomic using the <code translate="no">size</code> parameter in the JSON file. The example below uses a 1280x720 framebuffer on a 3840x2160 videomode :</p>
<pre class="cpp plain" translate="no">
 {
   &quot;device&quot;: &quot;/dev/dri/card0&quot;,
   &quot;outputs&quot;: [
     { &quot;name&quot;: &quot;HDMI1&quot;, &quot;mode&quot;: &quot;3840x2160&quot;, &quot;size&quot;: &quot;1280x720&quot;, &quot;format&quot;: &quot;argb8888&quot; }
   ]
 }
</pre>
<h3 id="eglfs-with-an-eglfs-kms-egldevice-backend">EGLFS with an eglfs_kms_egldevice backend</h3>
<p>This backend, typically used on Tegra devices, is similar to the KMS/DRM backend mentioned above, except that it relies on the EGLDevice and EGLStream extensions instead of GBM.</p>
<p>For technical details about this approach, check out <a href="https://wiki.qt.io/Qt_for_Embedded_Linux/XDC2014RitgerEGLNonMesa" translate="no">this presentation</a>.</p>
<p>As of Qt 5.7 this backend shares many of its internal implementation with the GBM-based backend. This means that multiple screens and the advanced configuration via <code translate="no">QT_QPA_EGLFS_KMS_CONFIG</code> are supported. Some settings, such as <code translate="no">hwcursor</code> and <code translate="no">pbuffers</code> are not applicable however.</p>
<p>By default, the backend will automatically choose the correct EGL layer for the default plane of each output. When necessary, this can be overridden by setting the <code translate="no">QT_QPA_EGLFS_LAYER_INDEX</code> environment variable to the index of the desired layer. This approach does not currently support multiple outputs, so its usage should be limited to systems with a single screen. To see which layers are available, and to debug potential startup issues, enable the logging category <code translate="no">qt.qpa.eglfs.kms</code>.</p>
<p>In some cases, it may be necessary to perform a video mode set on application startup even when the screen reports that the desired resolution is already set. This is normally optimized away, but if the screen stays powered down, try setting the environment variable <code translate="no">QT_QPA_EGLFS_ALWAYS_SET_MODE</code> to a non-zero value and relaunch the application.</p>
<p>To configure the behavior of the EGLStream object used by the backend, use the <code translate="no">QT_QPA_EGLFS_STREAM_FIFO_LENGTH</code> environment variable. This assumes that <code translate="no">KHR_stream_fifo</code> is supported by the target system. By default, the stream operates in mailbox mode. To switch to FIFO mode, set a value of 1 or greater. The value specifies the maximum number of frames the stream can hold.</p>
<p>On some systems it may become necessary to target a specific overlay plane through a pre-defined connector. Just forcing a layer index via <code translate="no">QT_QPA_EGLFS_LAYER_INDEX</code> does not perform plane configuration and is therefore not suitable in itself. Instead, in such special scenarios use the <code translate="no">QT_QPA_EGLFS_KMS_CONNECTOR_INDEX</code> and <code translate="no">QT_QPA_EGLFS_KMS_PLANE_INDEX</code> environment variables. When these are set, only the specified connector and plane will be in use, all other outputs will get ignored. The backend will take care of picking the EGL layer that corresponds to the desired plane, and configuring the plane.</p>
<h3 id="touch-input-in-systems-with-multiple-screens-on-kms-drm">Touch input in systems with multiple screens on KMS/DRM</h3>
<p>Touchscreens require additional considerations in multi-display systems because touch events have to be routed to the correct virtual screen, and this requires a correct mapping between touchscreens and display outputs.</p>
<p>The mapping is done via the JSON configuration file specified in <code translate="no">QT_QPA_EGLFS_KMS_CONFIG</code> and described in the previous sections. When a <code translate="no">touchDevice</code> property is present in an element of the <code translate="no">outputs</code> array, the value is treated as a device node and the touch device is associated with the display output in question.</p>
<p>For example, assuming our touchscreen has a device node of /dev/input/event5 and is a touchscreen integrated into the monitor connected via HDMI as the secondary screen, the following configuration ensures correct touch (and synthesized mouse) event translation:</p>
<pre class="cpp plain" translate="no">
  {
     &quot;device&quot;: &quot;drm-nvdc&quot;,
     &quot;outputs&quot;: [
       {
         &quot;name&quot;: &quot;HDMI1&quot;,
         &quot;touchDevice&quot;: &quot;/dev/input/event5&quot;,
         &quot;virtualIndex&quot;: 1
       },
       {
         &quot;name&quot;: &quot;DP1&quot;,
         &quot;virtualIndex&quot;: 0
       }
     ]
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>When in doubt, enable logging from both the graphics and input subsystems by setting the environment variable <code translate="no">QT_LOGGING_RULES=qt.qpa.*=true</code> before launching the application. This will help identify the correct input device nodes and may uncover output configuration issues that can be difficult to debug otherwise.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>As of Qt 5.14, the above is only supported for the evdevtouch and libinput backends. Other variants will continue to route events to the primary screen. To force the usage of evdevtouch on systems where multiple input backends are available, set the environment variable <code translate="no">QT_QPA_EGLFS_NO_LIBINPUT</code> to <code translate="no">1</code>.</p>
</div>
<h3 id="eglfs-with-other-backends">EGLFS with other backends</h3>
<p>Other backends, which are typically based on targeting the framebuffer or a composition API directly via the vendor's EGL implementation, usually provide limited or no support for multiple displays. On i.MX6-based boards with Vivante GPUs the <code translate="no">QT_QPA_EGLFS_FB</code> environment variable can be used to specify the framebuffer to target, similarly to linuxfb. On the Raspberry Pi the <code translate="no">QT_QPA_EGLFS_DISPMANX_ID</code> environment variable can be used to specify the screen to output to. The value corresponds to one of the <code translate="no">DISPMANX_ID_</code> constants, refer to the Dispmanx documentation. Note that these approaches, unlike KMS/DRM, will not typically allow output to multiple screens from the same application. Alternatively, driver-specific environment variables or kernel parameters may also be available as well to control the used framebuffer. Refer to the embedded board's documentation.</p>
<h2 id="video-memory">Video memory</h2>
<p>Systems with a fixed amount of dedicated video memory may need extra care before running Qt applications based on Qt Quick or classes like <a href="../qtopengl/qopenglwidget.html" translate="no">QOpenGLWidget</a>. The default setting may be insufficient for such applications, especially when they are displayed on a high resolution (for example, full HD) screen. In this case, they may start failing in unexpected ways. It is recommended to ensure that there is at least 128 MB of GPU memory available. For systems that do not have a fixed amount of memory reserved for the GPU, this is not an issue.</p>
<h3 id="linuxfb">linuxfb</h3>
<p>Use the <code translate="no">fb</code> plugin parameter to specify the framebuffer device to use.</p>
<h2 id="unix-signal-handlers">Unix signal handlers</h2>
<p>The console-oriented platform plugins like eglfs and linuxfb install signal handlers by default to capture interrupt (<code translate="no">SIGINT</code>), suspend and continue (<code translate="no">SIGTSTP</code>, <code translate="no">SIGCONT</code>) and termination (<code translate="no">SIGTERM</code>). This way the keyboard, terminal cursor, and possibly other graphics state can be restored when the application terminates or gets suspended due to <code translate="no">kill</code>, or <code translate="no">Ctrl+C</code> or <code translate="no">Ctrl+Z</code>. (although terminating or suspending via the keyboard is only possible when <code translate="no">QT_QPA_ENABLE_TERMINAL_KEYBOARD</code> is set, as outlined above in the Input section). However, in some cases capturing <code translate="no">SIGINT</code> can be undesirable as it may conflict with remote debugging for instance. Therefore, the environment variable <code translate="no">QT_QPA_NO_SIGNAL_HANDLER</code> is provided to opt-out from all built-in signal handling.</p>
<h2 id="fonts">Fonts</h2>
<p>Qt normally uses <code translate="no">fontconfig</code> to provide access to system fonts. If <code translate="no">fontconfig</code> is not available, Qt will fall back to using <code translate="no">QBasicFontDatabase</code>. In this case, Qt applications will look for fonts in Qt's <code translate="no">lib/fonts</code> directory. Qt will automatically detect pre-rendered fonts and TrueType fonts. This directory can be overridden by setting the <code translate="no">QT_QPA_FONTDIR</code> environment variable.</p>
<p>For more information on the supported formats, see <a href="qt-embedded-fonts.html" translate="no">Qt for Embedded Linux Fonts</a>.</p>
<div class="admonition note">
<p><b>Note: </b>Qt no longer ships any fonts in the <code translate="no">lib/fonts</code> directory. This means that it is up to the platform (the system image) to provide the necessary fonts.</p>
</div>
<h2 id="platform-plugins-for-windowing-systems-on-embedded-linux-devices">Platform plugins for windowing systems on embedded Linux devices</h2>
<h3 id="xcb">XCB</h3>
<p>This is the X11 plugin used on regular desktop Linux platforms. In some embedded environments, that provide X and the necessary development files for <a href="http://xcb.freedesktop.org" translate="no">xcb</a>, this plugin functions just like it does on a regular PC desktop.</p>
<div class="admonition note">
<p><b>Note: </b>On some devices there is no EGL and OpenGL support available under X because the EGL implementation is not compatible with Xlib. In this case the XCB plugin is built without EGL support, meaning that Qt Quick 2 or other OpenGL-based applications do not work with this platform plugin. It can still be used, however, to run software-rendered applications (based on <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> for example).</p>
</div>
<p>As a general rule, the usage of XCB on embedded devices is not advisable. Plugins like eglfs are likely to provide better performance and hardware acceleration.</p>
<h3 id="wayland">Wayland</h3>
<p><a href="http://wayland.freedesktop.org/" translate="no">Wayland</a> is a light-weight windowing system; or more precisely, it is a protocol for clients to talk to a display server.</p>
<p>Qt Wayland provides a <code translate="no">wayland</code> platform plugin that allows Qt applications to connect to a Wayland compositor.</p>
<p>For more details, see <a href="wayland-and-qt.html" translate="no">Wayland and Qt</a>.</p>
<h2 id="performance-enhancement-guidelines">Performance enhancement guidelines</h2>
<h3 id="use-hardware-rendering-where-possible">Use hardware rendering where possible</h3>
<p>When performance is critical to your application, avoid the use of Qt modules that rely on software rendering, such as <a href="../qtcharts/qtcharts-index.html" translate="no">Qt Charts</a>. Prefer modules that rely on hardware rendering instead, where possible.</p>
<h3 id="follow-the-best-practices-for-qt-quick">Follow the best practices for Qt Quick</h3>
<p>Follow the <a href="../qtquick/qtquick-bestpractices.html" translate="no">Best Practices for QML and Qt Quick</a>, especially with regards to including the <a href="../qtcmake/cmake-build-qml-application.html" translate="no">QML CMake API</a>, so that <a href="../qtquick/qtquick-tools-and-utilities.html#qmllint" translate="no">qmllint</a>, <a href="../qtqml/qtqml-qml-script-compiler.html" translate="no">QML script compiler</a> (qmlsc), and the <a href="../qtqml/qtqml-qml-type-compiler.html" translate="no">QML type compiler</a> (qmltc) are available. In addition, it's preferable to write declarative QML and minimize Javascript. For more information on how using excessive JavaScript may impact performance see <a href="qtquick-performance.html" translate="no">QML Performance Considerations And Suggestions</a>.</p>
<h3 id="use-images-textures-and-shader-effects-instead-of-the-canvas-qml-type">Use images/textures and shader effects instead of the Canvas QML type</h3>
<p>For drawing custom UI elements, use images/textures and <a href="topics-graphics.html#shader-effects" translate="no">Shader Effects</a>. Don't use the QML <a href="../qtquick/qml-qtquick-canvas.html" translate="no">Canvas</a> type. Shaders require hardware acceleration (GPU).</p>
<h3 id="use-qt-quick-instead-of-qt-widgets">Use Qt Quick instead of Qt Widgets</h3>
<p>With Qt Quick, it's possible to use either hardware-accelerated or software-rendered backends. For complex Uls, using Qt Widgets on embedded targets is not recommended, as it will always use a software backend.</p>
<p>There are trade-offs here:</p>
<ul>
<li>Using the QML engine and Qt Quick comes with initial overhead.</li>
<li>If your UI is very simple and repaints rarely, it may perform faster when implemented using Widgets instead of QML.</li>
<li>If your UI benefits from <a href="../qtquick/qtquick-statesanimations-animations.html" translate="no">animations</a>, <a href="../qtquick/qml-qtquick-flickable.html" translate="no">smooth scrolling</a>,and <a href="../qtquick/qml-qtquick-item.html#scale-prop" translate="no">scaling</a>, <a href="../qtquick/qml-qtquick-shadereffect.html" translate="no">rendering effects</a>, or <a href="../qtquick3d/qtquick3d-index.html" translate="no">3D</a> you need to have GPU acceleration, and thus Qt Quick.</li>
</ul>
<h3 id="choose-a-resolution-appropriate-for-your-ui-size">Choose a resolution appropriate for your UI size</h3>
<p>You need to be cautious with higher resolutions. Resolutions of 720p and higher may reduce performance.</p>
<h3 id="use-a-qml-window-type-as-your-application-s-root-element">Use a QML Window type as your application's root element</h3>
<p>Use a <a href="../qtquick/qml-qtquick-window.html" translate="no">Window</a> as your application's root element with the application's background <a href="../qtquick/qml-qtquick-window.html#color-prop" translate="no">color</a>.</p>
<p>The reasoning for this is that a Window component has a color property that has the effect of being a buffer clear. Rendering the background using a full-screen <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a> as an application's root <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> would cause an additional draw call. For some RHI backends this may be the same thing, but there is a difference between a <a href="../qtgui/qopenglfunctions.html#glClear" translate="no">glClear</a> call and drawing a quad. In most cases, a single, opaque image might not have a large performance impact but if you were to use an alpha value in that item's color, you might see a significant performance impact.</p>
<h2 id="related-topics">Related topics</h2>
<ul>
<li><a href="https://doc.qt.io/Boot2Qt/" translate="no">Boot to Qt</a></li>
<li><a href="configure-linux-device.html" translate="no">Configure an Embedded Linux Device</a></li>
<li><a href="inputs-linux-device.html" translate="no">Inputs on an Embedded Linux Device</a></li>
</ul>
</div>
<!-- @@@embedded-linux.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
