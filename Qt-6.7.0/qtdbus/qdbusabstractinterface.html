<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qdbusabstractinterface.cpp -->
  <meta name="description" content="The QDBusAbstractInterface class is the base class for all D-Bus interfaces in the Qt D-Bus binding, allowing access to remote interfaces.">
  <title>QDBusAbstractInterface Class | Qt D-Bus 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtdbus-index.html" translate="no">Qt D-Bus</a></li>
<li><a href="qtdbus-module.html" translate="no">C++ Classes</a></li>
<li>QDBusAbstractInterface</li>
<li id="buildversion"><a href="qtdbus-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QDBusAbstractInterface Class</h1>
<!-- $$$QDBusAbstractInterface-brief -->
<p>The QDBusAbstractInterface class is the base class for all D-Bus interfaces in the Qt D-Bus binding, allowing access to remote interfaces. <a href="#details">More...</a></p>
<!-- @@@QDBusAbstractInterface -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QDBusAbstractInterface&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS DBus) <br/>
target_link_libraries(mytarget PRIVATE Qt6::DBus)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += dbus</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html" translate="no">QObject</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qdbusconnectioninterface.html" translate="no">QDBusConnectionInterface</a> and <a href="qdbusinterface.html" translate="no">QDBusInterface</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qdbusabstractinterface-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#dtor.QDBusAbstractInterface" translate="no">~QDBusAbstractInterface</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDBusPendingCall </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#asyncCall-1" translate="no">asyncCall</a></b>(const QString &amp;<i>method</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDBusPendingCall </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#asyncCallWithArgumentList" translate="no">asyncCallWithArgumentList</a></b>(const QString &amp;<i>method</i>, const QList&lt;QVariant&gt; &amp;<i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDBusMessage </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#call-1" translate="no">call</a></b>(const QString &amp;<i>method</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDBusMessage </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#call-3" translate="no">call</a></b>(QDBus::CallMode <i>mode</i>, const QString &amp;<i>method</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDBusMessage </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#callWithArgumentList" translate="no">callWithArgumentList</a></b>(QDBus::CallMode <i>mode</i>, const QString &amp;<i>method</i>, const QList&lt;QVariant&gt; &amp;<i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#callWithCallback" translate="no">callWithCallback</a></b>(const QString &amp;<i>method</i>, const QList&lt;QVariant&gt; &amp;<i>args</i>, QObject *<i>receiver</i>, const char *<i>returnMethod</i>, const char *<i>errorMethod</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#callWithCallback-1" translate="no">callWithCallback</a></b>(const QString &amp;<i>method</i>, const QList&lt;QVariant&gt; &amp;<i>args</i>, QObject *<i>receiver</i>, const char *<i>slot</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDBusConnection </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#connection" translate="no">connection</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#interface" translate="no">interface</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#isInteractiveAuthorizationAllowed" translate="no">isInteractiveAuthorizationAllowed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDBusError </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#lastError" translate="no">lastError</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#path" translate="no">path</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#service" translate="no">service</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#setInteractiveAuthorizationAllowed" translate="no">setInteractiveAuthorizationAllowed</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#setTimeout" translate="no">setTimeout</a></b>(int <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qdbusabstractinterface.html#timeout" translate="no">timeout</a></b>() const</td></tr>
</table></div>
<!-- $$$QDBusAbstractInterface-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Generated-code classes also derive from QDBusAbstractInterface, all methods described here are also valid for generated-code classes. In addition to those described here, generated-code classes provide member functions for the remote methods, which allow for compile-time checking of the correct parameters and return values, as well as property type-matching and signal parameter-matching.</p>
</div>
<p><b>See also </b><a href="qdbusxml2cpp.html" translate="no">The QDBus compiler</a> and <a href="qdbusinterface.html" translate="no">QDBusInterface</a>.</p>
<!-- @@@QDBusAbstractInterface -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$~QDBusAbstractInterface[overload1]$$$~QDBusAbstractInterface -->
<h3 class="fn" translate="no" id="dtor.QDBusAbstractInterface"><code class="details extra" translate="no">[virtual noexcept]</code> QDBusAbstractInterface::<span class="name">~QDBusAbstractInterface</span>()</h3>
<p>Releases this object's resources.</p>
<!-- @@@~QDBusAbstractInterface -->
<!-- $$$asyncCall$$$asyncCallconstQString&Args&&... -->
<h3 class="fn" translate="no" id="asyncCall-1">template &lt;typename... Args&gt; <span class="type"><a href="qdbuspendingcall.html" translate="no">QDBusPendingCall</a></span> QDBusAbstractInterface::<span class="name">asyncCall</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>method</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>Calls the method <i translate="no">method</i> on this interface and passes <i translate="no">args</i> to the method. All <i translate="no">args</i> must be convertible to <a href="../qtcore/qvariant.html" translate="no">QVariant</a>.</p>
<p>The parameters to <code translate="no">call</code> are passed on to the remote function via D-Bus as input arguments. The returned <a href="qdbuspendingcall.html" translate="no">QDBusPendingCall</a> object can be used to find out information about the reply.</p>
<p>It can be used the following way:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qdbuspendingcall.html" translate="no">QDBusPendingCall</a></span> pcall <span class="operator">=</span> interface<span class="operator">-</span><span class="operator">&gt;</span>asyncCall(<span class="string">&quot;GetAPIVersion&quot;</span>_L1);
 <span class="keyword">auto</span> watcher <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qdbuspendingcallwatcher.html" translate="no">QDBusPendingCallWatcher</a></span>(pcall<span class="operator">,</span> <span class="keyword">this</span>);

 <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(watcher<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qdbuspendingcallwatcher.html" translate="no">QDBusPendingCallWatcher</a></span><span class="operator">::</span>finished<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span>
                  <span class="operator">[</span><span class="operator">&amp;</span><span class="operator">]</span>(<span class="type"><a href="qdbuspendingcallwatcher.html" translate="no">QDBusPendingCallWatcher</a></span> <span class="operator">*</span>w) {
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> value <span class="operator">=</span> retrieveValue();
     <span class="type"><a href="qdbuspendingreply.html" translate="no">QDBusPendingReply</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> reply(<span class="operator">*</span>w);
     <span class="type"><a href="qdbuspendingcall.html" translate="no">QDBusPendingCall</a></span> pcall;
     <span class="keyword">if</span> (reply<span class="operator">.</span>argumentAt<span class="operator">&lt;</span><span class="number">0</span><span class="operator">&gt;</span>() <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">14</span>)
         pcall <span class="operator">=</span> interface<span class="operator">-</span><span class="operator">&gt;</span>asyncCall(<span class="string">&quot;ProcessWorkUnicode&quot;</span>_L1<span class="operator">,</span> value);
     <span class="keyword">else</span>
         pcall <span class="operator">=</span> interface<span class="operator">-</span><span class="operator">&gt;</span>asyncCall(<span class="string">&quot;ProcessWork&quot;</span>_L1<span class="operator">,</span> <span class="string">&quot;UTF-8&quot;</span>_L1<span class="operator">,</span> value<span class="operator">.</span>toUtf8());

     w <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qdbuspendingcallwatcher.html" translate="no">QDBusPendingCallWatcher</a></span>(pcall);
     <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(w<span class="operator">,</span>  <span class="operator">&amp;</span><span class="type"><a href="qdbuspendingcallwatcher.html" translate="no">QDBusPendingCallWatcher</a></span><span class="operator">::</span>finished<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span>
                      <span class="operator">&amp;</span>Abstract_DBus_Interface<span class="operator">::</span>callFinishedSlot);
 });
</pre>
<p>This example illustrates function calling with 0, 1 and 2 parameters and illustrates different parameter types passed in each (the first call to <code translate="no">&quot;ProcessWorkUnicode&quot;</code> will contain one Unicode string, the second call to <code translate="no">&quot;ProcessWork&quot;</code> will contain one string and one byte array). See <a href="qdbusabstractinterface.html#call-1" translate="no">call</a>() for the same example in blocking (synchronous) calls.</p>
<div class="admonition note">
<p><b>Note: </b>Before Qt 5.14, this function accepted a maximum of just eight (8) arguments.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Method calls to local <code translate="no">QDBusServer</code>'s are never asynchronous due to implementation limitations.</p>
</div>
<p><b>See also </b><a href="qdbusabstractinterface.html#asyncCallWithArgumentList" translate="no">asyncCallWithArgumentList</a>().</p>
<!-- @@@asyncCall -->
<!-- $$$asyncCallWithArgumentList[overload1]$$$asyncCallWithArgumentListconstQString&constQList<QVariant>& -->
<h3 class="fn" translate="no" id="asyncCallWithArgumentList"><span class="type"><a href="qdbuspendingcall.html" translate="no">QDBusPendingCall</a></span> QDBusAbstractInterface::<span class="name">asyncCallWithArgumentList</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>method</i>, const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span>&gt; &amp;<i>args</i>)</h3>
<p>Places a call to the remote method specified by <i translate="no">method</i> on this interface, using <i translate="no">args</i> as arguments. This function returns a <a href="qdbuspendingcall.html" translate="no">QDBusPendingCall</a> object that can be used to track the status of the reply and access its contents once it has arrived.</p>
<p>Normally, you should place calls using <a href="qdbusabstractinterface.html#asyncCall-1" translate="no">asyncCall</a>().</p>
<div class="admonition note">
<p><b>Note: </b>Method calls to objects registered by the application itself are never asynchronous due to implementation limitations.</p>
</div>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@asyncCallWithArgumentList -->
<!-- $$$call$$$callconstQString&Args&&... -->
<h3 class="fn" translate="no" id="call-1">template &lt;typename... Args&gt; <span class="type"><a href="qdbusmessage.html" translate="no">QDBusMessage</a></span> QDBusAbstractInterface::<span class="name">call</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>method</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>Calls the method <i translate="no">method</i> on this interface and passes <i translate="no">args</i> to the method. All <i translate="no">args</i> must be convertible to <a href="../qtcore/qvariant.html" translate="no">QVariant</a>.</p>
<p>The parameters to <code translate="no">call</code> are passed on to the remote function via D-Bus as input arguments. Output arguments are returned in the <a href="qdbusmessage.html" translate="no">QDBusMessage</a> reply. If the reply is an error reply, <a href="qdbusabstractinterface.html#lastError" translate="no">lastError</a>() will also be set to the contents of the error message.</p>
<p>It can be used the following way:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> value <span class="operator">=</span> retrieveValue();
 <span class="type"><a href="qdbusmessage.html" translate="no">QDBusMessage</a></span> reply;

 <span class="type"><a href="qdbusreply.html" translate="no">QDBusReply</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> api <span class="operator">=</span> interface<span class="operator">-</span><span class="operator">&gt;</span>call(<span class="string">&quot;GetAPIVersion&quot;</span>_L1);
 <span class="keyword">if</span> (api <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">14</span>)
   reply <span class="operator">=</span> interface<span class="operator">-</span><span class="operator">&gt;</span>call(<span class="string">&quot;ProcessWorkUnicode&quot;</span>_L1<span class="operator">,</span> value);
 <span class="keyword">else</span>
   reply <span class="operator">=</span> interface<span class="operator">-</span><span class="operator">&gt;</span>call(<span class="string">&quot;ProcessWork&quot;</span>_L1<span class="operator">,</span> <span class="string">&quot;UTF-8&quot;</span>_L1<span class="operator">,</span> value<span class="operator">.</span>toUtf8());
</pre>
<p>This example illustrates function calling with 0, 1 and 2 parameters and illustrates different parameter types passed in each (the first call to <code translate="no">&quot;ProcessWorkUnicode&quot;</code> will contain one Unicode string, the second call to <code translate="no">&quot;ProcessWork&quot;</code> will contain one string and one byte array). See <a href="qdbusabstractinterface.html#asyncCall-1" translate="no">asyncCall</a>() for the same example in non-blocking (asynchronous) calls.</p>
<div class="admonition note">
<p><b>Note: </b>Before Qt 5.14, this function accepted a maximum of just eight (8) arguments.</p>
</div>
<p><b>See also </b><a href="qdbusabstractinterface.html#callWithArgumentList" translate="no">callWithArgumentList</a>().</p>
<!-- @@@call -->
<!-- $$$call$$$callQDBus::CallModeconstQString&Args&&... -->
<h3 class="fn" translate="no" id="call-3">template &lt;typename... Args&gt; <span class="type"><a href="qdbusmessage.html" translate="no">QDBusMessage</a></span> QDBusAbstractInterface::<span class="name">call</span>(<span class="type"><a href="qdbus.html#CallMode-enum" translate="no">QDBus::CallMode</a></span> <i>mode</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>method</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>This is an overloaded function.</p>
<p>Calls the method <i translate="no">method</i> on this interface and passes <i translate="no">args</i> to the method. All <i translate="no">args</i> must be convertible to <a href="../qtcore/qvariant.html" translate="no">QVariant</a>.</p>
<p>If <i translate="no">mode</i> is <code translate="no">NoWaitForReply</code>, then this function will return immediately after placing the call, without waiting for a reply from the remote method. Otherwise, <i translate="no">mode</i> indicates whether this function should activate the Qt Event Loop while waiting for the reply to arrive.</p>
<p>If this function reenters the Qt event loop in order to wait for the reply, it will exclude user input. During the wait, it may deliver signals and other method calls to your application. Therefore, it must be prepared to handle a reentrancy whenever a call is placed with call().</p>
<div class="admonition note">
<p><b>Note: </b>Before Qt 5.14, this function accepted a maximum of just eight (8) arguments.</p>
</div>
<p><b>See also </b><a href="qdbusabstractinterface.html#callWithArgumentList" translate="no">callWithArgumentList</a>().</p>
<!-- @@@call -->
<!-- $$$callWithArgumentList[overload1]$$$callWithArgumentListQDBus::CallModeconstQString&constQList<QVariant>& -->
<h3 class="fn" translate="no" id="callWithArgumentList"><span class="type"><a href="qdbusmessage.html" translate="no">QDBusMessage</a></span> QDBusAbstractInterface::<span class="name">callWithArgumentList</span>(<span class="type"><a href="qdbus.html#CallMode-enum" translate="no">QDBus::CallMode</a></span> <i>mode</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>method</i>, const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span>&gt; &amp;<i>args</i>)</h3>
<p>Places a call to the remote method specified by <i translate="no">method</i> on this interface, using <i translate="no">args</i> as arguments. This function returns the message that was received as a reply, which can be a normal <a href="qdbusmessage.html#MessageType-enum" translate="no">QDBusMessage::ReplyMessage</a> (indicating success) or <a href="qdbusmessage.html#MessageType-enum" translate="no">QDBusMessage::ErrorMessage</a> (if the call failed). The <i translate="no">mode</i> parameter specifies how this call should be placed.</p>
<p>If the call succeeds, <a href="qdbusabstractinterface.html#lastError" translate="no">lastError</a>() will be cleared; otherwise, it will contain the error this call produced.</p>
<p>Normally, you should place calls using <a href="qdbusabstractinterface.html#call-1" translate="no">call</a>().</p>
<div class="admonition warning">
<p><b>Warning: </b>If you use <code translate="no">UseEventLoop</code>, your code must be prepared to deal with any reentrancy: other method calls and signals may be delivered before this function returns, as well as other Qt queued signals and events.</p>
</div>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@callWithArgumentList -->
<!-- $$$callWithCallback[overload1]$$$callWithCallbackconstQString&constQList<QVariant>&QObject*constchar*constchar* -->
<h3 class="fn" translate="no" id="callWithCallback"><span class="type">bool</span> QDBusAbstractInterface::<span class="name">callWithCallback</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>method</i>, const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span>&gt; &amp;<i>args</i>, <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i>, const <span class="type">char</span> *<i>returnMethod</i>, const <span class="type">char</span> *<i>errorMethod</i>)</h3>
<p>Places a call to the remote method specified by <i translate="no">method</i> on this interface, using <i translate="no">args</i> as arguments. This function returns immediately after queueing the call. The reply from the remote function is delivered to the <i translate="no">returnMethod</i> on object <i translate="no">receiver</i>. If an error occurs, the <i translate="no">errorMethod</i> on object <i translate="no">receiver</i> is called instead.</p>
<p>This function returns <code translate="no">true</code> if the queueing succeeds. It does not indicate that the executed call succeeded. If it fails, the <i translate="no">errorMethod</i> is called. If the queueing failed, this function returns <code translate="no">false</code> and no slot will be called.</p>
<p>The <i translate="no">returnMethod</i> must have as its parameters the types returned by the function call. Optionally, it may have a <a href="qdbusmessage.html" translate="no">QDBusMessage</a> parameter as its last or only parameter. The <i translate="no">errorMethod</i> must have a <a href="qdbuserror.html" translate="no">QDBusError</a> as its only parameter.</p>
<div class="admonition note">
<p><b>Note: </b>Method calls to objects registered by the application itself are never asynchronous due to implementation limitations.</p>
</div>
<p><b>See also </b><a href="qdbuserror.html" translate="no">QDBusError</a> and <a href="qdbusmessage.html" translate="no">QDBusMessage</a>.</p>
<!-- @@@callWithCallback -->
<!-- $$$callWithCallback$$$callWithCallbackconstQString&constQList<QVariant>&QObject*constchar* -->
<h3 class="fn" translate="no" id="callWithCallback-1"><span class="type">bool</span> QDBusAbstractInterface::<span class="name">callWithCallback</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>method</i>, const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span>&gt; &amp;<i>args</i>, <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i>, const <span class="type">char</span> *<i>slot</i>)</h3>
<p>This is an overloaded function.</p>
<p>This function is deprecated. Please use the overloaded version.</p>
<p>Places a call to the remote method specified by <i translate="no">method</i> on this interface, using <i translate="no">args</i> as arguments. This function returns immediately after queueing the call. The reply from the remote function or any errors emitted by it are delivered to the <i translate="no">slot</i> slot on object <i translate="no">receiver</i>.</p>
<p>This function returns <code translate="no">true</code> if the queueing succeeded: it does not indicate that the call succeeded. If it failed, the slot will be called with an error message. <a href="qdbusabstractinterface.html#lastError" translate="no">lastError</a>() will not be set under those circumstances.</p>
<p><b>See also </b><a href="qdbuserror.html" translate="no">QDBusError</a> and <a href="qdbusmessage.html" translate="no">QDBusMessage</a>.</p>
<!-- @@@callWithCallback -->
<!-- $$$connection[overload1]$$$connection -->
<h3 class="fn" translate="no" id="connection"><span class="type"><a href="qdbusconnection.html" translate="no">QDBusConnection</a></span> QDBusAbstractInterface::<span class="name">connection</span>() const</h3>
<p>Returns the connection this interface is associated with.</p>
<!-- @@@connection -->
<!-- $$$interface[overload1]$$$interface -->
<h3 class="fn" translate="no" id="interface"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QDBusAbstractInterface::<span class="name">interface</span>() const</h3>
<p>Returns the name of this interface.</p>
<!-- @@@interface -->
<!-- $$$isInteractiveAuthorizationAllowed[overload1]$$$isInteractiveAuthorizationAllowed -->
<h3 class="fn" translate="no" id="isInteractiveAuthorizationAllowed"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">bool</span> QDBusAbstractInterface::<span class="name">isInteractiveAuthorizationAllowed</span>() const</h3>
<p>Returns whether, for asynchronous calls, the caller is prepared to wait for interactive authorization.</p>
<p>The default is <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qdbusabstractinterface.html#setInteractiveAuthorizationAllowed" translate="no">setInteractiveAuthorizationAllowed</a>() and <a href="qdbusmessage.html#setInteractiveAuthorizationAllowed" translate="no">QDBusMessage::setInteractiveAuthorizationAllowed</a>().</p>
<!-- @@@isInteractiveAuthorizationAllowed -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QDBusAbstractInterface::<span class="name">isValid</span>() const</h3>
<p>Returns <code translate="no">true</code> if this is a valid reference to a remote object. It returns <code translate="no">false</code> if there was an error during the creation of this interface (for instance, if the remote application does not exist).</p>
<p>Note: when dealing with remote objects, it is not always possible to determine if it exists when creating a <a href="qdbusinterface.html" translate="no">QDBusInterface</a>.</p>
<!-- @@@isValid -->
<!-- $$$lastError[overload1]$$$lastError -->
<h3 class="fn" translate="no" id="lastError"><span class="type"><a href="qdbuserror.html" translate="no">QDBusError</a></span> QDBusAbstractInterface::<span class="name">lastError</span>() const</h3>
<p>Returns the error the last operation produced, or an invalid error if the last operation did not produce an error.</p>
<!-- @@@lastError -->
<!-- $$$path[overload1]$$$path -->
<h3 class="fn" translate="no" id="path"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QDBusAbstractInterface::<span class="name">path</span>() const</h3>
<p>Returns the object path that this interface is associated with.</p>
<!-- @@@path -->
<!-- $$$service[overload1]$$$service -->
<h3 class="fn" translate="no" id="service"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QDBusAbstractInterface::<span class="name">service</span>() const</h3>
<p>Returns the name of the service this interface is associated with.</p>
<!-- @@@service -->
<!-- $$$setInteractiveAuthorizationAllowed[overload1]$$$setInteractiveAuthorizationAllowedbool -->
<h3 class="fn" translate="no" id="setInteractiveAuthorizationAllowed"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">void</span> QDBusAbstractInterface::<span class="name">setInteractiveAuthorizationAllowed</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Configures whether, for asynchronous calls, the caller is prepared to wait for interactive authorization.</p>
<p>If <i translate="no">enable</i> is set to <code translate="no">true</code>, the D-Bus messages generated for asynchronous calls via this interface will set the <code translate="no">ALLOW_INTERACTIVE_AUTHORIZATION</code> flag.</p>
<p>This flag is only useful when unprivileged code calls a more privileged method call, and an authorization framework is deployed that allows possibly interactive authorization.</p>
<p>The default is <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qdbusabstractinterface.html#isInteractiveAuthorizationAllowed" translate="no">isInteractiveAuthorizationAllowed</a>() and <a href="qdbusmessage.html#setInteractiveAuthorizationAllowed" translate="no">QDBusMessage::setInteractiveAuthorizationAllowed</a>().</p>
<!-- @@@setInteractiveAuthorizationAllowed -->
<!-- $$$setTimeout[overload1]$$$setTimeoutint -->
<h3 class="fn" translate="no" id="setTimeout"><span class="type">void</span> QDBusAbstractInterface::<span class="name">setTimeout</span>(<span class="type">int</span> <i>timeout</i>)</h3>
<p>Sets the timeout in milliseconds for all future DBus calls to <i translate="no">timeout</i>. -1 means the default DBus timeout (usually 25 seconds).</p>
<p><b>See also </b><a href="qdbusabstractinterface.html#timeout" translate="no">timeout</a>().</p>
<!-- @@@setTimeout -->
<!-- $$$timeout[overload1]$$$timeout -->
<h3 class="fn" translate="no" id="timeout"><span class="type">int</span> QDBusAbstractInterface::<span class="name">timeout</span>() const</h3>
<p>Returns the current value of the timeout in milliseconds. -1 means the default DBus timeout (usually 25 seconds).</p>
<p><b>See also </b><a href="qdbusabstractinterface.html#setTimeout" translate="no">setTimeout</a>().</p>
<!-- @@@timeout -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
