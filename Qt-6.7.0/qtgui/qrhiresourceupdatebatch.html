<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Records upload and copy type of operations.">
  <title>QRhiResourceUpdateBatch Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiResourceUpdateBatch</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiResourceUpdateBatch Class</h1>
<!-- $$$QRhiResourceUpdateBatch-brief -->
<p>Records upload and copy type of operations. <a href="#details">More...</a></p>
<!-- @@@QRhiResourceUpdateBatch -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiResourceUpdateBatch&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
</table></div>
<ul>
<li><a href="qrhiresourceupdatebatch-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#copyTexture" translate="no">copyTexture</a></b>(QRhiTexture *<i>dst</i>, QRhiTexture *<i>src</i>, const QRhiTextureCopyDescription &amp;<i>desc</i> = QRhiTextureCopyDescription())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#generateMips" translate="no">generateMips</a></b>(QRhiTexture *<i>tex</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#hasOptimalCapacity" translate="no">hasOptimalCapacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#merge" translate="no">merge</a></b>(QRhiResourceUpdateBatch *<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#readBackBuffer" translate="no">readBackBuffer</a></b>(QRhiBuffer *<i>buf</i>, quint32 <i>offset</i>, quint32 <i>size</i>, QRhiReadbackResult *<i>result</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#readBackTexture" translate="no">readBackTexture</a></b>(const QRhiReadbackDescription &amp;<i>rb</i>, QRhiReadbackResult *<i>result</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#release" translate="no">release</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#updateDynamicBuffer" translate="no">updateDynamicBuffer</a></b>(QRhiBuffer *<i>buf</i>, quint32 <i>offset</i>, quint32 <i>size</i>, const void *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#uploadStaticBuffer" translate="no">uploadStaticBuffer</a></b>(QRhiBuffer *<i>buf</i>, quint32 <i>offset</i>, quint32 <i>size</i>, const void *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#uploadStaticBuffer-1" translate="no">uploadStaticBuffer</a></b>(QRhiBuffer *<i>buf</i>, const void *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#uploadTexture" translate="no">uploadTexture</a></b>(QRhiTexture *<i>tex</i>, const QRhiTextureUploadDescription &amp;<i>desc</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiresourceupdatebatch.html#uploadTexture-1" translate="no">uploadTexture</a></b>(QRhiTexture *<i>tex</i>, const QImage &amp;<i>image</i>)</td></tr>
</table></div>
<!-- $$$QRhiResourceUpdateBatch-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>With <a href="qrhi.html" translate="no">QRhi</a> it is no longer possible to perform copy type of operations at arbitrary times. Instead, all such operations are recorded into batches that are then passed, most commonly, to <a href="qrhicommandbuffer.html#beginPass" translate="no">QRhiCommandBuffer::beginPass</a>(). What then happens under the hood is hidden from the application: the underlying implementations can defer and implement these operations in various different ways.</p>
<p>A resource update batch owns no graphics resources and does not perform any actual operations on its own. It should rather be viewed as a command buffer for update, upload, and copy type of commands.</p>
<p>To get an available, empty batch from the pool, call <a href="qrhi.html#nextResourceUpdateBatch" translate="no">QRhi::nextResourceUpdateBatch</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<!-- @@@QRhiResourceUpdateBatch -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$copyTexture[overload1]$$$copyTextureQRhiTexture*QRhiTexture*constQRhiTextureCopyDescription& -->
<h3 class="fn" translate="no" id="copyTexture"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">copyTexture</span>(<span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>dst</i>, <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>src</i>, const <span class="type"><a href="qrhitexturecopydescription.html" translate="no">QRhiTextureCopyDescription</a></span> &amp;<i>desc</i> = QRhiTextureCopyDescription())</h3>
<p>Enqueues a texture-to-texture copy operation from <i translate="no">src</i> into <i translate="no">dst</i> as described by <i translate="no">desc</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The source texture <i translate="no">src</i> must be created with <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::UsedAsTransferSource</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The format of the textures must match. With most graphics APIs the data is copied as-is without any format conversions. If <i translate="no">dst</i> and <i translate="no">src</i> are created with different formats, unspecified issues may arise.</p>
</div>
<!-- @@@copyTexture -->
<!-- $$$generateMips[overload1]$$$generateMipsQRhiTexture* -->
<h3 class="fn" translate="no" id="generateMips"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">generateMips</span>(<span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>)</h3>
<p>Enqueues a mipmap generation operation for the specified texture <i translate="no">tex</i>.</p>
<p>Both 2D and cube textures are supported.</p>
<div class="admonition note">
<p><b>Note: </b>The texture must be created with <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::MipMapped</a> and <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::UsedWithGenerateMips</a>.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b><a href="qrhi.html" translate="no">QRhi</a> cannot guarantee that mipmaps can be generated for all supported texture formats. For example, <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::RGBA32F</a> is not a <code translate="no">filterable</code> format in OpenGL ES 3.0 and Metal on iOS, and therefore the mipmap generation request may fail. RGBA8 and RGBA16F are typically filterable, so it is recommended to use these formats when mipmap generation is desired.</p>
</div>
<!-- @@@generateMips -->
<!-- $$$hasOptimalCapacity[overload1]$$$hasOptimalCapacity -->
<h3 class="fn" translate="no" id="hasOptimalCapacity"><span class="type">bool</span> QRhiResourceUpdateBatch::<span class="name">hasOptimalCapacity</span>() const</h3>
<p>Returns true until the number of buffer and texture operations enqueued onto this batch is below a reasonable limit.</p>
<p>The return value is false when the number of buffer and/or texture operations added to this batch have reached, or are about to reach, a certain limit. The batch is fully functional afterwards as well, but may need to allocate additional memory. Therefore, a renderer that collects lots of buffer and texture updates in a single batch when preparing a frame may want to consider <a href="qrhicommandbuffer.html#resourceUpdate" translate="no">submitting the batch</a> and <a href="qrhi.html#nextResourceUpdateBatch" translate="no">starting a new one</a> when this function returns false.</p>
<!-- @@@hasOptimalCapacity -->
<!-- $$$merge[overload1]$$$mergeQRhiResourceUpdateBatch* -->
<h3 class="fn" translate="no" id="merge"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">merge</span>(<span class="type">QRhiResourceUpdateBatch</span> *<i>other</i>)</h3>
<p>Copies all queued operations from the <i translate="no">other</i> batch into this one.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">other</i> may no longer contain valid data after the merge operation, and must not be submitted, but it will still need to be released by calling <a href="qrhiresourceupdatebatch.html#release" translate="no">release</a>().</p>
</div>
<p>This allows for a convenient pattern where resource updates that are already known during the initialization step are collected into a batch that is then merged into another when starting to first render pass later on:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> init()
 {
     initialUpdates <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
     initialUpdates<span class="operator">-</span><span class="operator">&gt;</span>uploadStaticBuffer(vbuf<span class="operator">,</span> vertexData);
     initialUpdates<span class="operator">-</span><span class="operator">&gt;</span>uploadStaticBuffer(ibuf<span class="operator">,</span> indexData);
     <span class="comment">// ...</span>
 }

 <span class="type">void</span> render()
 {
     <span class="type">QRhiResourceUpdateBatch</span> <span class="operator">*</span>resUpdates <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
     <span class="keyword">if</span> (initialUpdates) {
         resUpdates<span class="operator">-</span><span class="operator">&gt;</span>merge(initialUpdates);
         initialUpdates<span class="operator">-</span><span class="operator">&gt;</span>release();
         initialUpdates <span class="operator">=</span> nullptr;
     }
     <span class="comment">// resUpdates-&gt;updateDynamicBuffer(...);</span>
     cb<span class="operator">-</span><span class="operator">&gt;</span>beginPass(rt<span class="operator">,</span> clearCol<span class="operator">,</span> clearDs<span class="operator">,</span> resUpdates);
 }
</pre>
<!-- @@@merge -->
<!-- $$$readBackBuffer[overload1]$$$readBackBufferQRhiBuffer*quint32quint32QRhiReadbackResult* -->
<h3 class="fn" translate="no" id="readBackBuffer"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">readBackBuffer</span>(<span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>offset</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>size</i>, <span class="type"><a href="qrhireadbackresult.html" translate="no">QRhiReadbackResult</a></span> *<i>result</i>)</h3>
<p>Enqueues reading back a region of the <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> <i translate="no">buf</i>. The size of the region is specified by <i translate="no">size</i> in bytes, <i translate="no">offset</i> is the offset in bytes to start reading from.</p>
<p>A readback is asynchronous. <i translate="no">result</i> contains a callback that is invoked when the operation has completed. The data is provided in <a href="qrhireadbackresult.html#data-var" translate="no">QRhiReadbackResult::data</a>. Upon successful completion that <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a> will have a size equal to <i translate="no">size</i>. On failure the <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a> will be empty.</p>
<div class="admonition note">
<p><b>Note: </b>Reading buffers with a usage different than <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::UniformBuffer</a> is supported only when the <a href="qrhi.html#Feature-enum" translate="no">QRhi::ReadBackNonUniformBuffer</a> feature is reported as supported.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The asynchronous readback is guaranteed to have completed when one of the following conditions is met: <a href="qrhi.html#finish" translate="no">finish</a>() has been called; or, at least <code translate="no">N</code> frames have been <a href="qrhi.html#endFrame" translate="no">submitted</a>, including the frame that issued the readback operation, and the <a href="qrhi.html#beginFrame" translate="no">recording of a new frame</a> has been started, where <code translate="no">N</code> is the <a href="qrhi.html#resourceLimit" translate="no">resource limit value</a> returned for <a href="qrhi.html#ResourceLimit-enum" translate="no">QRhi::MaxAsyncReadbackFrames</a>.</p>
</div>
<p><b>See also </b><a href="qrhiresourceupdatebatch.html#readBackTexture" translate="no">readBackTexture</a>(), <a href="qrhi.html#isFeatureSupported" translate="no">QRhi::isFeatureSupported</a>(), and <a href="qrhi.html#resourceLimit" translate="no">QRhi::resourceLimit</a>().</p>
<!-- @@@readBackBuffer -->
<!-- $$$readBackTexture[overload1]$$$readBackTextureconstQRhiReadbackDescription&QRhiReadbackResult* -->
<h3 class="fn" translate="no" id="readBackTexture"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">readBackTexture</span>(const <span class="type"><a href="qrhireadbackdescription.html" translate="no">QRhiReadbackDescription</a></span> &amp;<i>rb</i>, <span class="type"><a href="qrhireadbackresult.html" translate="no">QRhiReadbackResult</a></span> *<i>result</i>)</h3>
<p>Enqueues a texture-to-host copy operation as described by <i translate="no">rb</i>.</p>
<p>Normally <i translate="no">rb</i> will specify a <a href="qrhitexture.html" translate="no">QRhiTexture</a> as the source. However, when the swapchain in the current frame was created with <a href="qrhiswapchain.html#Flag-enum" translate="no">QRhiSwapChain::UsedAsTransferSource</a>, it can also be the source of the readback. For this, leave the texture set to null in <i translate="no">rb</i>.</p>
<p>Unlike other operations, the results here need to be processed by the application. Therefore, <i translate="no">result</i> provides not just the data but also a callback as operations on the batch are asynchronous by nature:</p>
<pre class="cpp" translate="no">
 rhi<span class="operator">-</span><span class="operator">&gt;</span>beginFrame(swapchain);
 cb<span class="operator">-</span><span class="operator">&gt;</span>beginPass(swapchain<span class="operator">-</span><span class="operator">&gt;</span>currentFrameRenderTarget()<span class="operator">,</span> colorClear<span class="operator">,</span> dsClear);
 <span class="comment">// ...</span>
 <span class="type"><a href="qrhireadbackresult.html" translate="no">QRhiReadbackResult</a></span> <span class="operator">*</span>rbResult <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qrhireadbackresult.html" translate="no">QRhiReadbackResult</a></span>;
 rbResult<span class="operator">-</span><span class="operator">&gt;</span>completed <span class="operator">=</span> <span class="operator">[</span>rbResult<span class="operator">]</span> {
     {
         <span class="keyword">const</span> <span class="type"><a href="qimage.html" translate="no">QImage</a></span><span class="operator">::</span>Format fmt <span class="operator">=</span> <span class="type"><a href="qimage.html" translate="no">QImage</a></span><span class="operator">::</span>Format_RGBA8888_Premultiplied; <span class="comment">// fits QRhiTexture::RGBA8</span>
         <span class="keyword">const</span> <span class="type"><a href="../qtcore/qttypes.html#uchar-typedef" translate="no">uchar</a></span> <span class="operator">*</span>p <span class="operator">=</span> <span class="keyword">reinterpret_cast</span><span class="operator">&lt;</span><span class="keyword">const</span> <span class="type"><a href="../qtcore/qttypes.html#uchar-typedef" translate="no">uchar</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(rbResult<span class="operator">-</span><span class="operator">&gt;</span>data<span class="operator">.</span>constData());
         <span class="type"><a href="qimage.html" translate="no">QImage</a></span> image(p<span class="operator">,</span> rbResult<span class="operator">-</span><span class="operator">&gt;</span>pixelSize<span class="operator">.</span>width()<span class="operator">,</span> rbResult<span class="operator">-</span><span class="operator">&gt;</span>pixelSize<span class="operator">.</span>height()<span class="operator">,</span> fmt);
         image<span class="operator">.</span>save(<span class="string">&quot;result.png&quot;</span>);
     }
     <span class="keyword">delete</span> rbResult;
 };
 <span class="type">QRhiResourceUpdateBatch</span> <span class="operator">*</span>u <span class="operator">=</span> nextResourceUpdateBatch();
 <span class="type"><a href="qrhireadbackdescription.html" translate="no">QRhiReadbackDescription</a></span> rb; <span class="comment">// no texture -&gt; uses the current backbuffer of sc</span>
 u<span class="operator">-</span><span class="operator">&gt;</span>readBackTexture(rb<span class="operator">,</span> rbResult);
 cb<span class="operator">-</span><span class="operator">&gt;</span>endPass(u);
 rhi<span class="operator">-</span><span class="operator">&gt;</span>endFrame(swapchain);
</pre>
<div class="admonition note">
<p><b>Note: </b>The texture must be created with <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::UsedAsTransferSource</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Multisample textures cannot be read back.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The readback returns raw byte data, in order to allow the applications to interpret it in any way they see fit. Be aware of the blending settings of rendering code: if the blending is set up to rely on premultiplied alpha, the results of the readback must also be interpreted as Premultiplied.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When interpreting the resulting raw data, be aware that the readback happens with a byte ordered format. A <a href="qrhitexture.html#Format-enum" translate="no">RGBA8</a> texture maps therefore to byte ordered <a href="qimage.html" translate="no">QImage</a> formats, such as, <a href="qimage.html#Format-enum" translate="no">QImage::Format_RGBA8888</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The asynchronous readback is guaranteed to have completed when one of the following conditions is met: <a href="qrhi.html#finish" translate="no">finish</a>() has been called; or, at least <code translate="no">N</code> frames have been <a href="qrhi.html#endFrame" translate="no">submitted</a>, including the frame that issued the readback operation, and the <a href="qrhi.html#beginFrame" translate="no">recording of a new frame</a> has been started, where <code translate="no">N</code> is the <a href="qrhi.html#resourceLimit" translate="no">resource limit value</a> returned for <a href="qrhi.html#ResourceLimit-enum" translate="no">QRhi::MaxAsyncReadbackFrames</a>.</p>
</div>
<p>A single readback operation copies one mip level of one layer (cubemap face or 3D slice or texture array element) at a time. The level and layer are specified by the respective fields in <i translate="no">rb</i>.</p>
<p><b>See also </b><a href="qrhiresourceupdatebatch.html#readBackBuffer" translate="no">readBackBuffer</a>() and <a href="qrhi.html#resourceLimit" translate="no">QRhi::resourceLimit</a>().</p>
<!-- @@@readBackTexture -->
<!-- $$$release[overload1]$$$release -->
<h3 class="fn" translate="no" id="release"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">release</span>()</h3>
<p>Returns the batch to the pool. This should only be used when the batch is not passed to one of <a href="qrhicommandbuffer.html#beginPass" translate="no">QRhiCommandBuffer::beginPass</a>(), <a href="qrhicommandbuffer.html#endPass" translate="no">QRhiCommandBuffer::endPass</a>(), or <a href="qrhicommandbuffer.html#resourceUpdate" translate="no">QRhiCommandBuffer::resourceUpdate</a>() because these implicitly call destroy().</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a> instances must never by <code translate="no">deleted</code> by applications.</p>
</div>
<!-- @@@release -->
<!-- $$$updateDynamicBuffer[overload1]$$$updateDynamicBufferQRhiBuffer*quint32quint32constvoid* -->
<h3 class="fn" translate="no" id="updateDynamicBuffer"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">updateDynamicBuffer</span>(<span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>offset</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>size</i>, const <span class="type">void</span> *<i>data</i>)</h3>
<p>Enqueues updating a region of a <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> <i translate="no">buf</i> created with the type <a href="qrhibuffer.html#Type-enum" translate="no">QRhiBuffer::Dynamic</a>.</p>
<p>The region is specified <i translate="no">offset</i> and <i translate="no">size</i>. The actual bytes to write are specified by <i translate="no">data</i> which must have at least <i translate="no">size</i> bytes available. <i translate="no">data</i> can safely be destroyed or changed once this function returns.</p>
<div class="admonition note">
<p><b>Note: </b>If host writes are involved, which is the case with updateDynamicBuffer() typically as such buffers are backed by host visible memory with most backends, they may accumulate within a frame. Thus pass 1 reading a region changed by a batch passed to pass 2 may see the changes specified in pass 2's update batch.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qrhi.html" translate="no">QRhi</a> transparently manages double buffering in order to prevent stalling the graphics pipeline. The fact that a <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> may have multiple native buffer objects underneath can be safely ignored when using the <a href="qrhi.html" translate="no">QRhi</a> and <a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a>.</p>
</div>
<!-- @@@updateDynamicBuffer -->
<!-- $$$uploadStaticBuffer[overload1]$$$uploadStaticBufferQRhiBuffer*quint32quint32constvoid* -->
<h3 class="fn" translate="no" id="uploadStaticBuffer"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">uploadStaticBuffer</span>(<span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>offset</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>size</i>, const <span class="type">void</span> *<i>data</i>)</h3>
<p>Enqueues updating a region of a <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> <i translate="no">buf</i> created with the type <a href="qrhibuffer.html#Type-enum" translate="no">QRhiBuffer::Immutable</a> or <a href="qrhibuffer.html#Type-enum" translate="no">QRhiBuffer::Static</a>.</p>
<p>The region is specified <i translate="no">offset</i> and <i translate="no">size</i>. The actual bytes to write are specified by <i translate="no">data</i> which must have at least <i translate="no">size</i> bytes available. <i translate="no">data</i> can safely be destroyed or changed once this function returns.</p>
<!-- @@@uploadStaticBuffer -->
<!-- $$$uploadStaticBuffer$$$uploadStaticBufferQRhiBuffer*constvoid* -->
<h3 class="fn" translate="no" id="uploadStaticBuffer-1"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">uploadStaticBuffer</span>(<span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>, const <span class="type">void</span> *<i>data</i>)</h3>
<p>Enqueues updating the entire <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> <i translate="no">buf</i> created with the type <a href="qrhibuffer.html#Type-enum" translate="no">QRhiBuffer::Immutable</a> or <a href="qrhibuffer.html#Type-enum" translate="no">QRhiBuffer::Static</a>.</p>
<!-- @@@uploadStaticBuffer -->
<!-- $$$uploadTexture[overload1]$$$uploadTextureQRhiTexture*constQRhiTextureUploadDescription& -->
<h3 class="fn" translate="no" id="uploadTexture"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">uploadTexture</span>(<span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>, const <span class="type"><a href="qrhitextureuploaddescription.html" translate="no">QRhiTextureUploadDescription</a></span> &amp;<i>desc</i>)</h3>
<p>Enqueues uploading the image data for one or more mip levels in one or more layers of the texture <i translate="no">tex</i>.</p>
<p>The details of the copy (source <a href="qimage.html" translate="no">QImage</a> or compressed texture data, regions, target layers and levels) are described in <i translate="no">desc</i>.</p>
<!-- @@@uploadTexture -->
<!-- $$$uploadTexture$$$uploadTextureQRhiTexture*constQImage& -->
<h3 class="fn" translate="no" id="uploadTexture-1"><span class="type">void</span> QRhiResourceUpdateBatch::<span class="name">uploadTexture</span>(<span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>, const <span class="type"><a href="qimage.html" translate="no">QImage</a></span> &amp;<i>image</i>)</h3>
<p>Enqueues uploading the image data for mip level 0 of layer 0 of the texture <i translate="no">tex</i>.</p>
<p><i translate="no">tex</i> must have an uncompressed format. Its format must also be compatible with the <a href="qimage.html#format" translate="no">QImage::format</a>() of <i translate="no">image</i>. The source data is given in <i translate="no">image</i>.</p>
<!-- @@@uploadTexture -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
