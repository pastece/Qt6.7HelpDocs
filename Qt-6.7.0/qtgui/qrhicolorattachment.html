<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Describes the a single color attachment of a render target.">
  <title>QRhiColorAttachment Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiColorAttachment</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiColorAttachment Class</h1>
<!-- $$$QRhiColorAttachment-brief -->
<p>Describes the a single color attachment of a render target. <a href="#details">More...</a></p>
<!-- @@@QRhiColorAttachment -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiColorAttachment&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
</table></div>
<ul>
<li><a href="qrhicolorattachment-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#QRhiColorAttachment" translate="no">QRhiColorAttachment</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#QRhiColorAttachment-1" translate="no">QRhiColorAttachment</a></b>(QRhiTexture *<i>texture</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#QRhiColorAttachment-2" translate="no">QRhiColorAttachment</a></b>(QRhiRenderBuffer *<i>renderBuffer</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#layer" translate="no">layer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#level" translate="no">level</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> int </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#multiViewCount" translate="no">multiViewCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#renderBuffer" translate="no">renderBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#resolveLayer" translate="no">resolveLayer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#resolveLevel" translate="no">resolveLevel</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#resolveTexture" translate="no">resolveTexture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#setLayer" translate="no">setLayer</a></b>(int <i>layer</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#setLevel" translate="no">setLevel</a></b>(int <i>level</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#setMultiViewCount" translate="no">setMultiViewCount</a></b>(int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#setRenderBuffer" translate="no">setRenderBuffer</a></b>(QRhiRenderBuffer *<i>rb</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#setResolveLayer" translate="no">setResolveLayer</a></b>(int <i>layer</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#setResolveLevel" translate="no">setResolveLevel</a></b>(int <i>level</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#setResolveTexture" translate="no">setResolveTexture</a></b>(QRhiTexture *<i>tex</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#setTexture" translate="no">setTexture</a></b>(QRhiTexture *<i>tex</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qrhicolorattachment.html#texture" translate="no">texture</a></b>() const</td></tr>
</table></div>
<!-- $$$QRhiColorAttachment-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>A color attachment is either a <a href="qrhitexture.html" translate="no">QRhiTexture</a> or a <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>. The former, i.e. when <a href="qrhicolorattachment.html#texture" translate="no">texture</a>() is set, is used in most cases. QRhiColorAttachment is commonly used in combination with <a href="qrhitexturerendertargetdescription.html" translate="no">QRhiTextureRenderTargetDescription</a>.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhicolorattachment.html#texture" translate="no">texture</a>() and <a href="qrhicolorattachment.html#renderBuffer" translate="no">renderBuffer</a>() cannot be both set (be non-null at the same time).</p>
</div>
<p>Setting <a href="qrhicolorattachment.html#renderBuffer" translate="no">renderBuffer</a> instead is recommended only when multisampling is needed. Relying on <a href="qrhi.html#Feature-enum" translate="no">QRhi::MultisampleRenderBuffer</a> is a better choice than <a href="qrhi.html#Feature-enum" translate="no">QRhi::MultisampleTexture</a> in practice since the former is available in more run time configurations (e.g. when running on OpenGL ES 3.0 which has no support for multisample textures, but does support multisample renderbuffers).</p>
<p>When targeting a non-multisample texture, the <a href="qrhicolorattachment.html#layer" translate="no">layer</a>() and <a href="qrhicolorattachment.html#level" translate="no">level</a>() indicate the targeted layer (face index <code translate="no">0-5</code> for cubemaps) and mip level. For 3D textures <a href="qrhicolorattachment.html#layer" translate="no">layer</a>() specifies the slice (one 2D image within the 3D texture) to render to. For texture arrays <a href="qrhicolorattachment.html#layer" translate="no">layer</a>() is the array index.</p>
<p>When <a href="qrhicolorattachment.html#texture" translate="no">texture</a>() or <a href="qrhicolorattachment.html#renderBuffer" translate="no">renderBuffer</a>() is multisample, <a href="qrhicolorattachment.html#resolveTexture" translate="no">resolveTexture</a>() can be set optionally. When set, samples are resolved automatically into that (non-multisample) texture at the end of the render pass. When rendering into a multisample renderbuffers, this is the only way to get resolved, non-multisample content out of them. Multisample textures allow sampling in shaders so for them this is just one option.</p>
<div class="admonition note">
<p><b>Note: </b>when resolving is enabled, the multisample data may not be written out at all. This means that the multisample <a href="qrhicolorattachment.html#texture" translate="no">texture</a>() must not be used afterwards with shaders for sampling when <a href="qrhicolorattachment.html#resolveTexture" translate="no">resolveTexture</a>() is set.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<p><b>See also </b><a href="qrhitexturerendertargetdescription.html" translate="no">QRhiTextureRenderTargetDescription</a>.</p>
<!-- @@@QRhiColorAttachment -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QRhiColorAttachment[overload1]$$$QRhiColorAttachment -->
<h3 class="fn" translate="no" id="QRhiColorAttachment"><code class="details extra" translate="no">[constexpr noexcept]</code> QRhiColorAttachment::<span class="name">QRhiColorAttachment</span>()</h3>
<p>Constructs an empty color attachment description.</p>
<!-- @@@QRhiColorAttachment -->
<!-- $$$QRhiColorAttachment$$$QRhiColorAttachmentQRhiTexture* -->
<h3 class="fn" translate="no" id="QRhiColorAttachment-1">QRhiColorAttachment::<span class="name">QRhiColorAttachment</span>(<span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>texture</i>)</h3>
<p>Constructs a color attachment description that specifies <i translate="no">texture</i> as the associated color buffer.</p>
<!-- @@@QRhiColorAttachment -->
<!-- $$$QRhiColorAttachment$$$QRhiColorAttachmentQRhiRenderBuffer* -->
<h3 class="fn" translate="no" id="QRhiColorAttachment-2">QRhiColorAttachment::<span class="name">QRhiColorAttachment</span>(<span class="type"><a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *<i>renderBuffer</i>)</h3>
<p>Constructs a color attachment description that specifies <i translate="no">renderBuffer</i> as the associated color buffer.</p>
<!-- @@@QRhiColorAttachment -->
<!-- $$$layer[overload1]$$$layer -->
<h3 class="fn" translate="no" id="layer"><span class="type">int</span> QRhiColorAttachment::<span class="name">layer</span>() const</h3>
<p>Returns the layer index (cubemap face or array layer). 0 by default.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#setLayer" translate="no">setLayer</a>().</p>
<!-- @@@layer -->
<!-- $$$level[overload1]$$$level -->
<h3 class="fn" translate="no" id="level"><span class="type">int</span> QRhiColorAttachment::<span class="name">level</span>() const</h3>
<p>Returns the mip level. 0 by default.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#setLevel" translate="no">setLevel</a>().</p>
<!-- @@@level -->
<!-- $$$multiViewCount[overload1]$$$multiViewCount -->
<h3 class="fn" translate="no" id="multiViewCount"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">int</span> QRhiColorAttachment::<span class="name">multiViewCount</span>() const</h3>
<p>Returns the currently set number of views. Defaults to 0 which indicates the render target with this color attachment is not going to be used with multiview rendering.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#setMultiViewCount" translate="no">setMultiViewCount</a>().</p>
<!-- @@@multiViewCount -->
<!-- $$$renderBuffer[overload1]$$$renderBuffer -->
<h3 class="fn" translate="no" id="renderBuffer"><span class="type"><a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *QRhiColorAttachment::<span class="name">renderBuffer</span>() const</h3>
<p>Returns the renderbuffer this attachment description references, or <code translate="no">nullptr</code> if there is none.</p>
<p>In practice associating a <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> with a <a href="qrhicolorattachment.html" translate="no">QRhiColorAttachment</a> makes the most sense when setting up multisample rendering via a multisample <a href="qrhirenderbuffer.html#Type-enum" translate="no">color</a> renderbuffer that is then resolved into a non-multisample texture at the end of the render pass.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#setRenderBuffer" translate="no">setRenderBuffer</a>().</p>
<!-- @@@renderBuffer -->
<!-- $$$resolveLayer[overload1]$$$resolveLayer -->
<h3 class="fn" translate="no" id="resolveLayer"><span class="type">int</span> QRhiColorAttachment::<span class="name">resolveLayer</span>() const</h3>
<p>Returns the currently set resolve texture layer. Defaults to 0.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#setResolveLayer" translate="no">setResolveLayer</a>().</p>
<!-- @@@resolveLayer -->
<!-- $$$resolveLevel[overload1]$$$resolveLevel -->
<h3 class="fn" translate="no" id="resolveLevel"><span class="type">int</span> QRhiColorAttachment::<span class="name">resolveLevel</span>() const</h3>
<p>Returns the currently set resolve texture mip level. Defaults to 0.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#setResolveLevel" translate="no">setResolveLevel</a>().</p>
<!-- @@@resolveLevel -->
<!-- $$$resolveTexture[overload1]$$$resolveTexture -->
<h3 class="fn" translate="no" id="resolveTexture"><span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *QRhiColorAttachment::<span class="name">resolveTexture</span>() const</h3>
<p>Returns the resolve texture this attachment description references, or <code translate="no">nullptr</code> if there is none.</p>
<p>Setting a non-null resolve texture is applicable when the attachment references a multisample texture or renderbuffer. The <a href="qrhitexture.html" translate="no">QRhiTexture</a> in the resolveTexture() is then a non-multisample 2D texture (or texture array) with the same size (but a sample count of 1). The multisample content is automatically resolved into this texture at the end of each render pass.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#setResolveTexture" translate="no">setResolveTexture</a>().</p>
<!-- @@@resolveTexture -->
<!-- $$$setLayer[overload1]$$$setLayerint -->
<h3 class="fn" translate="no" id="setLayer"><span class="type">void</span> QRhiColorAttachment::<span class="name">setLayer</span>(<span class="type">int</span> <i>layer</i>)</h3>
<p>Sets the <i translate="no">layer</i> index.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#layer" translate="no">layer</a>().</p>
<!-- @@@setLayer -->
<!-- $$$setLevel[overload1]$$$setLevelint -->
<h3 class="fn" translate="no" id="setLevel"><span class="type">void</span> QRhiColorAttachment::<span class="name">setLevel</span>(<span class="type">int</span> <i>level</i>)</h3>
<p>Sets the mip <i translate="no">level</i>.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#level" translate="no">level</a>().</p>
<!-- @@@setLevel -->
<!-- $$$setMultiViewCount[overload1]$$$setMultiViewCountint -->
<h3 class="fn" translate="no" id="setMultiViewCount"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">void</span> QRhiColorAttachment::<span class="name">setMultiViewCount</span>(<span class="type">int</span> <i>count</i>)</h3>
<p>Sets the view <i translate="no">count</i>. Setting a value larger than 1 indicates that the render target with this color attachment is going to be used with multiview rendering. The default value is 0. Values smaller than 2 indicate no multiview rendering.</p>
<p>When <i translate="no">count</i> is set to <code translate="no">2</code> or greater, the color attachment must be associated with a 2D texture array. <a href="qrhicolorattachment.html#layer" translate="no">layer</a>() and <a href="qrhicolorattachment.html#multiViewCount" translate="no">multiViewCount</a>() together define the range of texture array elements that are targeted during multiview rendering.</p>
<p>For example, if <code translate="no">layer</code> is <code translate="no">0</code> and <code translate="no">multiViewCount</code> is <code translate="no">2</code>, the texture array must have 2 (or more) elements, and the multiview rendering will target elements 0 and 1. The <code translate="no">gl_ViewIndex</code> variable in the shaders has a value of <code translate="no">0</code> or <code translate="no">1</code> then, where view <code translate="no">0</code> corresponds to the texture array element <code translate="no">0</code>, and view <code translate="no">1</code> to the array element <code translate="no">1</code>.</p>
<div class="admonition note">
<p><b>Note: </b>Setting a <i translate="no">count</i> larger than 1, using a texture array as <a href="qrhicolorattachment.html#texture" translate="no">texture</a>(), and calling <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() on a <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> with this color attachment implies multiview rendering for the entire render pass. <a href="qrhicolorattachment.html#multiViewCount" translate="no">multiViewCount</a>() should not be set unless multiview rendering is wanted. Multiview cannot be used with texture types other than 2D texture arrays. (although 3D textures may work, depending on the graphics API and backend; applications are nonetheless advised not to rely on that and only use 2D texture arrays as the render targets of multiview rendering)</p>
</div>
<p>See <a href="https://registry.khronos.org/OpenGL/extensions/OVR/OVR_multiview.txt" translate="no">GL_OVR_multiview</a> for more details regarding multiview rendering. Do note that Qt requires <a href="https://registry.khronos.org/OpenGL/extensions/OVR/OVR_multiview2.txt" translate="no">GL_OVR_multiview2</a> as well, when running on OpenGL (ES).</p>
<p>Multiview rendering is available only when the <a href="qrhi.html#Feature-enum" translate="no">MultiView</a> feature is reported as supported from <a href="qrhi.html#isFeatureSupported" translate="no">isFeatureSupported</a>().</p>
<div class="admonition note">
<p><b>Note: </b>For portability, be aware of limitations that exist for multiview rendering with some of the graphics APIs. It is recommended that multiview render passes do not rely on any of the features that <a href="https://registry.khronos.org/OpenGL/extensions/OVR/OVR_multiview.txt" translate="no">GL_OVR_multiview</a> declares as unsupported. The one exception is shader stage outputs other than <code translate="no">gl_Position</code> depending on <code translate="no">gl_ViewIndex</code>: that can be relied on (even with OpenGL) because <a href="qrhi.html" translate="no">QRhi</a> never reports multiview as supported without <code translate="no">GL_OVR_multiview2</code> also being present.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Multiview rendering is not supported in combination with tessellation or geometry shaders, even though some implementations of some graphics APIs may allow this.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#multiViewCount" translate="no">multiViewCount</a>().</p>
<!-- @@@setMultiViewCount -->
<!-- $$$setRenderBuffer[overload1]$$$setRenderBufferQRhiRenderBuffer* -->
<h3 class="fn" translate="no" id="setRenderBuffer"><span class="type">void</span> QRhiColorAttachment::<span class="name">setRenderBuffer</span>(<span class="type"><a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *<i>rb</i>)</h3>
<p>Sets the renderbuffer <i translate="no">rb</i>.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhicolorattachment.html#texture" translate="no">texture</a>() and <a href="qrhicolorattachment.html#renderBuffer" translate="no">renderBuffer</a>() cannot be both set (be non-null at the same time).</p>
</div>
<p><b>See also </b><a href="qrhicolorattachment.html#renderBuffer" translate="no">renderBuffer</a>().</p>
<!-- @@@setRenderBuffer -->
<!-- $$$setResolveLayer[overload1]$$$setResolveLayerint -->
<h3 class="fn" translate="no" id="setResolveLayer"><span class="type">void</span> QRhiColorAttachment::<span class="name">setResolveLayer</span>(<span class="type">int</span> <i>layer</i>)</h3>
<p>Sets the resolve texture <i translate="no">layer</i> to use.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#resolveLayer" translate="no">resolveLayer</a>().</p>
<!-- @@@setResolveLayer -->
<!-- $$$setResolveLevel[overload1]$$$setResolveLevelint -->
<h3 class="fn" translate="no" id="setResolveLevel"><span class="type">void</span> QRhiColorAttachment::<span class="name">setResolveLevel</span>(<span class="type">int</span> <i>level</i>)</h3>
<p>Sets the resolve texture mip <i translate="no">level</i> to use.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#resolveLevel" translate="no">resolveLevel</a>().</p>
<!-- @@@setResolveLevel -->
<!-- $$$setResolveTexture[overload1]$$$setResolveTextureQRhiTexture* -->
<h3 class="fn" translate="no" id="setResolveTexture"><span class="type">void</span> QRhiColorAttachment::<span class="name">setResolveTexture</span>(<span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>)</h3>
<p>Sets the resolve texture <i translate="no">tex</i>.</p>
<p><i translate="no">tex</i> is expected to be a 2D texture or a 2D texture array. In either case, resolving targets a single mip level of a single layer (array element) of <i translate="no">tex</i>. The mip level and array layer are specified by <a href="qrhicolorattachment.html#resolveLevel" translate="no">resolveLevel</a>() and <a href="qrhicolorattachment.html#resolveLayer" translate="no">resolveLayer</a>().</p>
<p>An exception is <a href="qrhicolorattachment.html#setMultiViewCount" translate="no">multiview</a>: when the color attachment is associated with a texture array and multiview is enabled, the resolve texture must also be a texture array with sufficient elements for all views. In this case all elements that correspond to views are resolved automatically; the behavior is similar to the following pseudo-code:</p>
<pre class="cpp plain" translate="no">
 for (i = 0; i &lt; multiViewCount(); ++i)
     resolve texture's layer() + i into resolveTexture's resolveLayer() + i
</pre>
<p>Setting a non-multisample texture to resolve a multisample texture or renderbuffer automatically at the end of the render pass is often preferable to working with multisample textures (and not setting a resolve texture), because it avoids the need for writing dedicated fragment shaders that work exclusively with multisample textures (<code translate="no">sampler2DMS</code>, <code translate="no">texelFetch</code>, etc.), and rather allows using the same shader as one would if the attachment's texture was not multisampled to begin with. This comes at the expense of an additional resource (the non-multisample <i translate="no">tex</i>).</p>
<p><b>See also </b><a href="qrhicolorattachment.html#resolveTexture" translate="no">resolveTexture</a>().</p>
<!-- @@@setResolveTexture -->
<!-- $$$setTexture[overload1]$$$setTextureQRhiTexture* -->
<h3 class="fn" translate="no" id="setTexture"><span class="type">void</span> QRhiColorAttachment::<span class="name">setTexture</span>(<span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>)</h3>
<p>Sets the texture <i translate="no">tex</i>.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhicolorattachment.html#texture" translate="no">texture</a>() and <a href="qrhicolorattachment.html#renderBuffer" translate="no">renderBuffer</a>() cannot be both set (be non-null at the same time).</p>
</div>
<p><b>See also </b><a href="qrhicolorattachment.html#texture" translate="no">texture</a>().</p>
<!-- @@@setTexture -->
<!-- $$$texture[overload1]$$$texture -->
<h3 class="fn" translate="no" id="texture"><span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *QRhiColorAttachment::<span class="name">texture</span>() const</h3>
<p>Returns the texture this attachment description references, or <code translate="no">nullptr</code> if there is none.</p>
<p><b>See also </b><a href="qrhicolorattachment.html#setTexture" translate="no">setTexture</a>().</p>
<!-- @@@texture -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
