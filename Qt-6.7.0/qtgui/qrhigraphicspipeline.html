<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Graphics pipeline state resource.">
  <title>QRhiGraphicsPipeline Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiGraphicsPipeline</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#example-usage">Example usage</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiGraphicsPipeline Class</h1>
<!-- $$$QRhiGraphicsPipeline-brief -->
<p>Graphics pipeline state resource. <a href="#details">More...</a></p>
<!-- @@@QRhiGraphicsPipeline -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiGraphicsPipeline&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qrhiresource.html" translate="no">QRhiResource</a></td></tr>
</table></div>
<ul>
<li><a href="qrhigraphicspipeline-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> struct </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline-stencilopstate.html" translate="no">StencilOpState</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> struct </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline-targetblend.html" translate="no">TargetBlend</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#BlendFactor-enum" translate="no">BlendFactor</a></b> { Zero, One, SrcColor, OneMinusSrcColor, DstColor, &hellip;, OneMinusSrc1Alpha }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#BlendOp-enum" translate="no">BlendOp</a></b> { Add, Subtract, ReverseSubtract, Min, Max }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#ColorMaskComponent-enum" translate="no">ColorMask</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#ColorMaskComponent-enum" translate="no">ColorMaskComponent</a></b> { R, G, B, A }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#CompareOp-enum" translate="no">CompareOp</a></b> { Never, Less, Equal, LessOrEqual, Greater, &hellip;, Always }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#CullMode-enum" translate="no">CullMode</a></b> { None, Front, Back }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#Flag-enum" translate="no">Flag</a></b> { UsesBlendConstants, UsesStencilRef, UsesScissor, CompileShadersWithDebugInfo }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#Flag-enum" translate="no">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#FrontFace-enum" translate="no">FrontFace</a></b> { CCW, CW }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#PolygonMode-enum" translate="no">PolygonMode</a></b> { Fill, Line }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#StencilOp-enum" translate="no">StencilOp</a></b> { StencilZero, Keep, Replace, IncrementAndClamp, DecrementAndClamp, &hellip;, DecrementAndWrap }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#Topology-enum" translate="no">Topology</a></b> { Triangles, TriangleStrip, TriangleFan, Lines, LineStrip, &hellip;, Patches }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiShaderStage *</td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#cbeginShaderStages" translate="no">cbeginShaderStages</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiGraphicsPipeline::TargetBlend *</td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#cbeginTargetBlends" translate="no">cbeginTargetBlends</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiShaderStage *</td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#cendShaderStages" translate="no">cendShaderStages</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiGraphicsPipeline::TargetBlend *</td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#cendTargetBlends" translate="no">cendTargetBlends</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#create" translate="no">create</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiGraphicsPipeline::CullMode </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#cullMode" translate="no">cullMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#depthBias" translate="no">depthBias</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiGraphicsPipeline::CompareOp </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#depthOp" translate="no">depthOp</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiGraphicsPipeline::Flags </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiGraphicsPipeline::FrontFace </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#frontFace" translate="no">frontFace</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#hasDepthTest" translate="no">hasDepthTest</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#hasDepthWrite" translate="no">hasDepthWrite</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#hasStencilTest" translate="no">hasStencilTest</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#lineWidth" translate="no">lineWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> int </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#multiViewCount" translate="no">multiViewCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#patchControlPointCount" translate="no">patchControlPointCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiGraphicsPipeline::PolygonMode </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#polygonMode" translate="no">polygonMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderPassDescriptor *</td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#renderPassDescriptor" translate="no">renderPassDescriptor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#sampleCount" translate="no">sampleCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setCullMode" translate="no">setCullMode</a></b>(QRhiGraphicsPipeline::CullMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setDepthBias" translate="no">setDepthBias</a></b>(int <i>bias</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setDepthOp" translate="no">setDepthOp</a></b>(QRhiGraphicsPipeline::CompareOp <i>op</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setDepthTest" translate="no">setDepthTest</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setDepthWrite" translate="no">setDepthWrite</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setFlags" translate="no">setFlags</a></b>(QRhiGraphicsPipeline::Flags <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setFrontFace" translate="no">setFrontFace</a></b>(QRhiGraphicsPipeline::FrontFace <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setLineWidth" translate="no">setLineWidth</a></b>(float <i>width</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setMultiViewCount" translate="no">setMultiViewCount</a></b>(int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setPatchControlPointCount" translate="no">setPatchControlPointCount</a></b>(int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setPolygonMode" translate="no">setPolygonMode</a></b>(QRhiGraphicsPipeline::PolygonMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setRenderPassDescriptor" translate="no">setRenderPassDescriptor</a></b>(QRhiRenderPassDescriptor *<i>desc</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setSampleCount" translate="no">setSampleCount</a></b>(int <i>s</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setShaderResourceBindings" translate="no">setShaderResourceBindings</a></b>(QRhiShaderResourceBindings *<i>srb</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setShaderStages" translate="no">setShaderStages</a></b>(std::initializer_list&lt;QRhiShaderStage&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setShaderStages-1" translate="no">setShaderStages</a></b>(InputIterator <i>first</i>, InputIterator <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setSlopeScaledDepthBias" translate="no">setSlopeScaledDepthBias</a></b>(float <i>bias</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setStencilBack" translate="no">setStencilBack</a></b>(const QRhiGraphicsPipeline::StencilOpState &amp;<i>state</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setStencilFront" translate="no">setStencilFront</a></b>(const QRhiGraphicsPipeline::StencilOpState &amp;<i>state</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setStencilReadMask" translate="no">setStencilReadMask</a></b>(quint32 <i>mask</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setStencilTest" translate="no">setStencilTest</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setStencilWriteMask" translate="no">setStencilWriteMask</a></b>(quint32 <i>mask</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setTargetBlends" translate="no">setTargetBlends</a></b>(std::initializer_list&lt;QRhiGraphicsPipeline::TargetBlend&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setTargetBlends-1" translate="no">setTargetBlends</a></b>(InputIterator <i>first</i>, InputIterator <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setTopology" translate="no">setTopology</a></b>(QRhiGraphicsPipeline::Topology <i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#setVertexInputLayout" translate="no">setVertexInputLayout</a></b>(const QRhiVertexInputLayout &amp;<i>layout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBindings *</td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#shaderResourceBindings" translate="no">shaderResourceBindings</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiShaderStage *</td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#shaderStageAt" translate="no">shaderStageAt</a></b>(qsizetype <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#shaderStageCount" translate="no">shaderStageCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#slopeScaledDepthBias" translate="no">slopeScaledDepthBias</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiGraphicsPipeline::StencilOpState </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#stencilBack" translate="no">stencilBack</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiGraphicsPipeline::StencilOpState </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#stencilFront" translate="no">stencilFront</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint32 </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#stencilReadMask" translate="no">stencilReadMask</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint32 </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#stencilWriteMask" translate="no">stencilWriteMask</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiGraphicsPipeline::TargetBlend *</td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#targetBlendAt" translate="no">targetBlendAt</a></b>(qsizetype <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#targetBlendCount" translate="no">targetBlendCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiGraphicsPipeline::Topology </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#topology" translate="no">topology</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiVertexInputLayout </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#vertexInputLayout" translate="no">vertexInputLayout</a></b>() const</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiResource::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhigraphicspipeline.html#resourceType" translate="no">resourceType</a></b>() const override</td></tr>
</table></div>
<!-- $$$QRhiGraphicsPipeline-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Represents a graphics pipeline. What exactly this map to in the underlying native graphics API, varies. Where there is a concept of pipeline objects, for example with Vulkan, the <a href="qrhi.html" translate="no">QRhi</a> backend will create such an object upon calling <a href="qrhigraphicspipeline.html#create" translate="no">create</a>(). Elsewhere, for example with OpenGL, the QRhiGraphicsPipeline may merely collect the various state, and <a href="qrhigraphicspipeline.html#create" translate="no">create</a>()'s main task is to set up the corresponding shader program, but deferring looking at any of the requested state to a later point.</p>
<p>As with all <a href="qrhiresource.html" translate="no">QRhiResource</a> subclasses, the two-phased initialization pattern applies: setting any values via the setters, for example <a href="qrhigraphicspipeline.html#setDepthTest" translate="no">setDepthTest</a>(), is only effective after calling <a href="qrhigraphicspipeline.html#create" translate="no">create</a>(). Avoid changing any values once the QRhiGraphicsPipeline has been initialized via <a href="qrhigraphicspipeline.html#create" translate="no">create</a>(). To change some state, set the new value and call <a href="qrhigraphicspipeline.html#create" translate="no">create</a>() again. However, that will effectively release all underlying native resources and create new ones. As a result, it may be a heavy, expensive operation. Rather, prefer creating multiple pipelines with the different states, and <a href="qrhicommandbuffer.html#setGraphicsPipeline" translate="no">switch between them</a> when recording the render pass.</p>
<div class="admonition note">
<p><b>Note: </b>Setting the shader stages is mandatory. There must be at least one stage, and there must be a vertex stage.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Setting the shader resource bindings is mandatory. The referenced <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> must already have <a href="qrhigraphicspipeline.html#create" translate="no">create</a>() called on it by the time <a href="qrhigraphicspipeline.html#create" translate="no">create</a>() is called. Associating with a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> that has no bindings is also valid, as long as no shader in any stage expects any resources. Using a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> object that does not specify any actual resources (i.e., the buffers, textures, etc. for the binding points are set to <code translate="no">nullptr</code>) is valid as well, as long as a <a href="qrhishaderresourcebindings.html#isLayoutCompatible" translate="no">layout-compatible</a> <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a>, that specifies resources for all the bindings, is going to be set via <a href="qrhicommandbuffer.html#setShaderResources" translate="no">setShaderResources</a>() when recording the render pass.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Setting the render pass descriptor is mandatory. To obtain a <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> that can be passed to <a href="qrhigraphicspipeline.html#setRenderPassDescriptor" translate="no">setRenderPassDescriptor</a>(), use either <a href="qrhitexturerendertarget.html#newCompatibleRenderPassDescriptor" translate="no">QRhiTextureRenderTarget::newCompatibleRenderPassDescriptor</a>() or <a href="qrhiswapchain.html#newCompatibleRenderPassDescriptor" translate="no">QRhiSwapChain::newCompatibleRenderPassDescriptor</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Setting the vertex input layout is mandatory.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qrhigraphicspipeline.html#sampleCount" translate="no">sampleCount</a>() defaults to 1 and must match the sample count of the render target's color and depth stencil attachments.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The depth test, depth write, and stencil test are disabled by default. The face culling mode defaults to no culling.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qrhigraphicspipeline.html#stencilReadMask" translate="no">stencilReadMask</a>() and <a href="qrhigraphicspipeline.html#stencilWriteMask" translate="no">stencilWriteMask</a>() apply to both faces. They both default to 0xFF.</p>
</div>
<h4 id="example-usage">Example usage</h4>
<p>All settings of a graphics pipeline have defaults which might be suitable to many applications. Therefore a minimal example of creating a graphics pipeline could be the following. This assumes that the vertex shader takes a single <code translate="no">vec3 position</code> input at the input location 0. With the <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> and <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> objects, plus the <a href="qshader.html" translate="no">QShader</a> collections for the vertex and fragment stages, a pipeline could be created like this:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a></span> <span class="operator">*</span>srb;
 <span class="type"><a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a></span> <span class="operator">*</span>rpDesc;
 <span class="type"><a href="qshader.html" translate="no">QShader</a></span> vs<span class="operator">,</span> fs;
 <span class="comment">// ...</span>

 <span class="type"><a href="qrhivertexinputlayout.html" translate="no">QRhiVertexInputLayout</a></span> inputLayout;
 inputLayout<span class="operator">.</span>setBindings({ { <span class="number">3</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) } });
 inputLayout<span class="operator">.</span>setAttributes({ { <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a></span><span class="operator">::</span>Float3<span class="operator">,</span> <span class="number">0</span> } });

 <span class="type">QRhiGraphicsPipeline</span> <span class="operator">*</span>ps <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newGraphicsPipeline();
 ps<span class="operator">-</span><span class="operator">&gt;</span>setShaderStages({ { <span class="type"><a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a></span><span class="operator">::</span>Vertex<span class="operator">,</span> vs }<span class="operator">,</span> { <span class="type"><a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a></span><span class="operator">::</span>Fragment<span class="operator">,</span> fs } });
 ps<span class="operator">-</span><span class="operator">&gt;</span>setVertexInputLayout(inputLayout);
 ps<span class="operator">-</span><span class="operator">&gt;</span>setShaderResourceBindings(srb);
 ps<span class="operator">-</span><span class="operator">&gt;</span>setRenderPassDescriptor(rpDesc);
 <span class="keyword">if</span> (<span class="operator">!</span>ps<span class="operator">-</span><span class="operator">&gt;</span>create()) { error(); }
</pre>
<p>The above code creates a pipeline object that uses the defaults for many settings and states. For example, it will use a <a href="qrhigraphicspipeline.html#Topology-enum" translate="no">Triangles</a> topology, no backface culling, blending is disabled but color write is enabled for all four channels, depth test/write are disabled, stencil operations are disabled.</p>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<p><b>See also </b><a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> and <a href="qrhi.html" translate="no">QRhi</a>.</p>
<!-- @@@QRhiGraphicsPipeline -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$BlendFactor$$$Zero$$$One$$$SrcColor$$$OneMinusSrcColor$$$DstColor$$$OneMinusDstColor$$$SrcAlpha$$$OneMinusSrcAlpha$$$DstAlpha$$$OneMinusDstAlpha$$$ConstantColor$$$OneMinusConstantColor$$$ConstantAlpha$$$OneMinusConstantAlpha$$$SrcAlphaSaturate$$$Src1Color$$$OneMinusSrc1Color$$$Src1Alpha$$$OneMinusSrc1Alpha -->
<h3 class="fn" translate="no" id="BlendFactor-enum">enum QRhiGraphicsPipeline::<span class="name">BlendFactor</span></h3>
<p>Specifies the blend factor</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Zero</code></td><td class="topAlign tblval"><code translate="no">0</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::One</code></td><td class="topAlign tblval"><code translate="no">1</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::SrcColor</code></td><td class="topAlign tblval"><code translate="no">2</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::OneMinusSrcColor</code></td><td class="topAlign tblval"><code translate="no">3</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::DstColor</code></td><td class="topAlign tblval"><code translate="no">4</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::OneMinusDstColor</code></td><td class="topAlign tblval"><code translate="no">5</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::SrcAlpha</code></td><td class="topAlign tblval"><code translate="no">6</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::OneMinusSrcAlpha</code></td><td class="topAlign tblval"><code translate="no">7</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::DstAlpha</code></td><td class="topAlign tblval"><code translate="no">8</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::OneMinusDstAlpha</code></td><td class="topAlign tblval"><code translate="no">9</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::ConstantColor</code></td><td class="topAlign tblval"><code translate="no">10</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::OneMinusConstantColor</code></td><td class="topAlign tblval"><code translate="no">11</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::ConstantAlpha</code></td><td class="topAlign tblval"><code translate="no">12</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::OneMinusConstantAlpha</code></td><td class="topAlign tblval"><code translate="no">13</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::SrcAlphaSaturate</code></td><td class="topAlign tblval"><code translate="no">14</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Src1Color</code></td><td class="topAlign tblval"><code translate="no">15</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::OneMinusSrc1Color</code></td><td class="topAlign tblval"><code translate="no">16</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Src1Alpha</code></td><td class="topAlign tblval"><code translate="no">17</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::OneMinusSrc1Alpha</code></td><td class="topAlign tblval"><code translate="no">18</code></td></tr>
</table></div>
<!-- @@@BlendFactor -->
<!-- $$$BlendOp$$$Add$$$Subtract$$$ReverseSubtract$$$Min$$$Max -->
<h3 class="fn" translate="no" id="BlendOp-enum">enum QRhiGraphicsPipeline::<span class="name">BlendOp</span></h3>
<p>Specifies the blend operation</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Add</code></td><td class="topAlign tblval"><code translate="no">0</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Subtract</code></td><td class="topAlign tblval"><code translate="no">1</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::ReverseSubtract</code></td><td class="topAlign tblval"><code translate="no">2</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Min</code></td><td class="topAlign tblval"><code translate="no">3</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Max</code></td><td class="topAlign tblval"><code translate="no">4</code></td></tr>
</table></div>
<!-- @@@BlendOp -->
<!-- $$$ColorMaskComponent$$$R$$$G$$$B$$$A -->
<h3 class="flags" id="ColorMaskComponent-enum">enum QRhiGraphicsPipeline::<span class="name">ColorMaskComponent</span><br/>flags QRhiGraphicsPipeline::<span class="name">ColorMask</span></h3>
<p>Flag values for specifying the color write mask</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::R</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::G</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 1</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::B</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 2</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::A</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 3</code></td></tr>
</table></div>
<p>The ColorMask type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;ColorMaskComponent&gt;. It stores an OR combination of ColorMaskComponent values.</p>
<!-- @@@ColorMaskComponent -->
<!-- $$$CompareOp$$$Never$$$Less$$$Equal$$$LessOrEqual$$$Greater$$$NotEqual$$$GreaterOrEqual$$$Always -->
<h3 class="fn" translate="no" id="CompareOp-enum">enum QRhiGraphicsPipeline::<span class="name">CompareOp</span></h3>
<p>Specifies the depth or stencil comparison function</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Never</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Less</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">(default for depth)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Equal</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::LessOrEqual</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Greater</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::NotEqual</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::GreaterOrEqual</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Always</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">(default for stencil)</td></tr>
</table></div>
<!-- @@@CompareOp -->
<!-- $$$CullMode$$$None$$$Front$$$Back -->
<h3 class="fn" translate="no" id="CullMode-enum">enum QRhiGraphicsPipeline::<span class="name">CullMode</span></h3>
<p>Specifies the culling mode</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::None</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">No culling (default)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Front</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Cull front faces</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Back</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Cull back faces</td></tr>
</table></div>
<!-- @@@CullMode -->
<!-- $$$Flag$$$UsesBlendConstants$$$UsesStencilRef$$$UsesScissor$$$CompileShadersWithDebugInfo -->
<h3 class="flags" id="Flag-enum">enum QRhiGraphicsPipeline::<span class="name">Flag</span><br/>flags QRhiGraphicsPipeline::<span class="name">Flags</span></h3>
<p>Flag values for describing the dynamic state of the pipeline, and other options. The viewport is always dynamic.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::UsesBlendConstants</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td><td class="topAlign">Indicates that a blend color constant will be set via <a href="qrhicommandbuffer.html#setBlendConstants" translate="no">QRhiCommandBuffer::setBlendConstants</a>()</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::UsesStencilRef</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 1</code></td><td class="topAlign">Indicates that a stencil reference value will be set via <a href="qrhicommandbuffer.html#setStencilRef" translate="no">QRhiCommandBuffer::setStencilRef</a>()</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::UsesScissor</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 2</code></td><td class="topAlign">Indicates that a scissor rectangle will be set via <a href="qrhicommandbuffer.html#setScissor" translate="no">QRhiCommandBuffer::setScissor</a>()</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::CompileShadersWithDebugInfo</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 3</code></td><td class="topAlign">Requests compiling shaders with debug information enabled. This is relevant only when runtime shader compilation from source code is involved, and only when the underlying infrastructure supports this. With concrete examples, this is not relevant with Vulkan and SPIR-V, because the GLSL-to-SPIR-V compilation does not happen at run time. On the other hand, consider Direct3D and HLSL, where there are multiple options: when the <a href="qshader.html" translate="no">QShader</a> packages ship with pre-compiled bytecode (<code translate="no">DXBC</code>), debug information is to be requested through the tool that generates the <code translate="no">.qsb</code> file, similarly to the case of Vulkan and SPIR-V. However, when having HLSL source code in the pre- or runtime-generated <a href="qshader.html" translate="no">QShader</a> packages, the first phase of compilation (HLSL source to intermediate format) happens at run time too, with this flag taken into account. Debug information is relevant in particular with tools like RenderDoc since it allows seeing the original source code when investigating the pipeline and when performing vertex or fragment shader debugging.</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
<!-- $$$FrontFace$$$CCW$$$CW -->
<h3 class="fn" translate="no" id="FrontFace-enum">enum QRhiGraphicsPipeline::<span class="name">FrontFace</span></h3>
<p>Specifies the front face winding order</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::CCW</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Counter clockwise (default)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::CW</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Clockwise</td></tr>
</table></div>
<!-- @@@FrontFace -->
<!-- $$$PolygonMode$$$Fill$$$Line -->
<h3 class="fn" translate="no" id="PolygonMode-enum">enum QRhiGraphicsPipeline::<span class="name">PolygonMode</span></h3>
<p>Specifies the polygon rasterization mode</p>
<p>Polygon Mode (Triangle Fill Mode in Metal, Fill Mode in D3D) specifies the fill mode used when rasterizing polygons. Polygons may be drawn as solids (Fill), or as a wire mesh (Line).</p>
<p>Support for non-fill polygon modes is optional and is indicated by the <a href="qrhi.html#Feature-enum" translate="no">QRhi::NonFillPolygonMode</a> feature. With OpenGL ES and some Vulkan implementations the feature will likely be reported as unsupported, which then means values other than Fill cannot be used.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Fill</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The interior of the polygon is filled (default)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Line</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Boundary edges of the polygon are drawn as line segments.</td></tr>
</table></div>
<!-- @@@PolygonMode -->
<!-- $$$StencilOp$$$StencilZero$$$Keep$$$Replace$$$IncrementAndClamp$$$DecrementAndClamp$$$Invert$$$IncrementAndWrap$$$DecrementAndWrap -->
<h3 class="fn" translate="no" id="StencilOp-enum">enum QRhiGraphicsPipeline::<span class="name">StencilOp</span></h3>
<p>Specifies the stencil operation</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::StencilZero</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Keep</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">(default)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Replace</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::IncrementAndClamp</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::DecrementAndClamp</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Invert</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::IncrementAndWrap</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::DecrementAndWrap</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">&nbsp;</td></tr>
</table></div>
<!-- @@@StencilOp -->
<!-- $$$Topology$$$Triangles$$$TriangleStrip$$$TriangleFan$$$Lines$$$LineStrip$$$Points$$$Patches -->
<h3 class="fn" translate="no" id="Topology-enum">enum QRhiGraphicsPipeline::<span class="name">Topology</span></h3>
<p>Specifies the primitive topology</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Triangles</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">(default)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::TriangleStrip</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::TriangleFan</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">(only available if <a href="qrhi.html#Feature-enum" translate="no">QRhi::TriangleFanTopology</a> is supported)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Lines</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::LineStrip</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Points</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiGraphicsPipeline::Patches</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">(only available if <a href="qrhi.html#Feature-enum" translate="no">QRhi::Tessellation</a> is supported, and requires the tessellation stages to be present in the pipeline)</td></tr>
</table></div>
<!-- @@@Topology -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$cbeginShaderStages[overload1]$$$cbeginShaderStages -->
<h3 class="fn" translate="no" id="cbeginShaderStages">const <span class="type"><a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a></span> *QRhiGraphicsPipeline::<span class="name">cbeginShaderStages</span>() const</h3>
<p>Returns a const iterator pointing to the first item in the shader stage list.</p>
<!-- @@@cbeginShaderStages -->
<!-- $$$cbeginTargetBlends[overload1]$$$cbeginTargetBlends -->
<h3 class="fn" translate="no" id="cbeginTargetBlends">const <span class="type"><a href="qrhigraphicspipeline-targetblend.html" translate="no">QRhiGraphicsPipeline::TargetBlend</a></span> *QRhiGraphicsPipeline::<span class="name">cbeginTargetBlends</span>() const</h3>
<p>Returns a const iterator pointing to the first item in the render target blend setting list.</p>
<!-- @@@cbeginTargetBlends -->
<!-- $$$cendShaderStages[overload1]$$$cendShaderStages -->
<h3 class="fn" translate="no" id="cendShaderStages">const <span class="type"><a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a></span> *QRhiGraphicsPipeline::<span class="name">cendShaderStages</span>() const</h3>
<p>Returns a const iterator pointing just after the last item in the shader stage list.</p>
<!-- @@@cendShaderStages -->
<!-- $$$cendTargetBlends[overload1]$$$cendTargetBlends -->
<h3 class="fn" translate="no" id="cendTargetBlends">const <span class="type"><a href="qrhigraphicspipeline-targetblend.html" translate="no">QRhiGraphicsPipeline::TargetBlend</a></span> *QRhiGraphicsPipeline::<span class="name">cendTargetBlends</span>() const</h3>
<p>Returns a const iterator pointing just after the last item in the render target blend setting list.</p>
<!-- @@@cendTargetBlends -->
<!-- $$$create[overload1]$$$create -->
<h3 class="fn" translate="no" id="create"><code class="details extra" translate="no">[pure virtual]</code> <span class="type">bool</span> QRhiGraphicsPipeline::<span class="name">create</span>()</h3>
<p>Creates the corresponding native graphics resources. If there are already resources present due to an earlier create() with no corresponding <a href="qrhiresource.html#destroy" translate="no">destroy</a>(), then <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is called implicitly first.</p>
<p>Returns <code translate="no">true</code> when successful, <code translate="no">false</code> when a graphics operation failed. Regardless of the return value, calling <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is always safe.</p>
<div class="admonition note">
<p><b>Note: </b>This may be, depending on the underlying graphics API, an expensive operation, especially when shaders get compiled/optimized from source or from an intermediate bytecode format to the GPU's own instruction set. Where applicable, the <a href="qrhi.html" translate="no">QRhi</a> backend automatically sets up the relevant non-persistent facilities to accelerate this, for example the Vulkan backend automatically creates a <code translate="no">VkPipelineCache</code> to improve data reuse during the lifetime of the application.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Drivers may also employ various persistent (disk-based) caching strategies for shader and pipeline data, which is hidden to and is outside of Qt's control. In some cases, depending on the graphics API and the <a href="qrhi.html" translate="no">QRhi</a> backend, there are facilities within <a href="qrhi.html" translate="no">QRhi</a> for manually managing such a cache, allowing the retrieval of a serializable blob that can then be reloaded in the future runs of the application to ensure faster pipeline creation times. See <a href="qrhi.html#pipelineCacheData" translate="no">QRhi::pipelineCacheData</a>() and <a href="qrhi.html#setPipelineCacheData" translate="no">QRhi::setPipelineCacheData</a>() for details. Note also that when working with a <a href="qrhi.html" translate="no">QRhi</a> instance managed by a higher level Qt framework, such as Qt Quick, it is possible that such disk-based caching is taken care of automatically, for example <a href="../qtquick/qquickwindow.html" translate="no">QQuickWindow</a> uses a disk-based pipeline cache by default (which comes in addition to any driver-level caching).</p>
</div>
<!-- @@@create -->
<!-- $$$cullMode[overload1]$$$cullMode -->
<h3 class="fn" translate="no" id="cullMode"><span class="type"><a href="qrhigraphicspipeline.html#CullMode-enum" translate="no">QRhiGraphicsPipeline::CullMode</a></span> QRhiGraphicsPipeline::<span class="name">cullMode</span>() const</h3>
<p>Returns the currently set face culling mode.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setCullMode" translate="no">setCullMode</a>().</p>
<!-- @@@cullMode -->
<!-- $$$depthBias[overload1]$$$depthBias -->
<h3 class="fn" translate="no" id="depthBias"><span class="type">int</span> QRhiGraphicsPipeline::<span class="name">depthBias</span>() const</h3>
<p>Returns the currently set depth bias.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setDepthBias" translate="no">setDepthBias</a>().</p>
<!-- @@@depthBias -->
<!-- $$$depthOp[overload1]$$$depthOp -->
<h3 class="fn" translate="no" id="depthOp"><span class="type"><a href="qrhigraphicspipeline.html#CompareOp-enum" translate="no">QRhiGraphicsPipeline::CompareOp</a></span> QRhiGraphicsPipeline::<span class="name">depthOp</span>() const</h3>
<p>Returns the depth comparison function.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setDepthOp" translate="no">setDepthOp</a>().</p>
<!-- @@@depthOp -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><span class="type"><a href="qrhigraphicspipeline.html#Flag-enum" translate="no">QRhiGraphicsPipeline::Flags</a></span> QRhiGraphicsPipeline::<span class="name">flags</span>() const</h3>
<p>Returns the currently set flags.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setFlags" translate="no">setFlags</a>().</p>
<!-- @@@flags -->
<!-- $$$frontFace[overload1]$$$frontFace -->
<h3 class="fn" translate="no" id="frontFace"><span class="type"><a href="qrhigraphicspipeline.html#FrontFace-enum" translate="no">QRhiGraphicsPipeline::FrontFace</a></span> QRhiGraphicsPipeline::<span class="name">frontFace</span>() const</h3>
<p>Returns the currently set front face mode.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setFrontFace" translate="no">setFrontFace</a>().</p>
<!-- @@@frontFace -->
<!-- $$$hasDepthTest[overload1]$$$hasDepthTest -->
<h3 class="fn" translate="no" id="hasDepthTest"><span class="type">bool</span> QRhiGraphicsPipeline::<span class="name">hasDepthTest</span>() const</h3>
<p>Returns true if depth testing is enabled.</p>
<!-- @@@hasDepthTest -->
<!-- $$$hasDepthWrite[overload1]$$$hasDepthWrite -->
<h3 class="fn" translate="no" id="hasDepthWrite"><span class="type">bool</span> QRhiGraphicsPipeline::<span class="name">hasDepthWrite</span>() const</h3>
<p>Returns true if depth write is enabled.</p>
<!-- @@@hasDepthWrite -->
<!-- $$$hasStencilTest[overload1]$$$hasStencilTest -->
<h3 class="fn" translate="no" id="hasStencilTest"><span class="type">bool</span> QRhiGraphicsPipeline::<span class="name">hasStencilTest</span>() const</h3>
<p>Returns true if stencil testing is enabled.</p>
<!-- @@@hasStencilTest -->
<!-- $$$lineWidth[overload1]$$$lineWidth -->
<h3 class="fn" translate="no" id="lineWidth"><span class="type">float</span> QRhiGraphicsPipeline::<span class="name">lineWidth</span>() const</h3>
<p>Returns the currently set line width. The default is 1.0f.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setLineWidth" translate="no">setLineWidth</a>().</p>
<!-- @@@lineWidth -->
<!-- $$$multiViewCount[overload1]$$$multiViewCount -->
<h3 class="fn" translate="no" id="multiViewCount"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">int</span> QRhiGraphicsPipeline::<span class="name">multiViewCount</span>() const</h3>
<p>Returns the view count. The default is 0, indicating no multiview rendering.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setMultiViewCount" translate="no">setMultiViewCount</a>().</p>
<!-- @@@multiViewCount -->
<!-- $$$patchControlPointCount[overload1]$$$patchControlPointCount -->
<h3 class="fn" translate="no" id="patchControlPointCount"><span class="type">int</span> QRhiGraphicsPipeline::<span class="name">patchControlPointCount</span>() const</h3>
<p>Returns the currently set patch control point count.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setPatchControlPointCount" translate="no">setPatchControlPointCount</a>().</p>
<!-- @@@patchControlPointCount -->
<!-- $$$polygonMode[overload1]$$$polygonMode -->
<h3 class="fn" translate="no" id="polygonMode"><span class="type"><a href="qrhigraphicspipeline.html#PolygonMode-enum" translate="no">QRhiGraphicsPipeline::PolygonMode</a></span> QRhiGraphicsPipeline::<span class="name">polygonMode</span>() const</h3>
<p>Returns the polygon mode.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setPolygonMode" translate="no">setPolygonMode</a>().</p>
<!-- @@@polygonMode -->
<!-- $$$renderPassDescriptor[overload1]$$$renderPassDescriptor -->
<h3 class="fn" translate="no" id="renderPassDescriptor"><span class="type"><a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a></span> *QRhiGraphicsPipeline::<span class="name">renderPassDescriptor</span>() const</h3>
<p>Returns the currently set <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a>.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setRenderPassDescriptor" translate="no">setRenderPassDescriptor</a>().</p>
<!-- @@@renderPassDescriptor -->
<!-- $$$resourceType[overload1]$$$resourceType -->
<h3 class="fn" translate="no" id="resourceType"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="qrhiresource.html#Type-enum" translate="no">QRhiResource::Type</a></span> QRhiGraphicsPipeline::<span class="name">resourceType</span>() const</h3>
<p>Reimplements: <a href="qrhiresource.html#resourceType" translate="no">QRhiResource::resourceType() const</a>.</p>
<p>Returns the resource type.</p>
<!-- @@@resourceType -->
<!-- $$$sampleCount[overload1]$$$sampleCount -->
<h3 class="fn" translate="no" id="sampleCount"><span class="type">int</span> QRhiGraphicsPipeline::<span class="name">sampleCount</span>() const</h3>
<p>Returns the currently set sample count. 1 means no multisample antialiasing.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setSampleCount" translate="no">setSampleCount</a>().</p>
<!-- @@@sampleCount -->
<!-- $$$setCullMode[overload1]$$$setCullModeQRhiGraphicsPipeline::CullMode -->
<h3 class="fn" translate="no" id="setCullMode"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setCullMode</span>(<span class="type"><a href="qrhigraphicspipeline.html#CullMode-enum" translate="no">QRhiGraphicsPipeline::CullMode</a></span> <i>mode</i>)</h3>
<p>Sets the specified face culling <i translate="no">mode</i>.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#cullMode" translate="no">cullMode</a>().</p>
<!-- @@@setCullMode -->
<!-- $$$setDepthBias[overload1]$$$setDepthBiasint -->
<h3 class="fn" translate="no" id="setDepthBias"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setDepthBias</span>(<span class="type">int</span> <i>bias</i>)</h3>
<p>Sets the depth <i translate="no">bias</i>. The default value is 0.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#depthBias" translate="no">depthBias</a>().</p>
<!-- @@@setDepthBias -->
<!-- $$$setDepthOp[overload1]$$$setDepthOpQRhiGraphicsPipeline::CompareOp -->
<h3 class="fn" translate="no" id="setDepthOp"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setDepthOp</span>(<span class="type"><a href="qrhigraphicspipeline.html#CompareOp-enum" translate="no">QRhiGraphicsPipeline::CompareOp</a></span> <i>op</i>)</h3>
<p>Sets the depth comparison function <i translate="no">op</i>.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#depthOp" translate="no">depthOp</a>().</p>
<!-- @@@setDepthOp -->
<!-- $$$setDepthTest[overload1]$$$setDepthTestbool -->
<h3 class="fn" translate="no" id="setDepthTest"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setDepthTest</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Enables or disables depth testing based on <i translate="no">enable</i>. Both depth test and the writing out of depth data are disabled by default.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#hasDepthTest" translate="no">hasDepthTest</a>() and <a href="qrhigraphicspipeline.html#setDepthWrite" translate="no">setDepthWrite</a>().</p>
<!-- @@@setDepthTest -->
<!-- $$$setDepthWrite[overload1]$$$setDepthWritebool -->
<h3 class="fn" translate="no" id="setDepthWrite"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setDepthWrite</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Controls the writing out of depth data into the depth buffer based on <i translate="no">enable</i>. By default this is disabled. Depth write is typically enabled together with the depth test.</p>
<div class="admonition note">
<p><b>Note: </b>Enabling depth write without having depth testing enabled may not lead to the desired result, and should be avoided.</p>
</div>
<p><b>See also </b><a href="qrhigraphicspipeline.html#hasDepthWrite" translate="no">hasDepthWrite</a>() and <a href="qrhigraphicspipeline.html#setDepthTest" translate="no">setDepthTest</a>().</p>
<!-- @@@setDepthWrite -->
<!-- $$$setFlags[overload1]$$$setFlagsQRhiGraphicsPipeline::Flags -->
<h3 class="fn" translate="no" id="setFlags"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setFlags</span>(<span class="type"><a href="qrhigraphicspipeline.html#Flag-enum" translate="no">QRhiGraphicsPipeline::Flags</a></span> <i>f</i>)</h3>
<p>Sets the flags <i translate="no">f</i>.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#flags" translate="no">flags</a>().</p>
<!-- @@@setFlags -->
<!-- $$$setFrontFace[overload1]$$$setFrontFaceQRhiGraphicsPipeline::FrontFace -->
<h3 class="fn" translate="no" id="setFrontFace"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setFrontFace</span>(<span class="type"><a href="qrhigraphicspipeline.html#FrontFace-enum" translate="no">QRhiGraphicsPipeline::FrontFace</a></span> <i>f</i>)</h3>
<p>Sets the front face mode <i translate="no">f</i>.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#frontFace" translate="no">frontFace</a>().</p>
<!-- @@@setFrontFace -->
<!-- $$$setLineWidth[overload1]$$$setLineWidthfloat -->
<h3 class="fn" translate="no" id="setLineWidth"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setLineWidth</span>(<span class="type">float</span> <i>width</i>)</h3>
<p>Sets the line <i translate="no">width</i>. If the <a href="qrhi.html#Feature-enum" translate="no">QRhi::WideLines</a> feature is reported as unsupported at runtime, values other than 1.0f are ignored.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#lineWidth" translate="no">lineWidth</a>().</p>
<!-- @@@setLineWidth -->
<!-- $$$setMultiViewCount[overload1]$$$setMultiViewCountint -->
<h3 class="fn" translate="no" id="setMultiViewCount"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setMultiViewCount</span>(<span class="type">int</span> <i>count</i>)</h3>
<p>Sets the view <i translate="no">count</i> for multiview rendering. The default is 0, indicating no multiview rendering. <i translate="no">count</i> must be 2 or larger to trigger multiview rendering.</p>
<p>Multiview is only available when the <a href="qrhi.html#Feature-enum" translate="no">MultiView feature</a> is reported as supported. The render target must be a 2D texture array, and the color attachment for the render target must have the same <i translate="no">count</i> set.</p>
<p>See <a href="qrhicolorattachment.html#setMultiViewCount" translate="no">QRhiColorAttachment::setMultiViewCount</a>() for further details on multiview rendering.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#multiViewCount" translate="no">multiViewCount</a>(), <a href="qrhi.html#Feature-enum" translate="no">QRhi::MultiView</a>, and <a href="qrhicolorattachment.html#setMultiViewCount" translate="no">QRhiColorAttachment::setMultiViewCount</a>().</p>
<!-- @@@setMultiViewCount -->
<!-- $$$setPatchControlPointCount[overload1]$$$setPatchControlPointCountint -->
<h3 class="fn" translate="no" id="setPatchControlPointCount"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setPatchControlPointCount</span>(<span class="type">int</span> <i>count</i>)</h3>
<p>Sets the number of patch control points to <i translate="no">count</i>. The default value is 3. This is used only when the topology is set to <a href="qrhigraphicspipeline.html#Topology-enum" translate="no">Patches</a>.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#patchControlPointCount" translate="no">patchControlPointCount</a>().</p>
<!-- @@@setPatchControlPointCount -->
<!-- $$$setPolygonMode[overload1]$$$setPolygonModeQRhiGraphicsPipeline::PolygonMode -->
<h3 class="fn" translate="no" id="setPolygonMode"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setPolygonMode</span>(<span class="type"><a href="qrhigraphicspipeline.html#PolygonMode-enum" translate="no">QRhiGraphicsPipeline::PolygonMode</a></span> <i>mode</i>)</h3>
<p>Sets the polygon <i translate="no">mode</i>. The default is Fill.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#polygonMode" translate="no">polygonMode</a>() and <a href="qrhi.html#Feature-enum" translate="no">QRhi::NonFillPolygonMode</a>.</p>
<!-- @@@setPolygonMode -->
<!-- $$$setRenderPassDescriptor[overload1]$$$setRenderPassDescriptorQRhiRenderPassDescriptor* -->
<h3 class="fn" translate="no" id="setRenderPassDescriptor"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setRenderPassDescriptor</span>(<span class="type"><a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a></span> *<i>desc</i>)</h3>
<p>Associates with the specified <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> <i translate="no">desc</i>.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#renderPassDescriptor" translate="no">renderPassDescriptor</a>().</p>
<!-- @@@setRenderPassDescriptor -->
<!-- $$$setSampleCount[overload1]$$$setSampleCountint -->
<h3 class="fn" translate="no" id="setSampleCount"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setSampleCount</span>(<span class="type">int</span> <i>s</i>)</h3>
<p>Sets the sample count. Typical values for <i translate="no">s</i> are 1, 4, or 8. The pipeline must always be compatible with the render target, i.e. the sample counts must match.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#sampleCount" translate="no">sampleCount</a>() and <a href="qrhi.html#supportedSampleCounts" translate="no">QRhi::supportedSampleCounts</a>().</p>
<!-- @@@setSampleCount -->
<!-- $$$setShaderResourceBindings[overload1]$$$setShaderResourceBindingsQRhiShaderResourceBindings* -->
<h3 class="fn" translate="no" id="setShaderResourceBindings"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setShaderResourceBindings</span>(<span class="type"><a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a></span> *<i>srb</i>)</h3>
<p>Associates with <i translate="no">srb</i> describing the resource binding layout and the resources (<a href="qrhibuffer.html" translate="no">QRhiBuffer</a>, <a href="qrhitexture.html" translate="no">QRhiTexture</a>) themselves. The latter is optional, because only the layout matters during pipeline creation. Therefore, the <i translate="no">srb</i> passed in here can leave the actual buffer or texture objects unspecified (<code translate="no">nullptr</code>) as long as there is another, <a href="qrhishaderresourcebindings.html#isLayoutCompatible" translate="no">layout-compatible</a> <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> bound via <a href="qrhicommandbuffer.html#setShaderResources" translate="no">setShaderResources</a>() before recording the draw calls.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#shaderResourceBindings" translate="no">shaderResourceBindings</a>().</p>
<!-- @@@setShaderResourceBindings -->
<!-- $$$setShaderStages[overload1]$$$setShaderStagesstd::initializer_list<QRhiShaderStage> -->
<h3 class="fn" translate="no" id="setShaderStages"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setShaderStages</span>(<span class="type">std::initializer_list</span>&lt;<span class="type"><a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a></span>&gt; <i>list</i>)</h3>
<p>Sets the <i translate="no">list</i> of shader stages.</p>
<!-- @@@setShaderStages -->
<!-- $$$setShaderStages$$$setShaderStagesInputIteratorInputIterator -->
<h3 class="fn" translate="no" id="setShaderStages-1">template &lt;typename InputIterator&gt; <span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setShaderStages</span>(<span class="type">InputIterator</span> <i>first</i>, <span class="type">InputIterator</span> <i>last</i>)</h3>
<p>Sets the list of shader stages from the iterators <i translate="no">first</i> and <i translate="no">last</i>.</p>
<!-- @@@setShaderStages -->
<!-- $$$setSlopeScaledDepthBias[overload1]$$$setSlopeScaledDepthBiasfloat -->
<h3 class="fn" translate="no" id="setSlopeScaledDepthBias"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setSlopeScaledDepthBias</span>(<span class="type">float</span> <i>bias</i>)</h3>
<p>Sets the slope scaled depth <i translate="no">bias</i>. The default value is 0.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#slopeScaledDepthBias" translate="no">slopeScaledDepthBias</a>().</p>
<!-- @@@setSlopeScaledDepthBias -->
<!-- $$$setStencilBack[overload1]$$$setStencilBackconstQRhiGraphicsPipeline::StencilOpState& -->
<h3 class="fn" translate="no" id="setStencilBack"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setStencilBack</span>(const <span class="type"><a href="qrhigraphicspipeline-stencilopstate.html" translate="no">QRhiGraphicsPipeline::StencilOpState</a></span> &amp;<i>state</i>)</h3>
<p>Sets the stencil test <i translate="no">state</i> for back faces.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#stencilBack" translate="no">stencilBack</a>().</p>
<!-- @@@setStencilBack -->
<!-- $$$setStencilFront[overload1]$$$setStencilFrontconstQRhiGraphicsPipeline::StencilOpState& -->
<h3 class="fn" translate="no" id="setStencilFront"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setStencilFront</span>(const <span class="type"><a href="qrhigraphicspipeline-stencilopstate.html" translate="no">QRhiGraphicsPipeline::StencilOpState</a></span> &amp;<i>state</i>)</h3>
<p>Sets the stencil test <i translate="no">state</i> for front faces.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#stencilFront" translate="no">stencilFront</a>().</p>
<!-- @@@setStencilFront -->
<!-- $$$setStencilReadMask[overload1]$$$setStencilReadMaskquint32 -->
<h3 class="fn" translate="no" id="setStencilReadMask"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setStencilReadMask</span>(<span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>mask</i>)</h3>
<p>Sets the stencil read <i translate="no">mask</i>. The default value is 0xFF.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#stencilReadMask" translate="no">stencilReadMask</a>().</p>
<!-- @@@setStencilReadMask -->
<!-- $$$setStencilTest[overload1]$$$setStencilTestbool -->
<h3 class="fn" translate="no" id="setStencilTest"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setStencilTest</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Enables or disables stencil tests based on <i translate="no">enable</i>. By default this is disabled.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#hasStencilTest" translate="no">hasStencilTest</a>().</p>
<!-- @@@setStencilTest -->
<!-- $$$setStencilWriteMask[overload1]$$$setStencilWriteMaskquint32 -->
<h3 class="fn" translate="no" id="setStencilWriteMask"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setStencilWriteMask</span>(<span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>mask</i>)</h3>
<p>Sets the stencil write <i translate="no">mask</i>. The default value is 0xFF.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#stencilWriteMask" translate="no">stencilWriteMask</a>().</p>
<!-- @@@setStencilWriteMask -->
<!-- $$$setTargetBlends[overload1]$$$setTargetBlendsstd::initializer_list<QRhiGraphicsPipeline::TargetBlend> -->
<h3 class="fn" translate="no" id="setTargetBlends"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setTargetBlends</span>(<span class="type">std::initializer_list</span>&lt;<span class="type"><a href="qrhigraphicspipeline-targetblend.html" translate="no">QRhiGraphicsPipeline::TargetBlend</a></span>&gt; <i>list</i>)</h3>
<p>Sets the <i translate="no">list</i> of render target blend settings. This is a list because when multiple render targets are used (i.e., a <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> with more than one <a href="qrhicolorattachment.html" translate="no">QRhiColorAttachment</a>), there needs to be a <a href="qrhigraphicspipeline-targetblend.html" translate="no">TargetBlend</a> structure per render target (color attachment).</p>
<p>By default there is one default-constructed <a href="qrhigraphicspipeline-targetblend.html" translate="no">TargetBlend</a> set.</p>
<p><b>See also </b><a href="qrhi.html#ResourceLimit-enum" translate="no">QRhi::MaxColorAttachments</a>.</p>
<!-- @@@setTargetBlends -->
<!-- $$$setTargetBlends$$$setTargetBlendsInputIteratorInputIterator -->
<h3 class="fn" translate="no" id="setTargetBlends-1">template &lt;typename InputIterator&gt; <span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setTargetBlends</span>(<span class="type">InputIterator</span> <i>first</i>, <span class="type">InputIterator</span> <i>last</i>)</h3>
<p>Sets the list of render target blend settings from the iterators <i translate="no">first</i> and <i translate="no">last</i>.</p>
<!-- @@@setTargetBlends -->
<!-- $$$setTopology[overload1]$$$setTopologyQRhiGraphicsPipeline::Topology -->
<h3 class="fn" translate="no" id="setTopology"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setTopology</span>(<span class="type"><a href="qrhigraphicspipeline.html#Topology-enum" translate="no">QRhiGraphicsPipeline::Topology</a></span> <i>t</i>)</h3>
<p>Sets the primitive topology <i translate="no">t</i>.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#topology" translate="no">topology</a>().</p>
<!-- @@@setTopology -->
<!-- $$$setVertexInputLayout[overload1]$$$setVertexInputLayoutconstQRhiVertexInputLayout& -->
<h3 class="fn" translate="no" id="setVertexInputLayout"><span class="type">void</span> QRhiGraphicsPipeline::<span class="name">setVertexInputLayout</span>(const <span class="type"><a href="qrhivertexinputlayout.html" translate="no">QRhiVertexInputLayout</a></span> &amp;<i>layout</i>)</h3>
<p>Specifies the vertex input <i translate="no">layout</i>.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#vertexInputLayout" translate="no">vertexInputLayout</a>().</p>
<!-- @@@setVertexInputLayout -->
<!-- $$$shaderResourceBindings[overload1]$$$shaderResourceBindings -->
<h3 class="fn" translate="no" id="shaderResourceBindings"><span class="type"><a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a></span> *QRhiGraphicsPipeline::<span class="name">shaderResourceBindings</span>() const</h3>
<p>Returns the currently associated <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> object.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setShaderResourceBindings" translate="no">setShaderResourceBindings</a>().</p>
<!-- @@@shaderResourceBindings -->
<!-- $$$shaderStageAt[overload1]$$$shaderStageAtqsizetype -->
<h3 class="fn" translate="no" id="shaderStageAt">const <span class="type"><a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a></span> *QRhiGraphicsPipeline::<span class="name">shaderStageAt</span>(<span class="type"><a href="../qtcore/qttypes.html#qsizetype-typedef" translate="no">qsizetype</a></span> <i>index</i>) const</h3>
<p>Returns the shader stage at the specified <i translate="no">index</i>.</p>
<!-- @@@shaderStageAt -->
<!-- $$$shaderStageCount[overload1]$$$shaderStageCount -->
<h3 class="fn" translate="no" id="shaderStageCount"><span class="type"><a href="../qtcore/qttypes.html#qsizetype-typedef" translate="no">qsizetype</a></span> QRhiGraphicsPipeline::<span class="name">shaderStageCount</span>() const</h3>
<p>Returns the number of shader stages in this pipeline.</p>
<!-- @@@shaderStageCount -->
<!-- $$$slopeScaledDepthBias[overload1]$$$slopeScaledDepthBias -->
<h3 class="fn" translate="no" id="slopeScaledDepthBias"><span class="type">float</span> QRhiGraphicsPipeline::<span class="name">slopeScaledDepthBias</span>() const</h3>
<p>Returns the currently set slope scaled depth bias.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setSlopeScaledDepthBias" translate="no">setSlopeScaledDepthBias</a>().</p>
<!-- @@@slopeScaledDepthBias -->
<!-- $$$stencilBack[overload1]$$$stencilBack -->
<h3 class="fn" translate="no" id="stencilBack"><span class="type"><a href="qrhigraphicspipeline-stencilopstate.html" translate="no">QRhiGraphicsPipeline::StencilOpState</a></span> QRhiGraphicsPipeline::<span class="name">stencilBack</span>() const</h3>
<p>Returns the current stencil test state for back faces.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setStencilBack" translate="no">setStencilBack</a>().</p>
<!-- @@@stencilBack -->
<!-- $$$stencilFront[overload1]$$$stencilFront -->
<h3 class="fn" translate="no" id="stencilFront"><span class="type"><a href="qrhigraphicspipeline-stencilopstate.html" translate="no">QRhiGraphicsPipeline::StencilOpState</a></span> QRhiGraphicsPipeline::<span class="name">stencilFront</span>() const</h3>
<p>Returns the current stencil test state for front faces.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setStencilFront" translate="no">setStencilFront</a>().</p>
<!-- @@@stencilFront -->
<!-- $$$stencilReadMask[overload1]$$$stencilReadMask -->
<h3 class="fn" translate="no" id="stencilReadMask"><span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> QRhiGraphicsPipeline::<span class="name">stencilReadMask</span>() const</h3>
<p>Returns the currrent stencil read mask.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setStencilReadMask" translate="no">setStencilReadMask</a>().</p>
<!-- @@@stencilReadMask -->
<!-- $$$stencilWriteMask[overload1]$$$stencilWriteMask -->
<h3 class="fn" translate="no" id="stencilWriteMask"><span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> QRhiGraphicsPipeline::<span class="name">stencilWriteMask</span>() const</h3>
<p>Returns the current stencil write mask.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setStencilWriteMask" translate="no">setStencilWriteMask</a>().</p>
<!-- @@@stencilWriteMask -->
<!-- $$$targetBlendAt[overload1]$$$targetBlendAtqsizetype -->
<h3 class="fn" translate="no" id="targetBlendAt">const <span class="type"><a href="qrhigraphicspipeline-targetblend.html" translate="no">QRhiGraphicsPipeline::TargetBlend</a></span> *QRhiGraphicsPipeline::<span class="name">targetBlendAt</span>(<span class="type"><a href="../qtcore/qttypes.html#qsizetype-typedef" translate="no">qsizetype</a></span> <i>index</i>) const</h3>
<p>Returns the render target blend setting at the specified <i translate="no">index</i>.</p>
<!-- @@@targetBlendAt -->
<!-- $$$targetBlendCount[overload1]$$$targetBlendCount -->
<h3 class="fn" translate="no" id="targetBlendCount"><span class="type"><a href="../qtcore/qttypes.html#qsizetype-typedef" translate="no">qsizetype</a></span> QRhiGraphicsPipeline::<span class="name">targetBlendCount</span>() const</h3>
<p>Returns the number of render target blend settings.</p>
<!-- @@@targetBlendCount -->
<!-- $$$topology[overload1]$$$topology -->
<h3 class="fn" translate="no" id="topology"><span class="type"><a href="qrhigraphicspipeline.html#Topology-enum" translate="no">QRhiGraphicsPipeline::Topology</a></span> QRhiGraphicsPipeline::<span class="name">topology</span>() const</h3>
<p>Returns the currently set primitive topology.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setTopology" translate="no">setTopology</a>().</p>
<!-- @@@topology -->
<!-- $$$vertexInputLayout[overload1]$$$vertexInputLayout -->
<h3 class="fn" translate="no" id="vertexInputLayout"><span class="type"><a href="qrhivertexinputlayout.html" translate="no">QRhiVertexInputLayout</a></span> QRhiGraphicsPipeline::<span class="name">vertexInputLayout</span>() const</h3>
<p>Returns the currently set vertex input layout specification.</p>
<p><b>See also </b><a href="qrhigraphicspipeline.html#setVertexInputLayout" translate="no">setVertexInputLayout</a>().</p>
<!-- @@@vertexInputLayout -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
