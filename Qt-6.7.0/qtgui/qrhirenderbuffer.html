<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Renderbuffer resource.">
  <title>QRhiRenderBuffer Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiRenderBuffer</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiRenderBuffer Class</h1>
<!-- $$$QRhiRenderBuffer-brief -->
<p>Renderbuffer resource. <a href="#details">More...</a></p>
<!-- @@@QRhiRenderBuffer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiRenderBuffer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qrhiresource.html" translate="no">QRhiResource</a></td></tr>
</table></div>
<ul>
<li><a href="qrhirenderbuffer-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer-nativerenderbuffer.html" translate="no">NativeRenderBuffer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#Flag-enum" translate="no">Flag</a></b> { UsedWithSwapChainOnly }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#Flag-enum" translate="no">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#Type-enum" translate="no">Type</a></b> { DepthStencil, Color }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#create" translate="no">create</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#createFrom" translate="no">createFrom</a></b>(QRhiRenderBuffer::NativeRenderBuffer <i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderBuffer::Flags </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#pixelSize" translate="no">pixelSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#sampleCount" translate="no">sampleCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#setFlags" translate="no">setFlags</a></b>(QRhiRenderBuffer::Flags <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#setPixelSize" translate="no">setPixelSize</a></b>(const QSize &amp;<i>sz</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#setSampleCount" translate="no">setSampleCount</a></b>(int <i>s</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#setType" translate="no">setType</a></b>(QRhiRenderBuffer::Type <i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderBuffer::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#type" translate="no">type</a></b>() const</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiResource::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhirenderbuffer.html#resourceType" translate="no">resourceType</a></b>() const override</td></tr>
</table></div>
<!-- $$$QRhiRenderBuffer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Renderbuffers cannot be sampled or read but have some benefits over textures in some cases:</p>
<p>A <a href="qrhirenderbuffer.html#Type-enum" translate="no">DepthStencil</a> renderbuffer may be lazily allocated and be backed by transient memory with some APIs. On some platforms this may mean the depth/stencil buffer uses no physical backing at all.</p>
<p><a href="qrhirenderbuffer.html#Type-enum" translate="no">Color</a> renderbuffers are useful since <a href="qrhi.html#Feature-enum" translate="no">QRhi::MultisampleRenderBuffer</a> may be supported even when <a href="qrhi.html#Feature-enum" translate="no">QRhi::MultisampleTexture</a> is not.</p>
<p>How the renderbuffer is implemented by a backend is not exposed to the applications. In some cases it may be backed by ordinary textures, while in others there may be a different kind of native resource used.</p>
<p>Renderbuffers that are used as (and are only used as) depth-stencil buffers in combination with a <a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a>'s color buffers should have the <a href="qrhirenderbuffer.html#Flag-enum" translate="no">UsedWithSwapChainOnly</a> flag set. This serves a double purpose: such buffers, depending on the backend and the underlying APIs, be more efficient, and <a href="qrhi.html" translate="no">QRhi</a> provides automatic sizing behavior to match the color buffers, which means calling <a href="qrhirenderbuffer.html#setPixelSize" translate="no">setPixelSize</a>() and <a href="qrhirenderbuffer.html#create" translate="no">create</a>() are not necessary for such renderbuffers.</p>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<!-- @@@QRhiRenderBuffer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Flag$$$UsedWithSwapChainOnly -->
<h3 class="flags" id="Flag-enum">enum QRhiRenderBuffer::<span class="name">Flag</span><br/>flags QRhiRenderBuffer::<span class="name">Flags</span></h3>
<p>Flag values for <a href="qrhirenderbuffer.html#flags" translate="no">flags</a>() and <a href="qrhirenderbuffer.html#setFlags" translate="no">setFlags</a>()</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiRenderBuffer::UsedWithSwapChainOnly</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td><td class="topAlign">For <a href="qrhirenderbuffer.html#Type-enum" translate="no">DepthStencil</a> renderbuffers this indicates that the renderbuffer is only used in combination with a <a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a>, and never in any other way. This provides automatic sizing and resource rebuilding, so calling <a href="qrhirenderbuffer.html#setPixelSize" translate="no">setPixelSize</a>() or <a href="qrhirenderbuffer.html#create" translate="no">create</a>() is not needed whenever this flag is set. This flag value may also trigger backend-specific behavior, for example with OpenGL, where a separate windowing system interface API is in use (EGL, GLX, etc.), the flag is especially important as it avoids creating any actual renderbuffer resource as there is already a windowing system provided depth/stencil buffer as requested by <a href="qsurfaceformat.html" translate="no">QSurfaceFormat</a>.</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
<!-- $$$Type$$$DepthStencil$$$Color -->
<h3 class="fn" translate="no" id="Type-enum">enum QRhiRenderBuffer::<span class="name">Type</span></h3>
<p>Specifies the type of the renderbuffer</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiRenderBuffer::DepthStencil</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Combined depth/stencil</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiRenderBuffer::Color</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Color</td></tr>
</table></div>
<!-- @@@Type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$create[overload1]$$$create -->
<h3 class="fn" translate="no" id="create"><code class="details extra" translate="no">[pure virtual]</code> <span class="type">bool</span> QRhiRenderBuffer::<span class="name">create</span>()</h3>
<p>Creates the corresponding native graphics resources. If there are already resources present due to an earlier create() with no corresponding <a href="qrhiresource.html#destroy" translate="no">destroy</a>(), then <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is called implicitly first.</p>
<p>Returns <code translate="no">true</code> when successful, <code translate="no">false</code> when a graphics operation failed. Regardless of the return value, calling <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is always safe.</p>
<!-- @@@create -->
<!-- $$$createFrom[overload1]$$$createFromQRhiRenderBuffer::NativeRenderBuffer -->
<h3 class="fn" translate="no" id="createFrom"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QRhiRenderBuffer::<span class="name">createFrom</span>(<span class="type"><a href="qrhirenderbuffer-nativerenderbuffer.html" translate="no">QRhiRenderBuffer::NativeRenderBuffer</a></span> <i>src</i>)</h3>
<p>Similar to <a href="qrhirenderbuffer.html#create" translate="no">create</a>() except that no new native renderbuffer objects are created. Instead, the native renderbuffer object specified by <i translate="no">src</i> is used.</p>
<p>This allows importing an existing renderbuffer object (which must belong to the same device or sharing context, depending on the graphics API) from an external graphics engine.</p>
<div class="admonition note">
<p><b>Note: </b>This is currently applicable to OpenGL only. This function exists solely to allow importing a renderbuffer object that is bound to some special, external object, such as an EGLImageKHR. Once the application performed the glEGLImageTargetRenderbufferStorageOES call, the renderbuffer object can be passed to this function to create a wrapping <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>, which in turn can be passed in as a color attachment to a <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> to enable rendering to the EGLImage.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qrhirenderbuffer.html#pixelSize" translate="no">pixelSize</a>(), <a href="qrhirenderbuffer.html#sampleCount" translate="no">sampleCount</a>(), and <a href="qrhirenderbuffer.html#flags" translate="no">flags</a>() must still be set correctly. Passing incorrect sizes and other values to <a href="qrhi.html#newRenderBuffer" translate="no">QRhi::newRenderBuffer</a>() and then following it with a createFrom() expecting that the native renderbuffer object alone is sufficient to deduce such values is <b>wrong</b> and will lead to problems.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> does not take ownership of the native object, and <a href="qrhiresource.html#destroy" translate="no">destroy</a>() will not release that object.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function is only implemented when the <a href="qrhi.html#Feature-enum" translate="no">QRhi::RenderBufferImport</a> feature is reported as <a href="qrhi.html#isFeatureSupported" translate="no">supported</a>. Otherwise, the function does nothing and the return value is <code translate="no">false</code>.</p>
</div>
<p>Returns <code translate="no">true</code> when successful, <code translate="no">false</code> when not supported.</p>
<!-- @@@createFrom -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><span class="type"><a href="qrhirenderbuffer.html#Flag-enum" translate="no">QRhiRenderBuffer::Flags</a></span> QRhiRenderBuffer::<span class="name">flags</span>() const</h3>
<p>Returns the flags.</p>
<p><b>See also </b><a href="qrhirenderbuffer.html#setFlags" translate="no">setFlags</a>().</p>
<!-- @@@flags -->
<!-- $$$pixelSize[overload1]$$$pixelSize -->
<h3 class="fn" translate="no" id="pixelSize"><span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QRhiRenderBuffer::<span class="name">pixelSize</span>() const</h3>
<p>Returns the pixel size.</p>
<p><b>See also </b><a href="qrhirenderbuffer.html#setPixelSize" translate="no">setPixelSize</a>().</p>
<!-- @@@pixelSize -->
<!-- $$$resourceType[overload1]$$$resourceType -->
<h3 class="fn" translate="no" id="resourceType"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="qrhiresource.html#Type-enum" translate="no">QRhiResource::Type</a></span> QRhiRenderBuffer::<span class="name">resourceType</span>() const</h3>
<p>Reimplements: <a href="qrhiresource.html#resourceType" translate="no">QRhiResource::resourceType() const</a>.</p>
<p>Returns the resource type.</p>
<!-- @@@resourceType -->
<!-- $$$sampleCount[overload1]$$$sampleCount -->
<h3 class="fn" translate="no" id="sampleCount"><span class="type">int</span> QRhiRenderBuffer::<span class="name">sampleCount</span>() const</h3>
<p>Returns the sample count. 1 means no multisample antialiasing.</p>
<p><b>See also </b><a href="qrhirenderbuffer.html#setSampleCount" translate="no">setSampleCount</a>().</p>
<!-- @@@sampleCount -->
<!-- $$$setFlags[overload1]$$$setFlagsQRhiRenderBuffer::Flags -->
<h3 class="fn" translate="no" id="setFlags"><span class="type">void</span> QRhiRenderBuffer::<span class="name">setFlags</span>(<span class="type"><a href="qrhirenderbuffer.html#Flag-enum" translate="no">QRhiRenderBuffer::Flags</a></span> <i>f</i>)</h3>
<p>Sets the flags to <i translate="no">f</i>.</p>
<p><b>See also </b><a href="qrhirenderbuffer.html#flags" translate="no">flags</a>().</p>
<!-- @@@setFlags -->
<!-- $$$setPixelSize[overload1]$$$setPixelSizeconstQSize& -->
<h3 class="fn" translate="no" id="setPixelSize"><span class="type">void</span> QRhiRenderBuffer::<span class="name">setPixelSize</span>(const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>sz</i>)</h3>
<p>Sets the size (in pixels) to <i translate="no">sz</i>.</p>
<p><b>See also </b><a href="qrhirenderbuffer.html#pixelSize" translate="no">pixelSize</a>().</p>
<!-- @@@setPixelSize -->
<!-- $$$setSampleCount[overload1]$$$setSampleCountint -->
<h3 class="fn" translate="no" id="setSampleCount"><span class="type">void</span> QRhiRenderBuffer::<span class="name">setSampleCount</span>(<span class="type">int</span> <i>s</i>)</h3>
<p>Sets the sample count to <i translate="no">s</i>.</p>
<p><b>See also </b><a href="qrhirenderbuffer.html#sampleCount" translate="no">sampleCount</a>().</p>
<!-- @@@setSampleCount -->
<!-- $$$setType[overload1]$$$setTypeQRhiRenderBuffer::Type -->
<h3 class="fn" translate="no" id="setType"><span class="type">void</span> QRhiRenderBuffer::<span class="name">setType</span>(<span class="type"><a href="qrhirenderbuffer.html#Type-enum" translate="no">QRhiRenderBuffer::Type</a></span> <i>t</i>)</h3>
<p>Sets the type to <i translate="no">t</i>.</p>
<p><b>See also </b><a href="qrhirenderbuffer.html#type" translate="no">type</a>().</p>
<!-- @@@setType -->
<!-- $$$type[overload1]$$$type -->
<h3 class="fn" translate="no" id="type"><span class="type"><a href="qrhirenderbuffer.html#Type-enum" translate="no">QRhiRenderBuffer::Type</a></span> QRhiRenderBuffer::<span class="name">type</span>() const</h3>
<p>Returns the renderbuffer type.</p>
<p><b>See also </b><a href="qrhirenderbuffer.html#setType" translate="no">setType</a>().</p>
<!-- @@@type -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
