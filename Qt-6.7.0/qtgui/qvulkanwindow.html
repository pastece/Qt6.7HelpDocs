<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qvulkanwindow.cpp -->
  <meta name="description" content="The QVulkanWindow class is a convenience subclass of QWindow to perform Vulkan rendering.">
  <title>QVulkanWindow Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QVulkanWindow</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#coordinate-system-differences-between-opengl-and-vulkan">Coordinate system differences between OpenGL and Vulkan</a></li>
<li class="level2"><a href="#multisampling">Multisampling</a></li>
<li class="level2"><a href="#reading-images-back">Reading images back</a></li>
<li class="level2"><a href="#srgb-support">sRGB support</a></li>
<li class="level2"><a href="#validation-layers">Validation layers</a></li>
<li class="level2"><a href="#layers-device-features-and-extensions">Layers, device features, and extensions</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QVulkanWindow Class</h1>
<!-- $$$QVulkanWindow-brief -->
<p>The QVulkanWindow class is a convenience subclass of <a href="qwindow.html" translate="no">QWindow</a> to perform Vulkan rendering. <a href="#details">More...</a></p>
<!-- @@@QVulkanWindow -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QVulkanWindow&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qwindow.html" translate="no">QWindow</a></td></tr>
</table></div>
<ul>
<li><a href="qvulkanwindow-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#EnabledFeatures2Modifier-typedef" translate="no">EnabledFeatures2Modifier</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#EnabledFeaturesModifier-typedef" translate="no">EnabledFeaturesModifier</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#Flag-enum" translate="no">Flag</a></b> { PersistentResources }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#Flag-enum" translate="no">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#QueueCreateInfoModifier-typedef" translate="no">QueueCreateInfoModifier</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#QVulkanWindow" translate="no">QVulkanWindow</a></b>(QWindow *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#dtor.QVulkanWindow" translate="no">~QVulkanWindow</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;VkPhysicalDeviceProperties&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#availablePhysicalDevices" translate="no">availablePhysicalDevices</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMatrix4x4 </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#clipCorrectionMatrix" translate="no">clipCorrectionMatrix</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkFormat </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#colorFormat" translate="no">colorFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#concurrentFrameCount" translate="no">concurrentFrameCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVulkanWindowRenderer *</td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#createRenderer" translate="no">createRenderer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkCommandBuffer </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#currentCommandBuffer" translate="no">currentCommandBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#currentFrame" translate="no">currentFrame</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkFramebuffer </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#currentFramebuffer" translate="no">currentFramebuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#currentSwapChainImageIndex" translate="no">currentSwapChainImageIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkRenderPass </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#defaultRenderPass" translate="no">defaultRenderPass</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkFormat </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#depthStencilFormat" translate="no">depthStencilFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImage </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#depthStencilImage" translate="no">depthStencilImage</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImageView </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#depthStencilImageView" translate="no">depthStencilImageView</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkDevice </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#device" translate="no">device</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint32_t </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#deviceLocalMemoryIndex" translate="no">deviceLocalMemoryIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVulkanWindow::Flags </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#grab" translate="no">grab</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkCommandPool </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#graphicsCommandPool" translate="no">graphicsCommandPool</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkQueue </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#graphicsQueue" translate="no">graphicsQueue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint32_t </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#graphicsQueueFamilyIndex" translate="no">graphicsQueueFamilyIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint32_t </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#hostVisibleMemoryIndex" translate="no">hostVisibleMemoryIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImage </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#msaaColorImage" translate="no">msaaColorImage</a></b>(int <i>idx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImageView </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#msaaColorImageView" translate="no">msaaColorImageView</a></b>(int <i>idx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkPhysicalDevice </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#physicalDevice" translate="no">physicalDevice</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const VkPhysicalDeviceProperties *</td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#physicalDeviceProperties" translate="no">physicalDeviceProperties</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkSampleCountFlagBits </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#sampleCountFlagBits" translate="no">sampleCountFlagBits</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#setDeviceExtensions" translate="no">setDeviceExtensions</a></b>(const QByteArrayList &amp;<i>extensions</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#setEnabledFeaturesModifier" translate="no">setEnabledFeaturesModifier</a></b>(const QVulkanWindow::EnabledFeaturesModifier &amp;<i>modifier</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#setEnabledFeaturesModifier-1" translate="no">setEnabledFeaturesModifier</a></b>(QVulkanWindow::EnabledFeatures2Modifier <i>modifier</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#setFlags" translate="no">setFlags</a></b>(QVulkanWindow::Flags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#setPhysicalDeviceIndex" translate="no">setPhysicalDeviceIndex</a></b>(int <i>idx</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#setPreferredColorFormats" translate="no">setPreferredColorFormats</a></b>(const QList&lt;VkFormat&gt; &amp;<i>formats</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#setQueueCreateInfoModifier" translate="no">setQueueCreateInfoModifier</a></b>(const QVulkanWindow::QueueCreateInfoModifier &amp;<i>modifier</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#setSampleCount" translate="no">setSampleCount</a></b>(int <i>sampleCount</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVulkanInfoVector&lt;QVulkanExtension&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#supportedDeviceExtensions" translate="no">supportedDeviceExtensions</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;int&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#supportedSampleCounts" translate="no">supportedSampleCounts</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#supportsGrab" translate="no">supportsGrab</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImage </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#swapChainImage" translate="no">swapChainImage</a></b>(int <i>idx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#swapChainImageCount" translate="no">swapChainImageCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#swapChainImageSize" translate="no">swapChainImageSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImageView </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#swapChainImageView" translate="no">swapChainImageView</a></b>(int <i>idx</i>) const</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#frameGrabbed" translate="no">frameGrabbed</a></b>(const QImage &amp;<i>image</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> const int </td><td class="memItemRight bottomAlign"><b><a href="qvulkanwindow.html#MAX_CONCURRENT_FRAME_COUNT-var" translate="no">MAX_CONCURRENT_FRAME_COUNT</a></b></td></tr>
</table></div>
<!-- $$$QVulkanWindow-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QVulkanWindow is a Vulkan-capable <a href="qwindow.html" translate="no">QWindow</a> that manages a Vulkan device, a graphics queue, a command pool and buffer, a depth-stencil image and a double-buffered FIFO swapchain, while taking care of correct behavior when it comes to events like resize, special situations like not having a device queue supporting both graphics and presentation, device lost scenarios, and additional functionality like reading the rendered content back. Conceptually it is the counterpart of <a href="../qtopengl/qopenglwindow.html" translate="no">QOpenGLWindow</a> in the Vulkan world.</p>
<div class="admonition note">
<p><b>Note: </b>QVulkanWindow does not always eliminate the need to implement a fully custom <a href="qwindow.html" translate="no">QWindow</a> subclass as it will not necessarily be sufficient in advanced use cases.</p>
</div>
<p>QVulkanWindow can be embedded into <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>-based user interfaces via <a href="../qtwidgets/qwidget.html#createWindowContainer" translate="no">QWidget::createWindowContainer</a>(). This approach has a number of limitations, however. Make sure to study the <a href="../qtwidgets/qwidget.html#createWindowContainer" translate="no">documentation</a> first.</p>
<p>A typical application using QVulkanWindow may look like the following:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> VulkanRenderer : <span class="keyword">public</span> <span class="type"><a href="qvulkanwindowrenderer.html" translate="no">QVulkanWindowRenderer</a></span>
 {
 <span class="keyword">public</span>:
     VulkanRenderer(<span class="type"><a href="qvulkanwindow.html#QVulkanWindow" translate="no">QVulkanWindow</a></span> <span class="operator">*</span>w) : m_window(w)<span class="operator">,</span> m_devFuncs(nullptr) { }

     <span class="type">void</span> initResources() override
     {
         m_devFuncs <span class="operator">=</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>vulkanInstance()<span class="operator">-</span><span class="operator">&gt;</span>deviceFunctions(m_window<span class="operator">-</span><span class="operator">&gt;</span>device());
         <span class="comment">// ..</span>
     }
     <span class="type">void</span> initSwapChainResources() override { <span class="comment">/* ... */</span> }
     <span class="type">void</span> releaseSwapChainResources() override { <span class="comment">/* ... */</span> }
     <span class="type">void</span> releaseResources() override { <span class="comment">/* ... */</span> }

     <span class="type">void</span> startNextFrame() override
     {
         VkCommandBuffer cmdBuf <span class="operator">=</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>currentCommandBuffer();
         <span class="comment">// ...</span>
         m_devFuncs<span class="operator">-</span><span class="operator">&gt;</span>vkCmdBeginRenderPass(commandBuffer<span class="operator">,</span> renderPassBegin<span class="operator">,</span> contents);
         <span class="comment">// ...</span>
         m_window<span class="operator">-</span><span class="operator">&gt;</span>frameReady();
     }

 <span class="keyword">private</span>:
     <span class="type"><a href="qvulkanwindow.html#QVulkanWindow" translate="no">QVulkanWindow</a></span> <span class="operator">*</span>m_window;
     <span class="type"><a href="qvulkandevicefunctions.html" translate="no">QVulkanDeviceFunctions</a></span> <span class="operator">*</span>m_devFuncs;
 };

 <span class="keyword">class</span> VulkanWindow : <span class="keyword">public</span> <span class="type"><a href="qvulkanwindow.html#QVulkanWindow" translate="no">QVulkanWindow</a></span>
 {
 <span class="keyword">public</span>:
     <span class="type"><a href="qvulkanwindowrenderer.html" translate="no">QVulkanWindowRenderer</a></span> <span class="operator">*</span>createRenderer() override {
         <span class="keyword">return</span> <span class="keyword">new</span> VulkanRenderer(<span class="keyword">this</span>);
     }
 };

 <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>argv<span class="operator">[</span><span class="operator">]</span>)
 {
     <span class="type"><a href="qguiapplication.html" translate="no">QGuiApplication</a></span> app(argc<span class="operator">,</span> argv);

     <span class="type"><a href="qvulkaninstance.html" translate="no">QVulkanInstance</a></span> inst;
     <span class="comment">// enable the standard validation layers, when available</span>
     inst<span class="operator">.</span>setLayers({ <span class="string">&quot;VK_LAYER_KHRONOS_validation&quot;</span> });
     <span class="keyword">if</span> (<span class="operator">!</span>inst<span class="operator">.</span>create())
         <a href="../qtcore/qtlogging.html#qFatal" translate="no">qFatal</a>(<span class="string">&quot;Failed to create Vulkan instance: %d&quot;</span><span class="operator">,</span> inst<span class="operator">.</span>errorCode());

     VulkanWindow w;
     w<span class="operator">.</span>setVulkanInstance(<span class="operator">&amp;</span>inst);
     w<span class="operator">.</span>showMaximized();

     <span class="keyword">return</span> app<span class="operator">.</span>exec();
 }
</pre>
<p>As it can be seen in the example, the main patterns in QVulkanWindow usage are:</p>
<ul>
<li>The <a href="qvulkaninstance.html" translate="no">QVulkanInstance</a> is associated via <a href="qwindow.html#setVulkanInstance" translate="no">QWindow::setVulkanInstance</a>(). It is then retrievable via <a href="qwindow.html#vulkanInstance" translate="no">QWindow::vulkanInstance</a>() from everywhere, on any thread.</li>
<li>Similarly to <a href="qvulkaninstance.html" translate="no">QVulkanInstance</a>, device extensions can be queried via <a href="qvulkanwindow.html#supportedDeviceExtensions" translate="no">supportedDeviceExtensions</a>() before the actual initialization. Requesting an extension to be enabled is done via <a href="qvulkanwindow.html#setDeviceExtensions" translate="no">setDeviceExtensions</a>(). Such calls must be made before the window becomes visible, that is, before calling <a href="qwindow.html#show" translate="no">show</a>() or similar functions. Unsupported extension requests are gracefully ignored.</li>
<li>The renderer is implemented in a <a href="qvulkanwindowrenderer.html" translate="no">QVulkanWindowRenderer</a> subclass, an instance of which is created in the <a href="qvulkanwindow.html#createRenderer" translate="no">createRenderer</a>() factory function.</li>
<li>The core Vulkan commands are exposed via the <a href="qvulkanfunctions.html" translate="no">QVulkanFunctions</a> object, retrievable by calling <a href="qvulkaninstance.html#functions" translate="no">QVulkanInstance::functions</a>(). Device level functions are available after creating a VkDevice by calling <a href="qvulkaninstance.html#deviceFunctions" translate="no">QVulkanInstance::deviceFunctions</a>().</li>
<li>The building of the draw calls for the next frame happens in <a href="qvulkanwindowrenderer.html#startNextFrame" translate="no">QVulkanWindowRenderer::startNextFrame</a>(). The implementation is expected to add commands to the command buffer returned from <a href="qvulkanwindow.html#currentCommandBuffer" translate="no">currentCommandBuffer</a>(). Returning from the function does not indicate that the commands are ready for submission. Rather, an explicit call to <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>() is required. This allows asynchronous generation of commands, possibly on multiple threads. Simple implementations will simply call <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>() at the end of their <a href="qvulkanwindowrenderer.html#startNextFrame" translate="no">QVulkanWindowRenderer::startNextFrame</a>().</li>
<li>The basic Vulkan resources (physical device, graphics queue, a command pool, the window's main command buffer, image formats, etc.) are exposed on the QVulkanWindow via lightweight getter functions. Some of these are for convenience only, and applications are always free to query, create and manage additional resources directly via the Vulkan API.</li>
<li>The renderer lives in the gui/main thread, like the window itself. This thread is then throttled to the presentation rate, similarly to how OpenGL with a swap interval of 1 would behave. However, the renderer implementation is free to utilize multiple threads in any way it sees fit. The accessors like <a href="qwindow.html#vulkanInstance" translate="no">vulkanInstance</a>(), <a href="qvulkanwindow.html#currentCommandBuffer" translate="no">currentCommandBuffer</a>(), etc. can be called from any thread. The submission of the main command buffer, the queueing of present, and the building of the next frame do not start until <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>() is invoked on the gui/main thread.</li>
<li>When the window is made visible, the content is updated automatically. Further updates can be requested by calling <a href="qwindow.html#requestUpdate" translate="no">QWindow::requestUpdate</a>(). To render continuously, call <a href="qwindow.html#requestUpdate" translate="no">requestUpdate</a>() after <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>().</li>
</ul>
<p>For troubleshooting, enable the logging category <code translate="no">qt.vulkan</code>. Critical errors are printed via <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() automatically.</p>
<h3 id="coordinate-system-differences-between-opengl-and-vulkan">Coordinate system differences between OpenGL and Vulkan</h3>
<p>There are two notable differences to be aware of: First, with Vulkan Y points down the screen in clip space, while OpenGL uses an upwards pointing Y axis. Second, the standard OpenGL projection matrix assume a near and far plane values of -1 and 1, while Vulkan prefers 0 and 1.</p>
<p>In order to help applications migrate from OpenGL-based code without having to flip Y coordinates in the vertex data, and to allow using <a href="qmatrix4x4.html" translate="no">QMatrix4x4</a> functions like <a href="qmatrix4x4.html#perspective" translate="no">QMatrix4x4::perspective</a>() while keeping the Vulkan viewport's minDepth and maxDepth set to 0 and 1, QVulkanWindow provides a correction matrix retrievable by calling <a href="qvulkanwindow.html#clipCorrectionMatrix" translate="no">clipCorrectionMatrix</a>().</p>
<h3 id="multisampling">Multisampling</h3>
<p>While disabled by default, multisample antialiasing is fully supported by QVulkanWindow. Additional color buffers and resolving into the swapchain's non-multisample buffers are all managed automatically.</p>
<p>To query the supported sample counts, call <a href="qvulkanwindow.html#supportedSampleCounts" translate="no">supportedSampleCounts</a>(). When the returned set contains 4, 8, ..., passing one of those values to <a href="qvulkanwindow.html#setSampleCount" translate="no">setSampleCount</a>() requests multisample rendering.</p>
<div class="admonition note">
<p><b>Note: </b>unlike <a href="qsurfaceformat.html#setSamples" translate="no">QSurfaceFormat::setSamples</a>(), the list of supported sample counts are exposed to the applications in advance and there is no automatic falling back to lower sample counts in <a href="qvulkanwindow.html#setSampleCount" translate="no">setSampleCount</a>(). If the requested value is not supported, a warning is shown and a no multisampling will be used.</p>
</div>
<h3 id="reading-images-back">Reading images back</h3>
<p>When <a href="qvulkanwindow.html#supportsGrab" translate="no">supportsGrab</a>() returns true, QVulkanWindow can perform readbacks from the color buffer into a <a href="qimage.html" translate="no">QImage</a>. <a href="qvulkanwindow.html#grab" translate="no">grab</a>() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</p>
<h3 id="srgb-support">sRGB support</h3>
<p>While many applications will be fine with the default behavior of QVulkanWindow when it comes to swapchain image formats, <a href="qvulkanwindow.html#setPreferredColorFormats" translate="no">setPreferredColorFormats</a>() allows requesting a pre-defined format. This is useful most notably when working in the sRGB color space. Passing a format like <code translate="no">VK_FORMAT_B8G8R8A8_SRGB</code> results in choosing an sRGB format, when available.</p>
<h3 id="validation-layers">Validation layers</h3>
<p>During application development it can be extremely valuable to have the Vulkan validation layers enabled. As shown in the example code above, calling <a href="qvulkaninstance.html#setLayers" translate="no">QVulkanInstance::setLayers</a>() on the <a href="qvulkaninstance.html" translate="no">QVulkanInstance</a> before <a href="qvulkaninstance.html#create" translate="no">QVulkanInstance::create</a>() enables validation, assuming the Vulkan driver stack in the system contains the necessary layers.</p>
<div class="admonition note">
<p><b>Note: </b>Be aware of platform-specific differences. On desktop platforms installing the <a href="https://www.lunarg.com/vulkan-sdk/" translate="no">Vulkan SDK</a> is typically sufficient. However, Android for example requires deploying additional shared libraries together with the application, and also mandates a different list of validation layer names. See <a href="https://developer.android.com/ndk/guides/graphics/validation-layer.html" translate="no">the Android Vulkan development pages</a> for more information.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>QVulkanWindow does not expose device layers since this functionality has been deprecated since version 1.0.13 of the Vulkan API.</p>
</div>
<h3 id="layers-device-features-and-extensions">Layers, device features, and extensions</h3>
<p>To enable instance layers, call <a href="qvulkaninstance.html#setLayers" translate="no">QVulkanInstance::setLayers</a>() before creating the <a href="qvulkaninstance.html" translate="no">QVulkanInstance</a>. To query what instance layer are available, call <a href="qvulkaninstance.html#supportedLayers-1" translate="no">QVulkanInstance::supportedLayers</a>().</p>
<p>To enable device extensions, call <a href="qvulkanwindow.html#setDeviceExtensions" translate="no">setDeviceExtensions</a>() early on when setting up the QVulkanWindow. To query what device extensions are available, call <a href="qvulkanwindow.html#supportedDeviceExtensions" translate="no">supportedDeviceExtensions</a>().</p>
<p>Specifying an unsupported layer or extension is handled gracefully: this will not fail instance or device creation, but the layer or extension request is rather ignored.</p>
<p>When it comes to device features, QVulkanWindow enables all Vulkan 1.0 features that are reported as supported from vkGetPhysicalDeviceFeatures(). As an exception to this rule, <code translate="no">robustBufferAccess</code> is never enabled. Use the callback mechanism described below, if enabling that feature is desired.</p>
<p>This is not always desirable, and may be insufficient with Vulkan 1.1 and higher. Therefore, full control over the VkPhysicalDeviceFeatures used for device creation is possible too by registering a callback function with <a href="qvulkanwindow.html#setEnabledFeaturesModifier" translate="no">setEnabledFeaturesModifier</a>(). When set, the callback function is invoked, letting it alter the VkPhysicalDeviceFeatures or VkPhysicalDeviceFeatures2.</p>
</div>
<p><b>See also </b><a href="qvulkaninstance.html" translate="no">QVulkanInstance</a> and <a href="qwindow.html" translate="no">QWindow</a>.</p>
<!-- @@@QVulkanWindow -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$EnabledFeatures2Modifier -->
<h3 class="fn" translate="no" id="EnabledFeatures2Modifier-typedef"><code class="details extra" translate="no">[since 6.7]</code> QVulkanWindow::<span class="name">EnabledFeatures2Modifier</span></h3>
<p>A function that is called during graphics initialization to alter the VkPhysicalDeviceFeatures2 that is changed to the VkDeviceCreateInfo.</p>
<p>By default <a href="qvulkanwindow.html" translate="no">QVulkanWindow</a> enables all Vulkan 1.0 core features that the physical device reports as supported, with certain exceptions. In praticular, <code translate="no">robustBufferAccess</code> is always disabled in order to avoid unexpected performance hits.</p>
<p>This however is not always sufficient when working with Vulkan 1.1, 1.2, or 1.3 features and extensions. Hence this callback mechanism. If only Vulkan 1.0 is relevant at run time, use <a href="qvulkanwindow.html#setEnabledFeaturesModifier" translate="no">setEnabledFeaturesModifier</a>() instead.</p>
<p>The VkPhysicalDeviceFeatures2 reference passed to the callback function with <code translate="no">sType</code> set, but the rest zeroed out. It is up to the function to change members to true, or set up <code translate="no">pNext</code> chains as it sees fit.</p>
<div class="admonition note">
<p><b>Note: </b>When setting up <code translate="no">pNext</code> chains, make sure the referenced objects have a long enough lifetime, for example by storing them as member variables in the <a href="qvulkanwindow.html" translate="no">QVulkanWindow</a> subclass.</p>
</div>
<p>This typedef was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qvulkanwindow.html#setEnabledFeaturesModifier" translate="no">setEnabledFeaturesModifier</a>().</p>
<!-- @@@EnabledFeatures2Modifier -->
<!-- $$$EnabledFeaturesModifier -->
<h3 class="fn" translate="no" id="EnabledFeaturesModifier-typedef">QVulkanWindow::<span class="name">EnabledFeaturesModifier</span></h3>
<p>A function that is called during graphics initialization to alter the VkPhysicalDeviceFeatures that is passed in when creating a Vulkan device object.</p>
<p>By default <a href="qvulkanwindow.html" translate="no">QVulkanWindow</a> enables all Vulkan 1.0 core features that the physical device reports as supported, with certain exceptions. In praticular, <code translate="no">robustBufferAccess</code> is always disabled in order to avoid unexpected performance hits.</p>
<p>The VkPhysicalDeviceFeatures reference passed in is all zeroed out at the point when the function is invoked. It is up to the function to change members as it sees fit.</p>
<div class="admonition note">
<p><b>Note: </b>To control Vulkan 1.1, 1.2, or 1.3 features, use <a href="qvulkanwindow.html#EnabledFeatures2Modifier-typedef" translate="no">EnabledFeatures2Modifier</a> instead.</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#setEnabledFeaturesModifier" translate="no">setEnabledFeaturesModifier</a>().</p>
<!-- @@@EnabledFeaturesModifier -->
<!-- $$$Flag$$$PersistentResources -->
<h3 class="flags" id="Flag-enum">enum QVulkanWindow::<span class="name">Flag</span><br/>flags QVulkanWindow::<span class="name">Flags</span></h3>
<p>This enum describes the flags that can be passed to <a href="qvulkanwindow.html#setFlags" translate="no">setFlags</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QVulkanWindow::PersistentResources</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Ensures no graphics resources are released when the window becomes unexposed. The default behavior is to release everything, and reinitialize later when becoming visible again.</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
<!-- $$$QueueCreateInfoModifier -->
<h3 class="fn" translate="no" id="QueueCreateInfoModifier-typedef">QVulkanWindow::<span class="name">QueueCreateInfoModifier</span></h3>
<p>A function that is called during graphics initialization to add additional queues that should be created.</p>
<p>Set if the renderer needs additional queues besides the default graphics queue (e.g. a transfer queue). The provided queue family properties can be used to select the indices for the additional queues. The renderer can subsequently request the actual queue in initResources().</p>
<div class="admonition note">
<p><b>Note: </b>When requesting additional graphics queues, Qt itself always requests a graphics queue. You'll need to search queueCreateInfo for the appropriate entry and manipulate it to obtain the additional queue.</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#setQueueCreateInfoModifier" translate="no">setQueueCreateInfoModifier</a>().</p>
<!-- @@@QueueCreateInfoModifier -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QVulkanWindow[overload1]$$$QVulkanWindowQWindow* -->
<h3 class="fn" translate="no" id="QVulkanWindow"><code class="details extra" translate="no">[explicit]</code> QVulkanWindow::<span class="name">QVulkanWindow</span>(<span class="type"><a href="qwindow.html#QWindow" translate="no">QWindow</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new QVulkanWindow with the given <i translate="no">parent</i>.</p>
<p>The surface type is set to <a href="qsurface.html#SurfaceType-enum" translate="no">QSurface::VulkanSurface</a>.</p>
<!-- @@@QVulkanWindow -->
<!-- $$$~QVulkanWindow[overload1]$$$~QVulkanWindow -->
<h3 class="fn" translate="no" id="dtor.QVulkanWindow"><code class="details extra" translate="no">[virtual noexcept]</code> QVulkanWindow::<span class="name">~QVulkanWindow</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QVulkanWindow -->
<!-- $$$availablePhysicalDevices[overload1]$$$availablePhysicalDevices -->
<h3 class="fn" translate="no" id="availablePhysicalDevices"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type">VkPhysicalDeviceProperties</span>&gt; QVulkanWindow::<span class="name">availablePhysicalDevices</span>()</h3>
<p>Returns the list of properties for the supported physical devices in the system.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called before making the window visible.</p>
</div>
<!-- @@@availablePhysicalDevices -->
<!-- $$$clipCorrectionMatrix[overload1]$$$clipCorrectionMatrix -->
<h3 class="fn" translate="no" id="clipCorrectionMatrix"><span class="type"><a href="qmatrix4x4.html" translate="no">QMatrix4x4</a></span> QVulkanWindow::<span class="name">clipCorrectionMatrix</span>()</h3>
<p>Returns a <a href="qmatrix4x4.html" translate="no">QMatrix4x4</a> that can be used to correct for coordinate system differences between OpenGL and Vulkan.</p>
<p>By pre-multiplying the projection matrix with this matrix, applications can continue to assume that Y is pointing upwards, and can set minDepth and maxDepth in the viewport to 0 and 1, respectively, without having to do any further corrections to the vertex Z positions. Geometry from OpenGL applications can then be used as-is, assuming a rasterization state matching the OpenGL culling and front face settings.</p>
<!-- @@@clipCorrectionMatrix -->
<!-- $$$colorFormat[overload1]$$$colorFormat -->
<h3 class="fn" translate="no" id="colorFormat"><span class="type">VkFormat</span> QVulkanWindow::<span class="name">colorFormat</span>() const</h3>
<p>Returns the color buffer format used by the swapchain.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#setPreferredColorFormats" translate="no">setPreferredColorFormats</a>().</p>
<!-- @@@colorFormat -->
<!-- $$$concurrentFrameCount[overload1]$$$concurrentFrameCount -->
<h3 class="fn" translate="no" id="concurrentFrameCount"><span class="type">int</span> QVulkanWindow::<span class="name">concurrentFrameCount</span>() const</h3>
<p>Returns the number of frames that can be potentially active at the same time.</p>
<div class="admonition note">
<p><b>Note: </b>The value is constant for the entire lifetime of the <a href="qvulkanwindow.html" translate="no">QVulkanWindow</a>.</p>
</div>
<pre class="cpp" translate="no">
     <span class="keyword">class</span> Renderer {
         <span class="type">void</span> startNextFrame();
         <span class="comment">// ...</span>

         VkDescriptorBufferInfo m_uniformBufInfo<span class="operator">[</span><span class="type"><a href="qvulkanwindow.html#QVulkanWindow" translate="no">QVulkanWindow</a></span><span class="operator">::</span>MAX_CONCURRENT_FRAME_COUNT<span class="operator">]</span>;
         <span class="type"><a href="qvulkanwindow.html#QVulkanWindow" translate="no">QVulkanWindow</a></span> <span class="operator">*</span>m_window <span class="operator">=</span> nullptr;
     };

     <span class="type">void</span> Renderer<span class="operator">::</span>startNextFrame()
     {
         <span class="keyword">const</span> <span class="type">int</span> count <span class="operator">=</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>concurrentFrameCount();
         <span class="comment">// for (int i = 0; i &lt; count; ++i)</span>
             <span class="comment">// m_uniformBufInfo[i] = ...</span>
         <span class="comment">// ...</span>
     }
</pre>
<p><b>See also </b><a href="qvulkanwindow.html#currentFrame" translate="no">currentFrame</a>().</p>
<!-- @@@concurrentFrameCount -->
<!-- $$$createRenderer[overload1]$$$createRenderer -->
<h3 class="fn" translate="no" id="createRenderer"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="qvulkanwindowrenderer.html" translate="no">QVulkanWindowRenderer</a></span> *QVulkanWindow::<span class="name">createRenderer</span>()</h3>
<p>Returns a new instance of <a href="qvulkanwindowrenderer.html" translate="no">QVulkanWindowRenderer</a>.</p>
<p>This virtual function is called once during the lifetime of the window, at some point after making it visible for the first time.</p>
<p>The default implementation returns null and so no rendering will be performed apart from clearing the buffers.</p>
<p>The window takes ownership of the returned renderer object.</p>
<!-- @@@createRenderer -->
<!-- $$$currentCommandBuffer[overload1]$$$currentCommandBuffer -->
<h3 class="fn" translate="no" id="currentCommandBuffer"><span class="type">VkCommandBuffer</span> QVulkanWindow::<span class="name">currentCommandBuffer</span>() const</h3>
<p>Returns The active command buffer for the current swap chain image. Implementations of <a href="qvulkanwindowrenderer.html#startNextFrame" translate="no">QVulkanWindowRenderer::startNextFrame</a>() are expected to add commands to this command buffer.</p>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>().</p>
</div>
<!-- @@@currentCommandBuffer -->
<!-- $$$currentFrame[overload1]$$$currentFrame -->
<h3 class="fn" translate="no" id="currentFrame"><span class="type">int</span> QVulkanWindow::<span class="name">currentFrame</span>() const</h3>
<p>Returns the current frame index in the range [0, <a href="qvulkanwindow.html#concurrentFrameCount" translate="no">concurrentFrameCount</a>() - 1].</p>
<p>Renderer implementations will have to ensure that uniform data and other dynamic resources exist in multiple copies, in order to prevent frame N altering the data used by the still-active frames N - 1, N - 2, ... N - <a href="qvulkanwindow.html#concurrentFrameCount" translate="no">concurrentFrameCount</a>() + 1.</p>
<p>To avoid relying on dynamic array sizes, applications can use <a href="qvulkanwindow.html#MAX_CONCURRENT_FRAME_COUNT-var" translate="no">MAX_CONCURRENT_FRAME_COUNT</a> when declaring arrays. This is guaranteed to be always equal to or greater than the value returned from <a href="qvulkanwindow.html#concurrentFrameCount" translate="no">concurrentFrameCount</a>(). Such arrays can then be indexed by the value returned from this function.</p>
<pre class="cpp" translate="no">
     <span class="keyword">class</span> Renderer {
         <span class="type">void</span> startNextFrame();
         <span class="comment">// ...</span>

         VkDescriptorBufferInfo m_uniformBufInfo<span class="operator">[</span><span class="type"><a href="qvulkanwindow.html#QVulkanWindow" translate="no">QVulkanWindow</a></span><span class="operator">::</span>MAX_CONCURRENT_FRAME_COUNT<span class="operator">]</span>;
         <span class="type"><a href="qvulkanwindow.html#QVulkanWindow" translate="no">QVulkanWindow</a></span> <span class="operator">*</span>m_window <span class="operator">=</span> nullptr;
     };

     <span class="type">void</span> Renderer<span class="operator">::</span>startNextFrame()
     {
         VkDescriptorBufferInfo <span class="operator">&amp;</span>uniformBufInfo(m_uniformBufInfo<span class="operator">[</span>m_window<span class="operator">-</span><span class="operator">&gt;</span>currentFrame()<span class="operator">]</span>);
         <span class="comment">// ...</span>
     }
</pre>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>().</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#concurrentFrameCount" translate="no">concurrentFrameCount</a>().</p>
<!-- @@@currentFrame -->
<!-- $$$currentFramebuffer[overload1]$$$currentFramebuffer -->
<h3 class="fn" translate="no" id="currentFramebuffer"><span class="type">VkFramebuffer</span> QVulkanWindow::<span class="name">currentFramebuffer</span>() const</h3>
<p>Returns a VkFramebuffer for the current swapchain image using the default render pass.</p>
<p>The framebuffer has two attachments (color, depth-stencil) when multisampling is not in use, and three (color resolve, depth-stencil, multisample color) when <a href="qvulkanwindow.html#sampleCountFlagBits" translate="no">sampleCountFlagBits</a>() is greater than <code translate="no">VK_SAMPLE_COUNT_1_BIT</code>. Renderers must take this into account, for example when providing clear values.</p>
<div class="admonition note">
<p><b>Note: </b>Applications are not required to use this framebuffer in case they provide their own render pass instead of using the one returned from <a href="qvulkanwindow.html#defaultRenderPass" translate="no">defaultRenderPass</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>().</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#defaultRenderPass" translate="no">defaultRenderPass</a>().</p>
<!-- @@@currentFramebuffer -->
<!-- $$$currentSwapChainImageIndex[overload1]$$$currentSwapChainImageIndex -->
<h3 class="fn" translate="no" id="currentSwapChainImageIndex"><span class="type">int</span> QVulkanWindow::<span class="name">currentSwapChainImageIndex</span>() const</h3>
<p>Returns the current swap chain image index in the range [0, <a href="qvulkanwindow.html#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>().</p>
</div>
<!-- @@@currentSwapChainImageIndex -->
<!-- $$$defaultRenderPass[overload1]$$$defaultRenderPass -->
<h3 class="fn" translate="no" id="defaultRenderPass"><span class="type">VkRenderPass</span> QVulkanWindow::<span class="name">defaultRenderPass</span>() const</h3>
<p>Returns a typical render pass with one sub-pass.</p>
<div class="admonition note">
<p><b>Note: </b>Applications are not required to use this render pass. However, they are then responsible for ensuring the current swap chain and depth-stencil images get transitioned from <code translate="no">VK_IMAGE_LAYOUT_UNDEFINED</code> to <code translate="no">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code> and <code translate="no">VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> either via the application's custom render pass or by other means.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Stencil read/write is not enabled in this render pass.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#currentFramebuffer" translate="no">currentFramebuffer</a>().</p>
<!-- @@@defaultRenderPass -->
<!-- $$$depthStencilFormat[overload1]$$$depthStencilFormat -->
<h3 class="fn" translate="no" id="depthStencilFormat"><span class="type">VkFormat</span> QVulkanWindow::<span class="name">depthStencilFormat</span>() const</h3>
<p>Returns the format used by the depth-stencil buffer(s).</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@depthStencilFormat -->
<!-- $$$depthStencilImage[overload1]$$$depthStencilImage -->
<h3 class="fn" translate="no" id="depthStencilImage"><span class="type">VkImage</span> QVulkanWindow::<span class="name">depthStencilImage</span>() const</h3>
<p>Returns the depth-stencil image.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@depthStencilImage -->
<!-- $$$depthStencilImageView[overload1]$$$depthStencilImageView -->
<h3 class="fn" translate="no" id="depthStencilImageView"><span class="type">VkImageView</span> QVulkanWindow::<span class="name">depthStencilImageView</span>() const</h3>
<p>Returns the depth-stencil image view.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@depthStencilImageView -->
<!-- $$$device[overload1]$$$device -->
<h3 class="fn" translate="no" id="device"><span class="type">VkDevice</span> QVulkanWindow::<span class="name">device</span>() const</h3>
<p>Returns the active logical device.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@device -->
<!-- $$$deviceLocalMemoryIndex[overload1]$$$deviceLocalMemoryIndex -->
<h3 class="fn" translate="no" id="deviceLocalMemoryIndex"><span class="type">uint32_t</span> QVulkanWindow::<span class="name">deviceLocalMemoryIndex</span>() const</h3>
<p>Returns a device local memory type index suitable for general use.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>It is not guaranteed that this memory type is always suitable. The correct, cross-implementation solution - especially for device local images - is to manually pick a memory type after checking the mask returned from <code translate="no">vkGetImageMemoryRequirements</code>.</p>
</div>
<!-- @@@deviceLocalMemoryIndex -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><span class="type"><a href="qvulkanwindow.html#Flag-enum" translate="no">QVulkanWindow::Flags</a></span> QVulkanWindow::<span class="name">flags</span>() const</h3>
<p>Return the requested flags.</p>
<p><b>See also </b><a href="qvulkanwindow.html#setFlags" translate="no">setFlags</a>().</p>
<!-- @@@flags -->
<!-- $$$frameGrabbed[overload1]$$$frameGrabbedconstQImage& -->
<h3 class="fn" translate="no" id="frameGrabbed"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QVulkanWindow::<span class="name">frameGrabbed</span>(const <span class="type"><a href="qimage.html" translate="no">QImage</a></span> &amp;<i>image</i>)</h3>
<p>This signal is emitted when the <i translate="no">image</i> is ready.</p>
<!-- @@@frameGrabbed -->
<!-- $$$frameReady[overload1]$$$frameReady -->
<h3 class="fn" translate="no" id="frameReady"><span class="type">void</span> QVulkanWindow::<span class="name">frameReady</span>()</h3>
<p>This function must be called exactly once in response to each invocation of the <a href="qvulkanwindowrenderer.html#startNextFrame" translate="no">QVulkanWindowRenderer::startNextFrame</a>() implementation. At the time of this call, the main command buffer, exposed via <a href="qvulkanwindow.html#currentCommandBuffer" translate="no">currentCommandBuffer</a>(), must have all necessary rendering commands added to it since this function will trigger submitting the commands and queuing the present command.</p>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from the gui/main thread, which is where <a href="qvulkanwindowrenderer.html" translate="no">QVulkanWindowRenderer</a>'s functions are invoked and where the <a href="qvulkanwindow.html" translate="no">QVulkanWindow</a> instance lives.</p>
</div>
<p><b>See also </b><a href="qvulkanwindowrenderer.html#startNextFrame" translate="no">QVulkanWindowRenderer::startNextFrame</a>().</p>
<!-- @@@frameReady -->
<!-- $$$grab[overload1]$$$grab -->
<h3 class="fn" translate="no" id="grab"><span class="type"><a href="qimage.html" translate="no">QImage</a></span> QVulkanWindow::<span class="name">grab</span>()</h3>
<p>Builds and renders the next frame without presenting it, then performs a blocking readback of the image content.</p>
<p>Returns the image if the renderer's <a href="qvulkanwindowrenderer.html#startNextFrame" translate="no">startNextFrame</a>() implementation calls back <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>() directly. Otherwise, returns an incomplete image, that has the correct size but not the content yet. The content will be delivered via the <a href="qvulkanwindow.html#frameGrabbed" translate="no">frameGrabbed</a>() signal in the latter case.</p>
<p>The returned <a href="qimage.html" translate="no">QImage</a> always has a format of <a href="qimage.html#Format-enum" translate="no">QImage::Format_RGBA8888</a>. If the <a href="qvulkanwindow.html#colorFormat" translate="no">colorFormat</a>() is <code translate="no">VK_FORMAT_B8G8R8A8_UNORM</code>, the red and blue channels are swapped automatically since this format is commonly used as the default choice for swapchain color buffers. With any other color buffer format, there is no conversion performed by this function.</p>
<div class="admonition note">
<p><b>Note: </b>This function should not be called when a frame is in progress (that is, <a href="qvulkanwindow.html#frameReady" translate="no">frameReady</a>() has not yet been called back by the application).</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function is potentially expensive due to the additional, blocking readback.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function currently requires that the swapchain supports usage as a transfer source (<code translate="no">VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code>), and will fail otherwise.</p>
</div>
<!-- @@@grab -->
<!-- $$$graphicsCommandPool[overload1]$$$graphicsCommandPool -->
<h3 class="fn" translate="no" id="graphicsCommandPool"><span class="type">VkCommandPool</span> QVulkanWindow::<span class="name">graphicsCommandPool</span>() const</h3>
<p>Returns the active graphics command pool.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@graphicsCommandPool -->
<!-- $$$graphicsQueue[overload1]$$$graphicsQueue -->
<h3 class="fn" translate="no" id="graphicsQueue"><span class="type">VkQueue</span> QVulkanWindow::<span class="name">graphicsQueue</span>() const</h3>
<p>Returns the active graphics queue.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@graphicsQueue -->
<!-- $$$graphicsQueueFamilyIndex[overload1]$$$graphicsQueueFamilyIndex -->
<h3 class="fn" translate="no" id="graphicsQueueFamilyIndex"><span class="type">uint32_t</span> QVulkanWindow::<span class="name">graphicsQueueFamilyIndex</span>() const</h3>
<p>Returns the family index of the active graphics queue.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>(). Implementations of QVulkanWindowRenderer::updateQueueCreateInfo() can also call this function.</p>
</div>
<!-- @@@graphicsQueueFamilyIndex -->
<!-- $$$hostVisibleMemoryIndex[overload1]$$$hostVisibleMemoryIndex -->
<h3 class="fn" translate="no" id="hostVisibleMemoryIndex"><span class="type">uint32_t</span> QVulkanWindow::<span class="name">hostVisibleMemoryIndex</span>() const</h3>
<p>Returns a host visible memory type index suitable for general use.</p>
<p>The returned memory type will be both host visible and coherent. In addition, it will also be cached, if possible.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@hostVisibleMemoryIndex -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QVulkanWindow::<span class="name">isValid</span>() const</h3>
<p>Returns true if this window has successfully initialized all Vulkan resources, including the swapchain.</p>
<div class="admonition note">
<p><b>Note: </b>Initialization happens on the first expose event after the window is made visible.</p>
</div>
<!-- @@@isValid -->
<!-- $$$msaaColorImage[overload1]$$$msaaColorImageint -->
<h3 class="fn" translate="no" id="msaaColorImage"><span class="type">VkImage</span> QVulkanWindow::<span class="name">msaaColorImage</span>(<span class="type">int</span> <i>idx</i>) const</h3>
<p>Returns the specified multisample color image, or <code translate="no">VK_NULL_HANDLE</code> if multisampling is not in use.</p>
<p><i translate="no">idx</i> must be in the range [0, <a href="qvulkanwindow.html#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@msaaColorImage -->
<!-- $$$msaaColorImageView[overload1]$$$msaaColorImageViewint -->
<h3 class="fn" translate="no" id="msaaColorImageView"><span class="type">VkImageView</span> QVulkanWindow::<span class="name">msaaColorImageView</span>(<span class="type">int</span> <i>idx</i>) const</h3>
<p>Returns the specified multisample color image view, or <code translate="no">VK_NULL_HANDLE</code> if multisampling is not in use.</p>
<p><i translate="no">idx</i> must be in the range [0, <a href="qvulkanwindow.html#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@msaaColorImageView -->
<!-- $$$physicalDevice[overload1]$$$physicalDevice -->
<h3 class="fn" translate="no" id="physicalDevice"><span class="type">VkPhysicalDevice</span> QVulkanWindow::<span class="name">physicalDevice</span>() const</h3>
<p>Returns the active physical device.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@physicalDevice -->
<!-- $$$physicalDeviceProperties[overload1]$$$physicalDeviceProperties -->
<h3 class="fn" translate="no" id="physicalDeviceProperties">const <span class="type">VkPhysicalDeviceProperties</span> *QVulkanWindow::<span class="name">physicalDeviceProperties</span>() const</h3>
<p>Returns a pointer to the properties for the active physical device.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@physicalDeviceProperties -->
<!-- $$$sampleCountFlagBits[overload1]$$$sampleCountFlagBits -->
<h3 class="fn" translate="no" id="sampleCountFlagBits"><span class="type">VkSampleCountFlagBits</span> QVulkanWindow::<span class="name">sampleCountFlagBits</span>() const</h3>
<p>Returns the current sample count as a <code translate="no">VkSampleCountFlagBits</code> value.</p>
<p>When targeting the default render target, the <code translate="no">rasterizationSamples</code> field of <code translate="no">VkPipelineMultisampleStateCreateInfo</code> must be set to this value.</p>
<p><b>See also </b><a href="qvulkanwindow.html#setSampleCount" translate="no">setSampleCount</a>() and <a href="qvulkanwindow.html#supportedSampleCounts" translate="no">supportedSampleCounts</a>().</p>
<!-- @@@sampleCountFlagBits -->
<!-- $$$setDeviceExtensions[overload1]$$$setDeviceExtensionsconstQByteArrayList& -->
<h3 class="fn" translate="no" id="setDeviceExtensions"><span class="type">void</span> QVulkanWindow::<span class="name">setDeviceExtensions</span>(const <span class="type"><a href="../qtcore/qbytearraylist.html" translate="no">QByteArrayList</a></span> &amp;<i>extensions</i>)</h3>
<p>Sets the list of device <i translate="no">extensions</i> to be enabled.</p>
<p>Unsupported extensions are ignored.</p>
<p>The swapchain extension will always be added automatically, no need to include it in this list.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer.html#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<!-- @@@setDeviceExtensions -->
<!-- $$$setEnabledFeaturesModifier[overload1]$$$setEnabledFeaturesModifierconstQVulkanWindow::EnabledFeaturesModifier& -->
<h3 class="fn" translate="no" id="setEnabledFeaturesModifier"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">void</span> QVulkanWindow::<span class="name">setEnabledFeaturesModifier</span>(const <span class="type"><a href="qvulkanwindow.html#EnabledFeaturesModifier-typedef" translate="no">QVulkanWindow::EnabledFeaturesModifier</a></span> &amp;<i>modifier</i>)</h3>
<p>Sets the enabled device features modification function <i translate="no">modifier</i>.</p>
<div class="admonition note">
<p><b>Note: </b>To control Vulkan 1.1, 1.2, or 1.3 features, use the overload taking a <a href="qvulkanwindow.html#EnabledFeatures2Modifier-typedef" translate="no">EnabledFeatures2Modifier</a> instead.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">modifier</i> is passed to the callback function with all members set to false. It is up to the function to change members as it sees fit.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qvulkanwindow.html#EnabledFeaturesModifier-typedef" translate="no">EnabledFeaturesModifier</a>.</p>
<!-- @@@setEnabledFeaturesModifier -->
<!-- $$$setEnabledFeaturesModifier$$$setEnabledFeaturesModifierQVulkanWindow::EnabledFeatures2Modifier -->
<h3 class="fn" translate="no" id="setEnabledFeaturesModifier-1"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">void</span> QVulkanWindow::<span class="name">setEnabledFeaturesModifier</span>(<span class="type"><a href="qvulkanwindow.html#EnabledFeatures2Modifier-typedef" translate="no">QVulkanWindow::EnabledFeatures2Modifier</a></span> <i>modifier</i>)</h3>
<p>Sets the enabled device features modification function <i translate="no">modifier</i>.</p>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qvulkanwindow.html#EnabledFeatures2Modifier-typedef" translate="no">EnabledFeatures2Modifier</a>.</p>
<!-- @@@setEnabledFeaturesModifier -->
<!-- $$$setFlags[overload1]$$$setFlagsQVulkanWindow::Flags -->
<h3 class="fn" translate="no" id="setFlags"><span class="type">void</span> QVulkanWindow::<span class="name">setFlags</span>(<span class="type"><a href="qvulkanwindow.html#Flag-enum" translate="no">QVulkanWindow::Flags</a></span> <i>flags</i>)</h3>
<p>Configures the behavior based on the provided <i translate="no">flags</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer.html#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#flags" translate="no">flags</a>().</p>
<!-- @@@setFlags -->
<!-- $$$setPhysicalDeviceIndex[overload1]$$$setPhysicalDeviceIndexint -->
<h3 class="fn" translate="no" id="setPhysicalDeviceIndex"><span class="type">void</span> QVulkanWindow::<span class="name">setPhysicalDeviceIndex</span>(<span class="type">int</span> <i>idx</i>)</h3>
<p>Requests the usage of the physical device with index <i translate="no">idx</i>. The index corresponds to the list returned from <a href="qvulkanwindow.html#availablePhysicalDevices" translate="no">availablePhysicalDevices</a>().</p>
<p>By default the first physical device is used.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer.html#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<!-- @@@setPhysicalDeviceIndex -->
<!-- $$$setPreferredColorFormats[overload1]$$$setPreferredColorFormatsconstQList<VkFormat>& -->
<h3 class="fn" translate="no" id="setPreferredColorFormats"><span class="type">void</span> QVulkanWindow::<span class="name">setPreferredColorFormats</span>(const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type">VkFormat</span>&gt; &amp;<i>formats</i>)</h3>
<p>Sets the preferred <i translate="no">formats</i> of the swapchain.</p>
<p>By default no application-preferred format is set. In this case the surface's preferred format will be used or, in absence of that, <code translate="no">VK_FORMAT_B8G8R8A8_UNORM</code>.</p>
<p>The list in <i translate="no">formats</i> is ordered. If the first format is not supported, the second will be considered, and so on. When no formats in the list are supported, the behavior is the same as in the default case.</p>
<p>To query the actual format after initialization, call <a href="qvulkanwindow.html#colorFormat" translate="no">colorFormat</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer.html#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Reimplementing <a href="qvulkanwindowrenderer.html#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>() allows dynamically examining the list of supported formats, should that be desired. There the surface is retrievable via QVulkanInstace::surfaceForWindow(), while this function can still safely be called to affect the later stages of initialization.</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#colorFormat" translate="no">colorFormat</a>().</p>
<!-- @@@setPreferredColorFormats -->
<!-- $$$setQueueCreateInfoModifier[overload1]$$$setQueueCreateInfoModifierconstQVulkanWindow::QueueCreateInfoModifier& -->
<h3 class="fn" translate="no" id="setQueueCreateInfoModifier"><span class="type">void</span> QVulkanWindow::<span class="name">setQueueCreateInfoModifier</span>(const <span class="type"><a href="qvulkanwindow.html#QueueCreateInfoModifier-typedef" translate="no">QVulkanWindow::QueueCreateInfoModifier</a></span> &amp;<i>modifier</i>)</h3>
<p>Sets the queue create info modification function <i translate="no">modifier</i>.</p>
<p><b>See also </b><a href="qvulkanwindow.html#QueueCreateInfoModifier-typedef" translate="no">QueueCreateInfoModifier</a>.</p>
<!-- @@@setQueueCreateInfoModifier -->
<!-- $$$setSampleCount[overload1]$$$setSampleCountint -->
<h3 class="fn" translate="no" id="setSampleCount"><span class="type">void</span> QVulkanWindow::<span class="name">setSampleCount</span>(<span class="type">int</span> <i>sampleCount</i>)</h3>
<p>Requests multisample antialiasing with the given <i translate="no">sampleCount</i>. The valid values are 1, 2, 4, 8, ... up until the maximum value supported by the physical device.</p>
<p>When the sample count is greater than 1, <a href="qvulkanwindow.html" translate="no">QVulkanWindow</a> will create a multisample color buffer instead of simply targeting the swapchain's images. The rendering in the multisample buffer will get resolved into the non-multisample buffers at the end of each frame.</p>
<p>To examine the list of supported sample counts, call <a href="qvulkanwindow.html#supportedSampleCounts" translate="no">supportedSampleCounts</a>().</p>
<p>When setting up the rendering pipeline, call <a href="qvulkanwindow.html#sampleCountFlagBits" translate="no">sampleCountFlagBits</a>() to query the active sample count as a <code translate="no">VkSampleCountFlagBits</code> value.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer.html#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#supportedSampleCounts" translate="no">supportedSampleCounts</a>() and <a href="qvulkanwindow.html#sampleCountFlagBits" translate="no">sampleCountFlagBits</a>().</p>
<!-- @@@setSampleCount -->
<!-- $$$supportedDeviceExtensions[overload1]$$$supportedDeviceExtensions -->
<h3 class="fn" translate="no" id="supportedDeviceExtensions"><span class="type"><a href="qvulkaninfovector.html" translate="no">QVulkanInfoVector</a></span>&lt;<span class="type"><a href="qvulkanextension.html" translate="no">QVulkanExtension</a></span>&gt; QVulkanWindow::<span class="name">supportedDeviceExtensions</span>()</h3>
<p>Returns the list of the extensions that are supported by logical devices created from the physical device selected by <a href="qvulkanwindow.html#setPhysicalDeviceIndex" translate="no">setPhysicalDeviceIndex</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called before making the window visible.</p>
</div>
<!-- @@@supportedDeviceExtensions -->
<!-- $$$supportedSampleCounts[overload1]$$$supportedSampleCounts -->
<h3 class="fn" translate="no" id="supportedSampleCounts"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type">int</span>&gt; QVulkanWindow::<span class="name">supportedSampleCounts</span>()</h3>
<p>Returns the set of supported sample counts when using the physical device selected by <a href="qvulkanwindow.html#setPhysicalDeviceIndex" translate="no">setPhysicalDeviceIndex</a>(), as a sorted list.</p>
<p>By default <a href="qvulkanwindow.html" translate="no">QVulkanWindow</a> uses a sample count of 1. By calling <a href="qvulkanwindow.html#setSampleCount" translate="no">setSampleCount</a>() with a different value (2, 4, 8, ...) from the set returned by this function, multisample anti-aliasing can be requested.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called before making the window visible.</p>
</div>
<p><b>See also </b><a href="qvulkanwindow.html#setSampleCount" translate="no">setSampleCount</a>().</p>
<!-- @@@supportedSampleCounts -->
<!-- $$$supportsGrab[overload1]$$$supportsGrab -->
<h3 class="fn" translate="no" id="supportsGrab"><span class="type">bool</span> QVulkanWindow::<span class="name">supportsGrab</span>() const</h3>
<p>Returns true if the swapchain supports usage as transfer source, meaning <a href="qvulkanwindow.html#grab" translate="no">grab</a>() is functional.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@supportsGrab -->
<!-- $$$swapChainImage[overload1]$$$swapChainImageint -->
<h3 class="fn" translate="no" id="swapChainImage"><span class="type">VkImage</span> QVulkanWindow::<span class="name">swapChainImage</span>(<span class="type">int</span> <i>idx</i>) const</h3>
<p>Returns the specified swap chain image.</p>
<p><i translate="no">idx</i> must be in the range [0, <a href="qvulkanwindow.html#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@swapChainImage -->
<!-- $$$swapChainImageCount[overload1]$$$swapChainImageCount -->
<h3 class="fn" translate="no" id="swapChainImageCount"><span class="type">int</span> QVulkanWindow::<span class="name">swapChainImageCount</span>() const</h3>
<p>Returns the number of images in the swap chain.</p>
<div class="admonition note">
<p><b>Note: </b>Accessing this is necessary when providing a custom render pass and framebuffer. The framebuffer is specific to the current swapchain image and hence the application must provide multiple framebuffers.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@swapChainImageCount -->
<!-- $$$swapChainImageSize[overload1]$$$swapChainImageSize -->
<h3 class="fn" translate="no" id="swapChainImageSize"><span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QVulkanWindow::<span class="name">swapChainImageSize</span>() const</h3>
<p>Returns the image size of the swapchain.</p>
<p>This usually matches the size of the window, but may also differ in case <code translate="no">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code> reports a fixed size.</p>
<p>In addition, it has been observed on some platforms that the Vulkan-reported surface size is different with high DPI scaling active, meaning the <a href="qwindow.html" translate="no">QWindow</a>-reported <a href="qwindow.html#size" translate="no">size</a>() multiplied with the <a href="qwindow.html#devicePixelRatio" translate="no">devicePixelRatio</a>() was 1 pixel less or more when compared to the value returned from here, presumably due to differences in rounding. Rendering code should be aware of this, and any related rendering logic must be based in the value returned from here, never on the <a href="qwindow.html" translate="no">QWindow</a>-reported size. Regardless of which pixel size is correct in theory, Vulkan rendering must only ever rely on the Vulkan API-reported surface size. Otherwise validation errors may occur, e.g. when setting the viewport, because the application-provided values may become out-of-bounds from Vulkan's perspective.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@swapChainImageSize -->
<!-- $$$swapChainImageView[overload1]$$$swapChainImageViewint -->
<h3 class="fn" translate="no" id="swapChainImageView"><span class="type">VkImageView</span> QVulkanWindow::<span class="name">swapChainImageView</span>(<span class="type">int</span> <i>idx</i>) const</h3>
<p>Returns the specified swap chain image view.</p>
<p><i translate="no">idx</i> must be in the range [0, <a href="qvulkanwindow.html#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer.html#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer.html#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@swapChainImageView -->
</div>
<div class="vars">
<h2>Member Variable Documentation</h2>
<!-- $$$MAX_CONCURRENT_FRAME_COUNT -->
<h3 class="fn" translate="no" id="MAX_CONCURRENT_FRAME_COUNT-var">const <span class="type">int</span> QVulkanWindow::<span class="name">MAX_CONCURRENT_FRAME_COUNT</span></h3>
<p>This variable holds a constant value that is always equal to or greater than the maximum value of <a href="qvulkanwindow.html#concurrentFrameCount" translate="no">concurrentFrameCount</a>().</p>
<!-- @@@MAX_CONCURRENT_FRAME_COUNT -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
