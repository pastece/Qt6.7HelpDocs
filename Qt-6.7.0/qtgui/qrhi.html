<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Accelerated 2D/3D graphics API abstraction.">
  <title>QRhi Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhi</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#an-impression-of-the-api">An Impression of the API</a></li>
<li class="level2"><a href="#design-fundamentals">Design Fundamentals</a></li>
<li class="level2"><a href="#troubleshooting-and-profiling">Troubleshooting and Profiling</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhi Class</h1>
<!-- $$$QRhi-brief -->
<p>Accelerated 2D/3D graphics API abstraction. <a href="#details">More...</a></p>
<!-- @@@QRhi -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhi&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
</table></div>
<ul>
<li><a href="qrhi-members.html">List of all members, including inherited members</a></li>
<li>QRhi is part of <a href="painting-3d.html">Rendering in 3D</a>.</li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#BeginFrameFlag-enum" translate="no">BeginFrameFlag</a></b> { }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#BeginFrameFlag-enum" translate="no">BeginFrameFlags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#EndFrameFlag-enum" translate="no">EndFrameFlag</a></b> { SkipPresent }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#EndFrameFlag-enum" translate="no">EndFrameFlags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#Feature-enum" translate="no">Feature</a></b> { MultisampleTexture, MultisampleRenderBuffer, DebugMarkers, Timestamps, Instancing, &hellip;, MultiView }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#Flag-enum" translate="no">Flag</a></b> { EnableDebugMarkers, EnableTimestamps, PreferSoftwareRenderer, EnablePipelineCacheDataSave, SuppressSmokeTestWarnings }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#Flag-enum" translate="no">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#FrameOpResult-enum" translate="no">FrameOpResult</a></b> { FrameOpSuccess, FrameOpError, FrameOpSwapChainOutOfDate, FrameOpDeviceLost }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#Implementation-enum" translate="no">Implementation</a></b> { Null, Vulkan, OpenGLES2, D3D11, D3D12, Metal }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#ResourceLimit-enum" translate="no">ResourceLimit</a></b> { TextureSizeMin, TextureSizeMax, MaxColorAttachments, FramesInFlight, MaxAsyncReadbackFrames, &hellip;, MaxVertexOutputs }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#dtor.QRhi" translate="no">~QRhi</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#addCleanupCallback" translate="no">addCleanupCallback</a></b>(const QRhi::CleanupCallback &amp;<i>callback</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#addCleanupCallback-1" translate="no">addCleanupCallback</a></b>(const void *<i>key</i>, const QRhi::CleanupCallback &amp;<i>callback</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhi::Implementation </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#backend" translate="no">backend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#backendName" translate="no">backendName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhi::FrameOpResult </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#beginFrame" translate="no">beginFrame</a></b>(QRhiSwapChain *<i>swapChain</i>, QRhi::BeginFrameFlags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhi::FrameOpResult </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#beginOffscreenFrame" translate="no">beginOffscreenFrame</a></b>(QRhiCommandBuffer **<i>cb</i>, QRhi::BeginFrameFlags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMatrix4x4 </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#clipSpaceCorrMatrix" translate="no">clipSpaceCorrMatrix</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#currentFrameSlot" translate="no">currentFrameSlot</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiDriverInfo </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#driverInfo" translate="no">driverInfo</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhi::FrameOpResult </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#endFrame" translate="no">endFrame</a></b>(QRhiSwapChain *<i>swapChain</i>, QRhi::EndFrameFlags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhi::FrameOpResult </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#endOffscreenFrame" translate="no">endOffscreenFrame</a></b>(QRhi::EndFrameFlags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhi::FrameOpResult </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#finish" translate="no">finish</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#isClipDepthZeroToOne" translate="no">isClipDepthZeroToOne</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#isDeviceLost" translate="no">isDeviceLost</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#isFeatureSupported" translate="no">isFeatureSupported</a></b>(QRhi::Feature <i>feature</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#isRecordingFrame" translate="no">isRecordingFrame</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#isTextureFormatSupported" translate="no">isTextureFormatSupported</a></b>(QRhiTexture::Format <i>format</i>, QRhiTexture::Flags <i>flags</i> = {}) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#isYUpInFramebuffer" translate="no">isYUpInFramebuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#isYUpInNDC" translate="no">isYUpInNDC</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#makeThreadLocalNativeContextCurrent" translate="no">makeThreadLocalNativeContextCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiNativeHandles *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#nativeHandles" translate="no">nativeHandles</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newBuffer" translate="no">newBuffer</a></b>(QRhiBuffer::Type <i>type</i>, QRhiBuffer::UsageFlags <i>usage</i>, quint32 <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiComputePipeline *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newComputePipeline" translate="no">newComputePipeline</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiGraphicsPipeline *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newGraphicsPipeline" translate="no">newGraphicsPipeline</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newRenderBuffer" translate="no">newRenderBuffer</a></b>(QRhiRenderBuffer::Type <i>type</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1, QRhiRenderBuffer::Flags <i>flags</i> = {}, QRhiTexture::Format <i>backingFormatHint</i> = QRhiTexture::UnknownFormat)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiSampler *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newSampler" translate="no">newSampler</a></b>(QRhiSampler::Filter <i>magFilter</i>, QRhiSampler::Filter <i>minFilter</i>, QRhiSampler::Filter <i>mipmapMode</i>, QRhiSampler::AddressMode <i>addressU</i>, QRhiSampler::AddressMode <i>addressV</i>, QRhiSampler::AddressMode <i>addressW</i> = QRhiSampler::Repeat)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBindings *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newShaderResourceBindings" translate="no">newShaderResourceBindings</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiSwapChain *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newSwapChain" translate="no">newSwapChain</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newTexture" translate="no">newTexture</a></b>(QRhiTexture::Format <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1, QRhiTexture::Flags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newTexture-1" translate="no">newTexture</a></b>(QRhiTexture::Format <i>format</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>sampleCount</i> = 1, QRhiTexture::Flags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newTextureArray" translate="no">newTextureArray</a></b>(QRhiTexture::Format <i>format</i>, int <i>arraySize</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1, QRhiTexture::Flags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTextureRenderTarget *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#newTextureRenderTarget" translate="no">newTextureRenderTarget</a></b>(const QRhiTextureRenderTargetDescription &amp;<i>desc</i>, QRhiTextureRenderTarget::Flags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiResourceUpdateBatch *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#nextResourceUpdateBatch" translate="no">nextResourceUpdateBatch</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#pipelineCacheData" translate="no">pipelineCacheData</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#releaseCachedResources" translate="no">releaseCachedResources</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#removeCleanupCallback" translate="no">removeCleanupCallback</a></b>(const void *<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#resourceLimit" translate="no">resourceLimit</a></b>(QRhi::ResourceLimit <i>limit</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#runCleanup" translate="no">runCleanup</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#setPipelineCacheData" translate="no">setPipelineCacheData</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiStats </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#statistics" translate="no">statistics</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;int&gt; </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#supportedSampleCounts" translate="no">supportedSampleCounts</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QThread *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#thread" translate="no">thread</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#ubufAligned" translate="no">ubufAligned</a></b>(int <i>v</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#ubufAlignment" translate="no">ubufAlignment</a></b>() const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#backendName-1" translate="no">backendName</a></b>(QRhi::Implementation <i>impl</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhi *</td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#create" translate="no">create</a></b>(QRhi::Implementation <i>impl</i>, QRhiInitParams *<i>params</i>, QRhi::Flags <i>flags</i> = {}, QRhiNativeHandles *<i>importDevice</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#mipLevelsForSize" translate="no">mipLevelsForSize</a></b>(const QSize &amp;<i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#probe" translate="no">probe</a></b>(QRhi::Implementation <i>impl</i>, QRhiInitParams *<i>params</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#sizeForMipLevel" translate="no">sizeForMipLevel</a></b>(int <i>mipLevel</i>, const QSize &amp;<i>baseLevelSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiSwapChainProxyData </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#updateSwapChainProxyData" translate="no">updateSwapChainProxyData</a></b>(QRhi::Implementation <i>impl</i>, QWindow *<i>window</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> </td><td class="memItemRight bottomAlign"><b><a href="qrhi.html#QRhiShaderResourceBindingSet-typedef" translate="no">QRhiShaderResourceBindingSet</a></b></td></tr>
</table></div>
<!-- $$$QRhi-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The Qt Rendering Hardware Interface is an abstraction for hardware accelerated graphics APIs, such as, <a href="https://www.khronos.org/opengl/" translate="no">OpenGL</a>, <a href="https://www.khronos.org/opengles/" translate="no">OpenGL ES</a>, <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d" translate="no">Direct3D</a>, <a href="https://developer.apple.com/metal/" translate="no">Metal</a>, and <a href="https://www.khronos.org/vulkan/" translate="no">Vulkan</a>.</p>
<div class="admonition warning">
<p><b>Warning: </b>The QRhi family of classes in the Qt Gui module, including <a href="qshader.html" translate="no">QShader</a> and <a href="qshaderdescription.html" translate="no">QShaderDescription</a>, offer limited compatibility guarantees. There are no source or binary compatibility guarantees for these classes, meaning the API is only guaranteed to work with the Qt version the application was developed against. Source incompatible changes are however aimed to be kept at a minimum and will only be made in minor releases (6.7, 6.8, and so on). To use these classes in an application, link to <code translate="no">Qt::GuiPrivate</code> (if using CMake), and include the headers with the <code translate="no">rhi</code> prefix, for example <code translate="no">#include &lt;rhi/qrhi.h&gt;</code>.</p>
</div>
<p>Each QRhi instance is backed by a backend for a specific graphics API. The selection of the backend is a run time choice and is up to the application or library that creates the QRhi instance. Some backends are available on multiple platforms (OpenGL, Vulkan, Null), while APIs specific to a given platform are only available when running on the platform in question (Metal on macOS/iOS, Direct3D on Windows).</p>
<p>The available backends currently are:</p>
<ul>
<li>OpenGL 2.1 / OpenGL ES 2.0 or newer. Some extensions and newer core specification features are utilized when present, for example to enable multisample framebuffers or compute shaders. Operating in core profile contexts is supported as well. If necessary, applications can query the <a href="qrhi.html#Feature-enum" translate="no">feature flags</a> at runtime to check for features that are not supported in the OpenGL context backing the QRhi. The OpenGL backend builds on <a href="qopenglcontext.html" translate="no">QOpenGLContext</a>, <a href="qopenglfunctions.html" translate="no">QOpenGLFunctions</a>, and the related cross-platform infrastructure of the Qt GUI module.</li>
<li>Direct3D 11.1 or newer, with Shader Model 5.0 or newer. When the D3D runtime has no support for 11.1 features or Shader Model 5.0, initialization using an accelerated graphics device will fail, but using the <a href="https://learn.microsoft.com/en-us/windows/win32/direct3darticles/directx-warp" translate="no">software adapter</a> is still an option.</li>
<li>Direct3D 12 on Windows 10 version 1703 and newer, with Shader Model 5.0 or newer. Qt requires ID3D12Device2 to be present, hence the requirement for at least version 1703 of Windows 10. The D3D12 device is by default created with specifying a minimum feature level of <code translate="no">D3D_FEATURE_LEVEL_11_0</code>.</li>
<li>Metal 1.2 or newer.</li>
<li>Vulkan 1.0 or newer, optionally utilizing some Vulkan 1.1 level features.</li>
<li>Null, a &quot;dummy&quot; backend that issues no graphics calls at all.</li>
</ul>
<p>In order to allow shader code to be written once in Qt applications and libraries, all shaders are expected to be written in a single language which is then compiled into SPIR-V. Versions for various shading language are then generated from that, together with reflection information (inputs, outputs, shader resources). This is then packed into easily and efficiently serializable <a href="qshader.html" translate="no">QShader</a> instances. The compilers and tools to generate such shaders are not part of QRhi and the Qt GUI module, but the core classes for using such shaders, <a href="qshader.html" translate="no">QShader</a> and <a href="qshaderdescription.html" translate="no">QShaderDescription</a>, are. The APIs and tools for performing compilation and translation are part of the Qt Shader Tools module.</p>
<p>See the <a href="qtgui-rhiwindow-example.html" translate="no">RHI Window Example</a> for an introductory example of creating a portable, cross-platform application that performs accelerated 3D rendering onto a <a href="qwindow.html" translate="no">QWindow</a> using QRhi.</p>
<h3 id="an-impression-of-the-api">An Impression of the API</h3>
<p>To provide a quick look at the API with a short yet complete example that does not involve window-related setup, the following is a complete, runnable cross-platform application that renders 20 frames off-screen, and then saves the generated images to files after reading back the texture contents from the GPU. For an example that renders on-screen, which then involves setting up a <a href="qwindow.html" translate="no">QWindow</a> and a swapchain, refer to the <a href="qtgui-rhiwindow-example.html" translate="no">RHI Window Example</a>.</p>
<p>For brevity, the initialization of the QRhi is done based on the platform: the sample code here chooses Direct 3D 12 on Windows, Metal on macOS and iOS, and Vulkan otherwise. OpenGL and Direct 3D 11 are never used by this application, but support for those could be introduced with a few additional lines.</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;QGuiApplication&gt;</span>
 <span class="preprocessor">#include &lt;QImage&gt;</span>
 <span class="preprocessor">#include &lt;QFile&gt;</span>
 <span class="preprocessor">#include &lt;rhi/qrhi.h&gt;</span>

 <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span><span class="operator">*</span>argv)
 {
     <span class="type"><a href="qguiapplication.html" translate="no">QGuiApplication</a></span> app(argc<span class="operator">,</span> argv);

 <span class="preprocessor">#if QT_CONFIG(vulkan)</span>
     <span class="type"><a href="qvulkaninstance.html" translate="no">QVulkanInstance</a></span> inst;
 <span class="preprocessor">#endif</span>
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type">QRhi</span><span class="operator">&gt;</span> rhi;
 <span class="preprocessor">#if defined(Q_OS_WIN)</span>
     QRhiD3D12InitParams params;
     rhi<span class="operator">.</span>reset(<span class="type">QRhi</span><span class="operator">::</span>create(<span class="type">QRhi</span><span class="operator">::</span>D3D12<span class="operator">,</span> <span class="operator">&amp;</span>params));
 <span class="preprocessor">#elif defined(Q_OS_MACOS) || defined(Q_OS_IOS)</span>
     <span class="type"><a href="qrhimetalinitparams.html" translate="no">QRhiMetalInitParams</a></span> params;
     rhi<span class="operator">.</span>reset(<span class="type">QRhi</span><span class="operator">::</span>create(<span class="type">QRhi</span><span class="operator">::</span>Metal<span class="operator">,</span> <span class="operator">&amp;</span>params));
 <span class="preprocessor">#elif QT_CONFIG(vulkan)</span>
     inst<span class="operator">.</span>setExtensions(<span class="type"><a href="qrhivulkaninitparams.html" translate="no">QRhiVulkanInitParams</a></span><span class="operator">::</span>preferredInstanceExtensions());
     <span class="keyword">if</span> (inst<span class="operator">.</span>create()) {
         <span class="type"><a href="qrhivulkaninitparams.html" translate="no">QRhiVulkanInitParams</a></span> params;
         params<span class="operator">.</span>inst <span class="operator">=</span> <span class="operator">&amp;</span>inst;
         rhi<span class="operator">.</span>reset(<span class="type">QRhi</span><span class="operator">::</span>create(<span class="type">QRhi</span><span class="operator">::</span>Vulkan<span class="operator">,</span> <span class="operator">&amp;</span>params));
     } <span class="keyword">else</span> {
         <a href="../qtcore/qtlogging.html#qFatal" translate="no">qFatal</a>(<span class="string">&quot;Failed to create Vulkan instance&quot;</span>);
     }
 <span class="preprocessor">#endif</span>
     <span class="keyword">if</span> (rhi)
         <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>backendName() <span class="operator">&lt;</span><span class="operator">&lt;</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>driverInfo();
     <span class="keyword">else</span>
         <a href="../qtcore/qtlogging.html#qFatal" translate="no">qFatal</a>(<span class="string">&quot;Failed to initialize RHI&quot;</span>);

     <span class="type">float</span> rotation <span class="operator">=</span> <span class="number">0.0f</span>;
     <span class="type">float</span> opacity <span class="operator">=</span> <span class="number">1.0f</span>;
     <span class="type">int</span> opacityDir <span class="operator">=</span> <span class="number">1</span>;

     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span><span class="operator">&gt;</span> tex(rhi<span class="operator">-</span><span class="operator">&gt;</span>newTexture(<span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span><span class="operator">::</span>RGBA8<span class="operator">,</span>
                                                      <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span>(<span class="number">1280</span><span class="operator">,</span> <span class="number">720</span>)<span class="operator">,</span>
                                                      <span class="number">1</span><span class="operator">,</span>
                                                      <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span><span class="operator">::</span>RenderTarget <span class="operator">|</span> <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span><span class="operator">::</span>UsedAsTransferSource));
     tex<span class="operator">-</span><span class="operator">&gt;</span>create();
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a></span><span class="operator">&gt;</span> rt(rhi<span class="operator">-</span><span class="operator">&gt;</span>newTextureRenderTarget({ tex<span class="operator">.</span>get() }));
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a></span><span class="operator">&gt;</span> rp(rt<span class="operator">-</span><span class="operator">&gt;</span>newCompatibleRenderPassDescriptor());
     rt<span class="operator">-</span><span class="operator">&gt;</span>setRenderPassDescriptor(rp<span class="operator">.</span>get());
     rt<span class="operator">-</span><span class="operator">&gt;</span>create();

     QMatrix4x4 viewProjection <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>clipSpaceCorrMatrix();
     viewProjection<span class="operator">.</span>perspective(<span class="number">45.0f</span><span class="operator">,</span> <span class="number">1280</span> <span class="operator">/</span> <span class="number">720.f</span><span class="operator">,</span> <span class="number">0.01f</span><span class="operator">,</span> <span class="number">1000.0f</span>);
     viewProjection<span class="operator">.</span>translate(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">4</span>);

     <span class="keyword">static</span> <span class="type">float</span> vertexData<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> { <span class="comment">// Y up, CCW</span>
         <span class="number">0.0f</span><span class="operator">,</span>   <span class="number">0.5f</span><span class="operator">,</span>     <span class="number">1.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span>
         <span class="operator">-</span><span class="number">0.5f</span><span class="operator">,</span> <span class="operator">-</span><span class="number">0.5f</span><span class="operator">,</span>     <span class="number">0.0f</span><span class="operator">,</span> <span class="number">1.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span>
         <span class="number">0.5f</span><span class="operator">,</span>  <span class="operator">-</span><span class="number">0.5f</span><span class="operator">,</span>     <span class="number">0.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span> <span class="number">1.0f</span><span class="operator">,</span>
     };

     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">&gt;</span> vbuf(rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>Immutable<span class="operator">,</span>
                                                     <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>VertexBuffer<span class="operator">,</span>
                                                     <span class="keyword">sizeof</span>(vertexData)));
     vbuf<span class="operator">-</span><span class="operator">&gt;</span>create();

     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">&gt;</span> ubuf(rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>Dynamic<span class="operator">,</span>
                                                     <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>UniformBuffer<span class="operator">,</span>
                                                     <span class="number">64</span> <span class="operator">+</span> <span class="number">4</span>));
     ubuf<span class="operator">-</span><span class="operator">&gt;</span>create();

     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a></span><span class="operator">&gt;</span> srb(rhi<span class="operator">-</span><span class="operator">&gt;</span>newShaderResourceBindings());
     srb<span class="operator">-</span><span class="operator">&gt;</span>setBindings({
         <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>uniformBuffer(<span class="number">0</span><span class="operator">,</span>
                                                  <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>VertexStage <span class="operator">|</span> <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>FragmentStage<span class="operator">,</span>
                                                  ubuf<span class="operator">.</span>get())
     });
     srb<span class="operator">-</span><span class="operator">&gt;</span>create();

     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a></span><span class="operator">&gt;</span> ps(rhi<span class="operator">-</span><span class="operator">&gt;</span>newGraphicsPipeline());
     <span class="type"><a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a></span><span class="operator">::</span>TargetBlend premulAlphaBlend;
     premulAlphaBlend<span class="operator">.</span>enable <span class="operator">=</span> <span class="keyword">true</span>;
     ps<span class="operator">-</span><span class="operator">&gt;</span>setTargetBlends({ premulAlphaBlend });
     <span class="keyword">static</span> <span class="keyword">auto</span> getShader <span class="operator">=</span> <span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>name) {
         <span class="type"><a href="../qtcore/qfile.html" translate="no">QFile</a></span> f(name);
         <span class="keyword">return</span> f<span class="operator">.</span>open(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span><span class="operator">::</span>ReadOnly) <span class="operator">?</span> <span class="type"><a href="qshader.html" translate="no">QShader</a></span><span class="operator">::</span>fromSerialized(f<span class="operator">.</span>readAll()) : <span class="type"><a href="qshader.html" translate="no">QShader</a></span>();
     };
     ps<span class="operator">-</span><span class="operator">&gt;</span>setShaderStages({
         { <span class="type"><a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a></span><span class="operator">::</span>Vertex<span class="operator">,</span> getShader(QLatin1String(<span class="string">&quot;color.vert.qsb&quot;</span>)) }<span class="operator">,</span>
         { <span class="type"><a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a></span><span class="operator">::</span>Fragment<span class="operator">,</span> getShader(QLatin1String(<span class="string">&quot;color.frag.qsb&quot;</span>)) }
     });
     <span class="type"><a href="qrhivertexinputlayout.html" translate="no">QRhiVertexInputLayout</a></span> inputLayout;
     inputLayout<span class="operator">.</span>setBindings({
         { <span class="number">5</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) }
     });
     inputLayout<span class="operator">.</span>setAttributes({
         { <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a></span><span class="operator">::</span>Float2<span class="operator">,</span> <span class="number">0</span> }<span class="operator">,</span>
         { <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a></span><span class="operator">::</span>Float3<span class="operator">,</span> <span class="number">2</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) }
     });
     ps<span class="operator">-</span><span class="operator">&gt;</span>setVertexInputLayout(inputLayout);
     ps<span class="operator">-</span><span class="operator">&gt;</span>setShaderResourceBindings(srb<span class="operator">.</span>get());
     ps<span class="operator">-</span><span class="operator">&gt;</span>setRenderPassDescriptor(rp<span class="operator">.</span>get());
     ps<span class="operator">-</span><span class="operator">&gt;</span>create();

     <span class="type"><a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb;
     <span class="keyword">for</span> (<span class="type">int</span> frame <span class="operator">=</span> <span class="number">0</span>; frame <span class="operator">&lt;</span> <span class="number">20</span>; <span class="operator">+</span><span class="operator">+</span>frame) {
         rhi<span class="operator">-</span><span class="operator">&gt;</span>beginOffscreenFrame(<span class="operator">&amp;</span>cb);

         <span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>u <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
         <span class="keyword">if</span> (frame <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>)
             u<span class="operator">-</span><span class="operator">&gt;</span>uploadStaticBuffer(vbuf<span class="operator">.</span>get()<span class="operator">,</span> vertexData);

         QMatrix4x4 mvp <span class="operator">=</span> viewProjection;
         mvp<span class="operator">.</span>rotate(rotation<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span>);
         u<span class="operator">-</span><span class="operator">&gt;</span>updateDynamicBuffer(ubuf<span class="operator">.</span>get()<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">64</span><span class="operator">,</span> mvp<span class="operator">.</span>constData());
         rotation <span class="operator">+</span><span class="operator">=</span> <span class="number">5.0f</span>;

         u<span class="operator">-</span><span class="operator">&gt;</span>updateDynamicBuffer(ubuf<span class="operator">.</span>get()<span class="operator">,</span> <span class="number">64</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="operator">&amp;</span>opacity);
         opacity <span class="operator">+</span><span class="operator">=</span> opacityDir <span class="operator">*</span> <span class="number">0.2f</span>;
         <span class="keyword">if</span> (opacity <span class="operator">&lt;</span> <span class="number">0.0f</span> <span class="operator">|</span><span class="operator">|</span> opacity <span class="operator">&gt;</span> <span class="number">1.0f</span>) {
             opacityDir <span class="operator">*</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>;
             opacity <span class="operator">=</span> <a href="../qtcore/qtminmax-qtcore-proxy.html#qBound" translate="no">qBound</a>(<span class="number">0.0f</span><span class="operator">,</span> opacity<span class="operator">,</span> <span class="number">1.0f</span>);
         }

         cb<span class="operator">-</span><span class="operator">&gt;</span>beginPass(rt<span class="operator">.</span>get()<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>green<span class="operator">,</span> { <span class="number">1.0f</span><span class="operator">,</span> <span class="number">0</span> }<span class="operator">,</span> u);
         cb<span class="operator">-</span><span class="operator">&gt;</span>setGraphicsPipeline(ps<span class="operator">.</span>get());
         cb<span class="operator">-</span><span class="operator">&gt;</span>setViewport({ <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1280</span><span class="operator">,</span> <span class="number">720</span> });
         cb<span class="operator">-</span><span class="operator">&gt;</span>setShaderResources();
         <span class="keyword">const</span> <span class="type"><a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span><span class="operator">::</span>VertexInput vbufBinding(vbuf<span class="operator">.</span>get()<span class="operator">,</span> <span class="number">0</span>);
         cb<span class="operator">-</span><span class="operator">&gt;</span>setVertexInput(<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="operator">&amp;</span>vbufBinding);
         cb<span class="operator">-</span><span class="operator">&gt;</span>draw(<span class="number">3</span>);
         <span class="type"><a href="qrhireadbackresult.html" translate="no">QRhiReadbackResult</a></span> readbackResult;
         u <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
         u<span class="operator">-</span><span class="operator">&gt;</span>readBackTexture({ tex<span class="operator">.</span>get() }<span class="operator">,</span> <span class="operator">&amp;</span>readbackResult);
         cb<span class="operator">-</span><span class="operator">&gt;</span>endPass(u);

         rhi<span class="operator">-</span><span class="operator">&gt;</span>endOffscreenFrame();

         <span class="type"><a href="qimage.html" translate="no">QImage</a></span> image(<span class="keyword">reinterpret_cast</span><span class="operator">&lt;</span><span class="keyword">const</span> <span class="type"><a href="../qtcore/qttypes.html#uchar-typedef" translate="no">uchar</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(readbackResult<span class="operator">.</span>data<span class="operator">.</span>constData())<span class="operator">,</span>
                      readbackResult<span class="operator">.</span>pixelSize<span class="operator">.</span>width()<span class="operator">,</span>
                      readbackResult<span class="operator">.</span>pixelSize<span class="operator">.</span>height()<span class="operator">,</span>
                      <span class="type"><a href="qimage.html" translate="no">QImage</a></span><span class="operator">::</span>Format_RGBA8888_Premultiplied);
         <span class="keyword">if</span> (rhi<span class="operator">-</span><span class="operator">&gt;</span>isYUpInFramebuffer())
             image <span class="operator">=</span> image<span class="operator">.</span>mirrored();
         image<span class="operator">.</span>save(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">::</span>asprintf(<span class="string">&quot;frame%d.png&quot;</span><span class="operator">,</span> frame));
     }

     <span class="keyword">return</span> <span class="number">0</span>;
 }
</pre>
<p>The result of the application is 20 <code translate="no">PNG</code> images (frame0.png - frame19.png). These contain a rotating triangle with varying opacity over a green background.</p>
<p>The vertex and fragment shaders are expected to be processed and packaged into <code translate="no">.qsb</code> files. The Vulkan-compatible GLSL source code is the following:</p>
<p><i>color.vert</i></p>
<pre class="cpp" translate="no">
 #version 440

 layout(location = 0) in vec4 position;
 layout(location = 1) in vec3 color;
 layout(location = 0) out vec3 v_color;

 layout(std140, binding = 0) uniform buf {
     mat4 mvp;
     float opacity;
 };

 void main()
 {
     v_color = color;
     gl_Position = mvp * position;
 }
</pre>
<p><i>color.frag</i></p>
<pre class="cpp" translate="no">
 #version 440

 layout(location = 0) in vec3 v_color;
 layout(location = 0) out vec4 fragColor;

 layout(std140, binding = 0) uniform buf {
     mat4 mvp;
     float opacity;
 };

 void main()
 {
     fragColor = vec4(v_color * opacity, opacity);
 }
</pre>
<p>To manually compile and transpile these shaders to a number of targets (SPIR-V, HLSL, MSL, GLSL) and generate the <code translate="no">.qsb</code> files the application loads at run time, run <code translate="no">qsb --qt6 color.vert -o color.vert.qsb</code> and <code translate="no">qsb --qt6 color.frag -o color.frag.qsb</code>. Alternatively, the Qt Shader Tools module offers build system integration for CMake, the <code translate="no">qt_add_shaders()</code> CMake function, that can achieve the same at build time.</p>
<h3 id="design-fundamentals">Design Fundamentals</h3>
<p>A QRhi cannot be instantiated directly. Instead, use the <a href="qrhi.html#create" translate="no">create</a>() function. Delete the QRhi instance normally to release the graphics device.</p>
<h4 id="resources">Resources</h4>
<p>Instances of classes deriving from <a href="qrhiresource.html" translate="no">QRhiResource</a>, such as, <a href="qrhibuffer.html" translate="no">QRhiBuffer</a>, <a href="qrhitexture.html" translate="no">QRhiTexture</a>, etc., encapsulate zero, one, or more native graphics resources. Instances of such classes are always created via the <code translate="no">new</code> functions of the QRhi, such as, <a href="qrhi.html#newBuffer" translate="no">newBuffer</a>(), <a href="qrhi.html#newTexture" translate="no">newTexture</a>(), <a href="qrhi.html#newTextureRenderTarget" translate="no">newTextureRenderTarget</a>(), <a href="qrhi.html#newSwapChain" translate="no">newSwapChain</a>().</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> <span class="operator">*</span>vbuf <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>Immutable<span class="operator">,</span> <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>VertexBuffer<span class="operator">,</span> <span class="keyword">sizeof</span>(vertexData));
 <span class="keyword">if</span> (<span class="operator">!</span>vbuf<span class="operator">-</span><span class="operator">&gt;</span>create()) { error(); }
 <span class="comment">// ...</span>
 <span class="keyword">delete</span> vbuf;
</pre>
<ul>
<li>The returned value from functions like <a href="qrhi.html#newBuffer" translate="no">newBuffer</a>() is always owned by the caller.</li>
<li>Just creating an instance of a <a href="qrhiresource.html" translate="no">QRhiResource</a> subclass never allocates or initializes any native resources. That is only done when calling the <code translate="no">create()</code> function of a subclass, for example, <a href="qrhibuffer.html#create" translate="no">QRhiBuffer::create</a>() or <a href="qrhitexture.html#create" translate="no">QRhiTexture::create</a>().</li>
<li>The exceptions are <a href="qrhitexturerendertarget.html#newCompatibleRenderPassDescriptor" translate="no">QRhiTextureRenderTarget::newCompatibleRenderPassDescriptor</a>(), <a href="qrhiswapchain.html#newCompatibleRenderPassDescriptor" translate="no">QRhiSwapChain::newCompatibleRenderPassDescriptor</a>(), and <a href="qrhirenderpassdescriptor.html#newCompatibleRenderPassDescriptor" translate="no">QRhiRenderPassDescriptor::newCompatibleRenderPassDescriptor</a>(). There is no <code translate="no">create()</code> operation for these and the returned object is immediately active.</li>
<li>The resource objects themselves are treated as immutable: once a resource has <a href="qrhi.html#create" translate="no">create</a>() called, changing any parameters via the setters, such as, <a href="qrhitexture.html#setPixelSize" translate="no">QRhiTexture::setPixelSize</a>(), has no effect, unless the underlying native resource is released and <code translate="no">create()</code> is called again. See more about resource reuse in the sections below.</li>
<li>The underlying native resources are scheduled for releasing by the <a href="qrhiresource.html" translate="no">QRhiResource</a> destructor, or by calling <a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>(). Backends often queue release requests and defer executing them to an unspecified time, this is hidden from the applications. This way applications do not have to worry about releasing native resources that may still be in use by an in-flight frame.</li>
<li>Note that this does not mean that a <a href="qrhiresource.html" translate="no">QRhiResource</a> can freely be destroy()'ed or deleted within a frame (that is, in a <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>() - <a href="qrhi.html#endFrame" translate="no">endFrame</a>() section). As a general rule, all referenced <a href="qrhiresource.html" translate="no">QRhiResource</a> objects must stay unchanged until the frame is submitted by calling <a href="qrhi.html#endFrame" translate="no">endFrame</a>(). To ease this, <a href="qrhiresource.html#deleteLater" translate="no">QRhiResource::deleteLater</a>() is provided as a convenience.</li>
</ul>
<h4 id="command-buffers-and-deferred-command-execution">Command buffers and deferred command execution</h4>
<p>Regardless of the design and capabilities of the underlying graphics API, all QRhi backends implement some level of command buffers. No <a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> function issues any native bind or draw command (such as, <code translate="no">glDrawElements</code>) directly. Commands are always recorded in a queue, either native or provided by the QRhi backend. The command buffer is submitted, and so execution starts only upon <a href="qrhi.html#endFrame" translate="no">QRhi::endFrame</a>() or <a href="qrhi.html#finish" translate="no">QRhi::finish</a>().</p>
<p>The deferred nature has consequences for some types of objects. For example, writing to a dynamic buffer multiple times within a frame, in case such buffers are backed by host-visible memory, will result in making the results of all writes are visible to all draw calls in the command buffer of the frame, regardless of when the dynamic buffer update was recorded relative to a draw call.</p>
<p>Furthermore, instances of <a href="qrhiresource.html" translate="no">QRhiResource</a> subclasses must be treated immutable within a frame in which they are referenced in any way. Create all resources upfront, before starting to record commands for the next frame. Reusing a <a href="qrhiresource.html" translate="no">QRhiResource</a> instance within a frame (by calling <code translate="no">create()</code> then referencing it again in the same <code translate="no">beginFrame - endFrame</code> section) should be avoided as it may lead to unexpected results, depending on the backend.</p>
<p>As a general rule, all referenced <a href="qrhiresource.html" translate="no">QRhiResource</a> objects must stay valid and unmodified until the frame is submitted by calling <a href="qrhi.html#endFrame" translate="no">endFrame</a>(). On the other hand, calling <a href="qrhiresource.html#destroy" translate="no">destroy</a>() or deleting the <a href="qrhiresource.html" translate="no">QRhiResource</a> are always safe once the frame is submitted, regardless of the status of the underlying native resources (which may still be in use by the GPU - but that is taken care of internally).</p>
<p>Unlike APIs like OpenGL, upload and copy type of commands cannot be mixed with draw commands. The typical renderer will involve a sequence similar to the following:</p>
<ul>
<li>(re)create resources</li>
<li>begin frame</li>
<li>record/issue uploads and copies</li>
<li>start recording a render pass</li>
<li>record draw calls</li>
<li>end render pass</li>
<li>end frame</li>
</ul>
<p>Recording copy type of operations happens via <a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a>. Such operations are committed typically on <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>().</p>
<p>When working with legacy rendering engines designed for OpenGL, the migration to QRhi often involves redesigning from having a single <code translate="no">render</code> step (that performs copies and uploads, clears buffers, and issues draw calls, all mixed together) to a clearly separated, two phase <code translate="no">prepare</code> - <code translate="no">render</code> setup where the <code translate="no">render</code> step only starts a renderpass and records draw calls, while all resource creation and queuing of updates, uploads and copies happens beforehand, in the <code translate="no">prepare</code> step.</p>
<p>QRhi does not at the moment allow freely creating and submitting command buffers. This may be lifted in the future to some extent, in particular if compute support is introduced, but the model of well defined <code translate="no">frame-start</code> and <code translate="no">frame-end</code> points, combined with a dedicated, &quot;frame&quot; command buffer, where <code translate="no">frame-end</code> implies presenting, is going to remain the primary way of operating since this is what fits Qt's various UI technologies best.</p>
<h4 id="threading">Threading</h4>
<p>A QRhi instance and the associated resources can be created and used on any thread but all usage must be limited to that one single thread. When rendering to multiple QWindows in an application, having a dedicated thread and QRhi instance for each window is often advisable, as this can eliminate issues with unexpected throttling caused by presenting to multiple windows. Conceptually that is then the same as how Qt Quick scene graph's threaded render loop operates when working directly with OpenGL: one thread for each window, one <a href="qopenglcontext.html" translate="no">QOpenGLContext</a> for each thread. When moving onto QRhi, <a href="qopenglcontext.html" translate="no">QOpenGLContext</a> is replaced by QRhi, making the migration straightforward.</p>
<p>When it comes to externally created native objects, such as OpenGL contexts passed in via <a href="qrhigles2nativehandles.html" translate="no">QRhiGles2NativeHandles</a>, it is up to the application to ensure they are not misused by other threads.</p>
<p>Resources are not shareable between QRhi instances. This is an intentional choice since QRhi hides most queue, command buffer, and resource synchronization related tasks, and provides no API for them. Safe and efficient concurrent use of graphics resources from multiple threads is tied to those concepts, however, and is thus a topic that is currently out of scope, but may be introduced in the future.</p>
<div class="admonition note">
<p><b>Note: </b>The Metal backend requires that an autorelease pool is available on the rendering thread, ideally wrapping each iteration of the render loop. This needs no action from the users of QRhi when rendering on the main (gui) thread, but becomes important when a separate, dedicated render thread is used.</p>
</div>
<h4 id="resource-synchronization">Resource synchronization</h4>
<p>QRhi does not expose APIs for resource barriers or image layout transitions. Such synchronization is done implicitly by the backends, where applicable (for example, Vulkan), by tracking resource usage as necessary. Buffer and image barriers are inserted before render or compute passes transparently to the application.</p>
<div class="admonition note">
<p><b>Note: </b>Resources within a render or compute pass are expected to be bound to a single usage during that pass. For example, a buffer can be used as vertex, index, uniform, or storage buffer, but not a combination of them within a single pass. However, it is perfectly fine to use a buffer as a storage buffer in a compute pass, and then as a vertex buffer in a render pass, for example, assuming the buffer declared both usages upon creation.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Textures have this rule relaxed in certain cases, because using two subresources (typically two different mip levels) of the same texture for different access (one for load, one for store) is supported even within the same pass.</p>
</div>
<h4 id="resource-reuse">Resource reuse</h4>
<p>From the user's point of view a <a href="qrhiresource.html" translate="no">QRhiResource</a> is reusable immediately after calling <a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>(). With the exception of swapchains, calling <code translate="no">create()</code> on an already created object does an implicit <code translate="no">destroy()</code>. This provides a handy shortcut to reuse a <a href="qrhiresource.html" translate="no">QRhiResource</a> instance with different parameters, with a new native graphics object underneath.</p>
<p>The importance of reusing the same object lies in the fact that some objects reference other objects: for example, a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> can reference <a href="qrhibuffer.html" translate="no">QRhiBuffer</a>, <a href="qrhitexture.html" translate="no">QRhiTexture</a>, and <a href="qrhisampler.html" translate="no">QRhiSampler</a> instances. If in a later frame one of these buffers need to be resized or a sampler parameter needs changing, destroying and creating a whole new <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> or <a href="qrhisampler.html" translate="no">QRhiSampler</a> would invalidate all references to the old instance. By just changing the appropriate parameters via <a href="qrhibuffer.html#setSize" translate="no">QRhiBuffer::setSize</a>() or similar and then calling <a href="qrhibuffer.html#create" translate="no">QRhiBuffer::create</a>(), everything works as expected and there is no need to touch the <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> at all, even though there is a good chance that under the hood the <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> is now backed by a whole new native buffer.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> <span class="operator">*</span>ubuf <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>Dynamic<span class="operator">,</span> <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>UniformBuffer<span class="operator">,</span> <span class="number">256</span>);
 ubuf<span class="operator">-</span><span class="operator">&gt;</span>create();

 <span class="type"><a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a></span> <span class="operator">*</span>srb <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newShaderResourceBindings()
 srb<span class="operator">-</span><span class="operator">&gt;</span>setBindings({
     <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>uniformBuffer(<span class="number">0</span><span class="operator">,</span> <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>VertexStage <span class="operator">|</span> <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>FragmentStage<span class="operator">,</span> ubuf)
 });
 srb<span class="operator">-</span><span class="operator">&gt;</span>create();

 <span class="comment">// ...</span>

 <span class="comment">// now in a later frame we need to grow the buffer to a larger size</span>
 ubuf<span class="operator">-</span><span class="operator">&gt;</span>setSize(<span class="number">512</span>);
 ubuf<span class="operator">-</span><span class="operator">&gt;</span>create(); <span class="comment">// same as ubuf-&gt;destroy(); ubuf-&gt;create();</span>

 <span class="comment">// srb needs no changes whatsoever, any references in it to ubuf</span>
 <span class="comment">// stay valid. When it comes to internal details, such as that</span>
 <span class="comment">// ubuf may now be backed by a completely different native buffer</span>
 <span class="comment">// resource, that is is recognized and handled automatically by the</span>
 <span class="comment">// next setShaderResources().</span>
</pre>
<p><a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> offers the same contract: calling <a href="qrhicommandbuffer.html#beginPass" translate="no">QRhiCommandBuffer::beginPass</a>() is safe even when one of the render target's associated textures or renderbuffers has been rebuilt (by calling <code translate="no">create()</code> on it) since the creation of the render target object. This allows the application to resize a texture by setting a new pixel size on the <a href="qrhitexture.html" translate="no">QRhiTexture</a> and calling <a href="qrhi.html#create" translate="no">create</a>(), thus creating a whole new native texture resource underneath, without having to update the <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> as that will be done implicitly in beginPass().</p>
<h4 id="pooled-objects">Pooled objects</h4>
<p>In addition to resources, there are pooled objects as well, such as, <a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a>. An instance is retrieved via a <code translate="no">next</code> function, such as, <a href="qrhi.html#nextResourceUpdateBatch" translate="no">nextResourceUpdateBatch</a>(). The caller does not own the returned instance in this case. The only valid way of operating here is calling functions on the <a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a> and then passing it to <a href="qrhicommandbuffer.html#beginPass" translate="no">QRhiCommandBuffer::beginPass</a>() or <a href="qrhicommandbuffer.html#endPass" translate="no">QRhiCommandBuffer::endPass</a>(). These functions take care of returning the batch to the pool. Alternatively, a batch can be &quot;canceled&quot; and returned to the pool without processing by calling <a href="qrhiresourceupdatebatch.html#release" translate="no">QRhiResourceUpdateBatch::release</a>().</p>
<p>A typical pattern is thus:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>resUpdates <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
 <span class="comment">// ...</span>
 resUpdates<span class="operator">-</span><span class="operator">&gt;</span>updateDynamicBuffer(ubuf<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">64</span><span class="operator">,</span> mvp<span class="operator">.</span>constData());
 <span class="keyword">if</span> (<span class="operator">!</span>image<span class="operator">.</span>isNull()) {
     resUpdates<span class="operator">-</span><span class="operator">&gt;</span>uploadTexture(texture<span class="operator">,</span> image);
     image <span class="operator">=</span> <span class="type"><a href="qimage.html" translate="no">QImage</a></span>();
 }
 <span class="comment">// ...</span>
 <span class="type"><a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb <span class="operator">=</span> m_sc<span class="operator">-</span><span class="operator">&gt;</span>currentFrameCommandBuffer();
 <span class="comment">// note the last argument</span>
 cb<span class="operator">-</span><span class="operator">&gt;</span>beginPass(swapchain<span class="operator">-</span><span class="operator">&gt;</span>currentFrameRenderTarget()<span class="operator">,</span> clearCol<span class="operator">,</span> clearDs<span class="operator">,</span> resUpdates);
</pre>
<h4 id="swapchain-specifics">Swapchain specifics</h4>
<p><a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a> features some special semantics due to the peculiar nature of swapchains.</p>
<ul>
<li>It has no <code translate="no">create()</code> but rather a <a href="qrhiswapchain.html#createOrResize" translate="no">QRhiSwapChain::createOrResize</a>(). Repeatedly calling this function is <b>not</b> the same as calling <a href="qrhiresource.html#destroy" translate="no">QRhiSwapChain::destroy</a>() followed by <a href="qrhiswapchain.html#createOrResize" translate="no">QRhiSwapChain::createOrResize</a>(). This is because swapchains often have ways to handle the case where buffers need to be resized in a manner that is more efficient than a brute force destroying and recreating from scratch.</li>
<li>An active <a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a> must be released by calling <a href="qrhiresource.html#destroy" translate="no">destroy</a>(), or by destroying the object, before the <a href="qwindow.html" translate="no">QWindow</a>'s underlying QPlatformWindow, and so the associated native window object, is destroyed. It should not be postponed because releasing the swapchain may become problematic (and with some APIs, like Vulkan, is explicitly disallowed) when the native window is not around anymore, for example because the QPlatformWindow got destroyed upon getting a <a href="qwindow.html#close" translate="no">QWindow::close</a>(). Therefore, releasing the swapchain must happen whenever the targeted <a href="qwindow.html" translate="no">QWindow</a> sends the <a href="qplatformsurfaceevent.html#SurfaceEventType-enum" translate="no">QPlatformSurfaceEvent::SurfaceAboutToBeDestroyed</a> event. If the event does not arrive before the destruction of the <a href="qwindow.html" translate="no">QWindow</a> - this can happen when using <a href="../qtcore/qcoreapplication.html#quit" translate="no">QCoreApplication::quit</a>() -, then check QWindow::handle() after the event loop exits and invoke the swapchain release when non-null (meaning the underlying native window is still around).</li>
</ul>
<h4 id="ownership">Ownership</h4>
<p>The general rule is no ownership transfer. Creating a QRhi with an already existing graphics device does not mean the QRhi takes ownership of the device object. Similarly, ownership is not given away when a device or texture object is &quot;exported&quot; via <a href="qrhi.html#nativeHandles" translate="no">QRhi::nativeHandles</a>() or <a href="qrhitexture.html#nativeTexture" translate="no">QRhiTexture::nativeTexture</a>(). Most importantly, passing pointers in structs and via setters does not transfer ownership.</p>
<h3 id="troubleshooting-and-profiling">Troubleshooting and Profiling</h3>
<h4 id="error-reporting">Error reporting</h4>
<p>Functions such as <a href="qrhi.html#create" translate="no">QRhi::create</a>() and the resource classes' <code translate="no">create()</code> member functions (e.g., <a href="qrhibuffer.html#create" translate="no">QRhiBuffer::create</a>()) indicate failure with the return value (<code translate="no">nullptr</code> or <code translate="no">false</code>, respectively). When working with <a href="qshader.html" translate="no">QShader</a>, <a href="qshader.html#fromSerialized" translate="no">QShader::fromSerialized</a>() returns an invalid <a href="qshader.html" translate="no">QShader</a> (for which <a href="qshader.html#isValid" translate="no">isValid</a>() returns <code translate="no">false</code>) when the data passed to the function cannot be successfully deserialized. Some functions, <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>() in particular, may also sometimes report &quot;soft failures&quot;, such as <a href="qrhi.html#FrameOpResult-enum" translate="no">FrameOpSwapChainOutOfDate</a>, which do not indicate an unrecoverable error, but rather should be seen as a &quot;try again later&quot; response.</p>
<p>Warnings and errors may get printed at any time to the debug output via <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>(). It is therefore always advisable to inspect the output of the application.</p>
<p>Additional debug messages can be enabled via the following logging categories. Messages from these categories are not printed by default unless explicitly enabled via <a href="../qtcore/qloggingcategory.html" translate="no">QLoggingCategory</a> or the <code translate="no">QT_LOGGING_RULES</code> environment variable. For better interoperation with Qt Quick, the environment variable <code translate="no">QSG_INFO</code> also enables these debug prints.</p>
<ul>
<li><code translate="no">qt.rhi.general</code></li>
</ul>
<p>Additionally, applications can query the <a href="qrhi.html#backendName" translate="no">QRhi backend name</a> and <a href="qrhi.html#driverInfo" translate="no">graphics device information</a> from a successfully initialized QRhi. This can then be printed to the user or stored in the application logs even in production builds, if desired.</p>
<h4 id="investigating-rendering-problems">Investigating rendering problems</h4>
<p>When the rendering results are not as expected, or the application is experiencing problems, always consider checking with the the native 3D APIs' debug and validation facilities. QRhi itself features limited error checking since replicating the already existing, vast amount of functionality in the underlying layers is not reasonable.</p>
<ul>
<li>For Vulkan, controlling the <a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers" translate="no">Vulkan Validation Layers</a> is not in the scope of the QRhi, but rather can be achieved by configuring the <a href="qvulkaninstance.html" translate="no">QVulkanInstance</a> with the appropriate layers. For example, call <code translate="no">instance.setLayers({ &quot;VK_LAYER_KHRONOS_validation&quot; });</code> before invoking <a href="qvulkaninstance.html#create" translate="no">create</a>() on the <a href="qvulkaninstance.html" translate="no">QVulkanInstance</a>. (note that this assumes that the validation layers are actually installed and available, e.g. from the Vulkan SDK) By default, <a href="qvulkaninstance.html" translate="no">QVulkanInstance</a> conveniently redirects the Vulkan debug messages to <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>, meaning the validation messages get printed just like other Qt warnings.</li>
<li>With Direct 3D 11 and 12, a graphics device with the debug layer enabled can be requested by toggling the <code translate="no">enableDebugLayer</code> flag in the appropriate <a href="qrhid3d11initparams.html" translate="no">init params struct</a>. The messages appear on the debug output, which is visible in Qt Creator's messages panel or via a tool such as <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/debugview" translate="no">DebugView</a>.</li>
<li>For Metal, controlling Metal Validation is outside of QRhi's scope. Rather, to enable validation, run the application with the environment variable <code translate="no">METAL_DEVICE_WRAPPER_TYPE=1</code> set, or run the application within XCode. There may also be further settings and environment variable in modern XCode and macOS versions. See for instance <a href="https://developer.apple.com/documentation/metal/diagnosing_metal_programming_issues_early" translate="no">this page</a>.</li>
</ul>
<h4 id="frame-captures-and-performance-profiling">Frame captures and performance profiling</h4>
<p>A Qt application rendering with QRhi to a window while relying on a 3D API under the hood, is, from the windowing and graphics pipeline perspective at least, no different from any other (non-Qt) applications using the same 3D API. This means that tools and practices for debugging and profiling applications involving 3D graphics, such as games, all apply to such a Qt application as well.</p>
<p>A few examples of tools that can provide insights into the rendering internals of Qt applications that use QRhi, which includes Qt Quick and Qt Quick 3D based projects as well:</p>
<ul>
<li><a href="https://renderdoc.org/" translate="no">RenderDoc</a> allows taking frame captures and introspecting the recorded commands and pipeline state on Windows and Linux for applications using OpenGL, Vulkan, D3D11, or D3D12. When trying to figure out why some parts of the 3D scene do not show up as expected, RenderDoc is often a fast and efficient way to check the pipeline stages and the related state and discover the missing or incorrect value. It is also a tool that is actively used when developing Qt itself.</li>
<li>For NVIDIA-based systems, <a href="https://developer.nvidia.com/nsight-graphics" translate="no">Nsight Graphics</a> provides a graphics debugger tool on Windows and Linux. In addition to investigating the commands in the frame and the pipeline, the vendor-specific tools allow looking at timings and hardware performance information, which is not something simple frame captures can provide.</li>
<li>For AMD-based systems, the <a href="https://gpuopen.com/rgp/" translate="no">Radeon GPU Profiler</a> can be used to gain deeper insights into the application's rendering and its performance.</li>
<li>As QRhi supports Direct 3D 12, using <a href="https://devblogs.microsoft.com/pix/download/" translate="no">PIX</a>, a performance tuning and debugging tool for DirectX 12 games on Windows is an option as well.</li>
<li>On macOS, <a href="https://developer.apple.com/documentation/metal/debugging_tools/viewing_your_gpu_workload_with_the_metal_debugger" translate="no">the XCode Metal debugger</a> can be used to take and introspect frame captures, to investigate performance details, and debug shaders. In macOS 13 it is also possible to enable an overlay that displays frame rate and other information for any Metal-based window by setting the environment variable <code translate="no">MTL_HUD_ENABLED=1</code>.</li>
</ul>
<p>On mobile and embedded platforms, there may be vendor and platform-specific tools, provided by the GPU or SoC vendor, available to perform performance profiling of application using OpenGL ES or Vulkan.</p>
<p>When capturing frames, remember that objects and groups of commands can be named via debug markers, as long as <a href="qrhi.html#Flag-enum" translate="no">debug markers were enabled</a> for the QRhi, and the graphics API in use supports this. To annotate the command stream, call <a href="qrhicommandbuffer.html#debugMarkBegin" translate="no">debugMarkBegin</a>(), <a href="qrhicommandbuffer.html#debugMarkEnd" translate="no">debugMarkEnd</a>() and/or <a href="qrhicommandbuffer.html#debugMarkMsg" translate="no">debugMarkMsg</a>(). This can be particularly useful in larger frames with multiple render passes. Resources are named by calling <a href="qrhiresource.html#setName" translate="no">setName</a>() before <a href="qrhi.html#create" translate="no">create</a>().</p>
<p>To perform basic timing measurements on the CPU and GPU side within the application, <a href="../qtcore/qelapsedtimer.html" translate="no">QElapsedTimer</a> and <a href="qrhicommandbuffer.html#lastCompletedGpuTime" translate="no">QRhiCommandBuffer::lastCompletedGpuTime</a>() can be used. The latter is only available with select graphics APIs at the moment and requires opting in via the <a href="qrhi.html#Flag-enum" translate="no">QRhi::EnableTimestamps</a> flag.</p>
<h4 id="resource-leak-checking">Resource leak checking</h4>
<p>When destroying a QRhi object without properly destroying all buffers, textures, and other resources created from it, warnings about this are printed to the debug output whenever the application is a debug build, or when the <code translate="no">QT_RHI_LEAK_CHECK</code> environment variable is set to a non-zero value. This is a simple way to discover design issues around resource handling within the application rendering logic. Note however that some platforms and underlying graphics APIs may perform their own allocation and resource leak detection as well, over which Qt will have no direct control. For example, when using Vulkan, the memory allocator may raise failing assertions in debug builds when resources that own graphics memory allocations are not destroyed before the QRhi. In addition, the Vulkan validation layer, when enabled, will issue warnings about native graphics resources that were not released. Similarly, with Direct 3D warnings may get printed about unreleased COM objects when the application does not destroy the QRhi and its resources in the correct order.</p>
</div>
<p><b>See also </b><a href="qtgui-rhiwindow-example.html" translate="no">RHI Window Example</a>, <a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a>, <a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a>, <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a>, <a href="qshader.html" translate="no">QShader</a>, <a href="qrhibuffer.html" translate="no">QRhiBuffer</a>, <a href="qrhitexture.html" translate="no">QRhiTexture</a>, <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>, <a href="qrhisampler.html" translate="no">QRhiSampler</a>, <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>, <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a>, <a href="qrhicomputepipeline.html" translate="no">QRhiComputePipeline</a>, and <a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a>.</p>
<!-- @@@QRhi -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$BeginFrameFlag -->
<h3 class="flags" id="BeginFrameFlag-enum">enum QRhi::<span class="name">BeginFrameFlag</span><br/>flags QRhi::<span class="name">BeginFrameFlags</span></h3>
<p>Flag values for <a href="qrhi.html#beginFrame" translate="no">QRhi::beginFrame</a>()</p>
<p>The BeginFrameFlags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;BeginFrameFlag&gt;. It stores an OR combination of BeginFrameFlag values.</p>
<!-- @@@BeginFrameFlag -->
<!-- $$$EndFrameFlag$$$SkipPresent -->
<h3 class="flags" id="EndFrameFlag-enum">enum QRhi::<span class="name">EndFrameFlag</span><br/>flags QRhi::<span class="name">EndFrameFlags</span></h3>
<p>Flag values for <a href="qrhi.html#endFrame" translate="no">QRhi::endFrame</a>()</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhi::SkipPresent</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td><td class="topAlign">Specifies that no present command is to be queued or no swapBuffers call is to be made. This way no image is presented. Generating multiple frames with all having this flag set is not recommended (except, for example, for benchmarking purposes - but keep in mind that backends may behave differently when it comes to waiting for command completion without presenting so the results are not comparable between them)</td></tr>
</table></div>
<p>The EndFrameFlags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;EndFrameFlag&gt;. It stores an OR combination of EndFrameFlag values.</p>
<!-- @@@EndFrameFlag -->
<!-- $$$Feature$$$MultisampleTexture$$$MultisampleRenderBuffer$$$DebugMarkers$$$Timestamps$$$Instancing$$$CustomInstanceStepRate$$$PrimitiveRestart$$$NonDynamicUniformBuffers$$$NonFourAlignedEffectiveIndexBufferOffset$$$NPOTTextureRepeat$$$RedOrAlpha8IsRed$$$ElementIndexUint$$$Compute$$$WideLines$$$VertexShaderPointSize$$$BaseVertex$$$BaseInstance$$$TriangleFanTopology$$$ReadBackNonUniformBuffer$$$ReadBackNonBaseMipLevel$$$TexelFetch$$$RenderToNonBaseMipLevel$$$IntAttributes$$$ScreenSpaceDerivatives$$$ReadBackAnyTextureFormat$$$PipelineCacheDataLoadSave$$$ImageDataStride$$$RenderBufferImport$$$ThreeDimensionalTextures$$$RenderTo3DTextureSlice$$$TextureArrays$$$Tessellation$$$GeometryShader$$$TextureArrayRange$$$NonFillPolygonMode$$$OneDimensionalTextures$$$OneDimensionalTextureMipmaps$$$HalfAttributes$$$RenderToOneDimensionalTexture$$$ThreeDimensionalTextureMipmaps$$$MultiView -->
<h3 class="fn" translate="no" id="Feature-enum">enum QRhi::<span class="name">Feature</span></h3>
<p>Flag values to indicate what features are supported by the backend currently in use.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MultisampleTexture</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Indicates that textures with a sample count larger than 1 are supported. In practice this feature will be unsupported with OpenGL ES versions older than 3.1, and OpenGL older than 3.0.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MultisampleRenderBuffer</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Indicates that renderbuffers with a sample count larger than 1 are supported. In practice this feature will be unsupported with OpenGL ES 2.0, and may also be unsupported with OpenGL 2.x unless the relevant extensions are present.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::DebugMarkers</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Indicates that debug marker groups (and so <a href="qrhicommandbuffer.html#debugMarkBegin" translate="no">QRhiCommandBuffer::debugMarkBegin</a>()) are supported.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::Timestamps</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">Indicates that command buffer timestamps are supported. Relevant for <a href="qrhicommandbuffer.html#lastCompletedGpuTime" translate="no">QRhiCommandBuffer::lastCompletedGpuTime</a>(). This can be expected to be supported on Metal, Vulkan, Direct 3D 11 and 12, and OpenGL contexts of version 3.3 or newer. However, with some of these APIs support for timestamp queries is technically optional, and therefore it cannot be guaranteed that this feature is always supported with every implementation of them.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::Instancing</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Indicates that instanced drawing is supported. In practice this feature will be unsupported with OpenGL ES 2.0 and OpenGL 3.2 or older.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::CustomInstanceStepRate</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">Indicates that instance step rates other than 1 are supported. In practice this feature will always be unsupported with OpenGL. In addition, running with Vulkan 1.0 without VK_EXT_vertex_attribute_divisor will also lead to reporting false for this feature.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::PrimitiveRestart</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">Indicates that restarting the assembly of primitives when encountering an index value of 0xFFFF (<a href="qrhicommandbuffer.html#IndexFormat-enum" translate="no">IndexUInt16</a>) or 0xFFFFFFFF (<a href="qrhicommandbuffer.html#IndexFormat-enum" translate="no">IndexUInt32</a>) is enabled, for certain primitive topologies at least. <a href="qrhi.html" translate="no">QRhi</a> will try to enable this with all backends, but in some cases it will not be supported. Dynamically controlling primitive restart is not possible since with some APIs primitive restart with a fixed index is always on. Applications must assume that whenever this feature is reported as supported, the above mentioned index values <code translate="no">may</code> be treated specially, depending on the topology. The only two topologies where primitive restart is guaranteed to behave identically across backends, as long as this feature is reported as supported, are <a href="qrhigraphicspipeline.html#Topology-enum" translate="no">LineStrip</a> and <a href="qrhigraphicspipeline.html#Topology-enum" translate="no">TriangleStrip</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::NonDynamicUniformBuffers</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">Indicates that creating buffers with the usage <a href="qrhibuffer.html#UsageFlag-enum" translate="no">UniformBuffer</a> and the types <a href="qrhibuffer.html#Type-enum" translate="no">Immutable</a> or <a href="qrhibuffer.html#Type-enum" translate="no">Static</a> is supported. When reported as unsupported, uniform (constant) buffers must be created as <a href="qrhibuffer.html#Type-enum" translate="no">Dynamic</a>. (which is recommended regardless)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::NonFourAlignedEffectiveIndexBufferOffset</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">Indicates that effective index buffer offsets (<code translate="no">indexOffset + firstIndex * indexComponentSize</code>) that are not 4 byte aligned are supported. When not supported, attempting to issue a <a href="qrhicommandbuffer.html#drawIndexed" translate="no">drawIndexed</a>() with a non-aligned effective offset may lead to unspecified behavior. Relevant in particular for Metal, where this will be reported as unsupported.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::NPOTTextureRepeat</code></td><td class="topAlign tblval"><code translate="no">10</code></td><td class="topAlign">Indicates that the <a href="qrhisampler.html#AddressMode-enum" translate="no">Repeat</a> wrap mode and mipmap filtering modes are supported for textures with a non-power-of-two size. In practice this can only be false with OpenGL ES 2.0 implementations without <code translate="no">GL_OES_texture_npot</code>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::RedOrAlpha8IsRed</code></td><td class="topAlign tblval"><code translate="no">11</code></td><td class="topAlign">Indicates that the <a href="qrhitexture.html#Format-enum" translate="no">RED_OR_ALPHA8</a> format maps to a one component 8-bit <code translate="no">red</code> format. This is the case for all backends except OpenGL when using either OpenGL ES or a non-core profile context. There <code translate="no">GL_ALPHA</code>, a one component 8-bit <code translate="no">alpha</code> format, is used instead. Using the special texture format allows having a single code path for creating textures, leaving it up to the backend to decide the actual format, while the feature flag can be used to pick the appropriate shader variant for sampling the texture.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::ElementIndexUint</code></td><td class="topAlign tblval"><code translate="no">12</code></td><td class="topAlign">Indicates that 32-bit unsigned integer elements are supported in the index buffer. In practice this is true everywhere except when running on plain OpenGL ES 2.0 implementations without the necessary extension. When false, only 16-bit unsigned elements are supported in the index buffer.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::Compute</code></td><td class="topAlign tblval"><code translate="no">13</code></td><td class="topAlign">Indicates that compute shaders, image load/store, and storage buffers are supported. OpenGL older than 4.3 and OpenGL ES older than 3.1 have no compute support.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::WideLines</code></td><td class="topAlign tblval"><code translate="no">14</code></td><td class="topAlign">Indicates that lines with a width other than 1 are supported. When reported as not supported, the line width set on the graphics pipeline state is ignored. This can always be false with some backends (D3D11, D3D12, Metal). With Vulkan, the value depends on the implementation. With OpenGL, wide lines are not supported in core profile contexts.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::VertexShaderPointSize</code></td><td class="topAlign tblval"><code translate="no">15</code></td><td class="topAlign">Indicates that the size of rasterized points set via <code translate="no">gl_PointSize</code> in the vertex shader is taken into account. When reported as not supported, drawing points with a size other than 1 is not supported. Setting <code translate="no">gl_PointSize</code> in the shader is still valid then, but is ignored. (for example, when generating HLSL, the assignment is silently dropped from the generated code) Note that some APIs (Metal, Vulkan) require the point size to be set in the shader explicitly whenever drawing points, even when the size is 1, as they do not automatically default to 1.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::BaseVertex</code></td><td class="topAlign tblval"><code translate="no">16</code></td><td class="topAlign">Indicates that <a href="qrhicommandbuffer.html#drawIndexed" translate="no">drawIndexed</a>() supports the <code translate="no">vertexOffset</code> argument. When reported as not supported, the vertexOffset value in an indexed draw is ignored. In practice this feature will be unsupported with OpenGL and OpenGL ES versions lower than 3.2, and with Metal on older iOS devices, including the iOS Simulator.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::BaseInstance</code></td><td class="topAlign tblval"><code translate="no">17</code></td><td class="topAlign">Indicates that instanced draw commands support the <code translate="no">firstInstance</code> argument. When reported as not supported, the firstInstance value is ignored and the instance ID starts from 0. In practice this feature will be unsupported with OpenGL, and with Metal on older iOS devices, including the iOS Simulator.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::TriangleFanTopology</code></td><td class="topAlign tblval"><code translate="no">18</code></td><td class="topAlign">Indicates that <a href="qrhigraphicspipeline.html#setTopology" translate="no">QRhiGraphicsPipeline::setTopology</a>() supports <a href="qrhigraphicspipeline.html#Topology-enum" translate="no">QRhiGraphicsPipeline::TriangleFan</a>. In practice this feature will be unsupported with Metal and Direct 3D 11/12.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::ReadBackNonUniformBuffer</code></td><td class="topAlign tblval"><code translate="no">19</code></td><td class="topAlign">Indicates that <a href="qrhiresourceupdatebatch.html#readBackBuffer" translate="no">reading buffer contents</a> is supported for <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> instances with a usage different than UniformBuffer. In practice this feature will be unsupported with OpenGL ES 2.0.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::ReadBackNonBaseMipLevel</code></td><td class="topAlign tblval"><code translate="no">20</code></td><td class="topAlign">Indicates that specifying a mip level other than 0 is supported when reading back texture contents. When not supported, specifying a non-zero level in <a href="qrhireadbackdescription.html" translate="no">QRhiReadbackDescription</a> leads to returning an all-zero image. In practice this feature will be unsupported with OpenGL ES 2.0.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::TexelFetch</code></td><td class="topAlign tblval"><code translate="no">21</code></td><td class="topAlign">Indicates that texelFetch() and textureLod() are available in shaders. In practice this will be reported as unsupported with OpenGL ES 2.0 and OpenGL 2.x contexts, because GLSL 100 es and versions before 130 do not support these functions.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::RenderToNonBaseMipLevel</code></td><td class="topAlign tblval"><code translate="no">22</code></td><td class="topAlign">Indicates that specifying a mip level other than 0 is supported when creating a <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> with a <a href="qrhitexture.html" translate="no">QRhiTexture</a> as its color attachment. When not supported, <a href="qrhi.html#create" translate="no">create</a>() will fail whenever the target mip level is not zero. In practice this feature will be unsupported with OpenGL ES 2.0.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::IntAttributes</code></td><td class="topAlign tblval"><code translate="no">23</code></td><td class="topAlign">Indicates that specifying input attributes with signed and unsigned integer types for a shader pipeline is supported. When not supported, build() will succeed but just show a warning message and the values of the target attributes will be broken. In practice this feature will be unsupported with OpenGL ES 2.0 and OpenGL 2.x.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::ScreenSpaceDerivatives</code></td><td class="topAlign tblval"><code translate="no">24</code></td><td class="topAlign">Indicates that functions such as dFdx(), dFdy(), and fwidth() are supported in shaders. In practice this feature will be unsupported with OpenGL ES 2.0 without the GL_OES_standard_derivatives extension.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::ReadBackAnyTextureFormat</code></td><td class="topAlign tblval"><code translate="no">25</code></td><td class="topAlign">Indicates that reading back texture contents can be expected to work for any <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::Format</a>. Backends other than OpenGL can be expected to return true for this feature. When reported as false, which will typically happen with OpenGL, only the formats <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::RGBA8</a> and <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::BGRA8</a> are guaranteed to be supported for readbacks. In addition, with OpenGL, but not OpenGL ES, reading back the 1 byte per component formats <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::R8</a> and <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::RED_OR_ALPHA8</a> are supported as well. Reading back floating point formats <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::RGBA16F</a> and RGBA32F may work too with OpenGL, as long as the implementation provides support for these, but <a href="qrhi.html" translate="no">QRhi</a> can give no guarantees, as indicated by this flag.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::PipelineCacheDataLoadSave</code></td><td class="topAlign tblval"><code translate="no">26</code></td><td class="topAlign">Indicates that the <a href="qrhi.html#pipelineCacheData" translate="no">pipelineCacheData</a>() and <a href="qrhi.html#setPipelineCacheData" translate="no">setPipelineCacheData</a>() functions are functional. When not supported, the functions will not perform any action, the retrieved blob is always empty, and thus no benefits can be expected from retrieving and, during a subsequent run of the application, reloading the pipeline cache content.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::ImageDataStride</code></td><td class="topAlign tblval"><code translate="no">27</code></td><td class="topAlign">Indicates that specifying a custom stride (row length) for raw image data in texture uploads is supported. When not supported (which can happen when the underlying API is OpenGL ES 2.0 without support for GL_UNPACK_ROW_LENGTH), <a href="qrhitexturesubresourceuploaddescription.html#setDataStride" translate="no">QRhiTextureSubresourceUploadDescription::setDataStride</a>() must not be used.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::RenderBufferImport</code></td><td class="topAlign tblval"><code translate="no">28</code></td><td class="topAlign">Indicates that <a href="qrhirenderbuffer.html#createFrom" translate="no">QRhiRenderBuffer::createFrom</a>() is supported. For most graphics APIs this is not sensible because <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> encapsulates texture objects internally, just like <a href="qrhitexture.html" translate="no">QRhiTexture</a>. With OpenGL however, renderbuffer object exist as a separate object type in the API, and in certain environments (for example, where one may want to associated a renderbuffer object with an EGLImage object) it is important to allow wrapping an existing OpenGL renderbuffer object with a <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::ThreeDimensionalTextures</code></td><td class="topAlign tblval"><code translate="no">29</code></td><td class="topAlign">Indicates that 3D textures are supported. In practice this feature will be unsupported with OpenGL and OpenGL ES versions lower than 3.0.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::RenderTo3DTextureSlice</code></td><td class="topAlign tblval"><code translate="no">30</code></td><td class="topAlign">Indicates that rendering to a slice in a 3D texture is supported. This can be unsupported with Vulkan 1.0 due to relying on VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT which is a Vulkan 1.1 feature.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::TextureArrays</code></td><td class="topAlign tblval"><code translate="no">31</code></td><td class="topAlign">Indicates that texture arrays are supported and <a href="qrhi.html#newTextureArray" translate="no">QRhi::newTextureArray</a>() is functional. Note that even when texture arrays are not supported, arrays of textures are still available as those are two independent features.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::Tessellation</code></td><td class="topAlign tblval"><code translate="no">32</code></td><td class="topAlign">Indicates that the tessellation control and evaluation stages are supported. When reported as supported, the topology of a <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> can be set to <a href="qrhigraphicspipeline.html#Topology-enum" translate="no">Patches</a>, the number of control points can be set via <a href="qrhigraphicspipeline.html#setPatchControlPointCount" translate="no">setPatchControlPointCount</a>(), and shaders for tessellation control and evaluation can be specified in the <a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a> list. Tessellation shaders have portability issues between APIs (for example, translating GLSL/SPIR-V to HLSL is problematic due to the way hull shaders are structured, whereas Metal uses a somewhat different tessellation pipeline than others), and therefore unexpected issues may still arise, even though basic functionality is implemented across all the underlying APIs. For Direct 3D in particular, handwritten HLSL hull and domain shaders must be injected into each <a href="qshader.html" translate="no">QShader</a> for the tessellation control and evaluation stages, respectively, since qsb cannot generate these from SPIR-V. Note that isoline tessellation should be avoided as it will not be supported by all backends. The maximum patch control point count portable between backends is 32.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::GeometryShader</code></td><td class="topAlign tblval"><code translate="no">33</code></td><td class="topAlign">Indicates that the geometry shader stage is supported. When supported, a geometry shader can be specified in the <a href="qrhishaderstage.html" translate="no">QRhiShaderStage</a> list. Geometry Shaders are considered an experimental feature in <a href="qrhi.html" translate="no">QRhi</a> and can only be expected to be supported with Vulkan, Direct 3D, OpenGL (3.2+) and OpenGL ES (3.2+), assuming the implementation reports it as supported at run time. Geometry shaders have portability issues between APIs, and therefore no guarantees can be given for a universal solution. They will never be supported with Metal. Whereas with Direct 3D a handwritten HLSL geometry shader must be injected into each <a href="qshader.html" translate="no">QShader</a> for the geometry stage since qsb cannot generate this from SPIR-V.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::TextureArrayRange</code></td><td class="topAlign tblval"><code translate="no">34</code></td><td class="topAlign">Indicates that for <a href="qrhi.html#newTextureArray" translate="no">texture arrays</a> it is possible to specify a range that is exposed to the shaders. Normally all array layers are exposed and it is up to the shader to select the layer (via the third coordinate passed to texture() when sampling the <code translate="no">sampler2DArray</code>). When supported, calling QRhiTexture::setArrayRangeStart() and QRhiTexture::setArrayRangeLength() before <a href="qrhitexture.html#create" translate="no">building</a> or <a href="qrhitexture.html#createFrom" translate="no">importing</a> the native texture has an effect, and leads to selecting only the specified range from the array. This will be necessary in special cases, such as when working with accelerated video decoding and Direct 3D 11, because a texture array with both <code translate="no">D3D11_BIND_DECODER</code> and <code translate="no">D3D11_BIND_SHADER_RESOURCE</code> on it is only usable as a shader resource if a single array layer is selected. Note that all this is applicable only when the texture is used as a <a href="qrhishaderresourcebinding.html#Type-enum" translate="no">QRhiShaderResourceBinding::SampledTexture</a> or <a href="qrhishaderresourcebinding.html#Type-enum" translate="no">QRhiShaderResourceBinding::Texture</a> shader resource, and is not compatible with image load/store. This feature is only available with some backends as it does not map well to all graphics APIs, and it is only meant to provide support for special cases anyhow. In practice the feature can be expected to be supported with Direct3D 11/12 and Vulkan.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::NonFillPolygonMode</code></td><td class="topAlign tblval"><code translate="no">35</code></td><td class="topAlign">Indicates that setting a PolygonMode other than the default Fill is supported for <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a>. A common use case for changing the mode to Line is to get wireframe rendering. This however is not available as a core OpenGL ES feature, and is optional with Vulkan as well as some mobile GPUs may not offer the feature.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::OneDimensionalTextures</code></td><td class="topAlign tblval"><code translate="no">36</code></td><td class="topAlign">Indicates that 1D textures are supported. In practice this feature will be unsupported on OpenGL ES.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::OneDimensionalTextureMipmaps</code></td><td class="topAlign tblval"><code translate="no">37</code></td><td class="topAlign">Indicates that generating 1D texture mipmaps are supported. In practice this feature will be unsupported on backends that do not report support for OneDimensionalTextures, Metal, and Direct 3D 12.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::HalfAttributes</code></td><td class="topAlign tblval"><code translate="no">38</code></td><td class="topAlign">Indicates that specifying input attributes with half precision (16bit) floating point types for a shader pipeline is supported. When not supported, build() will succeed but just show a warning message and the values of the target attributes will be broken. In practice this feature will be unsupported in some OpenGL ES 2.0 and OpenGL 2.x implementations. Note that while Direct3D 11/12 does support half precision input attributes, it does not support the half3 type. The D3D backends pass half3 attributes as half4. To ensure cross platform compatibility, half3 inputs should be padded to 8 bytes.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::RenderToOneDimensionalTexture</code></td><td class="topAlign tblval"><code translate="no">39</code></td><td class="topAlign">Indicates that 1D texture render targets are supported. In practice this feature will be unsupported on backends that do not report support for OneDimensionalTextures, and Metal.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::ThreeDimensionalTextureMipmaps</code></td><td class="topAlign tblval"><code translate="no">40</code></td><td class="topAlign">Indicates that generating 3D texture mipmaps are supported. In practice this feature will be unsupported with Direct 3D 12.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MultiView</code></td><td class="topAlign tblval"><code translate="no">41</code></td><td class="topAlign">Indicates that multiview, see e.g. <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_multiview.html" translate="no">VK_KHR_multiview</a> is supported. With OpenGL ES 2.0, Direct 3D 11, and OpenGL (ES) implementations without <code translate="no">GL_OVR_multiview2</code> this feature will not be supported. With Vulkan 1.1 and newer, and Direct 3D 12 multiview is typically supported. When reported as supported, creating a <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> with a <a href="qrhicolorattachment.html" translate="no">QRhiColorAttachment</a> that references a texture array and has <a href="qrhicolorattachment.html#setMultiViewCount" translate="no">multiViewCount</a> set enables recording a render pass that uses multiview rendering. In addition, any <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> used in that render pass must have <a href="qrhigraphicspipeline.html#setMultiViewCount" translate="no">the same view count set</a>. Note that multiview is only available in combination with 2D texture arrays. It cannot be used to optimize the rendering into individual textures (e.g. two, for the left and right eyes). Rather, the target of a multiview render pass is always a texture array, automatically rendering to the layer (array element) corresponding to each view. Therefore this feature implies TextureArrays as well. Multiview rendering is not supported in combination with tessellation or geometry shaders. See <a href="qrhicolorattachment.html#setMultiViewCount" translate="no">QRhiColorAttachment::setMultiViewCount</a>() for further details on multiview rendering. This enum value has been introduced in Qt 6.7.</td></tr>
</table></div>
<!-- @@@Feature -->
<!-- $$$Flag$$$EnableDebugMarkers$$$PreferSoftwareRenderer$$$EnablePipelineCacheDataSave$$$EnableTimestamps$$$SuppressSmokeTestWarnings -->
<h3 class="flags" id="Flag-enum">enum QRhi::<span class="name">Flag</span><br/>flags QRhi::<span class="name">Flags</span></h3>
<p>Describes what special features to enable.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhi::EnableDebugMarkers</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td><td class="topAlign">Enables debug marker groups. Without this frame debugging features like making debug groups and custom resource name visible in external GPU debugging tools will not be available and functions like <a href="qrhicommandbuffer.html#debugMarkBegin" translate="no">QRhiCommandBuffer::debugMarkBegin</a>() will become no-ops. Avoid enabling in production builds as it may involve a small performance impact. Has no effect when the <a href="qrhi.html#Feature-enum" translate="no">QRhi::DebugMarkers</a> feature is not reported as supported.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::EnableTimestamps</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 3</code></td><td class="topAlign">Enables GPU timestamp collection. When not set, <a href="qrhicommandbuffer.html#lastCompletedGpuTime" translate="no">QRhiCommandBuffer::lastCompletedGpuTime</a>() always returns 0. Enable this only when needed since there may be a small amount of extra work involved (e.g. timestamp queries), depending on the underlying graphics API. Has no effect when the <a href="qrhi.html#Feature-enum" translate="no">QRhi::Timestamps</a> feature is not reported as supported.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::PreferSoftwareRenderer</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 1</code></td><td class="topAlign">Indicates that backends should prefer choosing an adapter or physical device that renders in software on the CPU. For example, with Direct3D there is typically a &quot;Basic Render Driver&quot; adapter available with <code translate="no">DXGI_ADAPTER_FLAG_SOFTWARE</code>. Setting this flag requests the backend to choose that adapter over any other, as long as no specific adapter was forced by other backend-specific means. With Vulkan this maps to preferring physical devices with <code translate="no">VK_PHYSICAL_DEVICE_TYPE_CPU</code>. When not available, or when it is not possible to decide if an adapter/device is software-based, this flag is ignored. It may also be ignored with graphics APIs that have no concept and means of enumerating adapters/devices.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::EnablePipelineCacheDataSave</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 2</code></td><td class="topAlign">Enables retrieving the pipeline cache contents, where applicable. When not set, <a href="qrhi.html#pipelineCacheData" translate="no">pipelineCacheData</a>() will return an empty blob always. With backends where retrieving and restoring the pipeline cache contents is not supported, the flag has no effect and the serialized cache data is always empty. The flag provides an opt-in mechanism because the cost of maintaining the related data structures is not insignificant with some backends. With Vulkan this feature maps directly to VkPipelineCache, vkGetPipelineCacheData and VkPipelineCacheCreateInfo::pInitialData. With Direct3D 11 there is no real pipline cache, but the results of HLSL-&gt;DXBC compilations are stored and can be serialized/deserialized via this mechanism. This allows skipping the time consuming D3DCompile() in future runs of the applications for shaders that come with HLSL source instead of offline pre-compiled bytecode. This can provide a huge boost in startup and load times, if there is a lot of HLSL source compilation happening. With OpenGL the &quot;pipeline cache&quot; is simulated by retrieving and loading shader program binaries (if supported by the driver). With OpenGL there are additional, disk-based caching mechanisms for shader/program binaries provided by Qt. Writing to those may get disabled whenever this flag is set since storing program binaries to multiple caches is not sensible.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::SuppressSmokeTestWarnings</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 4</code></td><td class="topAlign">Indicates that, with backends where this is relevant, certain, non-fatal <a href="qrhi.html#create" translate="no">QRhi::create</a>() failures should not produce <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() calls. For example, with D3D11, passing this flag makes a number of warning messages (that appear due to <a href="qrhi.html#create" translate="no">QRhi::create</a>() failing) to become categorized debug prints instead under the commonly used <code translate="no">qt.rhi.general</code> logging category. This can be used by engines, such as Qt Quick, that feature fallback logic, i.e. they retry calling <a href="qrhi.html#create" translate="no">create</a>() with a different set of flags (such as, PreferSoftwareRenderer), in order to hide the unconditional warnings from the output that would be printed when the first <a href="qrhi.html#create" translate="no">create</a>() attempt had failed.</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
<!-- $$$FrameOpResult$$$FrameOpSuccess$$$FrameOpError$$$FrameOpSwapChainOutOfDate$$$FrameOpDeviceLost -->
<h3 class="fn" translate="no" id="FrameOpResult-enum">enum QRhi::<span class="name">FrameOpResult</span></h3>
<p>Describes the result of operations that can have a soft failure.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhi::FrameOpSuccess</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Success</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::FrameOpError</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Unspecified error</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::FrameOpSwapChainOutOfDate</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The swapchain is in an inconsistent state internally. This can be recoverable by attempting to repeat the operation (such as, <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>()) later.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::FrameOpDeviceLost</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The graphics device was lost. This can be recoverable by attempting to repeat the operation (such as, <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>()) after releasing and reinitializing all objects backed by native graphics resources. See <a href="qrhi.html#isDeviceLost" translate="no">isDeviceLost</a>().</td></tr>
</table></div>
<!-- @@@FrameOpResult -->
<!-- $$$Implementation$$$Null$$$Vulkan$$$OpenGLES2$$$D3D11$$$Metal$$$D3D12 -->
<h3 class="fn" translate="no" id="Implementation-enum">enum QRhi::<span class="name">Implementation</span></h3>
<p>Describes which graphics API-specific backend gets used by a <a href="qrhi.html" translate="no">QRhi</a> instance.</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">QRhi::Null</code></td><td class="topAlign tblval"><code translate="no">0</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::Vulkan</code></td><td class="topAlign tblval"><code translate="no">1</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::OpenGLES2</code></td><td class="topAlign tblval"><code translate="no">2</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::D3D11</code></td><td class="topAlign tblval"><code translate="no">3</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::D3D12</code></td><td class="topAlign tblval"><code translate="no">5</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::Metal</code></td><td class="topAlign tblval"><code translate="no">4</code></td></tr>
</table></div>
<!-- @@@Implementation -->
<!-- $$$ResourceLimit$$$TextureSizeMin$$$TextureSizeMax$$$MaxColorAttachments$$$FramesInFlight$$$MaxAsyncReadbackFrames$$$MaxThreadGroupsPerDimension$$$MaxThreadsPerThreadGroup$$$MaxThreadGroupX$$$MaxThreadGroupY$$$MaxThreadGroupZ$$$TextureArraySizeMax$$$MaxUniformBufferRange$$$MaxVertexInputs$$$MaxVertexOutputs -->
<h3 class="fn" translate="no" id="ResourceLimit-enum">enum QRhi::<span class="name">ResourceLimit</span></h3>
<p>Describes the resource limit to query.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhi::TextureSizeMin</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Minimum texture width and height. This is typically 1. The minimum texture size is handled gracefully, meaning attempting to create a texture with an empty size will instead create a texture with the minimum size.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::TextureSizeMax</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Maximum texture width and height. This depends on the graphics API and sometimes the platform or implementation as well. Typically the value is in the range 4096 - 16384. Attempting to create textures larger than this is expected to fail.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxColorAttachments</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The maximum number of color attachments for a <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>, in case multiple render targets are supported. When MRT is not supported, the value is 1. Otherwise this is typically 8, but watch out for the fact that OpenGL only mandates 4 as the minimum, and that is what some OpenGL ES implementations provide.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::FramesInFlight</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The number of frames the backend may keep &quot;in flight&quot;: with backends like Vulkan or Metal, it is the responsibility of <a href="qrhi.html" translate="no">QRhi</a> to block whenever starting a new frame and finding the CPU is already <code translate="no">N - 1</code> frames ahead of the GPU (because the command buffer submitted in frame no. <code translate="no">current</code> - <code translate="no">N</code> has not yet completed). The value N is what is returned from here, and is typically 2. This can be relevant to applications that integrate rendering done directly with the graphics API, as such rendering code may want to perform double (if the value is 2) buffering for resources, such as, buffers, similarly to the <a href="qrhi.html" translate="no">QRhi</a> backends themselves. The current frame slot index (a value running 0, 1, .., N-1, then wrapping around) is retrievable from <a href="qrhi.html#currentFrameSlot" translate="no">QRhi::currentFrameSlot</a>(). The value is 1 for backends where the graphics API offers no such low level control over the command submission process. Note that pipelining may still happen even when this value is 1 (some backends, such as D3D11, are designed to attempt to enable this, for instance, by using an update strategy for uniform buffers that does not stall the pipeline), but that is then not controlled by <a href="qrhi.html" translate="no">QRhi</a> and so not reflected here in the API.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxAsyncReadbackFrames</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The number of <a href="qrhi.html#endFrame" translate="no">submitted</a> frames (including the one that contains the readback) after which an asynchronous texture or buffer readback is guaranteed to complete upon <a href="qrhi.html#beginFrame" translate="no">starting a new frame</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxThreadGroupsPerDimension</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The maximum number of compute work/thread groups that can be dispatched. Effectively the maximum value for the arguments of <a href="qrhicommandbuffer.html#dispatch" translate="no">QRhiCommandBuffer::dispatch</a>(). Typically 65535.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxThreadsPerThreadGroup</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">The maximum number of invocations in a single local work group, or in other terminology, the maximum number of threads in a thread group. Effectively the maximum value for the product of <code translate="no">local_size_x</code>, <code translate="no">local_size_y</code>, and <code translate="no">local_size_z</code> in the compute shader. Typical values are 128, 256, 512, 1024, or 1536. Watch out that both OpenGL ES and Vulkan specify only 128 as the minimum required limit for implementations. While uncommon for Vulkan, some OpenGL ES 3.1 implementations for mobile/embedded devices only support the spec-mandated minimum value.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxThreadGroupX</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">The maximum size of a work/thread group in the X dimension. Effectively the maximum value of <code translate="no">local_size_x</code> in the compute shader. Typically 256 or 1024.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxThreadGroupY</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">The maximum size of a work/thread group in the Y dimension. Effectively the maximum value of <code translate="no">local_size_y</code> in the compute shader. Typically 256 or 1024.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxThreadGroupZ</code></td><td class="topAlign tblval"><code translate="no">10</code></td><td class="topAlign">The maximum size of a work/thread group in the Z dimension. Effectively the maximum value of <code translate="no">local_size_z</code> in the compute shader. Typically 64 or 256.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::TextureArraySizeMax</code></td><td class="topAlign tblval"><code translate="no">11</code></td><td class="topAlign">Maximum texture array size. Typically in range 256 - 2048. Attempting to <a href="qrhi.html#newTextureArray" translate="no">create a texture array</a> with more elements will likely fail.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxUniformBufferRange</code></td><td class="topAlign tblval"><code translate="no">12</code></td><td class="topAlign">The number of bytes that can be exposed from a uniform buffer to the shaders at once. On OpenGL ES 2.0 and 3.0 implementations this may be as low as 3584 bytes (224 four component, 32 bits per component vectors). Elsewhere the value is typically 16384 (1024 vec4s) or 65536 (4096 vec4s).</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxVertexInputs</code></td><td class="topAlign tblval"><code translate="no">13</code></td><td class="topAlign">The number of input attributes to the vertex shader. The location in a <a href="qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a> must be in range <code translate="no">[0, MaxVertexInputs-1]</code>. The value may be as low as 8 with OpenGL ES 2.0. Elsewhere, typical values are 16, 31, or 32.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhi::MaxVertexOutputs</code></td><td class="topAlign tblval"><code translate="no">14</code></td><td class="topAlign">The maximum number of outputs (4 component vector <code translate="no">out</code> variables) from the vertex shader. The value may be as low as 8 with OpenGL ES 2.0, and 15 with OpenGL ES 3.0 and some Metal devices. Elsewhere, a typical value is 32.</td></tr>
</table></div>
<!-- @@@ResourceLimit -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$~QRhi[overload1]$$$~QRhi -->
<h3 class="fn" translate="no" id="dtor.QRhi"><code class="details extra" translate="no">[noexcept]</code> QRhi::<span class="name">~QRhi</span>()</h3>
<p>Destructor. Destroys the backend and releases resources.</p>
<!-- @@@~QRhi -->
<!-- $$$addCleanupCallback[overload1]$$$addCleanupCallbackconstQRhi::CleanupCallback& -->
<h3 class="fn" translate="no" id="addCleanupCallback"><span class="type">void</span> QRhi::<span class="name">addCleanupCallback</span>(const <span class="type">QRhi::CleanupCallback</span> &amp;<i>callback</i>)</h3>
<p>Registers a <i translate="no">callback</i> that is invoked either when the <a href="qrhi.html" translate="no">QRhi</a> is destroyed, or when <a href="qrhi.html#runCleanup" translate="no">runCleanup</a>() is called.</p>
<p>The callback will run with the graphics resource still available, so this provides an opportunity for the application to cleanly release <a href="qrhiresource.html" translate="no">QRhiResource</a> instances belonging to the <a href="qrhi.html" translate="no">QRhi</a>. This is particularly useful for managing the lifetime of resources stored in <code translate="no">cache</code> type of objects, where the cache holds QRhiResources or objects containing QRhiResources.</p>
<p><b>See also </b><a href="qrhi.html#runCleanup" translate="no">runCleanup</a>() and <a href="qrhi.html#dtor.QRhi" translate="no">~QRhi</a>().</p>
<!-- @@@addCleanupCallback -->
<!-- $$$addCleanupCallback$$$addCleanupCallbackconstvoid*constQRhi::CleanupCallback& -->
<h3 class="fn" translate="no" id="addCleanupCallback-1"><span class="type">void</span> QRhi::<span class="name">addCleanupCallback</span>(const <span class="type">void</span> *<i>key</i>, const <span class="type">QRhi::CleanupCallback</span> &amp;<i>callback</i>)</h3>
<p>This is an overloaded function.</p>
<p>Registers <i translate="no">callback</i> to be invoked either when the <a href="qrhi.html" translate="no">QRhi</a> is destroyed or when <a href="qrhi.html#runCleanup" translate="no">runCleanup</a>() is called. This overload takes an opaque pointer, <i translate="no">key</i>, that is used to ensure that a given callback is registered (and so called) only once.</p>
<p><b>See also </b><a href="qrhi.html#removeCleanupCallback" translate="no">removeCleanupCallback</a>().</p>
<!-- @@@addCleanupCallback -->
<!-- $$$backend[overload1]$$$backend -->
<h3 class="fn" translate="no" id="backend"><span class="type"><a href="qrhi.html#Implementation-enum" translate="no">QRhi::Implementation</a></span> QRhi::<span class="name">backend</span>() const</h3>
<p>Returns the backend type for this <a href="qrhi.html" translate="no">QRhi</a>.</p>
<!-- @@@backend -->
<!-- $$$backendName[overload1]$$$backendName -->
<h3 class="fn" translate="no" id="backendName">const <span class="type">char</span> *QRhi::<span class="name">backendName</span>() const</h3>
<p>Returns the backend type as string for this <a href="qrhi.html" translate="no">QRhi</a>.</p>
<!-- @@@backendName -->
<!-- $$$backendName$$$backendNameQRhi::Implementation -->
<h3 class="fn" translate="no" id="backendName-1"><code class="details extra" translate="no">[static]</code> const <span class="type">char</span> *QRhi::<span class="name">backendName</span>(<span class="type"><a href="qrhi.html#Implementation-enum" translate="no">QRhi::Implementation</a></span> <i>impl</i>)</h3>
<p>Returns a friendly name for the backend <i translate="no">impl</i>, usually the name of the 3D API in use.</p>
<!-- @@@backendName -->
<!-- $$$beginFrame[overload1]$$$beginFrameQRhiSwapChain*QRhi::BeginFrameFlags -->
<h3 class="fn" translate="no" id="beginFrame"><span class="type"><a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpResult</a></span> QRhi::<span class="name">beginFrame</span>(<span class="type"><a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a></span> *<i>swapChain</i>, <span class="type"><a href="qrhi.html#BeginFrameFlag-enum" translate="no">QRhi::BeginFrameFlags</a></span> <i>flags</i> = {})</h3>
<p>Starts a new frame targeting the next available buffer of <i translate="no">swapChain</i>.</p>
<p>A frame consists of resource updates and one or more render and compute passes.</p>
<p><i translate="no">flags</i> can indicate certain special cases.</p>
<p>The high level pattern of rendering into a <a href="qwindow.html" translate="no">QWindow</a> using a swapchain:</p>
<ul>
<li>Create a swapchain.</li>
<li>Call <a href="qrhiswapchain.html#createOrResize" translate="no">QRhiSwapChain::createOrResize</a>() whenever the surface size is different than before.</li>
<li>Call <a href="qrhiresource.html#destroy" translate="no">QRhiSwapChain::destroy</a>() on <a href="qplatformsurfaceevent.html#SurfaceEventType-enum" translate="no">QPlatformSurfaceEvent::SurfaceAboutToBeDestroyed</a>.</li>
<li>Then on every frame:<pre class="cpp plain" translate="no">
 beginFrame(sc);
 updates = nextResourceUpdateBatch();
 updates-&gt;...
 QRhiCommandBuffer *cb = sc-&gt;currentFrameCommandBuffer();
 cb-&gt;beginPass(sc-&gt;currentFrameRenderTarget(), colorClear, dsClear, updates);
 ...
 cb-&gt;endPass();
 ... // more passes as necessary
 endFrame(sc);
</pre>
</li>
</ul>
<p>Returns <a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpSuccess</a> on success, or another <a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpResult</a> value on failure. Some of these should be treated as soft, &quot;try again later&quot; type of errors: When <a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpSwapChainOutOfDate</a> is returned, the swapchain is to be resized or updated by calling <a href="qrhiswapchain.html#createOrResize" translate="no">QRhiSwapChain::createOrResize</a>(). The application should then attempt to generate a new frame. <a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpDeviceLost</a> means the graphics device is lost but this may also be recoverable by releasing all resources, including the <a href="qrhi.html" translate="no">QRhi</a> itself, and then recreating all resources. See <a href="qrhi.html#isDeviceLost" translate="no">isDeviceLost</a>() for further discussion.</p>
<p><b>See also </b><a href="qrhi.html#endFrame" translate="no">endFrame</a>(), <a href="qrhi.html#beginOffscreenFrame" translate="no">beginOffscreenFrame</a>(), and <a href="qrhi.html#isDeviceLost" translate="no">isDeviceLost</a>().</p>
<!-- @@@beginFrame -->
<!-- $$$beginOffscreenFrame[overload1]$$$beginOffscreenFrameQRhiCommandBuffer**QRhi::BeginFrameFlags -->
<h3 class="fn" translate="no" id="beginOffscreenFrame"><span class="type"><a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpResult</a></span> QRhi::<span class="name">beginOffscreenFrame</span>(<span class="type"><a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> **<i>cb</i>, <span class="type"><a href="qrhi.html#BeginFrameFlag-enum" translate="no">QRhi::BeginFrameFlags</a></span> <i>flags</i> = {})</h3>
<p>Starts a new offscreen frame. Provides a command buffer suitable for recording rendering commands in <i translate="no">cb</i>. <i translate="no">flags</i> is used to indicate certain special cases, just like with <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>().</p>
<div class="admonition note">
<p><b>Note: </b>The <a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> stored to *cb is not owned by the caller.</p>
</div>
<p>Rendering without a swapchain is possible as well. The typical use case is to use it in completely offscreen applications, e.g. to generate image sequences by rendering and reading back without ever showing a window.</p>
<p>Usage in on-screen applications (so <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>, <a href="qrhi.html#endFrame" translate="no">endFrame</a>, beginOffscreenFrame, <a href="qrhi.html#endOffscreenFrame" translate="no">endOffscreenFrame</a>, <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>, ...) is possible too but it does reduce parallelism so it should be done only infrequently.</p>
<p>Offscreen frames do not let the CPU potentially generate another frame while the GPU is still processing the previous one. This has the side effect that if readbacks are scheduled, the results are guaranteed to be available once <a href="qrhi.html#endOffscreenFrame" translate="no">endOffscreenFrame</a>() returns. That is not the case with frames targeting a swapchain: there the GPU is potentially better utilized, but working with readback operations needs more care from the application because <a href="qrhi.html#endFrame" translate="no">endFrame</a>(), unlike <a href="qrhi.html#endOffscreenFrame" translate="no">endOffscreenFrame</a>(), does not guarantee that the results from the readback are available at that point.</p>
<p>The skeleton of rendering a frame without a swapchain and then reading the frame contents back could look like the following:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qrhireadbackresult.html" translate="no">QRhiReadbackResult</a></span> rbResult;
 <span class="type"><a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb;
 rhi<span class="operator">-</span><span class="operator">&gt;</span>beginOffscreenFrame(<span class="operator">&amp;</span>cb);
 cb<span class="operator">-</span><span class="operator">&gt;</span>beginPass(rt<span class="operator">,</span> colorClear<span class="operator">,</span> dsClear);
 <span class="comment">// ...</span>
 u <span class="operator">=</span> nextResourceUpdateBatch();
 u<span class="operator">-</span><span class="operator">&gt;</span>readBackTexture(rb<span class="operator">,</span> <span class="operator">&amp;</span>rbResult);
 cb<span class="operator">-</span><span class="operator">&gt;</span>endPass(u);
 rhi<span class="operator">-</span><span class="operator">&gt;</span>endOffscreenFrame();
 <span class="comment">// image data available in rbResult</span>
</pre>
<p><b>See also </b><a href="qrhi.html#endOffscreenFrame" translate="no">endOffscreenFrame</a>() and <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>().</p>
<!-- @@@beginOffscreenFrame -->
<!-- $$$clipSpaceCorrMatrix[overload1]$$$clipSpaceCorrMatrix -->
<h3 class="fn" translate="no" id="clipSpaceCorrMatrix"><span class="type"><a href="qmatrix4x4.html" translate="no">QMatrix4x4</a></span> QRhi::<span class="name">clipSpaceCorrMatrix</span>() const</h3>
<p>Returns a matrix that can be used to allow applications keep using OpenGL-targeted vertex data and perspective projection matrices (such as, the ones generated by <a href="qmatrix4x4.html#perspective" translate="no">QMatrix4x4::perspective</a>()), regardless of the active <a href="qrhi.html" translate="no">QRhi</a> backend.</p>
<p>In a typical renderer, once <code translate="no">this_matrix * mvp</code> is used instead of just <code translate="no">mvp</code>, vertex data with Y up and viewports with depth range 0 - 1 can be used without considering what backend (and so graphics API) is going to be used at run time. This way branching based on <a href="qrhi.html#isYUpInNDC" translate="no">isYUpInNDC</a>() and <a href="qrhi.html#isClipDepthZeroToOne" translate="no">isClipDepthZeroToOne</a>() can be avoided (although such logic may still become required when implementing certain advanced graphics techniques).</p>
<p>See <a href="https://matthewwellings.com/blog/the-new-vulkan-coordinate-system/" translate="no">this page</a> for a discussion of the topic from Vulkan perspective.</p>
<!-- @@@clipSpaceCorrMatrix -->
<!-- $$$create[overload1]$$$createQRhi::ImplementationQRhiInitParams*QRhi::FlagsQRhiNativeHandles* -->
<h3 class="fn" translate="no" id="create"><code class="details extra" translate="no">[static]</code> <span class="type">QRhi</span> *QRhi::<span class="name">create</span>(<span class="type"><a href="qrhi.html#Implementation-enum" translate="no">QRhi::Implementation</a></span> <i>impl</i>, <span class="type"><a href="qrhiinitparams.html" translate="no">QRhiInitParams</a></span> *<i>params</i>, <span class="type"><a href="qrhi.html#Flag-enum" translate="no">QRhi::Flags</a></span> <i>flags</i> = {}, <span class="type"><a href="qrhinativehandles.html" translate="no">QRhiNativeHandles</a></span> *<i>importDevice</i> = nullptr)</h3>
<p>Returns a new <a href="qrhi.html" translate="no">QRhi</a> instance with a backend for the graphics API specified by <i translate="no">impl</i> with the specified <i translate="no">flags</i>.</p>
<p><i translate="no">params</i> must point to an instance of one of the backend-specific subclasses of <a href="qrhiinitparams.html" translate="no">QRhiInitParams</a>, such as, <a href="qrhivulkaninitparams.html" translate="no">QRhiVulkanInitParams</a>, <a href="qrhimetalinitparams.html" translate="no">QRhiMetalInitParams</a>, <a href="qrhid3d11initparams.html" translate="no">QRhiD3D11InitParams</a>, <a href="qrhid3d12initparams.html" translate="no">QRhiD3D12InitParams</a>, <a href="qrhigles2initparams.html" translate="no">QRhiGles2InitParams</a>. See these classes for examples on creating a <a href="qrhi.html" translate="no">QRhi</a>.</p>
<p><a href="qrhi.html" translate="no">QRhi</a> by design does not implement any fallback logic: if the specified API cannot be initialized, create() will fail, with warnings printed on the debug output by the backends. The clients of <a href="qrhi.html" translate="no">QRhi</a>, for example Qt Quick, may however provide additional logic that allow falling back to an API different than what was requested, depending on the platform. If the intention is just to test if initialization would succeed when calling create() at later point, it is preferable to use <a href="qrhi.html#probe" translate="no">probe</a>() instead of create(), because with some backends probing can be implemented in a more lightweight manner as opposed to create(), which performs full initialization of the infrastructure and is wasteful if that <a href="qrhi.html" translate="no">QRhi</a> instance is then thrown immediately away.</p>
<p><i translate="no">importDevice</i> allows using an already existing graphics device, without <a href="qrhi.html" translate="no">QRhi</a> creating its own. When not null, this parameter must point to an instance of one of the subclasses of <a href="qrhinativehandles.html" translate="no">QRhiNativeHandles</a>: <a href="qrhivulkannativehandles.html" translate="no">QRhiVulkanNativeHandles</a>, <a href="qrhid3d11nativehandles.html" translate="no">QRhiD3D11NativeHandles</a>, <a href="qrhid3d12nativehandles.html" translate="no">QRhiD3D12NativeHandles</a>, <a href="qrhimetalnativehandles.html" translate="no">QRhiMetalNativeHandles</a>, <a href="qrhigles2nativehandles.html" translate="no">QRhiGles2NativeHandles</a>. The exact details and semantics depend on the backand and the underlying graphics API.</p>
<p><b>See also </b><a href="qrhi.html#probe" translate="no">probe</a>().</p>
<!-- @@@create -->
<!-- $$$currentFrameSlot[overload1]$$$currentFrameSlot -->
<h3 class="fn" translate="no" id="currentFrameSlot"><span class="type">int</span> QRhi::<span class="name">currentFrameSlot</span>() const</h3>
<p>Returns the current frame slot index while recording a frame. Unspecified when called outside an active frame (that is, when <a href="qrhi.html#isRecordingFrame" translate="no">isRecordingFrame</a>() is <code translate="no">false</code>).</p>
<p>With backends like Vulkan or Metal, it is the responsibility of the <a href="qrhi.html" translate="no">QRhi</a> backend to block whenever starting a new frame and finding the CPU is already <code translate="no">FramesInFlight - 1</code> frames ahead of the GPU (because the command buffer submitted in frame no. <code translate="no">current</code> - <code translate="no">FramesInFlight</code> has not yet completed).</p>
<p>Resources that tend to change between frames (such as, the native buffer object backing a <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> with type <a href="qrhibuffer.html#Type-enum" translate="no">QRhiBuffer::Dynamic</a>) exist in multiple versions, so that each frame, that can be submitted while a previous one is still being processed, works with its own copy, thus avoiding the need to stall the pipeline when preparing the frame. (The contents of a resource that may still be in use in the GPU should not be touched, but simply always waiting for the previous frame to finish would reduce GPU utilization and ultimately, performance and efficiency.)</p>
<p>Conceptually this is somewhat similar to copy-on-write schemes used by some C++ containers and other types. It may also be similar to what an OpenGL or Direct 3D 11 implementation performs internally for certain type of objects.</p>
<p>In practice, such double (or triple) buffering resources is realized in the Vulkan, Metal, and similar <a href="qrhi.html" translate="no">QRhi</a> backends by having a fixed number of native resource (such as, VkBuffer) <code translate="no">slots</code> behind a <a href="qrhiresource.html" translate="no">QRhiResource</a>. That can then be indexed by a frame slot index running 0, 1, .., <a href="qrhi.html#ResourceLimit-enum" translate="no">FramesInFlight</a>-1, and then wrapping around.</p>
<p>All this is managed transparently to the users of <a href="qrhi.html" translate="no">QRhi</a>. However, applications that integrate rendering done directly with the graphics API may want to perform a similar double or triple buffering of their own graphics resources. That is then most easily achieved by knowing the values of the maximum number of in-flight frames (retrievable via <a href="qrhi.html#resourceLimit" translate="no">resourceLimit</a>()) and the current frame (slot) index (returned by this function).</p>
<p><b>See also </b><a href="qrhi.html#isRecordingFrame" translate="no">isRecordingFrame</a>(), <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>(), and <a href="qrhi.html#endFrame" translate="no">endFrame</a>().</p>
<!-- @@@currentFrameSlot -->
<!-- $$$driverInfo[overload1]$$$driverInfo -->
<h3 class="fn" translate="no" id="driverInfo"><span class="type"><a href="qrhidriverinfo.html" translate="no">QRhiDriverInfo</a></span> QRhi::<span class="name">driverInfo</span>() const</h3>
<p>Returns metadata for the graphics device used by this successfully initialized <a href="qrhi.html" translate="no">QRhi</a> instance.</p>
<!-- @@@driverInfo -->
<!-- $$$endFrame[overload1]$$$endFrameQRhiSwapChain*QRhi::EndFrameFlags -->
<h3 class="fn" translate="no" id="endFrame"><span class="type"><a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpResult</a></span> QRhi::<span class="name">endFrame</span>(<span class="type"><a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a></span> *<i>swapChain</i>, <span class="type"><a href="qrhi.html#EndFrameFlag-enum" translate="no">QRhi::EndFrameFlags</a></span> <i>flags</i> = {})</h3>
<p>Ends, commits, and presents a frame that was started in the last <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>() on <i translate="no">swapChain</i>.</p>
<p>Double (or triple) buffering is managed internally by the <a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a> and <a href="qrhi.html" translate="no">QRhi</a>.</p>
<p><i translate="no">flags</i> can optionally be used to change the behavior in certain ways. Passing <a href="qrhi.html#EndFrameFlag-enum" translate="no">QRhi::SkipPresent</a> skips queuing the Present command or calling swapBuffers.</p>
<p>Returns <a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpSuccess</a> on success, or another <a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpResult</a> value on failure. Some of these should be treated as soft, &quot;try again later&quot; type of errors: When <a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpSwapChainOutOfDate</a> is returned, the swapchain is to be resized or updated by calling <a href="qrhiswapchain.html#createOrResize" translate="no">QRhiSwapChain::createOrResize</a>(). The application should then attempt to generate a new frame. <a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpDeviceLost</a> means the graphics device is lost but this may also be recoverable by releasing all resources, including the <a href="qrhi.html" translate="no">QRhi</a> itself, and then recreating all resources. See <a href="qrhi.html#isDeviceLost" translate="no">isDeviceLost</a>() for further discussion.</p>
<p><b>See also </b><a href="qrhi.html#beginFrame" translate="no">beginFrame</a>() and <a href="qrhi.html#isDeviceLost" translate="no">isDeviceLost</a>().</p>
<!-- @@@endFrame -->
<!-- $$$endOffscreenFrame[overload1]$$$endOffscreenFrameQRhi::EndFrameFlags -->
<h3 class="fn" translate="no" id="endOffscreenFrame"><span class="type"><a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpResult</a></span> QRhi::<span class="name">endOffscreenFrame</span>(<span class="type"><a href="qrhi.html#EndFrameFlag-enum" translate="no">QRhi::EndFrameFlags</a></span> <i>flags</i> = {})</h3>
<p>Ends, submits, and waits for the offscreen frame.</p>
<p><i translate="no">flags</i> is not currently used.</p>
<p><b>See also </b><a href="qrhi.html#beginOffscreenFrame" translate="no">beginOffscreenFrame</a>().</p>
<!-- @@@endOffscreenFrame -->
<!-- $$$finish[overload1]$$$finish -->
<h3 class="fn" translate="no" id="finish"><span class="type"><a href="qrhi.html#FrameOpResult-enum" translate="no">QRhi::FrameOpResult</a></span> QRhi::<span class="name">finish</span>()</h3>
<p>Waits for any work on the graphics queue (where applicable) to complete, then executes all deferred operations, like completing readbacks and resource releases. Can be called inside and outside of a frame, but not inside a pass. Inside a frame it implies submitting any work on the command buffer.</p>
<div class="admonition note">
<p><b>Note: </b>Avoid this function. One case where it may be needed is when the results of an enqueued readback in a swapchain-based frame are needed at a fixed given point and so waiting for the results is desired.</p>
</div>
<!-- @@@finish -->
<!-- $$$isClipDepthZeroToOne[overload1]$$$isClipDepthZeroToOne -->
<h3 class="fn" translate="no" id="isClipDepthZeroToOne"><span class="type">bool</span> QRhi::<span class="name">isClipDepthZeroToOne</span>() const</h3>
<p>Returns <code translate="no">true</code> if the underlying graphics API uses depth range [0, 1] in clip space.</p>
<p>In practice this is <code translate="no">false</code> for OpenGL only, because OpenGL uses a post-projection depth range of [-1, 1]. (not to be confused with the NDC-to-window mapping controlled by glDepthRange(), which uses a range of [0, 1], unless overridden by the <a href="qrhiviewport.html" translate="no">QRhiViewport</a>) In some OpenGL versions glClipControl() could be used to change this, but the OpenGL backend of <a href="qrhi.html" translate="no">QRhi</a> does not use that function as it is not available in OpenGL ES or OpenGL versions lower than 4.5.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhi.html#clipSpaceCorrMatrix" translate="no">clipSpaceCorrMatrix</a>() includes the corresponding adjustment in its returned matrix. Therefore, many users of <a href="qrhi.html" translate="no">QRhi</a> do not need to take any further measures apart from pre-multiplying their projection matrices with <a href="qrhi.html#clipSpaceCorrMatrix" translate="no">clipSpaceCorrMatrix</a>(). However, some graphics techniques, such as, some types of shadow mapping, involve working with and outputting depth values in the shaders. These will need to query and take the value of this function into account as appropriate.</p>
</div>
<!-- @@@isClipDepthZeroToOne -->
<!-- $$$isDeviceLost[overload1]$$$isDeviceLost -->
<h3 class="fn" translate="no" id="isDeviceLost"><span class="type">bool</span> QRhi::<span class="name">isDeviceLost</span>() const</h3>
<p>Returns true if the graphics device was lost.</p>
<p>The loss of the device is typically detected in <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>(), <a href="qrhi.html#endFrame" translate="no">endFrame</a>() or <a href="qrhiswapchain.html#createOrResize" translate="no">QRhiSwapChain::createOrResize</a>(), depending on the backend and the underlying native APIs. The most common is <a href="qrhi.html#endFrame" translate="no">endFrame</a>() because that is where presenting happens. With some backends <a href="qrhiswapchain.html#createOrResize" translate="no">QRhiSwapChain::createOrResize</a>() can also fail due to a device loss. Therefore this function is provided as a generic way to check if a device loss was detected by a previous operation.</p>
<p>When the device is lost, no further operations should be done via the <a href="qrhi.html" translate="no">QRhi</a>. Rather, all <a href="qrhi.html" translate="no">QRhi</a> resources should be released, followed by destroying the <a href="qrhi.html" translate="no">QRhi</a>. A new <a href="qrhi.html" translate="no">QRhi</a> can then be attempted to be created. If successful, all graphics resources must be reinitialized. If not, try again later, repeatedly.</p>
<p>While simple applications may decide to not care about device loss, on the commonly used desktop platforms a device loss can happen due to a variety of reasons, including physically disconnecting the graphics adapter, disabling the device or driver, uninstalling or upgrading the graphics driver, or due to errors that lead to a graphics device reset. Some of these can happen under perfectly normal circumstances as well, for example the upgrade of the graphics driver to a newer version is a common task that can happen at any time while a Qt application is running. Users may very well expect applications to be able to survive this, even when the application is actively using an API like OpenGL or Direct3D.</p>
<p>Qt's own frameworks built on top of <a href="qrhi.html" translate="no">QRhi</a>, such as, Qt Quick, can be expected to handle and take appropriate measures when a device loss occurs. If the data for graphics resources, such as textures and buffers, are still available on the CPU side, such an event may not be noticeable on the application level at all since graphics resources can seamlessly be reinitialized then. However, applications and libraries working directly with <a href="qrhi.html" translate="no">QRhi</a> are expected to be prepared to check and handle device loss situations themselves.</p>
<div class="admonition note">
<p><b>Note: </b>With OpenGL, applications may need to opt-in to context reset notifications by setting <a href="qsurfaceformat.html#FormatOption-enum" translate="no">QSurfaceFormat::ResetNotification</a> on the <a href="qopenglcontext.html" translate="no">QOpenGLContext</a>. This is typically done by enabling the flag in <a href="qrhigles2initparams.html#format-var" translate="no">QRhiGles2InitParams::format</a>. Keep in mind however that some systems may generate context resets situations even when this flag is not set.</p>
</div>
<!-- @@@isDeviceLost -->
<!-- $$$isFeatureSupported[overload1]$$$isFeatureSupportedQRhi::Feature -->
<h3 class="fn" translate="no" id="isFeatureSupported"><span class="type">bool</span> QRhi::<span class="name">isFeatureSupported</span>(<span class="type"><a href="qrhi.html#Feature-enum" translate="no">QRhi::Feature</a></span> <i>feature</i>) const</h3>
<p>Returns <code translate="no">true</code> if the specified <i translate="no">feature</i> is supported</p>
<!-- @@@isFeatureSupported -->
<!-- $$$isRecordingFrame[overload1]$$$isRecordingFrame -->
<h3 class="fn" translate="no" id="isRecordingFrame"><span class="type">bool</span> QRhi::<span class="name">isRecordingFrame</span>() const</h3>
<p>Returns true when there is an active frame, meaning there was a <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>() (or <a href="qrhi.html#beginOffscreenFrame" translate="no">beginOffscreenFrame</a>()) with no corresponding <a href="qrhi.html#endFrame" translate="no">endFrame</a>() (or <a href="qrhi.html#endOffscreenFrame" translate="no">endOffscreenFrame</a>()) yet.</p>
<p><b>See also </b><a href="qrhi.html#currentFrameSlot" translate="no">currentFrameSlot</a>(), <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>(), and <a href="qrhi.html#endFrame" translate="no">endFrame</a>().</p>
<!-- @@@isRecordingFrame -->
<!-- $$$isTextureFormatSupported[overload1]$$$isTextureFormatSupportedQRhiTexture::FormatQRhiTexture::Flags -->
<h3 class="fn" translate="no" id="isTextureFormatSupported"><span class="type">bool</span> QRhi::<span class="name">isTextureFormatSupported</span>(<span class="type"><a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::Format</a></span> <i>format</i>, <span class="type"><a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::Flags</a></span> <i>flags</i> = {}) const</h3>
<p>Returns <code translate="no">true</code> if the specified texture <i translate="no">format</i> modified by <i translate="no">flags</i> is supported.</p>
<p>The query is supported both for uncompressed and compressed formats.</p>
<!-- @@@isTextureFormatSupported -->
<!-- $$$isYUpInFramebuffer[overload1]$$$isYUpInFramebuffer -->
<h3 class="fn" translate="no" id="isYUpInFramebuffer"><span class="type">bool</span> QRhi::<span class="name">isYUpInFramebuffer</span>() const</h3>
<p>Returns <code translate="no">true</code> if the underlying graphics API has the Y axis pointing up in framebuffers and images.</p>
<p>In practice this is <code translate="no">true</code> for OpenGL only.</p>
<!-- @@@isYUpInFramebuffer -->
<!-- $$$isYUpInNDC[overload1]$$$isYUpInNDC -->
<h3 class="fn" translate="no" id="isYUpInNDC"><span class="type">bool</span> QRhi::<span class="name">isYUpInNDC</span>() const</h3>
<p>Returns <code translate="no">true</code> if the underlying graphics API has the Y axis pointing up in its normalized device coordinate system.</p>
<p>In practice this is <code translate="no">false</code> for Vulkan only.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhi.html#clipSpaceCorrMatrix" translate="no">clipSpaceCorrMatrix</a>() includes the corresponding adjustment (to make Y point up) in its returned matrix.</p>
</div>
<!-- @@@isYUpInNDC -->
<!-- $$$makeThreadLocalNativeContextCurrent[overload1]$$$makeThreadLocalNativeContextCurrent -->
<h3 class="fn" translate="no" id="makeThreadLocalNativeContextCurrent"><span class="type">bool</span> QRhi::<span class="name">makeThreadLocalNativeContextCurrent</span>()</h3>
<p>With OpenGL this makes the OpenGL context current on the current thread. The function has no effect with other backends.</p>
<p>Calling this function is relevant typically in Qt framework code, when one has to ensure external OpenGL code provided by the application can still run like it did before with direct usage of OpenGL, as long as the <a href="qrhi.html" translate="no">QRhi</a> is using the OpenGL backend.</p>
<p>Returns false when failed, similarly to <a href="qopenglcontext.html#makeCurrent" translate="no">QOpenGLContext::makeCurrent</a>(). When the operation failed, <a href="qrhi.html#isDeviceLost" translate="no">isDeviceLost</a>() can be called to determine if there was a loss of context situation. Such a check is equivalent to checking via <a href="qopenglcontext.html#isValid" translate="no">QOpenGLContext::isValid</a>().</p>
<p><b>See also </b><a href="qopenglcontext.html#makeCurrent" translate="no">QOpenGLContext::makeCurrent</a>() and <a href="qopenglcontext.html#isValid" translate="no">QOpenGLContext::isValid</a>().</p>
<!-- @@@makeThreadLocalNativeContextCurrent -->
<!-- $$$mipLevelsForSize[overload1]$$$mipLevelsForSizeconstQSize& -->
<h3 class="fn" translate="no" id="mipLevelsForSize"><code class="details extra" translate="no">[static]</code> <span class="type">int</span> QRhi::<span class="name">mipLevelsForSize</span>(const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>size</i>)</h3>
<p>Returns the number of mip levels for a given <i translate="no">size</i>.</p>
<!-- @@@mipLevelsForSize -->
<!-- $$$nativeHandles[overload1]$$$nativeHandles -->
<h3 class="fn" translate="no" id="nativeHandles">const <span class="type"><a href="qrhinativehandles.html" translate="no">QRhiNativeHandles</a></span> *QRhi::<span class="name">nativeHandles</span>()</h3>
<p>Returns a pointer to the backend-specific collection of native objects for the device, context, and similar concepts used by the backend.</p>
<p>Cast to <a href="qrhivulkannativehandles.html" translate="no">QRhiVulkanNativeHandles</a>, <a href="qrhid3d11nativehandles.html" translate="no">QRhiD3D11NativeHandles</a>, <a href="qrhid3d12nativehandles.html" translate="no">QRhiD3D12NativeHandles</a>, <a href="qrhigles2nativehandles.html" translate="no">QRhiGles2NativeHandles</a>, or <a href="qrhimetalnativehandles.html" translate="no">QRhiMetalNativeHandles</a> as appropriate.</p>
<div class="admonition note">
<p><b>Note: </b>No ownership is transferred, neither for the returned pointer nor for any native objects.</p>
</div>
<!-- @@@nativeHandles -->
<!-- $$$newBuffer[overload1]$$$newBufferQRhiBuffer::TypeQRhiBuffer::UsageFlagsquint32 -->
<h3 class="fn" translate="no" id="newBuffer"><span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *QRhi::<span class="name">newBuffer</span>(<span class="type"><a href="qrhibuffer.html#Type-enum" translate="no">QRhiBuffer::Type</a></span> <i>type</i>, <span class="type"><a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::UsageFlags</a></span> <i>usage</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>size</i>)</h3>
<p>Returns a new buffer with the specified <i translate="no">type</i>, <i translate="no">usage</i>, and <i translate="no">size</i>.</p>
<div class="admonition note">
<p><b>Note: </b>Some <i translate="no">usage</i> and <i translate="no">type</i> combinations may not be supported by all backends. See <a href="qrhibuffer.html#UsageFlag-enum" translate="no">UsageFlags</a> and <a href="qrhi.html#Feature-enum" translate="no">the feature flags</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Backends may choose to allocate buffers bigger than <i translate="no">size</i>. This is done transparently to applications, so there are no special restrictions on the value of <i translate="no">size</i>. <a href="qrhibuffer.html#size" translate="no">QRhiBuffer::size</a>() will always report back the value that was requested in <i translate="no">size</i>.</p>
</div>
<p><b>See also </b><a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>().</p>
<!-- @@@newBuffer -->
<!-- $$$newComputePipeline[overload1]$$$newComputePipeline -->
<h3 class="fn" translate="no" id="newComputePipeline"><span class="type"><a href="qrhicomputepipeline.html" translate="no">QRhiComputePipeline</a></span> *QRhi::<span class="name">newComputePipeline</span>()</h3>
<p>Returns a new compute pipeline resource.</p>
<div class="admonition note">
<p><b>Note: </b>Compute is only available when the <a href="qrhi.html#Feature-enum" translate="no">Compute</a> feature is reported as supported.</p>
</div>
<p><b>See also </b><a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>().</p>
<!-- @@@newComputePipeline -->
<!-- $$$newGraphicsPipeline[overload1]$$$newGraphicsPipeline -->
<h3 class="fn" translate="no" id="newGraphicsPipeline"><span class="type"><a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a></span> *QRhi::<span class="name">newGraphicsPipeline</span>()</h3>
<p>Returns a new graphics pipeline resource.</p>
<p><b>See also </b><a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>().</p>
<!-- @@@newGraphicsPipeline -->
<!-- $$$newRenderBuffer[overload1]$$$newRenderBufferQRhiRenderBuffer::TypeconstQSize&intQRhiRenderBuffer::FlagsQRhiTexture::Format -->
<h3 class="fn" translate="no" id="newRenderBuffer"><span class="type"><a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *QRhi::<span class="name">newRenderBuffer</span>(<span class="type"><a href="qrhirenderbuffer.html#Type-enum" translate="no">QRhiRenderBuffer::Type</a></span> <i>type</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1, <span class="type"><a href="qrhirenderbuffer.html#Flag-enum" translate="no">QRhiRenderBuffer::Flags</a></span> <i>flags</i> = {}, <span class="type"><a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::Format</a></span> <i>backingFormatHint</i> = QRhiTexture::UnknownFormat)</h3>
<p>Returns a new renderbuffer with the specified <i translate="no">type</i>, <i translate="no">pixelSize</i>, <i translate="no">sampleCount</i>, and <i translate="no">flags</i>.</p>
<p>When <i translate="no">backingFormatHint</i> is set to a texture format other than <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::UnknownFormat</a>, it may be used by the backend to decide what format to use for the storage backing the renderbuffer.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">backingFormatHint</i> becomes relevant typically when multisampling and floating point texture formats are involved: rendering into a multisample <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> and then resolving into a non-RGBA8 <a href="qrhitexture.html" translate="no">QRhiTexture</a> implies (with some graphics APIs) that the storage backing the <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> uses the matching non-RGBA8 format. That means that passing a format like <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::RGBA32F</a> is important, because backends will typically opt for <a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::RGBA8</a> by default, which would then break later on due to attempting to set up RGBA8-&gt;RGBA32F multisample resolve in the color attachment(s) of the <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>.</p>
</div>
<p><b>See also </b><a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>().</p>
<!-- @@@newRenderBuffer -->
<!-- $$$newSampler[overload1]$$$newSamplerQRhiSampler::FilterQRhiSampler::FilterQRhiSampler::FilterQRhiSampler::AddressModeQRhiSampler::AddressModeQRhiSampler::AddressMode -->
<h3 class="fn" translate="no" id="newSampler"><span class="type"><a href="qrhisampler.html" translate="no">QRhiSampler</a></span> *QRhi::<span class="name">newSampler</span>(<span class="type"><a href="qrhisampler.html#Filter-enum" translate="no">QRhiSampler::Filter</a></span> <i>magFilter</i>, <span class="type"><a href="qrhisampler.html#Filter-enum" translate="no">QRhiSampler::Filter</a></span> <i>minFilter</i>, <span class="type"><a href="qrhisampler.html#Filter-enum" translate="no">QRhiSampler::Filter</a></span> <i>mipmapMode</i>, <span class="type"><a href="qrhisampler.html#AddressMode-enum" translate="no">QRhiSampler::AddressMode</a></span> <i>addressU</i>, <span class="type"><a href="qrhisampler.html#AddressMode-enum" translate="no">QRhiSampler::AddressMode</a></span> <i>addressV</i>, <span class="type"><a href="qrhisampler.html#AddressMode-enum" translate="no">QRhiSampler::AddressMode</a></span> <i>addressW</i> = QRhiSampler::Repeat)</h3>
<p>Returns a new sampler with the specified magnification filter <i translate="no">magFilter</i>, minification filter <i translate="no">minFilter</i>, mipmapping mode <i translate="no">mipmapMode</i>, and the addressing (wrap) modes <i translate="no">addressU</i>, <i translate="no">addressV</i>, and <i translate="no">addressW</i>.</p>
<div class="admonition note">
<p><b>Note: </b>Setting <i translate="no">mipmapMode</i> to a value other than <code translate="no">None</code> implies that images for all relevant mip levels will be provided either via <a href="qrhiresourceupdatebatch.html#uploadTexture" translate="no">texture uploads</a> or by calling <a href="qrhiresourceupdatebatch.html#generateMips" translate="no">generateMips</a>() on the texture that is used with this sampler. Attempting to use the sampler with a texture that has no data for all relevant mip levels will lead to rendering errors, with the exact behavior dependent on the underlying graphics API.</p>
</div>
<p><b>See also </b><a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>().</p>
<!-- @@@newSampler -->
<!-- $$$newShaderResourceBindings[overload1]$$$newShaderResourceBindings -->
<h3 class="fn" translate="no" id="newShaderResourceBindings"><span class="type"><a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a></span> *QRhi::<span class="name">newShaderResourceBindings</span>()</h3>
<p>Returns a new shader resource binding collection resource.</p>
<p><b>See also </b><a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>().</p>
<!-- @@@newShaderResourceBindings -->
<!-- $$$newSwapChain[overload1]$$$newSwapChain -->
<h3 class="fn" translate="no" id="newSwapChain"><span class="type"><a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a></span> *QRhi::<span class="name">newSwapChain</span>()</h3>
<p>Returns a new swapchain.</p>
<p><b>See also </b><a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>() and <a href="qrhiswapchain.html#createOrResize" translate="no">QRhiSwapChain::createOrResize</a>().</p>
<!-- @@@newSwapChain -->
<!-- $$$newTexture[overload1]$$$newTextureQRhiTexture::FormatconstQSize&intQRhiTexture::Flags -->
<h3 class="fn" translate="no" id="newTexture"><span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *QRhi::<span class="name">newTexture</span>(<span class="type"><a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::Format</a></span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1, <span class="type"><a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::Flags</a></span> <i>flags</i> = {})</h3>
<p>Returns a new 1D or 2D texture with the specified <i translate="no">format</i>, <i translate="no">pixelSize</i>, <i translate="no">sampleCount</i>, and <i translate="no">flags</i>.</p>
<p>A 1D texture array must have <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::OneDimensional</a> set in <i translate="no">flags</i>. This function will implicitly set this flag if the <i translate="no">pixelSize</i> height is 0.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">format</i> specifies the requested internal and external format, meaning the data to be uploaded to the texture will need to be in a compatible format, while the native texture may (but is not guaranteed to, in case of OpenGL at least) use this format internally.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>1D textures are only functional when the <a href="qrhi.html#Feature-enum" translate="no">OneDimensionalTextures</a> feature is reported as supported at run time. Further, mipmaps on 1D textures are only functional when the <a href="qrhi.html#Feature-enum" translate="no">OneDimensionalTextureMipmaps</a> feature is reported at run time.</p>
</div>
<p><b>See also </b><a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>().</p>
<!-- @@@newTexture -->
<!-- $$$newTexture$$$newTextureQRhiTexture::FormatintintintintQRhiTexture::Flags -->
<h3 class="fn" translate="no" id="newTexture-1"><span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *QRhi::<span class="name">newTexture</span>(<span class="type"><a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::Format</a></span> <i>format</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>sampleCount</i> = 1, <span class="type"><a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::Flags</a></span> <i>flags</i> = {})</h3>
<p>Returns a new 1D, 2D or 3D texture with the specified <i translate="no">format</i>, <i translate="no">width</i>, <i translate="no">height</i>, <i translate="no">depth</i>, <i translate="no">sampleCount</i>, and <i translate="no">flags</i>.</p>
<p>This overload is suitable for 3D textures because it allows specifying <i translate="no">depth</i>. A 3D texture must have <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::ThreeDimensional</a> set in <i translate="no">flags</i>, but using this overload that can be omitted because the flag is set implicitly whenever <i translate="no">depth</i> is greater than 0. For 1D, 2D and cube textures <i translate="no">depth</i> should be set to 0.</p>
<p>A 1D texture must have <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::OneDimensional</a> set in <i translate="no">flags</i>. This overload will implicitly set this flag if both <i translate="no">height</i> and <i translate="no">depth</i> are 0.</p>
<div class="admonition note">
<p><b>Note: </b>3D textures are only functional when the <a href="qrhi.html#Feature-enum" translate="no">ThreeDimensionalTextures</a> feature is reported as supported at run time.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>1D textures are only functional when the <a href="qrhi.html#Feature-enum" translate="no">OneDimensionalTextures</a> feature is reported as supported at run time. Further, mipmaps on 1D textures are only functional when the <a href="qrhi.html#Feature-enum" translate="no">OneDimensionalTextureMipmaps</a> feature is reported at run time.</p>
</div>
<p>This is an overloaded function.</p>
<!-- @@@newTexture -->
<!-- $$$newTextureArray[overload1]$$$newTextureArrayQRhiTexture::FormatintconstQSize&intQRhiTexture::Flags -->
<h3 class="fn" translate="no" id="newTextureArray"><span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *QRhi::<span class="name">newTextureArray</span>(<span class="type"><a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::Format</a></span> <i>format</i>, <span class="type">int</span> <i>arraySize</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1, <span class="type"><a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::Flags</a></span> <i>flags</i> = {})</h3>
<p>Returns a new 1D or 2D texture array with the specified <i translate="no">format</i>, <i translate="no">arraySize</i>, <i translate="no">pixelSize</i>, <i translate="no">sampleCount</i>, and <i translate="no">flags</i>.</p>
<p>This function implicitly sets <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::TextureArray</a> in <i translate="no">flags</i>.</p>
<p>A 1D texture array must have <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::OneDimensional</a> set in <i translate="no">flags</i>. This function will implicitly set this flag if the <i translate="no">pixelSize</i> height is 0.</p>
<div class="admonition note">
<p><b>Note: </b>Do not confuse texture arrays with arrays of textures. A <a href="qrhitexture.html" translate="no">QRhiTexture</a> created by this function is usable with 1D or 2D array samplers in the shader, for example: <code translate="no">layout(binding = 1) uniform sampler2DArray texArr;</code>. Arrays of textures refers to a list of textures that are exposed to the shader via <a href="qrhishaderresourcebinding.html#sampledTextures" translate="no">QRhiShaderResourceBinding::sampledTextures</a>() and a count &gt; 1, and declared in the shader for example like this: <code translate="no">layout(binding = 1) uniform sampler2D textures[4];</code></p>
</div>
<div class="admonition note">
<p><b>Note: </b>This is only functional when the <a href="qrhi.html#Feature-enum" translate="no">TextureArrays</a> feature is reported as supported at run time.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>1D textures are only functional when the <a href="qrhi.html#Feature-enum" translate="no">OneDimensionalTextures</a> feature is reported as supported at run time. Further, mipmaps on 1D textures are only functional when the <a href="qrhi.html#Feature-enum" translate="no">OneDimensionalTextureMipmaps</a> feature is reported at run time.</p>
</div>
<p><b>See also </b><a href="qrhi.html#newTexture" translate="no">newTexture</a>().</p>
<!-- @@@newTextureArray -->
<!-- $$$newTextureRenderTarget[overload1]$$$newTextureRenderTargetconstQRhiTextureRenderTargetDescription&QRhiTextureRenderTarget::Flags -->
<h3 class="fn" translate="no" id="newTextureRenderTarget"><span class="type"><a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a></span> *QRhi::<span class="name">newTextureRenderTarget</span>(const <span class="type"><a href="qrhitexturerendertargetdescription.html" translate="no">QRhiTextureRenderTargetDescription</a></span> &amp;<i>desc</i>, <span class="type"><a href="qrhitexturerendertarget.html#Flag-enum" translate="no">QRhiTextureRenderTarget::Flags</a></span> <i>flags</i> = {})</h3>
<p>Returns a new texture render target with color and depth/stencil attachments given in <i translate="no">desc</i>, and with the specified <i translate="no">flags</i>.</p>
<p><b>See also </b><a href="qrhiresource.html#destroy" translate="no">QRhiResource::destroy</a>().</p>
<!-- @@@newTextureRenderTarget -->
<!-- $$$nextResourceUpdateBatch[overload1]$$$nextResourceUpdateBatch -->
<h3 class="fn" translate="no" id="nextResourceUpdateBatch"><span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> *QRhi::<span class="name">nextResourceUpdateBatch</span>()</h3>
<p>Returns an available, empty batch to which copy type of operations can be recorded.</p>
<div class="admonition note">
<p><b>Note: </b>the return value is not owned by the caller and must never be destroyed. Instead, the batch is returned the pool for reuse by passing it to <a href="qrhicommandbuffer.html#beginPass" translate="no">QRhiCommandBuffer::beginPass</a>(), <a href="qrhicommandbuffer.html#endPass" translate="no">QRhiCommandBuffer::endPass</a>(), or <a href="qrhicommandbuffer.html#resourceUpdate" translate="no">QRhiCommandBuffer::resourceUpdate</a>(), or by calling QRhiResourceUpdateBatch::destroy() on it.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Can be called outside <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>() - <a href="qrhi.html#endFrame" translate="no">endFrame</a>() as well since a batch instance just collects data on its own, it does not perform any operations.</p>
</div>
<p>Due to not being tied to a frame being recorded, the following sequence is valid for example:</p>
<pre class="cpp" translate="no">
 rhi<span class="operator">-</span><span class="operator">&gt;</span>beginFrame(swapchain);
 <span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>u <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
 u<span class="operator">-</span><span class="operator">&gt;</span>uploadStaticBuffer(buf<span class="operator">,</span> data);
 <span class="comment">// ... do not commit the batch</span>
 rhi<span class="operator">-</span><span class="operator">&gt;</span>endFrame();
 <span class="comment">// u stays valid (assuming buf stays valid as well)</span>
 rhi<span class="operator">-</span><span class="operator">&gt;</span>beginFrame(swapchain);
 swapchain<span class="operator">-</span><span class="operator">&gt;</span>currentFrameCommandBuffer()<span class="operator">-</span><span class="operator">&gt;</span>resourceUpdate(u);
 <span class="comment">// ... draw with buf</span>
 rhi<span class="operator">-</span><span class="operator">&gt;</span>endFrame();
</pre>
<div class="admonition warning">
<p><b>Warning: </b>The maximum number of batches per <a href="qrhi.html" translate="no">QRhi</a> is 64. When this limit is reached, the function will return null until a batch is returned to the pool.</p>
</div>
<!-- @@@nextResourceUpdateBatch -->
<!-- $$$pipelineCacheData[overload1]$$$pipelineCacheData -->
<h3 class="fn" translate="no" id="pipelineCacheData"><span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> QRhi::<span class="name">pipelineCacheData</span>()</h3>
<p>Returns a binary data blob with data collected from the <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> and <a href="qrhicomputepipeline.html" translate="no">QRhiComputePipeline</a> successfully created during the lifetime of this <a href="qrhi.html" translate="no">QRhi</a>.</p>
<p>By saving and then, in subsequent runs of the same application, reloading the cache data, pipeline and shader creation times can potentially be reduced. What exactly the cache and its serialized version includes is not specified, is always specific to the backend used, and in some cases also dependent on the particular implementation of the graphics API.</p>
<p>When the <a href="qrhi.html#Feature-enum" translate="no">PipelineCacheDataLoadSave</a> is reported as unsupported, the returned <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a> is empty.</p>
<p>When the <a href="qrhi.html#Flag-enum" translate="no">EnablePipelineCacheDataSave</a> flag was not specified when calling <a href="qrhi.html#create" translate="no">create</a>(), the returned <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a> may be empty, even when the <a href="qrhi.html#Feature-enum" translate="no">PipelineCacheDataLoadSave</a> feature is supported.</p>
<p>When the returned data is non-empty, it is always specific to the Qt version and <a href="qrhi.html" translate="no">QRhi</a> backend. In addition, in some cases there is a strong dependency to the graphics device and the exact driver version used. <a href="qrhi.html" translate="no">QRhi</a> takes care of adding the appropriate header and safeguards that ensure that the data can always be passed safely to <a href="qrhi.html#setPipelineCacheData" translate="no">setPipelineCacheData</a>(), therefore attempting to load data from a run on another version of a driver will be handled safely and gracefully.</p>
<div class="admonition note">
<p><b>Note: </b>Calling <a href="qrhi.html#releaseCachedResources" translate="no">releaseCachedResources</a>() may, depending on the backend, clear the pipeline data collected. A subsequent call to this function may then not return any data.</p>
</div>
<p>See <a href="qrhi.html#Flag-enum" translate="no">EnablePipelineCacheDataSave</a> for further details about this feature.</p>
<div class="admonition note">
<p><b>Note: </b>Minimize the number of calls to this function. Retrieving the blob is not always a cheap operation, and therefore this function should only be called at a low frequency, ideally only once e.g. when closing the application.</p>
</div>
<p><b>See also </b><a href="qrhi.html#setPipelineCacheData" translate="no">setPipelineCacheData</a>(), <a href="qrhi.html#create" translate="no">create</a>(), and <a href="qrhi.html#isFeatureSupported" translate="no">isFeatureSupported</a>().</p>
<!-- @@@pipelineCacheData -->
<!-- $$$probe[overload1]$$$probeQRhi::ImplementationQRhiInitParams* -->
<h3 class="fn" translate="no" id="probe"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QRhi::<span class="name">probe</span>(<span class="type"><a href="qrhi.html#Implementation-enum" translate="no">QRhi::Implementation</a></span> <i>impl</i>, <span class="type"><a href="qrhiinitparams.html" translate="no">QRhiInitParams</a></span> *<i>params</i>)</h3>
<p>Returns true if <a href="qrhi.html#create" translate="no">create</a>() can be expected to succeed when called the given <i translate="no">impl</i> and <i translate="no">params</i>.</p>
<p>For some backends this is equivalent to calling <a href="qrhi.html#create" translate="no">create</a>(), checking its return value, and then destroying the resulting <a href="qrhi.html" translate="no">QRhi</a>.</p>
<p>For others, in particular with Metal, there may be a specific probing implementation, which allows testing in a more lightweight manner without polluting the debug output with warnings upon failures.</p>
<p><b>See also </b><a href="qrhi.html#create" translate="no">create</a>().</p>
<!-- @@@probe -->
<!-- $$$releaseCachedResources[overload1]$$$releaseCachedResources -->
<h3 class="fn" translate="no" id="releaseCachedResources"><span class="type">void</span> QRhi::<span class="name">releaseCachedResources</span>()</h3>
<p>Attempts to release resources in the backend's caches. This can include both CPU and GPU resources. Only memory and resources that can be recreated automatically are in scope. As an example, if the backend's <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> implementation maintains a cache of shader compilation results, calling this function leads to emptying that cache, thus potentially freeing up memory and graphics resources.</p>
<p>Calling this function makes sense in resource constrained environments, where at a certain point there is a need to ensure minimal resource usage, at the expense of performance.</p>
<!-- @@@releaseCachedResources -->
<!-- $$$removeCleanupCallback[overload1]$$$removeCleanupCallbackconstvoid* -->
<h3 class="fn" translate="no" id="removeCleanupCallback"><span class="type">void</span> QRhi::<span class="name">removeCleanupCallback</span>(const <span class="type">void</span> *<i>key</i>)</h3>
<p>Deregisters the callback with <i translate="no">key</i>. If no cleanup callback was registered with <i translate="no">key</i>, the function does nothing. Callbacks registered without a key cannot be removed.</p>
<p><b>See also </b><a href="qrhi.html#addCleanupCallback" translate="no">addCleanupCallback</a>().</p>
<!-- @@@removeCleanupCallback -->
<!-- $$$resourceLimit[overload1]$$$resourceLimitQRhi::ResourceLimit -->
<h3 class="fn" translate="no" id="resourceLimit"><span class="type">int</span> QRhi::<span class="name">resourceLimit</span>(<span class="type"><a href="qrhi.html#ResourceLimit-enum" translate="no">QRhi::ResourceLimit</a></span> <i>limit</i>) const</h3>
<p>Returns the value for the specified resource <i translate="no">limit</i>.</p>
<p>The values are expected to be queried by the backends upon initialization, meaning calling this function is a light operation.</p>
<!-- @@@resourceLimit -->
<!-- $$$runCleanup[overload1]$$$runCleanup -->
<h3 class="fn" translate="no" id="runCleanup"><span class="type">void</span> QRhi::<span class="name">runCleanup</span>()</h3>
<p>Invokes all registered cleanup functions. The list of cleanup callbacks it then cleared. Normally destroying the <a href="qrhi.html" translate="no">QRhi</a> does this automatically, but sometimes it can be useful to trigger cleanup in order to release all cached, non-essential resources.</p>
<p><b>See also </b><a href="qrhi.html#addCleanupCallback" translate="no">addCleanupCallback</a>().</p>
<!-- @@@runCleanup -->
<!-- $$$setPipelineCacheData[overload1]$$$setPipelineCacheDataconstQByteArray& -->
<h3 class="fn" translate="no" id="setPipelineCacheData"><span class="type">void</span> QRhi::<span class="name">setPipelineCacheData</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Loads <i translate="no">data</i> into the pipeline cache, when applicable.</p>
<p>When the <a href="qrhi.html#Feature-enum" translate="no">PipelineCacheDataLoadSave</a> is reported as unsupported, the function is safe to call, but has no effect.</p>
<p>The blob returned by <a href="qrhi.html#pipelineCacheData" translate="no">pipelineCacheData</a>() is always specific to the Qt version, the <a href="qrhi.html" translate="no">QRhi</a> backend, and, in some cases, also to the graphics device, and a given version of the graphics driver. <a href="qrhi.html" translate="no">QRhi</a> takes care of adding the appropriate header and safeguards that ensure that the data can always be passed safely to this function. If there is a mismatch, e.g. because the driver has been upgraded to a newer version, or because the data was generated from a different <a href="qrhi.html" translate="no">QRhi</a> backend, a warning is printed and <i translate="no">data</i> is safely ignored.</p>
<p>With Vulkan, this maps directly to VkPipelineCache. Calling this function creates a new Vulkan pipeline cache object, with its initial data sourced from <i translate="no">data</i>. The pipeline cache object is then used by all subsequently created <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> and <a href="qrhicomputepipeline.html" translate="no">QRhiComputePipeline</a> objects, thus accelerating, potentially, the pipeline creation.</p>
<p>With other APIs there is no real pipeline cache, but they may provide a cache with bytecode from shader compilations (D3D) or program binaries (OpenGL). In applications that perform a lot of shader compilation from source at run time this can provide a significant boost in subsequent runs if the &quot;pipeline cache&quot; is pre-seeded from an earlier run using this function.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhi.html" translate="no">QRhi</a> cannot give any guarantees that <i translate="no">data</i> has an effect on the pipeline and shader creation performance. With APIs like Vulkan, it is up to the driver to decide if <i translate="no">data</i> is used for some purpose, or if it is ignored.</p>
</div>
<p>See <a href="qrhi.html#Flag-enum" translate="no">EnablePipelineCacheDataSave</a> for further details about this feature.</p>
<div class="admonition note">
<p><b>Note: </b>This mechanism offered by <a href="qrhi.html" translate="no">QRhi</a> is independent of the drivers' own internal caching mechanism, if any. This means that, depending on the graphics API and its implementation, the exact effects of retrieving and then reloading <i translate="no">data</i> are not predictable. Improved performance may not be visible at all in case other caching mechanisms outside of Qt's control are already active.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Minimize the number of calls to this function. Loading the blob is not always a cheap operation, and therefore this function should only be called at a low frequency, ideally only once e.g. when starting the application.</p>
</div>
<p><b>See also </b><a href="qrhi.html#pipelineCacheData" translate="no">pipelineCacheData</a>() and <a href="qrhi.html#isFeatureSupported" translate="no">isFeatureSupported</a>().</p>
<!-- @@@setPipelineCacheData -->
<!-- $$$sizeForMipLevel[overload1]$$$sizeForMipLevelintconstQSize& -->
<h3 class="fn" translate="no" id="sizeForMipLevel"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QRhi::<span class="name">sizeForMipLevel</span>(<span class="type">int</span> <i>mipLevel</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>baseLevelSize</i>)</h3>
<p>Returns the texture image size for a given <i translate="no">mipLevel</i>, calculated based on the level 0 size given in <i translate="no">baseLevelSize</i>.</p>
<!-- @@@sizeForMipLevel -->
<!-- $$$statistics[overload1]$$$statistics -->
<h3 class="fn" translate="no" id="statistics"><span class="type"><a href="qrhistats.html" translate="no">QRhiStats</a></span> QRhi::<span class="name">statistics</span>() const</h3>
<p>Gathers and returns statistics about the timings and allocations of graphics resources.</p>
<p>Data about memory allocations is only available with some backends, where such operations are under Qt's control. With graphics APIs where there is no lower level control over resource memory allocations, this will never be supported and all relevant fields in the results are 0.</p>
<p>With Vulkan in particular, the values are valid always, and are queried from the underlying memory allocator library. This gives an insight into the memory requirements of the active buffers and textures.</p>
<p>The same is true for Direct 3D 12. In addition to the memory allocator library's statistics, here the result also includes a <code translate="no">totalUsageBytes</code> field which reports the total size including additional resources that are not under the memory allocator library's control (swapchain buffers, descriptor heaps, etc.), as reported by DXGI.</p>
<p>The values correspond to all types of memory used, combined. (i.e. video + system in case of a discreet GPU)</p>
<p>Additional data, such as the total time in milliseconds spent in graphics and compute pipeline creation (which usually involves shader compilation or cache lookups, and potentially expensive processing) is available with most backends.</p>
<div class="admonition note">
<p><b>Note: </b>The elapsed times for operations such as pipeline creation may be affected by various factors. The results should not be compared between different backends since the concept of &quot;pipelines&quot; and what exactly happens under the hood during, for instance, a call to <a href="qrhigraphicspipeline.html#create" translate="no">QRhiGraphicsPipeline::create</a>(), differ greatly between graphics APIs and their implementations.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Additionally, many drivers will likely employ various caching strategies for shaders, programs, pipelines. (independently of Qt's own similar facilities, such as <a href="qrhi.html#setPipelineCacheData" translate="no">setPipelineCacheData</a>() or the OpenGL-specific program binary disk cache). Because such internal behavior is transparent to the API client, Qt and <a href="qrhi.html" translate="no">QRhi</a> have no knowledge or control over the exact caching strategy, persistency, invalidation of the cached data, etc. When reading timings, such as the time spent on pipeline creation, the potential presence and unspecified behavior of driver-level caching mechanisms should be kept in mind.</p>
</div>
<!-- @@@statistics -->
<!-- $$$supportedSampleCounts[overload1]$$$supportedSampleCounts -->
<h3 class="fn" translate="no" id="supportedSampleCounts"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type">int</span>&gt; QRhi::<span class="name">supportedSampleCounts</span>() const</h3>
<p>Returns the list of supported sample counts.</p>
<p>A typical example would be (1, 2, 4, 8).</p>
<p>With some backend this list of supported values is fixed in advance, while with some others the (physical) device properties indicate what is supported at run time.</p>
<p><b>See also </b><a href="qrhirenderbuffer.html#setSampleCount" translate="no">QRhiRenderBuffer::setSampleCount</a>(), <a href="qrhitexture.html#setSampleCount" translate="no">QRhiTexture::setSampleCount</a>(), <a href="qrhigraphicspipeline.html#setSampleCount" translate="no">QRhiGraphicsPipeline::setSampleCount</a>(), and <a href="qrhiswapchain.html#setSampleCount" translate="no">QRhiSwapChain::setSampleCount</a>().</p>
<!-- @@@supportedSampleCounts -->
<!-- $$$thread[overload1]$$$thread -->
<h3 class="fn" translate="no" id="thread"><span class="type"><a href="../qtcore/qthread.html" translate="no">QThread</a></span> *QRhi::<span class="name">thread</span>() const</h3>
<p>Returns the thread on which the <a href="qrhi.html" translate="no">QRhi</a> was <a href="qrhi.html#create" translate="no">initialized</a>.</p>
<!-- @@@thread -->
<!-- $$$ubufAligned[overload1]$$$ubufAlignedint -->
<h3 class="fn" translate="no" id="ubufAligned"><span class="type">int</span> QRhi::<span class="name">ubufAligned</span>(<span class="type">int</span> <i>v</i>) const</h3>
<p>Returns the value (typically an offset) <i translate="no">v</i> aligned to the uniform buffer alignment given by by <a href="qrhi.html#ubufAlignment" translate="no">ubufAlignment</a>().</p>
<!-- @@@ubufAligned -->
<!-- $$$ubufAlignment[overload1]$$$ubufAlignment -->
<h3 class="fn" translate="no" id="ubufAlignment"><span class="type">int</span> QRhi::<span class="name">ubufAlignment</span>() const</h3>
<p>Returns the minimum uniform buffer offset alignment in bytes. This is typically 256.</p>
<p>Attempting to bind a uniform buffer region with an offset not aligned to this value will lead to failures depending on the backend and the underlying graphics API.</p>
<p><b>See also </b><a href="qrhi.html#ubufAligned" translate="no">ubufAligned</a>().</p>
<!-- @@@ubufAlignment -->
<!-- $$$updateSwapChainProxyData[overload1]$$$updateSwapChainProxyDataQRhi::ImplementationQWindow* -->
<h3 class="fn" translate="no" id="updateSwapChainProxyData"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qrhiswapchainproxydata.html" translate="no">QRhiSwapChainProxyData</a></span> QRhi::<span class="name">updateSwapChainProxyData</span>(<span class="type"><a href="qrhi.html#Implementation-enum" translate="no">QRhi::Implementation</a></span> <i>impl</i>, <span class="type"><a href="qwindow.html" translate="no">QWindow</a></span> *<i>window</i>)</h3>
<p>Generates and returns a <a href="qrhiswapchainproxydata.html" translate="no">QRhiSwapChainProxyData</a> struct containing opaque data specific to the backend and graphics API specified by <i translate="no">impl</i>. <i translate="no">window</i> is the <a href="qwindow.html" translate="no">QWindow</a> a swapchain is targeting.</p>
<p>The returned struct can be passed to <a href="qrhiswapchain.html#setProxyData" translate="no">QRhiSwapChain::setProxyData</a>(). This makes sense in threaded rendering systems: this static function is expected to be called on the <b>main (gui) thread</b>, unlike all <a href="qrhi.html" translate="no">QRhi</a> operations, then transferred to the thread working with the <a href="qrhi.html" translate="no">QRhi</a> and <a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a> and passed on to the swapchain. This allows doing native platform queries that are only safe to be called on the main thread, for example to query the CAMetalLayer from a NSView, and then passing on the data to the <a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a> living on the rendering thread. With the Metal example, doing the view.layer access on a dedicated rendering thread causes a warning in the Xcode Thread Checker. With the data proxy mechanism, this is avoided.</p>
<p>When threads are not involved, generating and passing on the <a href="qrhiswapchainproxydata.html" translate="no">QRhiSwapChainProxyData</a> is not required: backends are guaranteed to be able to query whatever is needed on their own, and if everything lives on the main (gui) thread, that should be sufficient.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">impl</i> should match what the <a href="qrhi.html" translate="no">QRhi</a> is created with. For example, calling with <a href="qrhi.html#Implementation-enum" translate="no">QRhi::Metal</a> on a non-Apple platform will not generate any useful data.</p>
</div>
<!-- @@@updateSwapChainProxyData -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$QRhiShaderResourceBindingSet -->
<h3 class="fn" translate="no" id="QRhiShaderResourceBindingSet-typedef"><code class="details extra" translate="no">[alias, since 6.7]</code> <span class="name">QRhiShaderResourceBindingSet</span></h3>
<p>Synonym for <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a>.</p>
<p>This typedef was introduced in Qt 6.7.</p>
<!-- @@@QRhiShaderResourceBindingSet -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
