<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Describes the shader resource for a single binding point.">
  <title>QRhiShaderResourceBinding Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiShaderResourceBinding</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiShaderResourceBinding Class</h1>
<!-- $$$QRhiShaderResourceBinding-brief -->
<p>Describes the shader resource for a single binding point. <a href="#details">More...</a></p>
<!-- @@@QRhiShaderResourceBinding -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiShaderResourceBinding&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
</table></div>
<ul>
<li><a href="qrhishaderresourcebinding-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">StageFlag</a></b> { VertexStage, TessellationControlStage, TessellationEvaluationStage, FragmentStage, ComputeStage, GeometryStage }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">StageFlags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#Type-enum" translate="no">Type</a></b> { UniformBuffer, SampledTexture, Texture, Sampler, ImageLoad, &hellip;, BufferLoadStore }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#isLayoutCompatible" translate="no">isLayoutCompatible</a></b>(const QRhiShaderResourceBinding &amp;<i>other</i>) const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#bufferLoad" translate="no">bufferLoad</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiBuffer *<i>buf</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#bufferLoad-1" translate="no">bufferLoad</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiBuffer *<i>buf</i>, quint32 <i>offset</i>, quint32 <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#bufferLoadStore" translate="no">bufferLoadStore</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiBuffer *<i>buf</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#bufferLoadStore-1" translate="no">bufferLoadStore</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiBuffer *<i>buf</i>, quint32 <i>offset</i>, quint32 <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#bufferStore" translate="no">bufferStore</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiBuffer *<i>buf</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#bufferStore-1" translate="no">bufferStore</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiBuffer *<i>buf</i>, quint32 <i>offset</i>, quint32 <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#imageLoad" translate="no">imageLoad</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiTexture *<i>tex</i>, int <i>level</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#imageLoadStore" translate="no">imageLoadStore</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiTexture *<i>tex</i>, int <i>level</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#imageStore" translate="no">imageStore</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiTexture *<i>tex</i>, int <i>level</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#sampledTexture" translate="no">sampledTexture</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiTexture *<i>tex</i>, QRhiSampler *<i>sampler</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#sampledTextures" translate="no">sampledTextures</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, int <i>count</i>, const QRhiShaderResourceBinding::TextureAndSampler *<i>texSamplers</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#sampler" translate="no">sampler</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiSampler *<i>sampler</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#texture" translate="no">texture</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiTexture *<i>tex</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#textures" translate="no">textures</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, int <i>count</i>, QRhiTexture **<i>tex</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#uniformBuffer" translate="no">uniformBuffer</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiBuffer *<i>buf</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#uniformBuffer-1" translate="no">uniformBuffer</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiBuffer *<i>buf</i>, quint32 <i>offset</i>, quint32 <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiShaderResourceBinding </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#uniformBufferWithDynamicOffset" translate="no">uniformBufferWithDynamicOffset</a></b>(int <i>binding</i>, QRhiShaderResourceBinding::StageFlags <i>stage</i>, QRhiBuffer *<i>buf</i>, quint32 <i>size</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#qHash-1" translate="no">qHash</a></b>(const QRhiShaderResourceBinding &amp;<i>b</i>, size_t <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#operator-not-eq-1" translate="no">operator!=</a></b>(const QRhiShaderResourceBinding &amp;<i>a</i>, const QRhiShaderResourceBinding &amp;<i>b</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebinding.html#operator-eq-eq-1" translate="no">operator==</a></b>(const QRhiShaderResourceBinding &amp;<i>a</i>, const QRhiShaderResourceBinding &amp;<i>b</i>)</td></tr>
</table></div>
<!-- $$$QRhiShaderResourceBinding-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>A QRhiShaderResourceBinding cannot be constructed directly. Instead, use the static functions such as <a href="qrhishaderresourcebinding.html#uniformBuffer" translate="no">uniformBuffer</a>() or <a href="qrhishaderresourcebinding.html#sampledTexture" translate="no">sampledTexture</a>() to get an instance.</p>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<!-- @@@QRhiShaderResourceBinding -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$StageFlag$$$VertexStage$$$TessellationControlStage$$$TessellationEvaluationStage$$$GeometryStage$$$FragmentStage$$$ComputeStage -->
<h3 class="flags" id="StageFlag-enum">enum QRhiShaderResourceBinding::<span class="name">StageFlag</span><br/>flags QRhiShaderResourceBinding::<span class="name">StageFlags</span></h3>
<p>Flag values to indicate which stages the shader resource is visible in</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::VertexStage</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td><td class="topAlign">Vertex stage</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::TessellationControlStage</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 1</code></td><td class="topAlign">Tessellation control (hull shader) stage</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::TessellationEvaluationStage</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 2</code></td><td class="topAlign">Tessellation evaluation (domain shader) stage</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::FragmentStage</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 4</code></td><td class="topAlign">Fragment (pixel shader) stage</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::ComputeStage</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 5</code></td><td class="topAlign">Compute stage</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::GeometryStage</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 3</code></td><td class="topAlign">Geometry stage</td></tr>
</table></div>
<p>The StageFlags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;StageFlag&gt;. It stores an OR combination of StageFlag values.</p>
<!-- @@@StageFlag -->
<!-- $$$Type$$$UniformBuffer$$$SampledTexture$$$Texture$$$Sampler$$$ImageLoad$$$ImageStore$$$ImageLoadStore$$$BufferLoad$$$BufferStore$$$BufferLoadStore -->
<h3 class="fn" translate="no" id="Type-enum">enum QRhiShaderResourceBinding::<span class="name">Type</span></h3>
<p>Specifies type of the shader resource bound to a binding point</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::UniformBuffer</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Uniform buffer</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::SampledTexture</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Combined image sampler (a texture and sampler pair). Even when the shading language associated with the underlying 3D API has no support for this concept (e.g. D3D and HLSL), this is still supported because the shader translation layer takes care of the appropriate translation and remapping of binding points or shader registers.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::Texture</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Texture (separate)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::Sampler</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Sampler (separate)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::ImageLoad</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">Image load (with GLSL this maps to doing <a href="qrhishaderresourcebinding.html#imageLoad" translate="no">imageLoad</a>() on a single level - and either one or all layers - of a texture exposed to the shader as an image object)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::ImageStore</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Image store (with GLSL this maps to doing <a href="qrhishaderresourcebinding.html#imageStore" translate="no">imageStore</a>() or imageAtomic*() on a single level - and either one or all layers - of a texture exposed to the shader as an image object)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::ImageLoadStore</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">Image load and store</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::BufferLoad</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">Storage buffer store (with GLSL this maps to reading from a shader storage buffer)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::BufferStore</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">Storage buffer store (with GLSL this maps to writing to a shader storage buffer)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiShaderResourceBinding::BufferLoadStore</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">Storage buffer load and store</td></tr>
</table></div>
<!-- @@@Type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$bufferLoad[overload1]$$$bufferLoadintQRhiShaderResourceBinding::StageFlagsQRhiBuffer* -->
<h3 class="fn" translate="no" id="bufferLoad"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">bufferLoad</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>)</h3>
<p>Returns a shader resource binding for a read-only storage buffer with the given <i translate="no">binding</i> number and pipeline <i translate="no">stage</i>.</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">buf</i> is not null, must have been created with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::StorageBuffer</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">buf</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</p>
</div>
<!-- @@@bufferLoad -->
<!-- $$$bufferLoad$$$bufferLoadintQRhiShaderResourceBinding::StageFlagsQRhiBuffer*quint32quint32 -->
<h3 class="fn" translate="no" id="bufferLoad-1"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">bufferLoad</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>offset</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>size</i>)</h3>
<p>Returns a shader resource binding for a read-only storage buffer with the given <i translate="no">binding</i> number and pipeline <i translate="no">stage</i>. This overload binds a region only, as specified by <i translate="no">offset</i> and <i translate="no">size</i>.</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">buf</i> is not null, must have been created with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::StorageBuffer</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">buf</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</p>
</div>
<!-- @@@bufferLoad -->
<!-- $$$bufferLoadStore[overload1]$$$bufferLoadStoreintQRhiShaderResourceBinding::StageFlagsQRhiBuffer* -->
<h3 class="fn" translate="no" id="bufferLoadStore"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">bufferLoadStore</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>)</h3>
<p>Returns a shader resource binding for a read-write storage buffer with the given <i translate="no">binding</i> number and pipeline <i translate="no">stage</i>.</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">buf</i> is not null, must have been created with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::StorageBuffer</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">buf</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</p>
</div>
<!-- @@@bufferLoadStore -->
<!-- $$$bufferLoadStore$$$bufferLoadStoreintQRhiShaderResourceBinding::StageFlagsQRhiBuffer*quint32quint32 -->
<h3 class="fn" translate="no" id="bufferLoadStore-1"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">bufferLoadStore</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>offset</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>size</i>)</h3>
<p>Returns a shader resource binding for a read-write storage buffer with the given <i translate="no">binding</i> number and pipeline <i translate="no">stage</i>. This overload binds a region only, as specified by <i translate="no">offset</i> and <i translate="no">size</i>.</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">buf</i> is not null, must have been created with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::StorageBuffer</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">buf</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</p>
</div>
<!-- @@@bufferLoadStore -->
<!-- $$$bufferStore[overload1]$$$bufferStoreintQRhiShaderResourceBinding::StageFlagsQRhiBuffer* -->
<h3 class="fn" translate="no" id="bufferStore"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">bufferStore</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>)</h3>
<p>Returns a shader resource binding for a write-only storage buffer with the given <i translate="no">binding</i> number and pipeline <i translate="no">stage</i>.</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">buf</i> is not null, must have been created with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::StorageBuffer</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">buf</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</p>
</div>
<!-- @@@bufferStore -->
<!-- $$$bufferStore$$$bufferStoreintQRhiShaderResourceBinding::StageFlagsQRhiBuffer*quint32quint32 -->
<h3 class="fn" translate="no" id="bufferStore-1"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">bufferStore</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>offset</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>size</i>)</h3>
<p>Returns a shader resource binding for a write-only storage buffer with the given <i translate="no">binding</i> number and pipeline <i translate="no">stage</i>. This overload binds a region only, as specified by <i translate="no">offset</i> and <i translate="no">size</i>.</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">buf</i> is not null, must have been created with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::StorageBuffer</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">buf</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</p>
</div>
<!-- @@@bufferStore -->
<!-- $$$imageLoad[overload1]$$$imageLoadintQRhiShaderResourceBinding::StageFlagsQRhiTexture*int -->
<h3 class="fn" translate="no" id="imageLoad"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">imageLoad</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>, <span class="type">int</span> <i>level</i>)</h3>
<p>Returns a shader resource binding for a read-only storage image with the given <i translate="no">binding</i> number and pipeline <i translate="no">stage</i>. The image load operations will have access to all layers of the specified <i translate="no">level</i>. (so if the texture is a cubemap, the shader must use imageCube instead of image2D)</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">tex</i> is not null, it must have been created with <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::UsedWithLoadStore</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">tex</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Image load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</p>
</div>
<!-- @@@imageLoad -->
<!-- $$$imageLoadStore[overload1]$$$imageLoadStoreintQRhiShaderResourceBinding::StageFlagsQRhiTexture*int -->
<h3 class="fn" translate="no" id="imageLoadStore"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">imageLoadStore</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>, <span class="type">int</span> <i>level</i>)</h3>
<p>Returns a shader resource binding for a read/write storage image with the given <i translate="no">binding</i> number and pipeline <i translate="no">stage</i>. The image load/store operations will have access to all layers of the specified <i translate="no">level</i>. (so if the texture is a cubemap, the shader must use imageCube instead of image2D)</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">tex</i> is not null, it must have been created with <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::UsedWithLoadStore</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">tex</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Image load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</p>
</div>
<!-- @@@imageLoadStore -->
<!-- $$$imageStore[overload1]$$$imageStoreintQRhiShaderResourceBinding::StageFlagsQRhiTexture*int -->
<h3 class="fn" translate="no" id="imageStore"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">imageStore</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>, <span class="type">int</span> <i>level</i>)</h3>
<p>Returns a shader resource binding for a write-only storage image with the given <i translate="no">binding</i> number and pipeline <i translate="no">stage</i>. The image store operations will have access to all layers of the specified <i translate="no">level</i>. (so if the texture is a cubemap, the shader must use imageCube instead of image2D)</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">tex</i> is not null, it must have been created with <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::UsedWithLoadStore</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">tex</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Image load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</p>
</div>
<!-- @@@imageStore -->
<!-- $$$isLayoutCompatible[overload1]$$$isLayoutCompatibleconstQRhiShaderResourceBinding& -->
<h3 class="fn" translate="no" id="isLayoutCompatible"><span class="type">bool</span> QRhiShaderResourceBinding::<span class="name">isLayoutCompatible</span>(const <span class="type">QRhiShaderResourceBinding</span> &amp;<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if the layout is compatible with <i translate="no">other</i>. The layout does not include the actual resource (such as, buffer or texture) and related parameters (such as, offset or size).</p>
<p>For example, <code translate="no">a</code> and <code translate="no">b</code> below are not equal, but are compatible layout-wise:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> a <span class="operator">=</span> <span class="type">QRhiShaderResourceBinding</span><span class="operator">::</span>uniformBuffer(<span class="number">0</span><span class="operator">,</span> <span class="type">QRhiShaderResourceBinding</span><span class="operator">::</span>VertexStage<span class="operator">,</span> buffer);
 <span class="keyword">auto</span> b <span class="operator">=</span> <span class="type">QRhiShaderResourceBinding</span><span class="operator">::</span>uniformBuffer(<span class="number">0</span><span class="operator">,</span> <span class="type">QRhiShaderResourceBinding</span><span class="operator">::</span>VertexStage<span class="operator">,</span> someOtherBuffer<span class="operator">,</span> <span class="number">256</span>);
</pre>
<!-- @@@isLayoutCompatible -->
<!-- $$$sampledTexture[overload1]$$$sampledTextureintQRhiShaderResourceBinding::StageFlagsQRhiTexture*QRhiSampler* -->
<h3 class="fn" translate="no" id="sampledTexture"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">sampledTexture</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>, <span class="type"><a href="qrhisampler.html" translate="no">QRhiSampler</a></span> *<i>sampler</i>)</h3>
<p>Returns a shader resource binding for the given binding number, pipeline stages, texture, and sampler specified by <i translate="no">binding</i>, <i translate="no">stage</i>, <i translate="no">tex</i>, <i translate="no">sampler</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function is equivalent to calling <a href="qrhishaderresourcebinding.html#sampledTextures" translate="no">sampledTextures</a>() with a <code translate="no">count</code> of 1.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">tex</i> and <i translate="no">sampler</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>A shader may not be able to consume more than 16 textures/samplers, depending on the underlying graphics API. This hard limit must be kept in mind in renderer design. This does not apply to texture arrays which consume a single binding point (shader register) and can contain 256-2048 textures, depending on the underlying graphics API. Arrays of textures (see <a href="qrhishaderresourcebinding.html#sampledTextures" translate="no">sampledTextures</a>()) are however no different in this regard than using the same number of individual textures.</p>
</div>
<p><b>See also </b><a href="qrhishaderresourcebinding.html#sampledTextures" translate="no">sampledTextures</a>().</p>
<!-- @@@sampledTexture -->
<!-- $$$sampledTextures[overload1]$$$sampledTexturesintQRhiShaderResourceBinding::StageFlagsintconstQRhiShaderResourceBinding::TextureAndSampler* -->
<h3 class="fn" translate="no" id="sampledTextures"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">sampledTextures</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type">int</span> <i>count</i>, const <span class="type">QRhiShaderResourceBinding::TextureAndSampler</span> *<i>texSamplers</i>)</h3>
<p>Returns a shader resource binding for the given binding number, pipeline stages, and the array of texture-sampler pairs specified by <i translate="no">binding</i>, <i translate="no">stage</i>, <i translate="no">count</i>, and <i translate="no">texSamplers</i>.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">count</i> must be at least 1, and not larger than 16.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">count</i> is 1, this function is equivalent to <a href="qrhishaderresourcebinding.html#sampledTexture" translate="no">sampledTexture</a>().</p>
</div>
<p>This function is relevant when arrays of combined image samplers are involved. For example, in GLSL <code translate="no">layout(binding = 5) uniform sampler2D shadowMaps[8];</code> declares an array of combined image samplers. The application is then expected provide a <a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a> for binding point 5, set up by calling this function with <i translate="no">count</i> set to 8 and a valid texture and sampler for each element of the array.</p>
<div class="admonition warning">
<p><b>Warning: </b>All elements of the array must be specified. With the above example, the only valid, portable approach is calling this function with a <i translate="no">count</i> of 8. Additionally, all <a href="qrhitexture.html" translate="no">QRhiTexture</a> and <a href="qrhisampler.html" translate="no">QRhiSampler</a> instances must be valid, meaning nullptr is not an accepted value. This is due to some of the underlying APIs, such as, Vulkan, that require a valid image and sampler object for each element in descriptor arrays. Applications are advised to provide &quot;dummy&quot; samplers and textures if some array elements are not relevant (due to not being accessed in the shader).</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">texSamplers</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<p><b>See also </b><a href="qrhishaderresourcebinding.html#sampledTexture" translate="no">sampledTexture</a>().</p>
<!-- @@@sampledTextures -->
<!-- $$$sampler[overload1]$$$samplerintQRhiShaderResourceBinding::StageFlagsQRhiSampler* -->
<h3 class="fn" translate="no" id="sampler"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">sampler</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhisampler.html" translate="no">QRhiSampler</a></span> *<i>sampler</i>)</h3>
<p>Returns a shader resource binding for the given binding number, pipeline stages, and sampler specified by <i translate="no">binding</i>, <i translate="no">stage</i>, <i translate="no">sampler</i>.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">sampler</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<p>Arrays of separate samplers are not supported.</p>
<p>This creates a binding for a separate sampler object, whereas <a href="qrhishaderresourcebinding.html#sampledTexture" translate="no">sampledTexture</a>() is suitable for combined image samplers. In Vulkan-compatible GLSL code separate samplers are declared as <code translate="no">sampler</code> as opposed to <code translate="no">sampler2D</code>: <code translate="no">layout(binding = 2) uniform sampler samp;</code></p>
<p>With both a <code translate="no">texture2D</code> and <code translate="no">sampler</code> present, they can be used together to sample the texture: <code translate="no">fragColor = texture(sampler2D(tex, samp), texcoord);</code>.</p>
<div class="admonition note">
<p><b>Note: </b>A shader may not be able to consume more than 16 samplers, depending on the underlying graphics API. This hard limit must be kept in mind in renderer design.</p>
</div>
<p><b>See also </b><a href="qrhishaderresourcebinding.html#texture" translate="no">texture</a>().</p>
<!-- @@@sampler -->
<!-- $$$texture[overload1]$$$textureintQRhiShaderResourceBinding::StageFlagsQRhiTexture* -->
<h3 class="fn" translate="no" id="texture"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">texture</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>tex</i>)</h3>
<p>Returns a shader resource binding for the given binding number, pipeline stages, and texture specified by <i translate="no">binding</i>, <i translate="no">stage</i>, <i translate="no">tex</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function is equivalent to calling <a href="qrhishaderresourcebinding.html#textures" translate="no">textures</a>() with a <code translate="no">count</code> of 1.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">tex</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<p>This creates a binding for a separate texture (image) object, whereas <a href="qrhishaderresourcebinding.html#sampledTexture" translate="no">sampledTexture</a>() is suitable for combined image samplers. In Vulkan-compatible GLSL code separate textures are declared as <code translate="no">texture2D</code> as opposed to <code translate="no">sampler2D</code>: <code translate="no">layout(binding = 1) uniform texture2D tex;</code></p>
<div class="admonition note">
<p><b>Note: </b>A shader may not be able to consume more than 16 textures, depending on the underlying graphics API. This hard limit must be kept in mind in renderer design. This does not apply to texture arrays which consume a single binding point (shader register) and can contain 256-2048 textures, depending on the underlying graphics API. Arrays of textures (see <a href="qrhishaderresourcebinding.html#sampledTextures" translate="no">sampledTextures</a>()) are however no different in this regard than using the same number of individual textures.</p>
</div>
<p><b>See also </b><a href="qrhishaderresourcebinding.html#textures" translate="no">textures</a>() and <a href="qrhishaderresourcebinding.html#sampler" translate="no">sampler</a>().</p>
<!-- @@@texture -->
<!-- $$$textures[overload1]$$$texturesintQRhiShaderResourceBinding::StageFlagsintQRhiTexture** -->
<h3 class="fn" translate="no" id="textures"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">textures</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type">int</span> <i>count</i>, <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> **<i>tex</i>)</h3>
<p>Returns a shader resource binding for the given binding number, pipeline stages, and the array of (separate) textures specified by <i translate="no">binding</i>, <i translate="no">stage</i>, <i translate="no">count</i>, and <i translate="no">tex</i>.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">count</i> must be at least 1, and not larger than 16.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">count</i> is 1, this function is equivalent to <a href="qrhishaderresourcebinding.html#texture" translate="no">texture</a>().</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>All elements of the array must be specified.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">tex</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<p><b>See also </b><a href="qrhishaderresourcebinding.html#texture" translate="no">texture</a>() and <a href="qrhishaderresourcebinding.html#sampler" translate="no">sampler</a>().</p>
<!-- @@@textures -->
<!-- $$$uniformBuffer[overload1]$$$uniformBufferintQRhiShaderResourceBinding::StageFlagsQRhiBuffer* -->
<h3 class="fn" translate="no" id="uniformBuffer"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">uniformBuffer</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>)</h3>
<p>Returns a shader resource binding for the given binding number, pipeline stages, and buffer specified by <i translate="no">binding</i>, <i translate="no">stage</i>, and <i translate="no">buf</i>.</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">buf</i> is not null, it must have been created with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::UniformBuffer</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">buf</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If the size of <i translate="no">buf</i> exceeds the limit reported for <a href="qrhi.html#ResourceLimit-enum" translate="no">QRhi::MaxUniformBufferRange</a>, unexpected errors may occur.</p>
</div>
<!-- @@@uniformBuffer -->
<!-- $$$uniformBuffer$$$uniformBufferintQRhiShaderResourceBinding::StageFlagsQRhiBuffer*quint32quint32 -->
<h3 class="fn" translate="no" id="uniformBuffer-1"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">uniformBuffer</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>offset</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>size</i>)</h3>
<p>Returns a shader resource binding for the given binding number, pipeline stages, and buffer specified by <i translate="no">binding</i>, <i translate="no">stage</i>, and <i translate="no">buf</i>. This overload binds a region only, as specified by <i translate="no">offset</i> and <i translate="no">size</i>.</p>
<div class="admonition note">
<p><b>Note: </b>It is up to the user to ensure the offset is aligned to <a href="qrhi.html#ubufAlignment" translate="no">QRhi::ubufAlignment</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">size</i> must be greater than 0.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">buf</i> is not null, it must have been created with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::UniformBuffer</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">buf</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If <i translate="no">size</i> exceeds the limit reported for <a href="qrhi.html#ResourceLimit-enum" translate="no">QRhi::MaxUniformBufferRange</a>, unexpected errors may occur.</p>
</div>
<!-- @@@uniformBuffer -->
<!-- $$$uniformBufferWithDynamicOffset[overload1]$$$uniformBufferWithDynamicOffsetintQRhiShaderResourceBinding::StageFlagsQRhiBuffer*quint32 -->
<h3 class="fn" translate="no" id="uniformBufferWithDynamicOffset"><code class="details extra" translate="no">[static]</code> <span class="type">QRhiShaderResourceBinding</span> QRhiShaderResourceBinding::<span class="name">uniformBufferWithDynamicOffset</span>(<span class="type">int</span> <i>binding</i>, <span class="type"><a href="qrhishaderresourcebinding.html#StageFlag-enum" translate="no">QRhiShaderResourceBinding::StageFlags</a></span> <i>stage</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>buf</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>size</i>)</h3>
<p>Returns a shader resource binding for the given binding number, pipeline stages, and buffer specified by <i translate="no">binding</i>, <i translate="no">stage</i>, and <i translate="no">buf</i>. The uniform buffer is assumed to have dynamic offset. The dynamic offset can be specified in <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(), thus allowing using varying offset values without creating new bindings for the buffer. The size of the bound region is specified by <i translate="no">size</i>. Like with non-dynamic offsets, <code translate="no">offset + size</code> cannot exceed the size of <i translate="no">buf</i>.</p>
<div class="admonition note">
<p><b>Note: </b>When <i translate="no">buf</i> is not null, it must have been created with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::UniformBuffer</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">buf</i> can be null. It is valid to create a <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with unspecified resources, but such an object cannot be used with <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> with resources present passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If <i translate="no">size</i> exceeds the limit reported for <a href="qrhi.html#ResourceLimit-enum" translate="no">QRhi::MaxUniformBufferRange</a>, unexpected errors may occur.</p>
</div>
<!-- @@@uniformBufferWithDynamicOffset -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash$$$qHashconstQRhiShaderResourceBinding&size_t -->
<h3 class="fn" translate="no" id="qHash-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type">QRhiShaderResourceBinding</span> &amp;<i>b</i>, <span class="type">size_t</span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for <i translate="no">b</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<!-- @@@qHash -->
<!-- $$$operator!=$$$operator!=constQRhiShaderResourceBinding&constQRhiShaderResourceBinding& -->
<h3 class="fn" translate="no" id="operator-not-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type">QRhiShaderResourceBinding</span> &amp;<i>a</i>, const <span class="type">QRhiShaderResourceBinding</span> &amp;<i>b</i>)</h3>
<p>Returns <code translate="no">false</code> if all the bindings in the two <a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a> objects <i translate="no">a</i> and <i translate="no">b</i> are equal; otherwise returns <code translate="no">true</code>.</p>
<!-- @@@operator!= -->
<!-- $$$operator==$$$operator==constQRhiShaderResourceBinding&constQRhiShaderResourceBinding& -->
<h3 class="fn" translate="no" id="operator-eq-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type">QRhiShaderResourceBinding</span> &amp;<i>a</i>, const <span class="type">QRhiShaderResourceBinding</span> &amp;<i>b</i>)</h3>
<p>Returns <code translate="no">true</code> if the contents of the two <a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a> objects <i translate="no">a</i> and <i translate="no">b</i> are equal. This includes the resources (buffer, texture) and related parameters (offset, size) as well. To only compare layouts (binding point, pipeline stage, resource type), use <a href="qrhishaderresourcebinding.html#isLayoutCompatible" translate="no">isLayoutCompatible</a>() instead.</p>
<!-- @@@operator== -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
