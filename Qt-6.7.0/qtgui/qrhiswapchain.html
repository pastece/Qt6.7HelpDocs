<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Swapchain resource.">
  <title>QRhiSwapChain Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiSwapChain</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiSwapChain Class</h1>
<!-- $$$QRhiSwapChain-brief -->
<p>Swapchain resource. <a href="#details">More...</a></p>
<!-- @@@QRhiSwapChain -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiSwapChain&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qrhiresource.html" translate="no">QRhiResource</a></td></tr>
</table></div>
<ul>
<li><a href="qrhiswapchain-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#Flag-enum" translate="no">Flag</a></b> { SurfaceHasPreMulAlpha, SurfaceHasNonPreMulAlpha, sRGB, UsedAsTransferSource, NoVSync, MinimalBufferCount }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#Flag-enum" translate="no">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#Format-enum" translate="no">Format</a></b> { SDR, HDRExtendedSrgbLinear, HDR10, HDRExtendedDisplayP3Linear }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#StereoTargetBuffer-enum" translate="no">StereoTargetBuffer</a></b> { LeftBuffer, RightBuffer }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiCommandBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#currentFrameCommandBuffer" translate="no">currentFrameCommandBuffer</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiRenderTarget *</td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#currentFrameRenderTarget" translate="no">currentFrameRenderTarget</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiRenderTarget *</td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#currentFrameRenderTarget-1" translate="no">currentFrameRenderTarget</a></b>(QRhiSwapChain::StereoTargetBuffer <i>targetBuffer</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#currentPixelSize" translate="no">currentPixelSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#depthStencil" translate="no">depthStencil</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiSwapChain::Flags </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiSwapChain::Format </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#format" translate="no">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiSwapChainHdrInfo </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#hdrInfo" translate="no">hdrInfo</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#isFormatSupported" translate="no">isFormatSupported</a></b>(QRhiSwapChain::Format <i>f</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiRenderPassDescriptor *</td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#newCompatibleRenderPassDescriptor" translate="no">newCompatibleRenderPassDescriptor</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiSwapChainProxyData </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#proxyData" translate="no">proxyData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderPassDescriptor *</td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#renderPassDescriptor" translate="no">renderPassDescriptor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#sampleCount" translate="no">sampleCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#setDepthStencil" translate="no">setDepthStencil</a></b>(QRhiRenderBuffer *<i>ds</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#setFlags" translate="no">setFlags</a></b>(QRhiSwapChain::Flags <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#setFormat" translate="no">setFormat</a></b>(QRhiSwapChain::Format <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#setProxyData" translate="no">setProxyData</a></b>(const QRhiSwapChainProxyData &amp;<i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#setRenderPassDescriptor" translate="no">setRenderPassDescriptor</a></b>(QRhiRenderPassDescriptor *<i>desc</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#setSampleCount" translate="no">setSampleCount</a></b>(int <i>samples</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#setWindow" translate="no">setWindow</a></b>(QWindow *<i>window</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#surfacePixelSize" translate="no">surfacePixelSize</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWindow *</td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#window" translate="no">window</a></b>() const</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiResource::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhiswapchain.html#resourceType" translate="no">resourceType</a></b>() const override</td></tr>
</table></div>
<!-- $$$QRhiSwapChain-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>A swapchain enables presenting rendering results to a surface. A swapchain is typically backed by a set of color buffers. Of these, one is displayed at a time.</p>
<p>Below is a typical pattern for creating and managing a swapchain and some associated resources in order to render onto a <a href="qwindow.html" translate="no">QWindow</a>:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> init()
 {
     sc <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newSwapChain();
     ds <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newRenderBuffer(<span class="type"><a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span><span class="operator">::</span>DepthStencil<span class="operator">,</span>
                               <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span>()<span class="operator">,</span> <span class="comment">// no need to set the size here due to UsedWithSwapChainOnly</span>
                               <span class="number">1</span><span class="operator">,</span>
                               <span class="type"><a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span><span class="operator">::</span>UsedWithSwapChainOnly);
     sc<span class="operator">-</span><span class="operator">&gt;</span>setWindow(window);
     sc<span class="operator">-</span><span class="operator">&gt;</span>setDepthStencil(ds);
     rp <span class="operator">=</span> sc<span class="operator">-</span><span class="operator">&gt;</span>newCompatibleRenderPassDescriptor();
     sc<span class="operator">-</span><span class="operator">&gt;</span>setRenderPassDescriptor(rp);
     resizeSwapChain();
 }

 <span class="type">void</span> resizeSwapChain()
 {
     hasSwapChain <span class="operator">=</span> sc<span class="operator">-</span><span class="operator">&gt;</span>createOrResize();
 }

 <span class="type">void</span> render()
 {
     <span class="keyword">if</span> (<span class="operator">!</span>hasSwapChain <span class="operator">|</span><span class="operator">|</span> notExposed)
         <span class="keyword">return</span>;

     <span class="keyword">if</span> (sc<span class="operator">-</span><span class="operator">&gt;</span>currentPixelSize() <span class="operator">!</span><span class="operator">=</span> sc<span class="operator">-</span><span class="operator">&gt;</span>surfacePixelSize() <span class="operator">|</span><span class="operator">|</span> newlyExposed) {
         resizeSwapChain();
         <span class="keyword">if</span> (<span class="operator">!</span>hasSwapChain)
             <span class="keyword">return</span>;
         newlyExposed <span class="operator">=</span> <span class="keyword">false</span>;
     }

     rhi<span class="operator">-</span><span class="operator">&gt;</span>beginFrame(sc);
     <span class="comment">// ...</span>
     rhi<span class="operator">-</span><span class="operator">&gt;</span>endFrame(sc);
 }
</pre>
<p>Avoid relying on <a href="qwindow.html" translate="no">QWindow</a> resize events to resize swapchains, especially considering that surface sizes may not always fully match the <a href="qwindow.html" translate="no">QWindow</a> reported dimensions. The safe, cross-platform approach is to do the check via <a href="qrhiswapchain.html#surfacePixelSize" translate="no">surfacePixelSize</a>() whenever starting a new frame.</p>
<p>Releasing the swapchain must happen while the <a href="qwindow.html" translate="no">QWindow</a> and the underlying native window is fully up and running. Building on the previous example:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> releaseSwapChain()
 {
     <span class="keyword">if</span> (hasSwapChain) {
         sc<span class="operator">-</span><span class="operator">&gt;</span>destroy();
         hasSwapChain <span class="operator">=</span> <span class="keyword">false</span>;
     }
 }

 <span class="comment">// assuming Window is our QWindow subclass</span>
 <span class="type">bool</span> Window<span class="operator">::</span>event(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> <span class="operator">*</span>e)
 {
     <span class="keyword">switch</span> (e<span class="operator">-</span><span class="operator">&gt;</span>type()) {
     <span class="keyword">case</span> <span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>UpdateRequest: <span class="comment">// for QWindow::requestUpdate()</span>
         render();
         <span class="keyword">break</span>;
     <span class="keyword">case</span> <span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>PlatformSurface:
         <span class="keyword">if</span> (<span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="qplatformsurfaceevent.html" translate="no">QPlatformSurfaceEvent</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(e)<span class="operator">-</span><span class="operator">&gt;</span>surfaceEventType() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qplatformsurfaceevent.html" translate="no">QPlatformSurfaceEvent</a></span><span class="operator">::</span>SurfaceAboutToBeDestroyed)
             releaseSwapChain();
         <span class="keyword">break</span>;
     <span class="keyword">default</span>:
         <span class="keyword">break</span>;
     }
     <span class="keyword">return</span> <span class="type"><a href="qwindow.html" translate="no">QWindow</a></span><span class="operator">::</span>event(e);
 }
</pre>
<p>Initializing the swapchain and starting to render the first frame cannot start at any time. The safe, cross-platform approach is to rely on expose events. <a href="qexposeevent.html" translate="no">QExposeEvent</a> is a loosely specified event that is sent whenever a window gets mapped, obscured, and resized, depending on the platform.</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> Window<span class="operator">::</span>exposeEvent(<span class="type"><a href="qexposeevent.html" translate="no">QExposeEvent</a></span> <span class="operator">*</span>)
 {
     <span class="comment">// initialize and start rendering when the window becomes usable for graphics purposes</span>
     <span class="keyword">if</span> (isExposed() <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>running) {
         running <span class="operator">=</span> <span class="keyword">true</span>;
         init();
     }

     <span class="comment">// stop pushing frames when not exposed or size becomes 0</span>
     <span class="keyword">if</span> ((<span class="operator">!</span>isExposed() <span class="operator">|</span><span class="operator">|</span> (hasSwapChain <span class="operator">&amp;</span><span class="operator">&amp;</span> sc<span class="operator">-</span><span class="operator">&gt;</span>surfacePixelSize()<span class="operator">.</span>isEmpty())) <span class="operator">&amp;</span><span class="operator">&amp;</span> running)
         notExposed <span class="operator">=</span> <span class="keyword">true</span>;

     <span class="comment">// continue when exposed again and the surface has a valid size</span>
     <span class="keyword">if</span> (isExposed() <span class="operator">&amp;</span><span class="operator">&amp;</span> running <span class="operator">&amp;</span><span class="operator">&amp;</span> notExposed <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>sc<span class="operator">-</span><span class="operator">&gt;</span>surfacePixelSize()<span class="operator">.</span>isEmpty()) {
         notExposed <span class="operator">=</span> <span class="keyword">false</span>;
         newlyExposed <span class="operator">=</span> <span class="keyword">true</span>;
     }

     <span class="keyword">if</span> (isExposed() <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>sc<span class="operator">-</span><span class="operator">&gt;</span>surfacePixelSize()<span class="operator">.</span>isEmpty())
         render();
 }
</pre>
<p>Once the rendering has started, a simple way to request a new frame is <a href="qwindow.html#requestUpdate" translate="no">QWindow::requestUpdate</a>(). While on some platforms this is merely a small timer, on others it has a specific implementation: for instance on macOS or iOS it may be backed by <a href="https://developer.apple.com/documentation/corevideo/cvdisplaylink?language=objc" translate="no">CVDisplayLink</a>. The example above is already prepared for update requests by handling <a href="../qtcore/qevent.html#Type-enum" translate="no">QEvent::UpdateRequest</a>.</p>
<p>While acting as a <a href="qrhirendertarget.html" translate="no">QRhiRenderTarget</a>, QRhiSwapChain also manages a <a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a>. Calling <a href="qrhi.html#endFrame" translate="no">QRhi::endFrame</a>() submits the recorded commands and also enqueues a <code translate="no">present</code> request. The default behavior is to do this with a swap interval of 1, meaning synchronizing to the display's vertical refresh is enabled. Thus the rendering thread calling beginFrame() and endFrame() will get throttled to vsync. On some backends this can be disabled by passing QRhiSwapChain:<a href="qrhiswapchain.html#Flag-enum" translate="no">NoVSync</a> in <a href="qrhiswapchain.html#flags" translate="no">flags</a>().</p>
<p>Multisampling (MSAA) is handled transparently to the applications when requested via <a href="qrhiswapchain.html#setSampleCount" translate="no">setSampleCount</a>(). Where applicable, QRhiSwapChain will take care of creating additional color buffers and issuing a multisample resolve command at the end of a frame. For OpenGL, it is necessary to request the appropriate sample count also via <a href="qsurfaceformat.html" translate="no">QSurfaceFormat</a>, by calling <a href="qsurfaceformat.html#setDefaultFormat" translate="no">QSurfaceFormat::setDefaultFormat</a>() before initializing the <a href="qrhi.html" translate="no">QRhi</a>.</p>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<!-- @@@QRhiSwapChain -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Flag$$$SurfaceHasPreMulAlpha$$$SurfaceHasNonPreMulAlpha$$$sRGB$$$UsedAsTransferSource$$$NoVSync$$$MinimalBufferCount -->
<h3 class="flags" id="Flag-enum">enum QRhiSwapChain::<span class="name">Flag</span><br/>flags QRhiSwapChain::<span class="name">Flags</span></h3>
<p>Flag values to describe swapchain properties</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::SurfaceHasPreMulAlpha</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td><td class="topAlign">Indicates that the target surface has transparency with premultiplied alpha. For example, this is what Qt Quick uses when the alpha channel is enabled on the target <a href="qwindow.html" translate="no">QWindow</a>, because the scenegraph rendrerer always outputs fragments with alpha multiplied into the red, green, and blue values. To ensure identical behavior across platforms, always set <a href="qsurfaceformat.html#alphaBufferSize" translate="no">QSurfaceFormat::alphaBufferSize</a>() to a non-zero value on the target <a href="qwindow.html" translate="no">QWindow</a> whenever this flag is set on the swapchain.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::SurfaceHasNonPreMulAlpha</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 1</code></td><td class="topAlign">Indicates the target surface has transparency with non-premultiplied alpha. Be aware that this may not be supported on some systems, if the system compositor always expects content with premultiplied alpha. In that case the behavior with this flag set is expected to be equivalent to SurfaceHasPreMulAlpha.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::sRGB</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 2</code></td><td class="topAlign">Requests to pick an sRGB format for the swapchain's color buffers and/or render target views, where applicable. Note that this implies that sRGB framebuffer update and blending will get enabled for all content targeting this swapchain, and opting out is not possible. For OpenGL, set <a href="qsurfaceformat.html#ColorSpace-enum" translate="no">sRGBColorSpace</a> on the <a href="qsurfaceformat.html" translate="no">QSurfaceFormat</a> of the <a href="qwindow.html" translate="no">QWindow</a> in addition. Applicable only when the swapchain format is set to <a href="qrhiswapchain.html#Format-enum" translate="no">QRhiSwapChain::SDR</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::UsedAsTransferSource</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 3</code></td><td class="topAlign">Indicates the swapchain will be used as the source of a readback in <a href="qrhiresourceupdatebatch.html#readBackTexture" translate="no">QRhiResourceUpdateBatch::readBackTexture</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::NoVSync</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 4</code></td><td class="topAlign">Requests disabling waiting for vertical sync, also avoiding throttling the rendering thread. The behavior is backend specific and applicable only where it is possible to control this. Some may ignore the request altogether. For OpenGL, try instead setting the swap interval to 0 on the <a href="qwindow.html" translate="no">QWindow</a> via <a href="qsurfaceformat.html#setSwapInterval" translate="no">QSurfaceFormat::setSwapInterval</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::MinimalBufferCount</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 5</code></td><td class="topAlign">Requests creating the swapchain with the minimum number of buffers, which is in practice 2, unless the graphics implementation has a higher minimum number than that. Only applicable with backends where such control is available via the graphics API, for example, Vulkan. By default it is up to the backend to decide what number of buffers it requests (in practice this is almost always either 2 or 3), and it is not the applications' concern. However, on Vulkan for instance the backend will likely prefer the higher number (3), for example to avoid odd performance issues with some Vulkan implementations on mobile devices. It could be that on some platforms it can prove to be beneficial to force the lower buffer count (2), so this flag allows forcing that. Note that all this has no effect on the number of frames kept in flight, so the CPU (<a href="qrhi.html" translate="no">QRhi</a>) will still prepare frames at most <code translate="no">N - 1</code> frames ahead of the GPU, even when the swapchain image buffer count larger than <code translate="no">N</code>. (<code translate="no">N</code> = <a href="qrhi.html#ResourceLimit-enum" translate="no">QRhi::FramesInFlight</a> and typically 2).</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
<!-- $$$Format$$$SDR$$$HDRExtendedSrgbLinear$$$HDR10$$$HDRExtendedDisplayP3Linear -->
<h3 class="fn" translate="no" id="Format-enum">enum QRhiSwapChain::<span class="name">Format</span></h3>
<p>Describes the swapchain format. The default format is SDR.</p>
<p>This enum is used with <a href="qrhiswapchain.html#isFormatSupported" translate="no">isFormatSupported</a>() to check upfront if creating the swapchain with the given format is supported by the platform and the window's associated screen, and with <a href="qrhiswapchain.html#setFormat" translate="no">setFormat</a>() to set the requested format in the swapchain before calling <a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>() for the first time.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::SDR</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">8-bit RGBA or BGRA, depending on the backend and platform. With OpenGL ES in particular, it could happen that the platform provides less than 8 bits (e.g. due to EGL and the <a href="qsurfaceformat.html" translate="no">QSurfaceFormat</a> choosing a 565 or 444 format - this is outside the control of <a href="qrhi.html" translate="no">QRhi</a>). Standard dynamic range. May be combined with setting the <a href="qrhiswapchain.html#Flag-enum" translate="no">QRhiSwapChain::sRGB</a> flag.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::HDRExtendedSrgbLinear</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">16-bit float RGBA, high dynamic range, extended linear sRGB (scRGB) color space. This involves Rec. 709 primaries (same as SDR/sRGB) and linear colors. Conversion to the display's native color space (such as, HDR10) is performed by the windowing system. On Windows this is the canonical color space of the system compositor, and is the recommended format for HDR swapchains in general on desktop platforms.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::HDR10</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">10-bit unsigned int RGB or BGR with 2 bit alpha, high dynamic range, HDR10 (Rec. 2020) color space with an ST2084 PQ transfer function.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::HDRExtendedDisplayP3Linear</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">16-bit float RGBA, high dynamic range, extended linear Display P3 color space. The primary choice for HDR on platforms such as iOS and VisionOS.</td></tr>
</table></div>
<!-- @@@Format -->
<!-- $$$StereoTargetBuffer$$$LeftBuffer$$$RightBuffer -->
<h3 class="fn" translate="no" id="StereoTargetBuffer-enum">enum QRhiSwapChain::<span class="name">StereoTargetBuffer</span></h3>
<p>Selects the backbuffer to use with a stereoscopic swapchain.</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::LeftBuffer</code></td><td class="topAlign tblval"><code translate="no">0</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiSwapChain::RightBuffer</code></td><td class="topAlign tblval"><code translate="no">1</code></td></tr>
</table></div>
<!-- @@@StereoTargetBuffer -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$createOrResize[overload1]$$$createOrResize -->
<h3 class="fn" translate="no" id="createOrResize"><code class="details extra" translate="no">[pure virtual]</code> <span class="type">bool</span> QRhiSwapChain::<span class="name">createOrResize</span>()</h3>
<p>Creates the swapchain if not already done and resizes the swapchain buffers to match the current size of the targeted surface. Call this whenever the size of the target surface is different than before.</p>
<div class="admonition note">
<p><b>Note: </b>call <a href="qrhiresource.html#destroy" translate="no">destroy</a>() only when the swapchain needs to be released completely, typically upon <a href="qplatformsurfaceevent.html#SurfaceEventType-enum" translate="no">QPlatformSurfaceEvent::SurfaceAboutToBeDestroyed</a>. To perform resizing, just call createOrResize().</p>
</div>
<p>Returns <code translate="no">true</code> when successful, <code translate="no">false</code> when a graphics operation failed. Regardless of the return value, calling <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is always safe.</p>
<!-- @@@createOrResize -->
<!-- $$$currentFrameCommandBuffer[overload1]$$$currentFrameCommandBuffer -->
<h3 class="fn" translate="no" id="currentFrameCommandBuffer"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> *QRhiSwapChain::<span class="name">currentFrameCommandBuffer</span>()</h3>
<p>Returns a command buffer on which rendering commands and resource updates can be recorded within a <a href="qrhi.html#beginFrame" translate="no">beginFrame</a> - <a href="qrhi.html#endFrame" translate="no">endFrame</a> block, assuming beginFrame() was called with this swapchain.</p>
<div class="admonition note">
<p><b>Note: </b>The returned object is valid also after endFrame(), up until the next beginFrame(), but the returned command buffer should not be used to record any commands then. Rather, it can be used to query data collected during the frame (or previous frames), for example by calling <a href="qrhicommandbuffer.html#lastCompletedGpuTime" translate="no">lastCompletedGpuTime</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The value must not be cached and reused between frames. The caller should not hold on to the returned object once <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>() is called again. Instead, the command buffer object should be queried again by calling this function.</p>
</div>
<!-- @@@currentFrameCommandBuffer -->
<!-- $$$currentFrameRenderTarget[overload1]$$$currentFrameRenderTarget -->
<h3 class="fn" translate="no" id="currentFrameRenderTarget"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qrhirendertarget.html" translate="no">QRhiRenderTarget</a></span> *QRhiSwapChain::<span class="name">currentFrameRenderTarget</span>()</h3>
<p>Returns a render target that can used with beginPass() in order to render the swapchain's current backbuffer. Only valid within a <a href="qrhi.html#beginFrame" translate="no">QRhi::beginFrame</a>() - <a href="qrhi.html#endFrame" translate="no">QRhi::endFrame</a>() block where beginFrame() was called with this swapchain.</p>
<div class="admonition note">
<p><b>Note: </b>the value must not be cached and reused between frames</p>
</div>
<!-- @@@currentFrameRenderTarget -->
<!-- $$$currentFrameRenderTarget$$$currentFrameRenderTargetQRhiSwapChain::StereoTargetBuffer -->
<h3 class="fn" translate="no" id="currentFrameRenderTarget-1"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="qrhirendertarget.html" translate="no">QRhiRenderTarget</a></span> *QRhiSwapChain::<span class="name">currentFrameRenderTarget</span>(<span class="type"><a href="qrhiswapchain.html#StereoTargetBuffer-enum" translate="no">QRhiSwapChain::StereoTargetBuffer</a></span> <i>targetBuffer</i>)</h3>
<p>Returns a render target that can be used with beginPass() in order to render to the swapchain's left or right backbuffer. This overload should be used only with stereoscopic rendering, that is, when the associated <a href="qwindow.html" translate="no">QWindow</a> is backed by two color buffers, one for each eye, instead of just one.</p>
<p>When stereoscopic rendering is not supported, the return value will be the default target. It is supported by all hardware backends except for Metal, in combination with <a href="qsurfaceformat.html#FormatOption-enum" translate="no">QSurfaceFormat::StereoBuffers</a>, assuming it is supported by the graphics and display driver stack at run time. Metal and Null backends are going to return the default render target from this overload.</p>
<div class="admonition note">
<p><b>Note: </b>the value must not be cached and reused between frames</p>
</div>
<!-- @@@currentFrameRenderTarget -->
<!-- $$$currentPixelSize[overload1]$$$currentPixelSize -->
<h3 class="fn" translate="no" id="currentPixelSize"><span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QRhiSwapChain::<span class="name">currentPixelSize</span>() const</h3>
<p>Returns the size with which the swapchain was last successfully built. Use this to decide if <a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>() needs to be called again: if <code translate="no">currentPixelSize() != surfacePixelSize()</code> then the swapchain needs to be resized.</p>
<div class="admonition note">
<p><b>Note: </b>Typical rendering logic will call this function to get the output size when starting to prepare a new frame, and base dependent calculations (such as, the viewport) on the size returned from this function.</p>
</div>
<p>While in many cases the value is the same as <code translate="no">QWindow::size() * QWindow::devicePixelRatio()</code>, relying on the <a href="qwindow.html" translate="no">QWindow</a>-reported size is not guaranteed to be correct on all platforms and graphics API implementations. Using this function is therefore strongly recommended whenever there is a need to identify the dimensions, in pixels, of the output layer or surface.</p>
<p>This also has the added benefit of avoiding potential data races when <a href="qrhi.html" translate="no">QRhi</a> is used on a dedicated rendering thread, because the need to call <a href="qwindow.html" translate="no">QWindow</a> functions, that may then access data updated on the main thread, is avoided.</p>
<p><b>See also </b><a href="qrhiswapchain.html#surfacePixelSize" translate="no">surfacePixelSize</a>().</p>
<!-- @@@currentPixelSize -->
<!-- $$$depthStencil[overload1]$$$depthStencil -->
<h3 class="fn" translate="no" id="depthStencil"><span class="type"><a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *QRhiSwapChain::<span class="name">depthStencil</span>() const</h3>
<p>Returns the currently associated renderbuffer for depth-stencil.</p>
<p><b>See also </b><a href="qrhiswapchain.html#setDepthStencil" translate="no">setDepthStencil</a>().</p>
<!-- @@@depthStencil -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><span class="type"><a href="qrhiswapchain.html#Flag-enum" translate="no">QRhiSwapChain::Flags</a></span> QRhiSwapChain::<span class="name">flags</span>() const</h3>
<p>Returns the currently set flags.</p>
<p><b>See also </b><a href="qrhiswapchain.html#setFlags" translate="no">setFlags</a>().</p>
<!-- @@@flags -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" translate="no" id="format"><span class="type"><a href="qrhiswapchain.html#Format-enum" translate="no">QRhiSwapChain::Format</a></span> QRhiSwapChain::<span class="name">format</span>() const</h3>
<p>Returns the currently set format.</p>
<p><b>See also </b><a href="qrhiswapchain.html#setFormat" translate="no">setFormat</a>().</p>
<!-- @@@format -->
<!-- $$$hdrInfo[overload1]$$$hdrInfo -->
<h3 class="fn" translate="no" id="hdrInfo"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="qrhiswapchainhdrinfo.html" translate="no">QRhiSwapChainHdrInfo</a></span> QRhiSwapChain::<span class="name">hdrInfo</span>()</h3>
<p>Returns the HDR information for the associated display.</p>
<p>Do not assume that this is a cheap operation. Depending on the platform, this function makes various platform queries which may have a performance impact.</p>
<div class="admonition note">
<p><b>Note: </b>Can be called before <a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>() as long as the window is <a href="qrhiswapchain.html#setWindow" translate="no">set</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>What happens when moving a window with an initialized swapchain between displays (HDR to HDR with different characteristics, HDR to SDR, etc.) is not currently well-defined and depends heavily on the windowing system and compositor, with potentially varying behavior between platforms. Currently <a href="qrhi.html" translate="no">QRhi</a> only guarantees that hdrInfo() returns valid data, if available, for the display to which the swapchain's associated window belonged at the time of <a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>().</p>
</div>
<p><b>See also </b><a href="qrhiswapchainhdrinfo.html" translate="no">QRhiSwapChainHdrInfo</a>.</p>
<!-- @@@hdrInfo -->
<!-- $$$isFormatSupported[overload1]$$$isFormatSupportedQRhiSwapChain::Format -->
<h3 class="fn" translate="no" id="isFormatSupported"><code class="details extra" translate="no">[pure virtual]</code> <span class="type">bool</span> QRhiSwapChain::<span class="name">isFormatSupported</span>(<span class="type"><a href="qrhiswapchain.html#Format-enum" translate="no">QRhiSwapChain::Format</a></span> <i>f</i>)</h3>
<p>Returns true if the given swapchain format <i translate="no">f</i> is supported. SDR is always supported.</p>
<div class="admonition note">
<p><b>Note: </b>Can be called independently of <a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>(), but <a href="qrhiswapchain.html#window" translate="no">window</a>() must already be set. Calling without the window set may lead to unexpected results depending on the backend and platform (most likely false for any HDR format), because HDR format support is usually tied to the output (screen) to which the swapchain's associated window belongs at any given time. If the result is true for a HDR format, then creating the swapchain with that format is expected to succeed as long as the window is not moved to another screen in the meantime.</p>
</div>
<p>The main use of this function is to call it before the first <a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>() after the window is already set. This allow the <a href="qrhi.html" translate="no">QRhi</a> backends to perform platform or windowing system specific queries to determine if the window (and the screen it is on) is capable of true HDR output with the specified format.</p>
<p>When the format is reported as supported, call <a href="qrhiswapchain.html#setFormat" translate="no">setFormat</a>() to set the requested format and call <a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>(). Be aware of the consequences however: successfully requesting a HDR format will involve having to deal with a different color space, possibly doing white level correction for non-HDR-aware content, adjusting tonemapping methods, adjusting offscreen render target settings, etc.</p>
<p><b>See also </b><a href="qrhiswapchain.html#setFormat" translate="no">setFormat</a>().</p>
<!-- @@@isFormatSupported -->
<!-- $$$newCompatibleRenderPassDescriptor[overload1]$$$newCompatibleRenderPassDescriptor -->
<h3 class="fn" translate="no" id="newCompatibleRenderPassDescriptor"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a></span> *QRhiSwapChain::<span class="name">newCompatibleRenderPassDescriptor</span>()</h3>
<p>Returns a new <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> that is compatible with this swapchain.</p>
<p>The returned value is used in two ways: it can be passed to <a href="qrhiswapchain.html#setRenderPassDescriptor" translate="no">setRenderPassDescriptor</a>() and <a href="qrhigraphicspipeline.html#setRenderPassDescriptor" translate="no">QRhiGraphicsPipeline::setRenderPassDescriptor</a>(). A render pass descriptor describes the attachments (color, depth/stencil) and the load/store behavior that can be affected by <a href="qrhiswapchain.html#flags" translate="no">flags</a>(). A <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> can only be used in combination with a swapchain that has a <a href="qrhirenderpassdescriptor.html#isCompatible" translate="no">compatible</a> <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> set.</p>
<p><b>See also </b><a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>().</p>
<!-- @@@newCompatibleRenderPassDescriptor -->
<!-- $$$proxyData[overload1]$$$proxyData -->
<h3 class="fn" translate="no" id="proxyData"><span class="type"><a href="qrhiswapchainproxydata.html" translate="no">QRhiSwapChainProxyData</a></span> QRhiSwapChain::<span class="name">proxyData</span>() const</h3>
<p>Returns the currently set proxy data.</p>
<p><b>See also </b><a href="qrhiswapchain.html#setProxyData" translate="no">setProxyData</a>().</p>
<!-- @@@proxyData -->
<!-- $$$renderPassDescriptor[overload1]$$$renderPassDescriptor -->
<h3 class="fn" translate="no" id="renderPassDescriptor"><span class="type"><a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a></span> *QRhiSwapChain::<span class="name">renderPassDescriptor</span>() const</h3>
<p>Returns the currently associated <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> object.</p>
<p><b>See also </b><a href="qrhiswapchain.html#setRenderPassDescriptor" translate="no">setRenderPassDescriptor</a>().</p>
<!-- @@@renderPassDescriptor -->
<!-- $$$resourceType[overload1]$$$resourceType -->
<h3 class="fn" translate="no" id="resourceType"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="qrhiresource.html#Type-enum" translate="no">QRhiResource::Type</a></span> QRhiSwapChain::<span class="name">resourceType</span>() const</h3>
<p>Reimplements: <a href="qrhiresource.html#resourceType" translate="no">QRhiResource::resourceType() const</a>.</p>
<p>Returns the resource type.</p>
<!-- @@@resourceType -->
<!-- $$$sampleCount[overload1]$$$sampleCount -->
<h3 class="fn" translate="no" id="sampleCount"><span class="type">int</span> QRhiSwapChain::<span class="name">sampleCount</span>() const</h3>
<p>Returns the currently set sample count. 1 means no multisample antialiasing.</p>
<p><b>See also </b><a href="qrhiswapchain.html#setSampleCount" translate="no">setSampleCount</a>().</p>
<!-- @@@sampleCount -->
<!-- $$$setDepthStencil[overload1]$$$setDepthStencilQRhiRenderBuffer* -->
<h3 class="fn" translate="no" id="setDepthStencil"><span class="type">void</span> QRhiSwapChain::<span class="name">setDepthStencil</span>(<span class="type"><a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *<i>ds</i>)</h3>
<p>Sets the renderbuffer <i translate="no">ds</i> for use as a depth-stencil buffer.</p>
<p><b>See also </b><a href="qrhiswapchain.html#depthStencil" translate="no">depthStencil</a>().</p>
<!-- @@@setDepthStencil -->
<!-- $$$setFlags[overload1]$$$setFlagsQRhiSwapChain::Flags -->
<h3 class="fn" translate="no" id="setFlags"><span class="type">void</span> QRhiSwapChain::<span class="name">setFlags</span>(<span class="type"><a href="qrhiswapchain.html#Flag-enum" translate="no">QRhiSwapChain::Flags</a></span> <i>f</i>)</h3>
<p>Sets the flags <i translate="no">f</i>.</p>
<p><b>See also </b><a href="qrhiswapchain.html#flags" translate="no">flags</a>().</p>
<!-- @@@setFlags -->
<!-- $$$setFormat[overload1]$$$setFormatQRhiSwapChain::Format -->
<h3 class="fn" translate="no" id="setFormat"><span class="type">void</span> QRhiSwapChain::<span class="name">setFormat</span>(<span class="type"><a href="qrhiswapchain.html#Format-enum" translate="no">QRhiSwapChain::Format</a></span> <i>f</i>)</h3>
<p>Sets the format <i translate="no">f</i>.</p>
<p>Avoid setting formats that are reported as unsupported from <a href="qrhiswapchain.html#isFormatSupported" translate="no">isFormatSupported</a>(). Note that support for a given format may depend on the screen the swapchain's associated window is opened on. On some platforms, such as Windows and macOS, for HDR output to work it is necessary to have HDR output enabled in the display settings.</p>
<p>See <a href="qrhiswapchain.html#isFormatSupported" translate="no">isFormatSupported</a>(), <a href="qrhiswapchainhdrinfo.html" translate="no">QRhiSwapChainHdrInfo</a>, and <a href="qrhiswapchain.html#Format-enum" translate="no">Format</a> for more information on high dynamic range output.</p>
<p><b>See also </b><a href="qrhiswapchain.html#format" translate="no">format</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setProxyData[overload1]$$$setProxyDataconstQRhiSwapChainProxyData& -->
<h3 class="fn" translate="no" id="setProxyData"><span class="type">void</span> QRhiSwapChain::<span class="name">setProxyData</span>(const <span class="type"><a href="qrhiswapchainproxydata.html" translate="no">QRhiSwapChainProxyData</a></span> &amp;<i>d</i>)</h3>
<p>Sets the proxy data <i translate="no">d</i>.</p>
<p><b>See also </b><a href="qrhiswapchain.html#proxyData" translate="no">proxyData</a>() and <a href="qrhi.html#updateSwapChainProxyData" translate="no">QRhi::updateSwapChainProxyData</a>().</p>
<!-- @@@setProxyData -->
<!-- $$$setRenderPassDescriptor[overload1]$$$setRenderPassDescriptorQRhiRenderPassDescriptor* -->
<h3 class="fn" translate="no" id="setRenderPassDescriptor"><span class="type">void</span> QRhiSwapChain::<span class="name">setRenderPassDescriptor</span>(<span class="type"><a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a></span> *<i>desc</i>)</h3>
<p>Associates with the <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> <i translate="no">desc</i>.</p>
<p><b>See also </b><a href="qrhiswapchain.html#renderPassDescriptor" translate="no">renderPassDescriptor</a>().</p>
<!-- @@@setRenderPassDescriptor -->
<!-- $$$setSampleCount[overload1]$$$setSampleCountint -->
<h3 class="fn" translate="no" id="setSampleCount"><span class="type">void</span> QRhiSwapChain::<span class="name">setSampleCount</span>(<span class="type">int</span> <i>samples</i>)</h3>
<p>Sets the sample count. Common values for <i translate="no">samples</i> are 1 (no MSAA), 4 (4x MSAA), or 8 (8x MSAA).</p>
<p><b>See also </b><a href="qrhiswapchain.html#sampleCount" translate="no">sampleCount</a>() and <a href="qrhi.html#supportedSampleCounts" translate="no">QRhi::supportedSampleCounts</a>().</p>
<!-- @@@setSampleCount -->
<!-- $$$setWindow[overload1]$$$setWindowQWindow* -->
<h3 class="fn" translate="no" id="setWindow"><span class="type">void</span> QRhiSwapChain::<span class="name">setWindow</span>(<span class="type"><a href="qwindow.html" translate="no">QWindow</a></span> *<i>window</i>)</h3>
<p>Sets the <i translate="no">window</i>.</p>
<p><b>See also </b><a href="qrhiswapchain.html#window" translate="no">window</a>().</p>
<!-- @@@setWindow -->
<!-- $$$surfacePixelSize[overload1]$$$surfacePixelSize -->
<h3 class="fn" translate="no" id="surfacePixelSize"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QRhiSwapChain::<span class="name">surfacePixelSize</span>()</h3>
<p>Returns The size of the window's associated surface or layer.</p>
<div class="admonition warning">
<p><b>Warning: </b>Do not assume this is the same as <code translate="no">QWindow::size() * QWindow::devicePixelRatio()</code>. With some graphics APIs and windowing system interfaces (for example, Vulkan) there is a theoretical possibility for a surface to assume a size different from the associated window. To support these cases, <b>rendering logic must always base size-derived calculations (such as, viewports) on the size reported from <a href="qrhiswapchain.html" translate="no">QRhiSwapChain</a>, and never on the size queried from <a href="qwindow.html" translate="no">QWindow</a></b>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><b>Can also be called before <a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>(), if at least <a href="qrhiswapchain.html#window" translate="no">window</a>() is already set. This in combination with <a href="qrhiswapchain.html#currentPixelSize" translate="no">currentPixelSize</a>() allows to detect when a swapchain needs to be resized.</b> However, watch out for the fact that the size of the underlying native object (surface, layer, or similar) is &quot;live&quot;, so whenever this function is called, it returns the latest value reported by the underlying implementation, without any atomicity guarantee. Therefore, using this function to determine pixel sizes for graphics resources that are used in a frame is strongly discouraged. Rely on <a href="qrhiswapchain.html#currentPixelSize" translate="no">currentPixelSize</a>() instead which returns a size that is atomic and will not change between <a href="qrhiswapchain.html#createOrResize" translate="no">createOrResize</a>() invocations.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>For depth-stencil buffers used in combination with the swapchain's color buffers, it is strongly recommended to rely on the automatic sizing and rebuilding behavior provided by the <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>:UsedWithSwapChainOnly flag. Avoid querying the surface size via this function just to get a size that can be passed to <a href="qrhirenderbuffer.html#setPixelSize" translate="no">QRhiRenderBuffer::setPixelSize</a>() as that would suffer from the lack of atomicity as described above.</p>
</div>
<p><b>See also </b><a href="qrhiswapchain.html#currentPixelSize" translate="no">currentPixelSize</a>().</p>
<!-- @@@surfacePixelSize -->
<!-- $$$window[overload1]$$$window -->
<h3 class="fn" translate="no" id="window"><span class="type"><a href="qwindow.html" translate="no">QWindow</a></span> *QRhiSwapChain::<span class="name">window</span>() const</h3>
<p>Returns the currently set window.</p>
<p><b>See also </b><a href="qrhiswapchain.html#setWindow" translate="no">setWindow</a>().</p>
<!-- @@@window -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
