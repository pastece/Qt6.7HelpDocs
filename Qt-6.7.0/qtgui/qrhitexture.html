<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Texture resource.">
  <title>QRhiTexture Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiTexture</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#example-usage">Example usage</a></li>
<li class="level2"><a href="#common-patterns">Common patterns</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiTexture Class</h1>
<!-- $$$QRhiTexture-brief -->
<p>Texture resource. <a href="#details">More...</a></p>
<!-- @@@QRhiTexture -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiTexture&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qrhiresource.html" translate="no">QRhiResource</a></td></tr>
</table></div>
<ul>
<li><a href="qrhitexture-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture-nativetexture.html" translate="no">NativeTexture</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#Flag-enum" translate="no">Flag</a></b> { RenderTarget, CubeMap, MipMapped, sRGB, UsedAsTransferSource, &hellip;, OneDimensional }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#Flag-enum" translate="no">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#Format-enum" translate="no">Format</a></b> { UnknownFormat, RGBA8, BGRA8, R8, RG8, &hellip;, ASTC_12x12 }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#arrayRangeLength" translate="no">arrayRangeLength</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#arrayRangeStart" translate="no">arrayRangeStart</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#arraySize" translate="no">arraySize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#create" translate="no">create</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#createFrom" translate="no">createFrom</a></b>(QRhiTexture::NativeTexture <i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#depth" translate="no">depth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture::Flags </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture::Format </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#format" translate="no">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiTexture::NativeTexture </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#nativeTexture" translate="no">nativeTexture</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#pixelSize" translate="no">pixelSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#sampleCount" translate="no">sampleCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#setArrayRange" translate="no">setArrayRange</a></b>(int <i>startIndex</i>, int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#setArraySize" translate="no">setArraySize</a></b>(int <i>arraySize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#setDepth" translate="no">setDepth</a></b>(int <i>depth</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#setFlags" translate="no">setFlags</a></b>(QRhiTexture::Flags <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#setFormat" translate="no">setFormat</a></b>(QRhiTexture::Format <i>fmt</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#setNativeLayout" translate="no">setNativeLayout</a></b>(int <i>layout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#setPixelSize" translate="no">setPixelSize</a></b>(const QSize &amp;<i>sz</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#setSampleCount" translate="no">setSampleCount</a></b>(int <i>s</i>)</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiResource::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhitexture.html#resourceType" translate="no">resourceType</a></b>() const override</td></tr>
</table></div>
<!-- $$$QRhiTexture-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>A QRhiTexture encapsulates a native texture object, such as a <code translate="no">VkImage</code> or <code translate="no">MTLTexture</code>.</p>
<p>A QRhiTexture instance is always created by calling <a href="qrhi.html#newTexture" translate="no">the QRhi's newTexture() function</a>. This creates no native graphics resources. To do that, call <a href="qrhitexture.html#create" translate="no">create</a>() after setting the appropriate options, such as the format and size, although in most cases these are already set based on the arguments passed to <a href="qrhi.html#newTexture" translate="no">newTexture</a>().</p>
<p>Setting the <a href="qrhitexture.html#Flag-enum" translate="no">flags</a> correctly is essential, otherwise various errors can occur depending on the underlying <a href="qrhi.html" translate="no">QRhi</a> backend and graphics API. For example, when a texture will be rendered into from a render pass via <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>, the texture must be created with the <a href="qrhitexture.html#Flag-enum" translate="no">RenderTarget</a> flag set. Similarly, when the texture is going to be <a href="qrhiresourceupdatebatch.html#readBackTexture" translate="no">read back</a>, the <a href="qrhitexture.html#Flag-enum" translate="no">UsedAsTransferSource</a> flag must be set upfront. Mipmapped textures must have the <a href="qrhitexture.html#Flag-enum" translate="no">MipMapped</a> flag set. And so on. It is not possible to change the flags once <a href="qrhitexture.html#create" translate="no">create</a>() has succeeded. To release the existing and create a new native texture object with the changed settings, call the setters and call <a href="qrhitexture.html#create" translate="no">create</a>() again. This then might be a potentially expensive operation.</p>
<h4 id="example-usage">Example usage</h4>
<p>To create a 2D texture with a size of 512x512 pixels and set its contents to all green:</p>
<pre class="cpp" translate="no">
 <span class="type">QRhiTexture</span> <span class="operator">*</span>texture <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newTexture(<span class="type">QRhiTexture</span><span class="operator">::</span>RGBA8<span class="operator">,</span> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span>(<span class="number">512</span><span class="operator">,</span> <span class="number">512</span>));
 <span class="keyword">if</span> (<span class="operator">!</span>texture<span class="operator">-</span><span class="operator">&gt;</span>create()) { error(); }
 <span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>batch <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
 <span class="type"><a href="qimage.html" translate="no">QImage</a></span> image(<span class="number">512</span><span class="operator">,</span> <span class="number">512</span><span class="operator">,</span> <span class="type"><a href="qimage.html" translate="no">QImage</a></span><span class="operator">::</span>Format_RGBA8888);
 image<span class="operator">.</span>fill(<span class="type">Qt</span><span class="operator">::</span>green);
 batch<span class="operator">-</span><span class="operator">&gt;</span>uploadTexture(texture<span class="operator">,</span> image);
 <span class="comment">// ...</span>
 commandBuffer<span class="operator">-</span><span class="operator">&gt;</span>resourceUpdate(batch); <span class="comment">// or, alternatively, pass 'batch' to a beginPass() call</span>
</pre>
<h4 id="common-patterns">Common patterns</h4>
<p>A call to <a href="qrhitexture.html#create" translate="no">create</a>() destroys any existing native resources if <a href="qrhitexture.html#create" translate="no">create</a>() was successfully called before. If those native resources are still in use by an in-flight frame (i.e., there's a chance they are still read by the GPU), the destroying of those resources is deferred automatically. Thus a very common and convenient pattern to safely change the size of an already existing texture is the following. In practice this drops and creates a whole new native texture resource underneath, so it is not necessarily a cheap operation, but is more convenient and still faster than the alternatives, because by not destroying the <code translate="no">texture</code> object itself, all references to it stay valid in other data structures (e.g., in any QShaderResourceBinding the QRhiTexture is referenced from).</p>
<pre class="cpp" translate="no">
 <span class="comment">// determine newSize, e.g. based on the swapchain's output size or other factors</span>
 <span class="keyword">if</span> (texture<span class="operator">-</span><span class="operator">&gt;</span>pixelSize() <span class="operator">!</span><span class="operator">=</span> newSize) {
     texture<span class="operator">-</span><span class="operator">&gt;</span>setPixelSize(newSize);
     <span class="keyword">if</span> (<span class="operator">!</span>texture<span class="operator">-</span><span class="operator">&gt;</span>create()) { error(); }
 }
 <span class="comment">// continue using texture, fill it with new data</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<p><b>See also </b><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a>, <a href="qrhi.html" translate="no">QRhi</a>, and <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>.</p>
<!-- @@@QRhiTexture -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Flag$$$RenderTarget$$$CubeMap$$$MipMapped$$$sRGB$$$UsedAsTransferSource$$$UsedWithGenerateMips$$$UsedWithLoadStore$$$UsedAsCompressedAtlas$$$ExternalOES$$$ThreeDimensional$$$TextureRectangleGL$$$TextureArray$$$OneDimensional -->
<h3 class="flags" id="Flag-enum">enum QRhiTexture::<span class="name">Flag</span><br/>flags QRhiTexture::<span class="name">Flags</span></h3>
<p>Flag values to specify how the texture is going to be used. Not honoring the flags set before <a href="qrhitexture.html#create" translate="no">create</a>() and attempting to use the texture in ways that was not declared upfront can lead to unspecified behavior or decreased performance depending on the backend and the underlying graphics API.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::RenderTarget</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td><td class="topAlign">The texture going to be used in combination with <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::CubeMap</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 2</code></td><td class="topAlign">The texture is a cubemap. Such textures have 6 layers, one for each face in the order of +X, -X, +Y, -Y, +Z, -Z. Cubemap textures cannot be multisample.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::MipMapped</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 3</code></td><td class="topAlign">The texture has mipmaps. The appropriate mip count is calculated automatically and can also be retrieved via <a href="qrhi.html#mipLevelsForSize" translate="no">QRhi::mipLevelsForSize</a>(). The images for the mip levels have to be provided in the texture uploaded or generated via <a href="qrhiresourceupdatebatch.html#generateMips" translate="no">QRhiResourceUpdateBatch::generateMips</a>(). Multisample textures cannot have mipmaps.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::sRGB</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 4</code></td><td class="topAlign">Use an sRGB format.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::UsedAsTransferSource</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 5</code></td><td class="topAlign">The texture is used as the source of a texture copy or readback, meaning the texture is given as the source in <a href="qrhiresourceupdatebatch.html#copyTexture" translate="no">QRhiResourceUpdateBatch::copyTexture</a>() or <a href="qrhiresourceupdatebatch.html#readBackTexture" translate="no">QRhiResourceUpdateBatch::readBackTexture</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::UsedWithGenerateMips</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 6</code></td><td class="topAlign">The texture is going to be used with <a href="qrhiresourceupdatebatch.html#generateMips" translate="no">QRhiResourceUpdateBatch::generateMips</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::UsedWithLoadStore</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 7</code></td><td class="topAlign">The texture is going to be used with image load/store operations, for example, in a compute shader.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::UsedAsCompressedAtlas</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 8</code></td><td class="topAlign">The texture has a compressed format and the dimensions of subresource uploads may not match the texture size.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ExternalOES</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 9</code></td><td class="topAlign">The texture should use the GL_TEXTURE_EXTERNAL_OES target with OpenGL. This flag is ignored with other graphics APIs.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ThreeDimensional</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 10</code></td><td class="topAlign">The texture is a 3D texture. Such textures should be created with the <a href="qrhi.html#newTexture" translate="no">QRhi::newTexture</a>() overload taking a depth in addition to width and height. A 3D texture can have mipmaps but cannot be multisample. When rendering into, or uploading data to a 3D texture, the <code translate="no">layer</code> specified in the render target's color attachment or the upload description refers to a single slice in range [0..depth-1]. The underlying graphics API may not support 3D textures at run time. Support is indicated by the <a href="qrhi.html#Feature-enum" translate="no">QRhi::ThreeDimensionalTextures</a> feature.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::TextureRectangleGL</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 11</code></td><td class="topAlign">The texture should use the GL_TEXTURE_RECTANGLE target with OpenGL. This flag is ignored with other graphics APIs. Just like ExternalOES, this flag is useful when working with platform APIs where native OpenGL texture objects received from the platform are wrapped in a <a href="qrhitexture.html" translate="no">QRhiTexture</a>, and the platform can only provide textures for a non-2D texture target.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::TextureArray</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 12</code></td><td class="topAlign">The texture is a texture array, i.e. a single texture object that is a homogeneous array of 2D textures. Texture arrays are created with <a href="qrhi.html#newTextureArray" translate="no">QRhi::newTextureArray</a>(). The underlying graphics API may not support texture array objects at run time. Support is indicated by the <a href="qrhi.html#Feature-enum" translate="no">QRhi::TextureArrays</a> feature. When rendering into, or uploading data to a texture array, the <code translate="no">layer</code> specified in the render target's color attachment or the upload description selects a single element in the array.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::OneDimensional</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 13</code></td><td class="topAlign">The texture is a 1D texture. Such textures can be created by passing a 0 height and depth to <a href="qrhi.html#newTexture" translate="no">QRhi::newTexture</a>(). Note that there can be limitations on one dimensional textures depending on the underlying graphics API. For example, rendering to them or using them with mipmap-based filtering may be unsupported. This is indicated by the <a href="qrhi.html#Feature-enum" translate="no">QRhi::OneDimensionalTextures</a> and <a href="qrhi.html#Feature-enum" translate="no">QRhi::OneDimensionalTextureMipmaps</a> feature flags.</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
<!-- $$$Format$$$UnknownFormat$$$RGBA8$$$BGRA8$$$R8$$$RG8$$$R16$$$RG16$$$RED_OR_ALPHA8$$$RGBA16F$$$RGBA32F$$$R16F$$$R32F$$$RGB10A2$$$D16$$$D24$$$D24S8$$$D32F$$$BC1$$$BC2$$$BC3$$$BC4$$$BC5$$$BC6H$$$BC7$$$ETC2_RGB8$$$ETC2_RGB8A1$$$ETC2_RGBA8$$$ASTC_4x4$$$ASTC_5x4$$$ASTC_5x5$$$ASTC_6x5$$$ASTC_6x6$$$ASTC_8x5$$$ASTC_8x6$$$ASTC_8x8$$$ASTC_10x5$$$ASTC_10x6$$$ASTC_10x8$$$ASTC_10x10$$$ASTC_12x10$$$ASTC_12x12 -->
<h3 class="fn" translate="no" id="Format-enum">enum QRhiTexture::<span class="name">Format</span></h3>
<p>Specifies the texture format. See also <a href="qrhi.html#isTextureFormatSupported" translate="no">QRhi::isTextureFormatSupported</a>() and note that <a href="qrhitexture.html#flags" translate="no">flags</a>() can modify the format when <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::sRGB</a> is set.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::UnknownFormat</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Not a valid format. This cannot be passed to <a href="qrhitexture.html#setFormat" translate="no">setFormat</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::RGBA8</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Four component, unsigned normalized 8 bit per component. Always supported.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::BGRA8</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Four component, unsigned normalized 8 bit per component.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::R8</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">One component, unsigned normalized 8 bit.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::RG8</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">Two components, unsigned normalized 8 bit.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::R16</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">One component, unsigned normalized 16 bit.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::RG16</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">Two component, unsigned normalized 16 bit.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::RED_OR_ALPHA8</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">Either same as R8, or is a similar format with the component swizzled to alpha, depending on <a href="qrhi.html#Feature-enum" translate="no">RedOrAlpha8IsRed</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::RGBA16F</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">Four components, 16-bit float per component.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::RGBA32F</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">Four components, 32-bit float per component.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::R16F</code></td><td class="topAlign tblval"><code translate="no">10</code></td><td class="topAlign">One component, 16-bit float.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::R32F</code></td><td class="topAlign tblval"><code translate="no">11</code></td><td class="topAlign">One component, 32-bit float.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::RGB10A2</code></td><td class="topAlign tblval"><code translate="no">12</code></td><td class="topAlign">Four components, unsigned normalized 10 bit R, G, and B, 2-bit alpha. This is a packed format so native endianness applies. Note that there is no BGR10A2. This is because RGB10A2 maps to DXGI_FORMAT_R10G10B10A2_UNORM with D3D, MTLPixelFormatRGB10A2Unorm with Metal, VK_FORMAT_A2B10G10R10_UNORM_PACK32 with Vulkan, and GL_RGB10_A2/GL_RGB/GL_UNSIGNED_INT_2_10_10_10_REV on OpenGL (ES). This is the only universally supported RGB30 option. The corresponding <a href="qimage.html" translate="no">QImage</a> formats are <a href="qimage.html#Format-enum" translate="no">QImage::Format_BGR30</a> and <a href="qimage.html#Format-enum" translate="no">QImage::Format_A2BGR30_Premultiplied</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::D16</code></td><td class="topAlign tblval"><code translate="no">13</code></td><td class="topAlign">16-bit depth (normalized unsigned integer)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::D24</code></td><td class="topAlign tblval"><code translate="no">14</code></td><td class="topAlign">24-bit depth (normalized unsigned integer)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::D24S8</code></td><td class="topAlign tblval"><code translate="no">15</code></td><td class="topAlign">24-bit depth (normalized unsigned integer), 8 bit stencil</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::D32F</code></td><td class="topAlign tblval"><code translate="no">16</code></td><td class="topAlign">32-bit depth (32-bit float)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::BC1</code></td><td class="topAlign tblval"><code translate="no">17</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::BC2</code></td><td class="topAlign tblval"><code translate="no">18</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::BC3</code></td><td class="topAlign tblval"><code translate="no">19</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::BC4</code></td><td class="topAlign tblval"><code translate="no">20</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::BC5</code></td><td class="topAlign tblval"><code translate="no">21</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::BC6H</code></td><td class="topAlign tblval"><code translate="no">22</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::BC7</code></td><td class="topAlign tblval"><code translate="no">23</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ETC2_RGB8</code></td><td class="topAlign tblval"><code translate="no">24</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ETC2_RGB8A1</code></td><td class="topAlign tblval"><code translate="no">25</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ETC2_RGBA8</code></td><td class="topAlign tblval"><code translate="no">26</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_4x4</code></td><td class="topAlign tblval"><code translate="no">27</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_5x4</code></td><td class="topAlign tblval"><code translate="no">28</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_5x5</code></td><td class="topAlign tblval"><code translate="no">29</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_6x5</code></td><td class="topAlign tblval"><code translate="no">30</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_6x6</code></td><td class="topAlign tblval"><code translate="no">31</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_8x5</code></td><td class="topAlign tblval"><code translate="no">32</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_8x6</code></td><td class="topAlign tblval"><code translate="no">33</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_8x8</code></td><td class="topAlign tblval"><code translate="no">34</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_10x5</code></td><td class="topAlign tblval"><code translate="no">35</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_10x6</code></td><td class="topAlign tblval"><code translate="no">36</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_10x8</code></td><td class="topAlign tblval"><code translate="no">37</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_10x10</code></td><td class="topAlign tblval"><code translate="no">38</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_12x10</code></td><td class="topAlign tblval"><code translate="no">39</code></td><td class="topAlign">&nbsp;</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTexture::ASTC_12x12</code></td><td class="topAlign tblval"><code translate="no">40</code></td><td class="topAlign">&nbsp;</td></tr>
</table></div>
<!-- @@@Format -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$arrayRangeLength[overload1]$$$arrayRangeLength -->
<h3 class="fn" translate="no" id="arrayRangeLength"><span class="type">int</span> QRhiTexture::<span class="name">arrayRangeLength</span>() const</h3>
<p>Returns the exposed array range size when <a href="qrhitexture.html#setArrayRange" translate="no">setArrayRange</a>() was called.</p>
<p><b>See also </b><a href="qrhitexture.html#setArrayRange" translate="no">setArrayRange</a>().</p>
<!-- @@@arrayRangeLength -->
<!-- $$$arrayRangeStart[overload1]$$$arrayRangeStart -->
<h3 class="fn" translate="no" id="arrayRangeStart"><span class="type">int</span> QRhiTexture::<span class="name">arrayRangeStart</span>() const</h3>
<p>Returns the first array layer when <a href="qrhitexture.html#setArrayRange" translate="no">setArrayRange</a>() was called.</p>
<p><b>See also </b><a href="qrhitexture.html#setArrayRange" translate="no">setArrayRange</a>().</p>
<!-- @@@arrayRangeStart -->
<!-- $$$arraySize[overload1]$$$arraySize -->
<h3 class="fn" translate="no" id="arraySize"><span class="type">int</span> QRhiTexture::<span class="name">arraySize</span>() const</h3>
<p>Returns the texture array size.</p>
<p><b>See also </b><a href="qrhitexture.html#setArraySize" translate="no">setArraySize</a>().</p>
<!-- @@@arraySize -->
<!-- $$$create[overload1]$$$create -->
<h3 class="fn" translate="no" id="create"><code class="details extra" translate="no">[pure virtual]</code> <span class="type">bool</span> QRhiTexture::<span class="name">create</span>()</h3>
<p>Creates the corresponding native graphics resources. If there are already resources present due to an earlier create() with no corresponding <a href="qrhiresource.html#destroy" translate="no">destroy</a>(), then <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is called implicitly first.</p>
<p>Returns <code translate="no">true</code> when successful, <code translate="no">false</code> when a graphics operation failed. Regardless of the return value, calling <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is always safe.</p>
<!-- @@@create -->
<!-- $$$createFrom[overload1]$$$createFromQRhiTexture::NativeTexture -->
<h3 class="fn" translate="no" id="createFrom"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QRhiTexture::<span class="name">createFrom</span>(<span class="type"><a href="qrhitexture-nativetexture.html" translate="no">QRhiTexture::NativeTexture</a></span> <i>src</i>)</h3>
<p>Similar to <a href="qrhitexture.html#create" translate="no">create</a>(), except that no new native textures are created. Instead, the native texture resources specified by <i translate="no">src</i> is used.</p>
<p>This allows importing an existing native texture object (which must belong to the same device or sharing context, depending on the graphics API) from an external graphics engine.</p>
<p>Returns true if the specified existing native texture object has been successfully wrapped as a non-owning <a href="qrhitexture.html" translate="no">QRhiTexture</a>.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhitexture.html#format" translate="no">format</a>(), <a href="qrhitexture.html#pixelSize" translate="no">pixelSize</a>(), <a href="qrhitexture.html#sampleCount" translate="no">sampleCount</a>(), and <a href="qrhitexture.html#flags" translate="no">flags</a>() must still be set correctly. Passing incorrect sizes and other values to <a href="qrhi.html#newTexture" translate="no">QRhi::newTexture</a>() and then following it with a createFrom() expecting that the native texture object alone is sufficient to deduce such values is <b>wrong</b> and will lead to problems.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qrhitexture.html" translate="no">QRhiTexture</a> does not take ownership of the texture object. <a href="qrhiresource.html#destroy" translate="no">destroy</a>() does not free the object or any associated memory.</p>
</div>
<p>The opposite of this operation, exposing a <a href="qrhitexture.html" translate="no">QRhiTexture</a>-created native texture object to a foreign engine, is possible via <a href="qrhitexture.html#nativeTexture" translate="no">nativeTexture</a>().</p>
<div class="admonition note">
<p><b>Note: </b>When importing a 3D texture, or a texture array object, or, with OpenGL ES, an external texture, it is then especially important to set the corresponding flags (<a href="qrhitexture.html#Flag-enum" translate="no">ThreeDimensional</a>, <a href="qrhitexture.html#Flag-enum" translate="no">TextureArray</a>, <a href="qrhitexture.html#Flag-enum" translate="no">ExternalOES</a>) via <a href="qrhitexture.html#setFlags" translate="no">setFlags</a>() before calling this function.</p>
</div>
<!-- @@@createFrom -->
<!-- $$$depth[overload1]$$$depth -->
<h3 class="fn" translate="no" id="depth"><span class="type">int</span> QRhiTexture::<span class="name">depth</span>() const</h3>
<p>Returns the depth for 3D textures.</p>
<p><b>See also </b><a href="qrhitexture.html#setDepth" translate="no">setDepth</a>().</p>
<!-- @@@depth -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><span class="type"><a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::Flags</a></span> QRhiTexture::<span class="name">flags</span>() const</h3>
<p>Returns the texture flags.</p>
<p><b>See also </b><a href="qrhitexture.html#setFlags" translate="no">setFlags</a>().</p>
<!-- @@@flags -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" translate="no" id="format"><span class="type"><a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::Format</a></span> QRhiTexture::<span class="name">format</span>() const</h3>
<p>Returns the texture format.</p>
<p><b>See also </b><a href="qrhitexture.html#setFormat" translate="no">setFormat</a>().</p>
<!-- @@@format -->
<!-- $$$nativeTexture[overload1]$$$nativeTexture -->
<h3 class="fn" translate="no" id="nativeTexture"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="qrhitexture-nativetexture.html" translate="no">QRhiTexture::NativeTexture</a></span> QRhiTexture::<span class="name">nativeTexture</span>()</h3>
<p>Returns the underlying native resources for this texture. The returned value will be empty if exposing the underlying native resources is not supported by the backend.</p>
<p><b>See also </b><a href="qrhitexture.html#createFrom" translate="no">createFrom</a>().</p>
<!-- @@@nativeTexture -->
<!-- $$$pixelSize[overload1]$$$pixelSize -->
<h3 class="fn" translate="no" id="pixelSize"><span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QRhiTexture::<span class="name">pixelSize</span>() const</h3>
<p>Returns the size in pixels.</p>
<p><b>See also </b><a href="qrhitexture.html#setPixelSize" translate="no">setPixelSize</a>().</p>
<!-- @@@pixelSize -->
<!-- $$$resourceType[overload1]$$$resourceType -->
<h3 class="fn" translate="no" id="resourceType"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="qrhiresource.html#Type-enum" translate="no">QRhiResource::Type</a></span> QRhiTexture::<span class="name">resourceType</span>() const</h3>
<p>Reimplements: <a href="qrhiresource.html#resourceType" translate="no">QRhiResource::resourceType() const</a>.</p>
<p>Returns the resource type.</p>
<!-- @@@resourceType -->
<!-- $$$sampleCount[overload1]$$$sampleCount -->
<h3 class="fn" translate="no" id="sampleCount"><span class="type">int</span> QRhiTexture::<span class="name">sampleCount</span>() const</h3>
<p>Returns the sample count. 1 means no multisample antialiasing.</p>
<p><b>See also </b><a href="qrhitexture.html#setSampleCount" translate="no">setSampleCount</a>().</p>
<!-- @@@sampleCount -->
<!-- $$$setArrayRange[overload1]$$$setArrayRangeintint -->
<h3 class="fn" translate="no" id="setArrayRange"><span class="type">void</span> QRhiTexture::<span class="name">setArrayRange</span>(<span class="type">int</span> <i>startIndex</i>, <span class="type">int</span> <i>count</i>)</h3>
<p>Normally all array layers are exposed and it is up to the shader to select the layer via the third coordinate passed to the <code translate="no">texture()</code> GLSL function when sampling the <code translate="no">sampler2DArray</code>. When <a href="qrhi.html#Feature-enum" translate="no">QRhi::TextureArrayRange</a> is reported as supported, calling setArrayRange() before <a href="qrhitexture.html#create" translate="no">create</a>() or <a href="qrhitexture.html#createFrom" translate="no">createFrom</a>() requests selecting only the specified range, <i translate="no">count</i> elements starting from <i translate="no">startIndex</i>. The shader logic can then be written with this in mind.</p>
<p><b>See also </b><a href="qrhi.html#Feature-enum" translate="no">QRhi::TextureArrayRange</a>.</p>
<!-- @@@setArrayRange -->
<!-- $$$setArraySize[overload1]$$$setArraySizeint -->
<h3 class="fn" translate="no" id="setArraySize"><span class="type">void</span> QRhiTexture::<span class="name">setArraySize</span>(<span class="type">int</span> <i>arraySize</i>)</h3>
<p>Sets the texture <i translate="no">arraySize</i>.</p>
<p><b>See also </b><a href="qrhitexture.html#arraySize" translate="no">arraySize</a>().</p>
<!-- @@@setArraySize -->
<!-- $$$setDepth[overload1]$$$setDepthint -->
<h3 class="fn" translate="no" id="setDepth"><span class="type">void</span> QRhiTexture::<span class="name">setDepth</span>(<span class="type">int</span> <i>depth</i>)</h3>
<p>Sets the <i translate="no">depth</i> for a 3D texture.</p>
<p><b>See also </b><a href="qrhitexture.html#depth" translate="no">depth</a>().</p>
<!-- @@@setDepth -->
<!-- $$$setFlags[overload1]$$$setFlagsQRhiTexture::Flags -->
<h3 class="fn" translate="no" id="setFlags"><span class="type">void</span> QRhiTexture::<span class="name">setFlags</span>(<span class="type"><a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::Flags</a></span> <i>f</i>)</h3>
<p>Sets the texture flags to <i translate="no">f</i>.</p>
<p><b>See also </b><a href="qrhitexture.html#flags" translate="no">flags</a>().</p>
<!-- @@@setFlags -->
<!-- $$$setFormat[overload1]$$$setFormatQRhiTexture::Format -->
<h3 class="fn" translate="no" id="setFormat"><span class="type">void</span> QRhiTexture::<span class="name">setFormat</span>(<span class="type"><a href="qrhitexture.html#Format-enum" translate="no">QRhiTexture::Format</a></span> <i>fmt</i>)</h3>
<p>Sets the requested texture format to <i translate="no">fmt</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The value set is only taken into account upon the next call to <a href="qrhitexture.html#create" translate="no">create</a>(), i.e. when the underlying graphics resource are (re)created. Setting a new value is futile otherwise and must be avoided since it can lead to inconsistent state.</p>
</div>
<p><b>See also </b><a href="qrhitexture.html#format" translate="no">format</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setNativeLayout[overload1]$$$setNativeLayoutint -->
<h3 class="fn" translate="no" id="setNativeLayout"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QRhiTexture::<span class="name">setNativeLayout</span>(<span class="type">int</span> <i>layout</i>)</h3>
<p>With some graphics APIs, such as Vulkan, integrating custom rendering code that uses the graphics API directly needs special care when it comes to image layouts. This function allows communicating the expected <i translate="no">layout</i> the image backing the <a href="qrhitexture.html" translate="no">QRhiTexture</a> is in after the native rendering commands.</p>
<p>For example, consider rendering into a <a href="qrhitexture.html" translate="no">QRhiTexture</a>'s VkImage directly with Vulkan in a code block enclosed by <a href="qrhicommandbuffer.html#beginExternal" translate="no">QRhiCommandBuffer::beginExternal</a>() and <a href="qrhicommandbuffer.html#endExternal" translate="no">QRhiCommandBuffer::endExternal</a>(), followed by using the image for texture sampling in a <a href="qrhi.html" translate="no">QRhi</a>-based render pass. To avoid potentially incorrect image layout transitions, this function can be used to indicate what the image layout will be once the commands recorded in said code block complete.</p>
<p>Calling this function makes sense only after <a href="qrhicommandbuffer.html#endExternal" translate="no">QRhiCommandBuffer::endExternal</a>() and before a subsequent <a href="qrhicommandbuffer.html#beginPass" translate="no">QRhiCommandBuffer::beginPass</a>().</p>
<p>This function has no effect with <a href="qrhi.html" translate="no">QRhi</a> backends where the underlying graphics API does not expose a concept of image layouts.</p>
<div class="admonition note">
<p><b>Note: </b>With Vulkan <i translate="no">layout</i> is a <code translate="no">VkImageLayout</code>. With Direct 3D 12 <i translate="no">layout</i> is a value composed of the bits from <code translate="no">D3D12_RESOURCE_STATES</code>.</p>
</div>
<!-- @@@setNativeLayout -->
<!-- $$$setPixelSize[overload1]$$$setPixelSizeconstQSize& -->
<h3 class="fn" translate="no" id="setPixelSize"><span class="type">void</span> QRhiTexture::<span class="name">setPixelSize</span>(const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>sz</i>)</h3>
<p>Sets the texture size, specified in pixels, to <i translate="no">sz</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The value set is only taken into account upon the next call to <a href="qrhitexture.html#create" translate="no">create</a>(), i.e. when the underlying graphics resource are (re)created. Setting a new value is futile otherwise and must be avoided since it can lead to inconsistent state. The same applies to all other setters as well.</p>
</div>
<p><b>See also </b><a href="qrhitexture.html#pixelSize" translate="no">pixelSize</a>().</p>
<!-- @@@setPixelSize -->
<!-- $$$setSampleCount[overload1]$$$setSampleCountint -->
<h3 class="fn" translate="no" id="setSampleCount"><span class="type">void</span> QRhiTexture::<span class="name">setSampleCount</span>(<span class="type">int</span> <i>s</i>)</h3>
<p>Sets the sample count to <i translate="no">s</i>.</p>
<p><b>See also </b><a href="qrhitexture.html#sampleCount" translate="no">sampleCount</a>().</p>
<!-- @@@setSampleCount -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
