<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qpixmap.cpp -->
  <meta name="description" content="The QPixmap class is an off-screen image representation that can be used as a paint device.">
  <title>QPixmap Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QPixmap</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#reading-and-writing-image-files">Reading and Writing Image Files</a></li>
<li class="level2"><a href="#pixmap-information">Pixmap Information</a></li>
<li class="level2"><a href="#pixmap-conversion">Pixmap Conversion</a></li>
<li class="level2"><a href="#pixmap-transformations">Pixmap Transformations</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QPixmap Class</h1>
<!-- $$$QPixmap-brief -->
<p>The QPixmap class is an off-screen image representation that can be used as a paint device. <a href="#details">More...</a></p>
<!-- @@@QPixmap -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QPixmap&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qpaintdevice.html" translate="no">QPaintDevice</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qbitmap.html" translate="no">QBitmap</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qpixmap-members.html">List of all members, including inherited members</a></li>
<li>QPixmap is part of <a href="painting.html">Painting Classes</a> and <a href="../qtcore/shared.html">Implicitly Shared Classes</a>.</li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#QPixmap-1" translate="no">QPixmap</a></b>(int <i>width</i>, int <i>height</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#QPixmap-2" translate="no">QPixmap</a></b>(const QSize &amp;<i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#QPixmap-3" translate="no">QPixmap</a></b>(const QString &amp;<i>fileName</i>, const char *<i>format</i> = nullptr, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#QPixmap-4" translate="no">QPixmap</a></b>(const char *const[] <i>xpm</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#QPixmap-5" translate="no">QPixmap</a></b>(const QPixmap &amp;<i>pixmap</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#QPixmap-6" translate="no">QPixmap</a></b>(QPixmap &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#dtor.QPixmap" translate="no">~QPixmap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#cacheKey" translate="no">cacheKey</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#convertFromImage" translate="no">convertFromImage</a></b>(const QImage &amp;<i>image</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#copy" translate="no">copy</a></b>(const QRect &amp;<i>rectangle</i> = QRect()) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#copy-1" translate="no">copy</a></b>(int <i>x</i>, int <i>y</i>, int <i>width</i>, int <i>height</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBitmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#createHeuristicMask" translate="no">createHeuristicMask</a></b>(bool <i>clipTight</i> = true) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBitmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#createMaskFromColor" translate="no">createMaskFromColor</a></b>(const QColor &amp;<i>maskColor</i>, Qt::MaskMode <i>mode</i> = Qt::MaskInColor) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#depth" translate="no">depth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#detach" translate="no">detach</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> QSizeF </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#deviceIndependentSize" translate="no">deviceIndependentSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#devicePixelRatio" translate="no">devicePixelRatio</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#fill" translate="no">fill</a></b>(const QColor &amp;<i>color</i> = Qt::white)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#hasAlpha" translate="no">hasAlpha</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#hasAlphaChannel" translate="no">hasAlphaChannel</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#height" translate="no">height</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#isNull" translate="no">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#isQBitmap" translate="no">isQBitmap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#load" translate="no">load</a></b>(const QString &amp;<i>fileName</i>, const char *<i>format</i> = nullptr, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#loadFromData" translate="no">loadFromData</a></b>(const uchar *<i>data</i>, uint <i>len</i>, const char *<i>format</i> = nullptr, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#loadFromData-1" translate="no">loadFromData</a></b>(const QByteArray &amp;<i>data</i>, const char *<i>format</i> = nullptr, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBitmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#mask" translate="no">mask</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRect </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#rect" translate="no">rect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#save" translate="no">save</a></b>(const QString &amp;<i>fileName</i>, const char *<i>format</i> = nullptr, int <i>quality</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#save-1" translate="no">save</a></b>(QIODevice *<i>device</i>, const char *<i>format</i> = nullptr, int <i>quality</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#scaled" translate="no">scaled</a></b>(const QSize &amp;<i>size</i>, Qt::AspectRatioMode <i>aspectRatioMode</i> = Qt::IgnoreAspectRatio, Qt::TransformationMode <i>transformMode</i> = Qt::FastTransformation) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#scaled-1" translate="no">scaled</a></b>(int <i>width</i>, int <i>height</i>, Qt::AspectRatioMode <i>aspectRatioMode</i> = Qt::IgnoreAspectRatio, Qt::TransformationMode <i>transformMode</i> = Qt::FastTransformation) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#scaledToHeight" translate="no">scaledToHeight</a></b>(int <i>height</i>, Qt::TransformationMode <i>mode</i> = Qt::FastTransformation) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#scaledToWidth" translate="no">scaledToWidth</a></b>(int <i>width</i>, Qt::TransformationMode <i>mode</i> = Qt::FastTransformation) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#scroll" translate="no">scroll</a></b>(int <i>dx</i>, int <i>dy</i>, int <i>x</i>, int <i>y</i>, int <i>width</i>, int <i>height</i>, QRegion *<i>exposed</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#scroll-1" translate="no">scroll</a></b>(int <i>dx</i>, int <i>dy</i>, const QRect &amp;<i>rect</i>, QRegion *<i>exposed</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#setDevicePixelRatio" translate="no">setDevicePixelRatio</a></b>(qreal <i>scaleFactor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#setMask" translate="no">setMask</a></b>(const QBitmap &amp;<i>mask</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#swap" translate="no">swap</a></b>(QPixmap &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#toImage" translate="no">toImage</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#transformed" translate="no">transformed</a></b>(const QTransform &amp;<i>transform</i>, Qt::TransformationMode <i>mode</i> = Qt::FastTransformation) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#width" translate="no">width</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#operator-QVariant" translate="no">operator QVariant</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#operator-not" translate="no">operator!</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap &amp;</td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#operator-eq" translate="no">operator=</a></b>(const QPixmap &amp;<i>pixmap</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap &amp;</td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#operator-eq-1" translate="no">operator=</a></b>(QPixmap &amp;&amp;<i>other</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#defaultDepth" translate="no">defaultDepth</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#fromImage" translate="no">fromImage</a></b>(const QImage &amp;<i>image</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#fromImage-1" translate="no">fromImage</a></b>(QImage &amp;&amp;<i>image</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#fromImageReader" translate="no">fromImageReader</a></b>(QImageReader *<i>imageReader</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTransform </td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#trueMatrix" translate="no">trueMatrix</a></b>(const QTransform &amp;<i>matrix</i>, int <i>width</i>, int <i>height</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#operator-lt-lt-2" translate="no">operator&lt;&lt;</a></b>(QDataStream &amp;<i>stream</i>, const QPixmap &amp;<i>pixmap</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qpixmap.html#operator-gt-gt-2" translate="no">operator&gt;&gt;</a></b>(QDataStream &amp;<i>stream</i>, QPixmap &amp;<i>pixmap</i>)</td></tr>
</table></div>
<!-- $$$QPixmap-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Qt provides four classes for handling image data: <a href="qimage.html" translate="no">QImage</a>, QPixmap, <a href="qbitmap.html" translate="no">QBitmap</a> and <a href="qpicture.html" translate="no">QPicture</a>. <a href="qimage.html" translate="no">QImage</a> is designed and optimized for I/O, and for direct pixel access and manipulation, while QPixmap is designed and optimized for showing images on screen. <a href="qbitmap.html" translate="no">QBitmap</a> is only a convenience class that inherits QPixmap, ensuring a depth of 1. The <a href="qpixmap.html#isQBitmap" translate="no">isQBitmap</a>() function returns <code translate="no">true</code> if a QPixmap object is really a bitmap, otherwise returns <code translate="no">false</code>. Finally, the <a href="qpicture.html" translate="no">QPicture</a> class is a paint device that records and replays <a href="qpainter.html" translate="no">QPainter</a> commands.</p>
<p>A QPixmap can easily be displayed on the screen using <a href="../qtwidgets/qlabel.html" translate="no">QLabel</a> or one of <a href="../qtwidgets/qabstractbutton.html" translate="no">QAbstractButton</a>'s subclasses (such as <a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a> and <a href="../qtwidgets/qtoolbutton.html" translate="no">QToolButton</a>). <a href="../qtwidgets/qlabel.html" translate="no">QLabel</a> has a pixmap property, whereas <a href="../qtwidgets/qabstractbutton.html" translate="no">QAbstractButton</a> has an icon property.</p>
<p>QPixmap objects can be passed around by value since the QPixmap class uses implicit data sharing. For more information, see the <a href="../qtcore/implicit-sharing.html" translate="no">Implicit Data Sharing</a> documentation. QPixmap objects can also be streamed.</p>
<p>Note that the pixel data in a pixmap is internal and is managed by the underlying window system. Because QPixmap is a <a href="qpaintdevice.html" translate="no">QPaintDevice</a> subclass, <a href="qpainter.html" translate="no">QPainter</a> can be used to draw directly onto pixmaps. Pixels can only be accessed through <a href="qpainter.html" translate="no">QPainter</a> functions or by converting the QPixmap to a <a href="qimage.html" translate="no">QImage</a>. However, the <a href="qpixmap.html#fill" translate="no">fill</a>() function is available for initializing the entire pixmap with a given color.</p>
<p>There are functions to convert between <a href="qimage.html" translate="no">QImage</a> and QPixmap. Typically, the <a href="qimage.html" translate="no">QImage</a> class is used to load an image file, optionally manipulating the image data, before the <a href="qimage.html" translate="no">QImage</a> object is converted into a QPixmap to be shown on screen. Alternatively, if no manipulation is desired, the image file can be loaded directly into a QPixmap.</p>
<p>QPixmap provides a collection of functions that can be used to obtain a variety of information about the pixmap. In addition, there are several functions that enables transformation of the pixmap.</p>
<h3 id="reading-and-writing-image-files">Reading and Writing Image Files</h3>
<p>QPixmap provides several ways of reading an image file: The file can be loaded when constructing the QPixmap object, or by using the <a href="qpixmap.html#load" translate="no">load</a>() or <a href="qpixmap.html#loadFromData" translate="no">loadFromData</a>() functions later on. When loading an image, the file name can either refer to an actual file on disk or to one of the application's embedded resources. See <a href="../qtcore/resources.html" translate="no">The Qt Resource System</a> overview for details on how to embed images and other resource files in the application's executable.</p>
<p>Simply call the <a href="qpixmap.html#save" translate="no">save</a>() function to save a QPixmap object.</p>
<p>The complete list of supported file formats are available through the <a href="qimagereader.html#supportedImageFormats" translate="no">QImageReader::supportedImageFormats</a>() and <a href="qimagewriter.html#supportedImageFormats" translate="no">QImageWriter::supportedImageFormats</a>() functions. New file formats can be added as plugins. By default, Qt supports the following formats:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Format</th><th >Description</th><th >Qt's support</th></tr></thead>
<tr valign="top" class="odd"><td >BMP</td><td >Windows Bitmap</td><td >Read/write</td></tr>
<tr valign="top" class="even"><td >GIF</td><td >Graphic Interchange Format (optional)</td><td >Read</td></tr>
<tr valign="top" class="odd"><td >JPG</td><td >Joint Photographic Experts Group</td><td >Read/write</td></tr>
<tr valign="top" class="even"><td >JPEG</td><td >Joint Photographic Experts Group</td><td >Read/write</td></tr>
<tr valign="top" class="odd"><td >PNG</td><td >Portable Network Graphics</td><td >Read/write</td></tr>
<tr valign="top" class="even"><td >PBM</td><td >Portable Bitmap</td><td >Read</td></tr>
<tr valign="top" class="odd"><td >PGM</td><td >Portable Graymap</td><td >Read</td></tr>
<tr valign="top" class="even"><td >PPM</td><td >Portable Pixmap</td><td >Read/write</td></tr>
<tr valign="top" class="odd"><td >XBM</td><td >X11 Bitmap</td><td >Read/write</td></tr>
<tr valign="top" class="even"><td >XPM</td><td >X11 Pixmap</td><td >Read/write</td></tr>
</table></div>
<h3 id="pixmap-information">Pixmap Information</h3>
<p>QPixmap provides a collection of functions that can be used to obtain a variety of information about the pixmap:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th ></th><th >Available Functions</th></tr></thead>
<tr valign="top" class="odd"><td >Geometry</td><td >The <a href="qpixmap.html#size" translate="no">size</a>(), <a href="qpixmap.html#width" translate="no">width</a>() and <a href="qpixmap.html#height" translate="no">height</a>() functions provide information about the pixmap's size. The <a href="qpixmap.html#rect" translate="no">rect</a>() function returns the image's enclosing rectangle.</td></tr>
<tr valign="top" class="even"><td >Alpha component</td><td >The <a href="qpixmap.html#hasAlphaChannel" translate="no">hasAlphaChannel</a>() returns <code translate="no">true</code> if the pixmap has a format that respects the alpha channel, otherwise returns <code translate="no">false</code>. The <a href="qpixmap.html#hasAlpha" translate="no">hasAlpha</a>(), <a href="qpixmap.html#setMask" translate="no">setMask</a>() and <a href="qpixmap.html#mask" translate="no">mask</a>() functions are legacy and should not be used. They are potentially very slow.<p>The <a href="qpixmap.html#createHeuristicMask" translate="no">createHeuristicMask</a>() function creates and returns a 1-bpp heuristic mask (i.e. a <a href="qbitmap.html" translate="no">QBitmap</a>) for this pixmap. It works by selecting a color from one of the corners and then chipping away pixels of that color, starting at all the edges. The <a href="qpixmap.html#createMaskFromColor" translate="no">createMaskFromColor</a>() function creates and returns a mask (i.e. a <a href="qbitmap.html" translate="no">QBitmap</a>) for the pixmap based on a given color.</p>
</td></tr>
<tr valign="top" class="odd"><td >Low-level information</td><td >The <a href="qpixmap.html#depth" translate="no">depth</a>() function returns the depth of the pixmap. The <a href="qpixmap.html#defaultDepth" translate="no">defaultDepth</a>() function returns the default depth, i.e. the depth used by the application on the given screen.<p>The <a href="qpixmap.html#cacheKey" translate="no">cacheKey</a>() function returns a number that uniquely identifies the contents of the QPixmap object.</p>
</td></tr>
</table></div>
<h3 id="pixmap-conversion">Pixmap Conversion</h3>
<p>A QPixmap object can be converted into a <a href="qimage.html" translate="no">QImage</a> using the <a href="qpixmap.html#toImage" translate="no">toImage</a>() function. Likewise, a <a href="qimage.html" translate="no">QImage</a> can be converted into a QPixmap using the <a href="qpixmap.html#fromImage" translate="no">fromImage</a>(). If this is too expensive an operation, you can use <a href="qbitmap.html#fromImage" translate="no">QBitmap::fromImage</a>() instead.</p>
<p>To convert a QPixmap to and from HICON you can use the <a href="qimage.html#toHICON" translate="no">QImage::toHICON</a>() and <a href="qimage.html#fromHICON" translate="no">QImage::fromHICON</a>() functions respectively (after converting the QPixmap to a <a href="qimage.html" translate="no">QImage</a>, as explained above).</p>
<h3 id="pixmap-transformations">Pixmap Transformations</h3>
<p>QPixmap supports a number of functions for creating a new pixmap that is a transformed version of the original:</p>
<p>The <a href="qpixmap.html#scaled" translate="no">scaled</a>(), <a href="qpixmap.html#scaledToWidth" translate="no">scaledToWidth</a>() and <a href="qpixmap.html#scaledToHeight" translate="no">scaledToHeight</a>() functions return scaled copies of the pixmap, while the <a href="qpixmap.html#copy" translate="no">copy</a>() function creates a QPixmap that is a plain copy of the original one.</p>
<p>The <a href="qpixmap.html#transformed" translate="no">transformed</a>() function returns a copy of the pixmap that is transformed with the given transformation matrix and transformation mode: Internally, the transformation matrix is adjusted to compensate for unwanted translation, i.e. <a href="qpixmap.html#transformed" translate="no">transformed</a>() returns the smallest pixmap containing all transformed points of the original pixmap. The static <a href="qpixmap.html#trueMatrix" translate="no">trueMatrix</a>() function returns the actual matrix used for transforming the pixmap.</p>
</div>
<p><b>See also </b><a href="qbitmap.html" translate="no">QBitmap</a>, <a href="qimage.html" translate="no">QImage</a>, <a href="qimagereader.html" translate="no">QImageReader</a>, and <a href="qimagewriter.html" translate="no">QImageWriter</a>.</p>
<!-- @@@QPixmap -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QPixmap[overload1]$$$QPixmap -->
<h3 class="fn" translate="no" id="QPixmap">QPixmap::<span class="name">QPixmap</span>()</h3>
<p>Constructs a null pixmap.</p>
<p><b>See also </b><a href="qpixmap.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@QPixmap -->
<!-- $$$QPixmap$$$QPixmapintint -->
<h3 class="fn" translate="no" id="QPixmap-1">QPixmap::<span class="name">QPixmap</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>)</h3>
<p>Constructs a pixmap with the given <i translate="no">width</i> and <i translate="no">height</i>. If either <i translate="no">width</i> or <i translate="no">height</i> is zero, a null pixmap is constructed.</p>
<div class="admonition warning">
<p><b>Warning: </b>This will create a QPixmap with uninitialized data. Call <a href="qpixmap.html#fill" translate="no">fill</a>() to fill the pixmap with an appropriate color before drawing onto it with <a href="qpainter.html" translate="no">QPainter</a>.</p>
</div>
<p><b>See also </b><a href="qpixmap.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@QPixmap -->
<!-- $$$QPixmap$$$QPixmapconstQSize& -->
<h3 class="fn" translate="no" id="QPixmap-2"><code class="details extra" translate="no">[explicit]</code> QPixmap::<span class="name">QPixmap</span>(const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>size</i>)</h3>
<p>This is an overloaded function.</p>
<p>Constructs a pixmap of the given <i translate="no">size</i>.</p>
<div class="admonition warning">
<p><b>Warning: </b>This will create a QPixmap with uninitialized data. Call <a href="qpixmap.html#fill" translate="no">fill</a>() to fill the pixmap with an appropriate color before drawing onto it with <a href="qpainter.html" translate="no">QPainter</a>.</p>
</div>
<!-- @@@QPixmap -->
<!-- $$$QPixmap$$$QPixmapconstQString&constchar*Qt::ImageConversionFlags -->
<h3 class="fn" translate="no" id="QPixmap-3">QPixmap::<span class="name">QPixmap</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>fileName</i>, const <span class="type">char</span> *<i>format</i> = nullptr, <span class="type"><a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor)</h3>
<p>Constructs a pixmap from the file with the given <i translate="no">fileName</i>. If the file does not exist or is of an unknown format, the pixmap becomes a null pixmap.</p>
<p>The loader attempts to read the pixmap using the specified <i translate="no">format</i>. If the <i translate="no">format</i> is not specified (which is the default), the loader probes the file for a header to guess the file format.</p>
<p>The file name can either refer to an actual file on disk or to one of the application's embedded resources. See the <a href="../qtcore/resources.html" translate="no">Resource System</a> overview for details on how to embed images and other resource files in the application's executable.</p>
<p>If the image needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the <i translate="no">flags</i> to control the conversion.</p>
<p>The <i translate="no">fileName</i>, <i translate="no">format</i> and <i translate="no">flags</i> parameters are passed on to <a href="qpixmap.html#load" translate="no">load</a>(). This means that the data in <i translate="no">fileName</i> is not compiled into the binary. If <i translate="no">fileName</i> contains a relative path (e.g. the filename only) the relevant file must be found relative to the runtime working directory.</p>
<p><b>See also </b><a href="qpixmap.html#reading-and-writing-image-files" translate="no">Reading and Writing Image Files</a>.</p>
<!-- @@@QPixmap -->
<!-- $$$QPixmap$$$QPixmapconstchar*const[] -->
<h3 class="fn" translate="no" id="QPixmap-4"><code class="details extra" translate="no">[explicit]</code> QPixmap::<span class="name">QPixmap</span>(const <span class="type">char</span> *const[] <i>xpm</i>)</h3>
<p>Constructs a pixmap from the given <i translate="no">xpm</i> data, which must be a valid XPM image.</p>
<p>Errors are silently ignored.</p>
<p>Note that it's possible to squeeze the XPM variable a little bit by using an unusual declaration:</p>
<pre class="cpp" translate="no">
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span> <span class="keyword">const</span> start_xpm<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
     <span class="string">&quot;16 15 8 1&quot;</span><span class="operator">,</span>
     <span class="string">&quot;a c #cec6bd&quot;</span><span class="operator">,</span>
     <span class="comment">// etc.</span>
 };
</pre>
<p>The extra <code translate="no">const</code> makes the entire definition read-only, which is slightly more efficient (for example, when the code is in a shared library) and ROMable when the application is to be stored in ROM.</p>
<!-- @@@QPixmap -->
<!-- $$$QPixmap$$$QPixmapconstQPixmap& -->
<h3 class="fn" translate="no" id="QPixmap-5">QPixmap::<span class="name">QPixmap</span>(const <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> &amp;<i>pixmap</i>)</h3>
<p>Constructs a pixmap that is a copy of the given <i translate="no">pixmap</i>.</p>
<p><b>See also </b><a href="qpixmap.html#copy" translate="no">copy</a>().</p>
<!-- @@@QPixmap -->
<!-- $$$QPixmap$$$QPixmapQPixmap&& -->
<h3 class="fn" translate="no" id="QPixmap-6"><code class="details extra" translate="no">[noexcept]</code> QPixmap::<span class="name">QPixmap</span>(<span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a QPixmap instance from <i translate="no">other</i>.</p>
<p><b>See also </b><a href="qpixmap.html#swap" translate="no">swap</a>() and <a href="qpixmap.html#operator-eq-1" translate="no">operator=</a>(QPixmap&amp;&amp;).</p>
<!-- @@@QPixmap -->
<!-- $$$~QPixmap[overload1]$$$~QPixmap -->
<h3 class="fn" translate="no" id="dtor.QPixmap"><code class="details extra" translate="no">[virtual noexcept]</code> QPixmap::<span class="name">~QPixmap</span>()</h3>
<p>Destroys the pixmap.</p>
<!-- @@@~QPixmap -->
<!-- $$$cacheKey[overload1]$$$cacheKey -->
<h3 class="fn" translate="no" id="cacheKey"><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QPixmap::<span class="name">cacheKey</span>() const</h3>
<p>Returns a number that identifies this <a href="qpixmap.html" translate="no">QPixmap</a>. Distinct <a href="qpixmap.html" translate="no">QPixmap</a> objects can only have the same cache key if they refer to the same contents.</p>
<p>The cacheKey() will change when the pixmap is altered.</p>
<!-- @@@cacheKey -->
<!-- $$$convertFromImage[overload1]$$$convertFromImageconstQImage&Qt::ImageConversionFlags -->
<h3 class="fn" translate="no" id="convertFromImage"><span class="type">bool</span> QPixmap::<span class="name">convertFromImage</span>(const <span class="type"><a href="qimage.html" translate="no">QImage</a></span> &amp;<i>image</i>, <span class="type"><a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor)</h3>
<p>Replaces this pixmap's data with the given <i translate="no">image</i> using the specified <i translate="no">flags</i> to control the conversion. The <i translate="no">flags</i> argument is a bitwise-OR of the <a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a>. Passing 0 for <i translate="no">flags</i> sets all the default options. Returns <code translate="no">true</code> if the result is that this pixmap is not null.</p>
<p>Note: this function was part of Qt 3 support in Qt 4.6 and earlier. It has been promoted to official API status in 4.7 to support updating the pixmap's image without creating a new <a href="qpixmap.html" translate="no">QPixmap</a> as <a href="qpixmap.html#fromImage" translate="no">fromImage</a>() would.</p>
<p><b>See also </b><a href="qpixmap.html#fromImage" translate="no">fromImage</a>().</p>
<!-- @@@convertFromImage -->
<!-- $$$copy[overload1]$$$copyconstQRect& -->
<h3 class="fn" translate="no" id="copy"><span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">copy</span>(const <span class="type"><a href="../qtcore/qrect.html" translate="no">QRect</a></span> &amp;<i>rectangle</i> = QRect()) const</h3>
<p>Returns a deep copy of the subset of the pixmap that is specified by the given <i translate="no">rectangle</i>. For more information on deep copies, see the <a href="../qtcore/implicit-sharing.html" translate="no">Implicit Data Sharing</a> documentation.</p>
<p>If the given <i translate="no">rectangle</i> is empty, the whole image is copied.</p>
<p><b>See also </b><a href="qpixmap.html#operator-eq" translate="no">operator=</a>(), <a href="qpixmap.html#QPixmap" translate="no">QPixmap</a>(), and <a href="qpixmap.html#pixmap-transformations" translate="no">Pixmap Transformations</a>.</p>
<!-- @@@copy -->
<!-- $$$copy$$$copyintintintint -->
<h3 class="fn" translate="no" id="copy-1"><span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">copy</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a deep copy of the subset of the pixmap that is specified by the rectangle <a href="../qtcore/qrect.html" translate="no">QRect</a>( <i translate="no">x</i>, <i translate="no">y</i>, <i translate="no">width</i>, <i translate="no">height</i>).</p>
<!-- @@@copy -->
<!-- $$$createHeuristicMask[overload1]$$$createHeuristicMaskbool -->
<h3 class="fn" translate="no" id="createHeuristicMask"><span class="type"><a href="qbitmap.html" translate="no">QBitmap</a></span> QPixmap::<span class="name">createHeuristicMask</span>(<span class="type">bool</span> <i>clipTight</i> = true) const</h3>
<p>Creates and returns a heuristic mask for this pixmap.</p>
<p>The function works by selecting a color from one of the corners and then chipping away pixels of that color, starting at all the edges. If <i translate="no">clipTight</i> is true (the default) the mask is just large enough to cover the pixels; otherwise, the mask is larger than the data pixels.</p>
<p>The mask may not be perfect but it should be reasonable, so you can do things such as the following:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> myPixmap;
 myPixmap<span class="operator">.</span>setMask(myPixmap<span class="operator">.</span>createHeuristicMask());
</pre>
<p>This function is slow because it involves converting to/from a <a href="qimage.html" translate="no">QImage</a>, and non-trivial computations.</p>
<p><b>See also </b><a href="qimage.html#createHeuristicMask" translate="no">QImage::createHeuristicMask</a>() and <a href="qpixmap.html#createMaskFromColor" translate="no">createMaskFromColor</a>().</p>
<!-- @@@createHeuristicMask -->
<!-- $$$createMaskFromColor[overload1]$$$createMaskFromColorconstQColor&Qt::MaskMode -->
<h3 class="fn" translate="no" id="createMaskFromColor"><span class="type"><a href="qbitmap.html" translate="no">QBitmap</a></span> QPixmap::<span class="name">createMaskFromColor</span>(const <span class="type"><a href="qcolor.html" translate="no">QColor</a></span> &amp;<i>maskColor</i>, <span class="type"><a href="../qtcore/qt.html#MaskMode-enum" translate="no">Qt::MaskMode</a></span> <i>mode</i> = Qt::MaskInColor) const</h3>
<p>Creates and returns a mask for this pixmap based on the given <i translate="no">maskColor</i>. If the <i translate="no">mode</i> is <a href="../qtcore/qt.html#MaskMode-enum" translate="no">Qt::MaskInColor</a>, all pixels matching the maskColor will be transparent. If <i translate="no">mode</i> is <a href="../qtcore/qt.html#MaskMode-enum" translate="no">Qt::MaskOutColor</a>, all pixels matching the maskColor will be opaque.</p>
<p>This function is slow because it involves converting to/from a <a href="qimage.html" translate="no">QImage</a>.</p>
<p><b>See also </b><a href="qpixmap.html#createHeuristicMask" translate="no">createHeuristicMask</a>() and <a href="qimage.html#createMaskFromColor" translate="no">QImage::createMaskFromColor</a>().</p>
<!-- @@@createMaskFromColor -->
<!-- $$$defaultDepth[overload1]$$$defaultDepth -->
<h3 class="fn" translate="no" id="defaultDepth"><code class="details extra" translate="no">[static]</code> <span class="type">int</span> QPixmap::<span class="name">defaultDepth</span>()</h3>
<p>Returns the default pixmap depth used by the application.</p>
<p>On all platforms the depth of the primary screen will be returned.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qguiapplication.html" translate="no">QGuiApplication</a> must be created before calling this function.</p>
</div>
<p><b>See also </b><a href="qpixmap.html#depth" translate="no">depth</a>(), <a href="../qtwidgets/qcolormap.html#depth" translate="no">QColormap::depth</a>(), and <a href="qpixmap.html#pixmap-information" translate="no">Pixmap Information</a>.</p>
<!-- @@@defaultDepth -->
<!-- $$$depth[overload1]$$$depth -->
<h3 class="fn" translate="no" id="depth"><span class="type">int</span> QPixmap::<span class="name">depth</span>() const</h3>
<p>Returns the depth of the pixmap.</p>
<p>The pixmap depth is also called bits per pixel (bpp) or bit planes of a pixmap. A null pixmap has depth 0.</p>
<p><b>See also </b><a href="qpixmap.html#defaultDepth" translate="no">defaultDepth</a>() and <a href="qpixmap.html#pixmap-information" translate="no">Pixmap Information</a>.</p>
<!-- @@@depth -->
<!-- $$$detach[overload1]$$$detach -->
<h3 class="fn" translate="no" id="detach"><span class="type">void</span> QPixmap::<span class="name">detach</span>()</h3>
<p>Detaches the pixmap from shared pixmap data.</p>
<p>A pixmap is automatically detached by Qt whenever its contents are about to change. This is done in almost all <a href="qpixmap.html" translate="no">QPixmap</a> member functions that modify the pixmap (<a href="qpixmap.html#fill" translate="no">fill</a>(), <a href="qpixmap.html#fromImage" translate="no">fromImage</a>(), <a href="qpixmap.html#load" translate="no">load</a>(), etc.), and in <a href="qpainter.html#begin" translate="no">QPainter::begin</a>() on a pixmap.</p>
<p>There are two exceptions in which detach() must be called explicitly, that is when calling the handle() or the x11PictureHandle() function (only available on X11). Otherwise, any modifications done using system calls, will be performed on the shared data.</p>
<p>The detach() function returns immediately if there is just a single reference or if the pixmap has not been initialized yet.</p>
<!-- @@@detach -->
<!-- $$$deviceIndependentSize[overload1]$$$deviceIndependentSize -->
<h3 class="fn" translate="no" id="deviceIndependentSize"><code class="details extra" translate="no">[since 6.2]</code> <span class="type"><a href="../qtcore/qsizef.html" translate="no">QSizeF</a></span> QPixmap::<span class="name">deviceIndependentSize</span>() const</h3>
<p>Returns the size of the pixmap in device independent pixels.</p>
<p>This value should be used when using the pixmap size in user interface size calculations.</p>
<p>The return value is equivalent to pixmap.<a href="qpixmap.html#size" translate="no">size</a>() / pixmap.<a href="qpixmap.html#devicePixelRatio" translate="no">devicePixelRatio</a>().</p>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@deviceIndependentSize -->
<!-- $$$devicePixelRatio[overload1]$$$devicePixelRatio -->
<h3 class="fn" translate="no" id="devicePixelRatio"><span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> QPixmap::<span class="name">devicePixelRatio</span>() const</h3>
<p>Returns the device pixel ratio for the pixmap. This is the ratio between <i>device pixels</i> and <i>device independent pixels</i>.</p>
<p>Use this function when calculating layout geometry based on the pixmap size: <a href="../qtcore/qsize.html" translate="no">QSize</a> layoutSize = image.<a href="qpixmap.html#size" translate="no">size</a>() / image.devicePixelRatio()</p>
<p>The default value is 1.0.</p>
<p><b>See also </b><a href="qpixmap.html#setDevicePixelRatio" translate="no">setDevicePixelRatio</a>() and <a href="qimagereader.html" translate="no">QImageReader</a>.</p>
<!-- @@@devicePixelRatio -->
<!-- $$$fill[overload1]$$$fillconstQColor& -->
<h3 class="fn" translate="no" id="fill"><span class="type">void</span> QPixmap::<span class="name">fill</span>(const <span class="type"><a href="qcolor.html" translate="no">QColor</a></span> &amp;<i>color</i> = Qt::white)</h3>
<p>Fills the pixmap with the given <i translate="no">color</i>.</p>
<p>The effect of this function is undefined when the pixmap is being painted on.</p>
<p><b>See also </b><a href="qpixmap.html#pixmap-transformations" translate="no">Pixmap Transformations</a>.</p>
<!-- @@@fill -->
<!-- $$$fromImage[overload1]$$$fromImageconstQImage&Qt::ImageConversionFlags -->
<h3 class="fn" translate="no" id="fromImage"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">fromImage</span>(const <span class="type"><a href="qimage.html" translate="no">QImage</a></span> &amp;<i>image</i>, <span class="type"><a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor)</h3>
<p>Converts the given <i translate="no">image</i> to a pixmap using the specified <i translate="no">flags</i> to control the conversion. The <i translate="no">flags</i> argument is a bitwise-OR of the <a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a>. Passing 0 for <i translate="no">flags</i> sets all the default options.</p>
<p>In case of monochrome and 8-bit images, the image is first converted to a 32-bit pixmap and then filled with the colors in the color table. If this is too expensive an operation, you can use <a href="qbitmap.html#fromImage" translate="no">QBitmap::fromImage</a>() instead.</p>
<p><b>See also </b><a href="qpixmap.html#fromImageReader" translate="no">fromImageReader</a>(), <a href="qpixmap.html#toImage" translate="no">toImage</a>(), and <a href="qpixmap.html#pixmap-conversion" translate="no">Pixmap Conversion</a>.</p>
<!-- @@@fromImage -->
<!-- $$$fromImage$$$fromImageQImage&&Qt::ImageConversionFlags -->
<h3 class="fn" translate="no" id="fromImage-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">fromImage</span>(<span class="type"><a href="qimage.html" translate="no">QImage</a></span> &amp;&amp;<i>image</i>, <span class="type"><a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor)</h3>
<p>This is an overloaded function.</p>
<p>Converts the given <i translate="no">image</i> to a pixmap without copying if possible.</p>
<!-- @@@fromImage -->
<!-- $$$fromImageReader[overload1]$$$fromImageReaderQImageReader*Qt::ImageConversionFlags -->
<h3 class="fn" translate="no" id="fromImageReader"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">fromImageReader</span>(<span class="type"><a href="qimagereader.html" translate="no">QImageReader</a></span> *<i>imageReader</i>, <span class="type"><a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor)</h3>
<p>Create a <a href="qpixmap.html" translate="no">QPixmap</a> from an image read directly from an <i translate="no">imageReader</i>. The <i translate="no">flags</i> argument is a bitwise-OR of the <a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a>. Passing 0 for <i translate="no">flags</i> sets all the default options.</p>
<p>On some systems, reading an image directly to <a href="qpixmap.html" translate="no">QPixmap</a> can use less memory than reading a <a href="qimage.html" translate="no">QImage</a> to convert it to <a href="qpixmap.html" translate="no">QPixmap</a>.</p>
<p><b>See also </b><a href="qpixmap.html#fromImage" translate="no">fromImage</a>(), <a href="qpixmap.html#toImage" translate="no">toImage</a>(), and <a href="qpixmap.html#pixmap-conversion" translate="no">Pixmap Conversion</a>.</p>
<!-- @@@fromImageReader -->
<!-- $$$hasAlpha[overload1]$$$hasAlpha -->
<h3 class="fn" translate="no" id="hasAlpha"><span class="type">bool</span> QPixmap::<span class="name">hasAlpha</span>() const</h3>
<p>Returns <code translate="no">true</code> if this pixmap has an alpha channel, <i>or</i> has a mask, otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qpixmap.html#hasAlphaChannel" translate="no">hasAlphaChannel</a>() and <a href="qpixmap.html#mask" translate="no">mask</a>().</p>
<!-- @@@hasAlpha -->
<!-- $$$hasAlphaChannel[overload1]$$$hasAlphaChannel -->
<h3 class="fn" translate="no" id="hasAlphaChannel"><span class="type">bool</span> QPixmap::<span class="name">hasAlphaChannel</span>() const</h3>
<p>Returns <code translate="no">true</code> if the pixmap has a format that respects the alpha channel, otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qpixmap.html#hasAlpha" translate="no">hasAlpha</a>().</p>
<!-- @@@hasAlphaChannel -->
<!-- $$$height[overload1]$$$height -->
<h3 class="fn" translate="no" id="height"><span class="type">int</span> QPixmap::<span class="name">height</span>() const</h3>
<p>Returns the height of the pixmap.</p>
<p><b>See also </b><a href="qpixmap.html#size" translate="no">size</a>() and <a href="qpixmap.html#pixmap-information" translate="no">Pixmap Information</a>.</p>
<!-- @@@height -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" translate="no" id="isNull"><span class="type">bool</span> QPixmap::<span class="name">isNull</span>() const</h3>
<p>Returns <code translate="no">true</code> if this is a null pixmap; otherwise returns <code translate="no">false</code>.</p>
<p>A null pixmap has zero width, zero height and no contents. You cannot draw in a null pixmap.</p>
<!-- @@@isNull -->
<!-- $$$isQBitmap[overload1]$$$isQBitmap -->
<h3 class="fn" translate="no" id="isQBitmap"><span class="type">bool</span> QPixmap::<span class="name">isQBitmap</span>() const</h3>
<p>Returns <code translate="no">true</code> if this is a <a href="qbitmap.html" translate="no">QBitmap</a>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isQBitmap -->
<!-- $$$load[overload1]$$$loadconstQString&constchar*Qt::ImageConversionFlags -->
<h3 class="fn" translate="no" id="load"><span class="type">bool</span> QPixmap::<span class="name">load</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>fileName</i>, const <span class="type">char</span> *<i>format</i> = nullptr, <span class="type"><a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor)</h3>
<p>Loads a pixmap from the file with the given <i translate="no">fileName</i>. Returns true if the pixmap was successfully loaded; otherwise invalidates the pixmap and returns <code translate="no">false</code>.</p>
<p>The loader attempts to read the pixmap using the specified <i translate="no">format</i>. If the <i translate="no">format</i> is not specified (which is the default), the loader probes the file for a header to guess the file format.</p>
<p>The file name can either refer to an actual file on disk or to one of the application's embedded resources. See the <a href="../qtcore/resources.html" translate="no">Resource System</a> overview for details on how to embed pixmaps and other resource files in the application's executable.</p>
<p>If the data needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the <i translate="no">flags</i> to control the conversion.</p>
<p>Note that QPixmaps are automatically added to the <a href="qpixmapcache.html" translate="no">QPixmapCache</a> when loaded from a file in main thread; the key used is internal and cannot be acquired.</p>
<p><b>See also </b><a href="qpixmap.html#loadFromData" translate="no">loadFromData</a>() and <a href="qpixmap.html#reading-and-writing-image-files" translate="no">Reading and Writing Image Files</a>.</p>
<!-- @@@load -->
<!-- $$$loadFromData[overload1]$$$loadFromDataconstuchar*uintconstchar*Qt::ImageConversionFlags -->
<h3 class="fn" translate="no" id="loadFromData"><span class="type">bool</span> QPixmap::<span class="name">loadFromData</span>(const <span class="type"><a href="../qtcore/qttypes.html#uchar-typedef" translate="no">uchar</a></span> *<i>data</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>len</i>, const <span class="type">char</span> *<i>format</i> = nullptr, <span class="type"><a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor)</h3>
<p>Loads a pixmap from the <i translate="no">len</i> first bytes of the given binary <i translate="no">data</i>. Returns <code translate="no">true</code> if the pixmap was loaded successfully; otherwise invalidates the pixmap and returns <code translate="no">false</code>.</p>
<p>The loader attempts to read the pixmap using the specified <i translate="no">format</i>. If the <i translate="no">format</i> is not specified (which is the default), the loader probes the file for a header to guess the file format.</p>
<p>If the data needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the <i translate="no">flags</i> to control the conversion.</p>
<p><b>See also </b><a href="qpixmap.html#load" translate="no">load</a>() and <a href="qpixmap.html#reading-and-writing-image-files" translate="no">Reading and Writing Image Files</a>.</p>
<!-- @@@loadFromData -->
<!-- $$$loadFromData$$$loadFromDataconstQByteArray&constchar*Qt::ImageConversionFlags -->
<h3 class="fn" translate="no" id="loadFromData-1"><span class="type">bool</span> QPixmap::<span class="name">loadFromData</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>, const <span class="type">char</span> *<i>format</i> = nullptr, <span class="type"><a href="../qtcore/qt.html#ImageConversionFlag-enum" translate="no">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor)</h3>
<p>This is an overloaded function.</p>
<p>Loads a pixmap from the binary <i translate="no">data</i> using the specified <i translate="no">format</i> and conversion <i translate="no">flags</i>.</p>
<!-- @@@loadFromData -->
<!-- $$$mask[overload1]$$$mask -->
<h3 class="fn" translate="no" id="mask"><span class="type"><a href="qbitmap.html" translate="no">QBitmap</a></span> QPixmap::<span class="name">mask</span>() const</h3>
<p>Extracts a bitmap mask from the pixmap's alpha channel.</p>
<div class="admonition warning">
<p><b>Warning: </b>This is potentially an expensive operation. The mask of the pixmap is extracted dynamically from the pixeldata.</p>
</div>
<p><b>See also </b><a href="qpixmap.html#setMask" translate="no">setMask</a>() and <a href="qpixmap.html#pixmap-information" translate="no">Pixmap Information</a>.</p>
<!-- @@@mask -->
<!-- $$$rect[overload1]$$$rect -->
<h3 class="fn" translate="no" id="rect"><span class="type"><a href="../qtcore/qrect.html" translate="no">QRect</a></span> QPixmap::<span class="name">rect</span>() const</h3>
<p>Returns the pixmap's enclosing rectangle.</p>
<p><b>See also </b><a href="qpixmap.html#pixmap-information" translate="no">Pixmap Information</a>.</p>
<!-- @@@rect -->
<!-- $$$save[overload1]$$$saveconstQString&constchar*int -->
<h3 class="fn" translate="no" id="save"><span class="type">bool</span> QPixmap::<span class="name">save</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>fileName</i>, const <span class="type">char</span> *<i>format</i> = nullptr, <span class="type">int</span> <i>quality</i> = -1) const</h3>
<p>Saves the pixmap to the file with the given <i translate="no">fileName</i> using the specified image file <i translate="no">format</i> and <i translate="no">quality</i> factor. Returns <code translate="no">true</code> if successful; otherwise returns <code translate="no">false</code>.</p>
<p>The <i translate="no">quality</i> factor must be in the range [0,100] or -1. Specify 0 to obtain small compressed files, 100 for large uncompressed files, and -1 to use the default settings.</p>
<p>If <i translate="no">format</i> is <code translate="no">nullptr</code>, an image format will be chosen from <i translate="no">fileName</i>'s suffix.</p>
<p><b>See also </b><a href="qpixmap.html#reading-and-writing-image-files" translate="no">Reading and Writing Image Files</a>.</p>
<!-- @@@save -->
<!-- $$$save$$$saveQIODevice*constchar*int -->
<h3 class="fn" translate="no" id="save-1"><span class="type">bool</span> QPixmap::<span class="name">save</span>(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span> *<i>device</i>, const <span class="type">char</span> *<i>format</i> = nullptr, <span class="type">int</span> <i>quality</i> = -1) const</h3>
<p>This is an overloaded function.</p>
<p>This function writes a <a href="qpixmap.html" translate="no">QPixmap</a> to the given <i translate="no">device</i> using the specified image file <i translate="no">format</i> and <i translate="no">quality</i> factor. This can be used, for example, to save a pixmap directly into a <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> pixmap;
 <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> bytes;
 <span class="type"><a href="../qtcore/qbuffer.html" translate="no">QBuffer</a></span> buffer(<span class="operator">&amp;</span>bytes);
 buffer<span class="operator">.</span>open(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span><span class="operator">::</span>WriteOnly);
 pixmap<span class="operator">.</span>save(<span class="operator">&amp;</span>buffer<span class="operator">,</span> <span class="string">&quot;PNG&quot;</span>); <span class="comment">// writes pixmap into bytes in PNG format</span>
</pre>
<!-- @@@save -->
<!-- $$$scaled[overload1]$$$scaledconstQSize&Qt::AspectRatioModeQt::TransformationMode -->
<h3 class="fn" translate="no" id="scaled"><span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">scaled</span>(const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>size</i>, <span class="type"><a href="../qtcore/qt.html#AspectRatioMode-enum" translate="no">Qt::AspectRatioMode</a></span> <i>aspectRatioMode</i> = Qt::IgnoreAspectRatio, <span class="type"><a href="../qtcore/qt.html#TransformationMode-enum" translate="no">Qt::TransformationMode</a></span> <i>transformMode</i> = Qt::FastTransformation) const</h3>
<p>Scales the pixmap to the given <i translate="no">size</i>, using the aspect ratio and transformation modes specified by <i translate="no">aspectRatioMode</i> and <i translate="no">transformMode</i>.</p>
<p class="centerAlign"><img src="images/qimage-scaling.png" alt="" /></p><ul>
<li>If <i translate="no">aspectRatioMode</i> is <a href="../qtcore/qt.html#AspectRatioMode-enum" translate="no">Qt::IgnoreAspectRatio</a>, the pixmap is scaled to <i translate="no">size</i>.</li>
<li>If <i translate="no">aspectRatioMode</i> is <a href="../qtcore/qt.html#AspectRatioMode-enum" translate="no">Qt::KeepAspectRatio</a>, the pixmap is scaled to a rectangle as large as possible inside <i translate="no">size</i>, preserving the aspect ratio.</li>
<li>If <i translate="no">aspectRatioMode</i> is <a href="../qtcore/qt.html#AspectRatioMode-enum" translate="no">Qt::KeepAspectRatioByExpanding</a>, the pixmap is scaled to a rectangle as small as possible outside <i translate="no">size</i>, preserving the aspect ratio.</li>
</ul>
<p>If the given <i translate="no">size</i> is empty, this function returns a null pixmap.</p>
<p>In some cases it can be more beneficial to draw the pixmap to a painter with a scale set rather than scaling the pixmap. This is the case when the painter is for instance based on OpenGL or when the scale factor changes rapidly.</p>
<p><b>See also </b><a href="qpixmap.html#isNull" translate="no">isNull</a>() and <a href="qpixmap.html#pixmap-transformations" translate="no">Pixmap Transformations</a>.</p>
<!-- @@@scaled -->
<!-- $$$scaled$$$scaledintintQt::AspectRatioModeQt::TransformationMode -->
<h3 class="fn" translate="no" id="scaled-1"><span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">scaled</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type"><a href="../qtcore/qt.html#AspectRatioMode-enum" translate="no">Qt::AspectRatioMode</a></span> <i>aspectRatioMode</i> = Qt::IgnoreAspectRatio, <span class="type"><a href="../qtcore/qt.html#TransformationMode-enum" translate="no">Qt::TransformationMode</a></span> <i>transformMode</i> = Qt::FastTransformation) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a copy of the pixmap scaled to a rectangle with the given <i translate="no">width</i> and <i translate="no">height</i> according to the given <i translate="no">aspectRatioMode</i> and <i translate="no">transformMode</i>.</p>
<p>If either the <i translate="no">width</i> or the <i translate="no">height</i> is zero or negative, this function returns a null pixmap.</p>
<!-- @@@scaled -->
<!-- $$$scaledToHeight[overload1]$$$scaledToHeightintQt::TransformationMode -->
<h3 class="fn" translate="no" id="scaledToHeight"><span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">scaledToHeight</span>(<span class="type">int</span> <i>height</i>, <span class="type"><a href="../qtcore/qt.html#TransformationMode-enum" translate="no">Qt::TransformationMode</a></span> <i>mode</i> = Qt::FastTransformation) const</h3>
<p>Returns a scaled copy of the image. The returned image is scaled to the given <i translate="no">height</i> using the specified transformation <i translate="no">mode</i>. The width of the pixmap is automatically calculated so that the aspect ratio of the pixmap is preserved.</p>
<p>If <i translate="no">height</i> is 0 or negative, a null pixmap is returned.</p>
<p><b>See also </b><a href="qpixmap.html#isNull" translate="no">isNull</a>() and <a href="qpixmap.html#pixmap-transformations" translate="no">Pixmap Transformations</a>.</p>
<!-- @@@scaledToHeight -->
<!-- $$$scaledToWidth[overload1]$$$scaledToWidthintQt::TransformationMode -->
<h3 class="fn" translate="no" id="scaledToWidth"><span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">scaledToWidth</span>(<span class="type">int</span> <i>width</i>, <span class="type"><a href="../qtcore/qt.html#TransformationMode-enum" translate="no">Qt::TransformationMode</a></span> <i>mode</i> = Qt::FastTransformation) const</h3>
<p>Returns a scaled copy of the image. The returned image is scaled to the given <i translate="no">width</i> using the specified transformation <i translate="no">mode</i>. The height of the pixmap is automatically calculated so that the aspect ratio of the pixmap is preserved.</p>
<p>If <i translate="no">width</i> is 0 or negative, a null pixmap is returned.</p>
<p><b>See also </b><a href="qpixmap.html#isNull" translate="no">isNull</a>() and <a href="qpixmap.html#pixmap-transformations" translate="no">Pixmap Transformations</a>.</p>
<!-- @@@scaledToWidth -->
<!-- $$$scroll[overload1]$$$scrollintintintintintintQRegion* -->
<h3 class="fn" translate="no" id="scroll"><span class="type">void</span> QPixmap::<span class="name">scroll</span>(<span class="type">int</span> <i>dx</i>, <span class="type">int</span> <i>dy</i>, <span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type"><a href="qregion.html" translate="no">QRegion</a></span> *<i>exposed</i> = nullptr)</h3>
<p>This convenience function is equivalent to calling QPixmap::scroll(<i translate="no">dx</i>, <i translate="no">dy</i>, <a href="../qtcore/qrect.html" translate="no">QRect</a>(<i translate="no">x</i>, <i translate="no">y</i>, <i translate="no">width</i>, <i translate="no">height</i>), <i translate="no">exposed</i>).</p>
<p><b>See also </b><a href="../qtwidgets/qwidget.html#scroll" translate="no">QWidget::scroll</a>() and <a href="../qtwidgets/qgraphicsitem.html#scroll" translate="no">QGraphicsItem::scroll</a>().</p>
<!-- @@@scroll -->
<!-- $$$scroll$$$scrollintintconstQRect&QRegion* -->
<h3 class="fn" translate="no" id="scroll-1"><span class="type">void</span> QPixmap::<span class="name">scroll</span>(<span class="type">int</span> <i>dx</i>, <span class="type">int</span> <i>dy</i>, const <span class="type"><a href="../qtcore/qrect.html" translate="no">QRect</a></span> &amp;<i>rect</i>, <span class="type"><a href="qregion.html" translate="no">QRegion</a></span> *<i>exposed</i> = nullptr)</h3>
<p>Scrolls the area <i translate="no">rect</i> of this pixmap by (<i translate="no">dx</i>, <i translate="no">dy</i>). The exposed region is left unchanged. You can optionally pass a pointer to an empty <a href="qregion.html" translate="no">QRegion</a> to get the region that is <i translate="no">exposed</i> by the scroll operation.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> pixmap(<span class="string">&quot;background.png&quot;</span>);
 <span class="type"><a href="qregion.html" translate="no">QRegion</a></span> exposed;
 pixmap<span class="operator">.</span>scroll(<span class="number">10</span><span class="operator">,</span> <span class="number">10</span><span class="operator">,</span> pixmap<span class="operator">.</span>rect()<span class="operator">,</span> <span class="operator">&amp;</span>exposed);
</pre>
<p>You cannot scroll while there is an active painter on the pixmap.</p>
<p><b>See also </b><a href="../qtwidgets/qwidget.html#scroll" translate="no">QWidget::scroll</a>() and <a href="../qtwidgets/qgraphicsitem.html#scroll" translate="no">QGraphicsItem::scroll</a>().</p>
<!-- @@@scroll -->
<!-- $$$setDevicePixelRatio[overload1]$$$setDevicePixelRatioqreal -->
<h3 class="fn" translate="no" id="setDevicePixelRatio"><span class="type">void</span> QPixmap::<span class="name">setDevicePixelRatio</span>(<span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> <i>scaleFactor</i>)</h3>
<p>Sets the device pixel ratio for the pixmap. This is the ratio between image pixels and device-independent pixels.</p>
<p>The default <i translate="no">scaleFactor</i> is 1.0. Setting it to something else has two effects:</p>
<p>QPainters that are opened on the pixmap will be scaled. For example, painting on a 200x200 image if with a ratio of 2.0 will result in effective (device-independent) painting bounds of 100x100.</p>
<p>Code paths in Qt that calculate layout geometry based on the pixmap size will take the ratio into account: <a href="../qtcore/qsize.html" translate="no">QSize</a> layoutSize = pixmap.<a href="qpixmap.html#size" translate="no">size</a>() / pixmap.<a href="qpixmap.html#devicePixelRatio" translate="no">devicePixelRatio</a>() The net effect of this is that the pixmap is displayed as high-DPI pixmap rather than a large pixmap (see <a href="qpainter.html#drawing-high-resolution-versions-of-pixmaps-and-images" translate="no">Drawing High Resolution Versions of Pixmaps and Images</a>).</p>
<p><b>See also </b><a href="qpixmap.html#devicePixelRatio" translate="no">devicePixelRatio</a>() and <a href="qpixmap.html#deviceIndependentSize" translate="no">deviceIndependentSize</a>().</p>
<!-- @@@setDevicePixelRatio -->
<!-- $$$setMask[overload1]$$$setMaskconstQBitmap& -->
<h3 class="fn" translate="no" id="setMask"><span class="type">void</span> QPixmap::<span class="name">setMask</span>(const <span class="type"><a href="qbitmap.html" translate="no">QBitmap</a></span> &amp;<i>mask</i>)</h3>
<p>Sets a mask bitmap.</p>
<p>This function merges the <i translate="no">mask</i> with the pixmap's alpha channel. A pixel value of 1 on the mask means the pixmap's pixel is unchanged; a value of 0 means the pixel is transparent. The mask must have the same size as this pixmap.</p>
<p>Setting a null mask resets the mask, leaving the previously transparent pixels black. The effect of this function is undefined when the pixmap is being painted on.</p>
<div class="admonition warning">
<p><b>Warning: </b>This is potentially an expensive operation.</p>
</div>
<p><b>See also </b><a href="qpixmap.html#mask" translate="no">mask</a>(), <a href="qpixmap.html#pixmap-transformations" translate="no">Pixmap Transformations</a>, and <a href="qbitmap.html" translate="no">QBitmap</a>.</p>
<!-- @@@setMask -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QPixmap::<span class="name">size</span>() const</h3>
<p>Returns the size of the pixmap.</p>
<p><b>See also </b><a href="qpixmap.html#width" translate="no">width</a>(), <a href="qpixmap.html#height" translate="no">height</a>(), and <a href="qpixmap.html#pixmap-information" translate="no">Pixmap Information</a>.</p>
<!-- @@@size -->
<!-- $$$swap[overload1]$$$swapQPixmap& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QPixmap::<span class="name">swap</span>(<span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> &amp;<i>other</i>)</h3>
<p>Swaps pixmap <i translate="no">other</i> with this pixmap. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$toImage[overload1]$$$toImage -->
<h3 class="fn" translate="no" id="toImage"><span class="type"><a href="qimage.html" translate="no">QImage</a></span> QPixmap::<span class="name">toImage</span>() const</h3>
<p>Converts the pixmap to a <a href="qimage.html" translate="no">QImage</a>. Returns a null image if the conversion fails.</p>
<p>If the pixmap has 1-bit depth, the returned image will also be 1 bit deep. Images with more bits will be returned in a format closely represents the underlying system. Usually this will be <a href="qimage.html#Format-enum" translate="no">QImage::Format_ARGB32_Premultiplied</a> for pixmaps with an alpha and <a href="qimage.html#Format-enum" translate="no">QImage::Format_RGB32</a> or <a href="qimage.html#Format-enum" translate="no">QImage::Format_RGB16</a> for pixmaps without alpha.</p>
<p>Note that for the moment, alpha masks on monochrome images are ignored.</p>
<p><b>See also </b><a href="qpixmap.html#fromImage" translate="no">fromImage</a>() and <a href="qimage.html#image-formats" translate="no">Image Formats</a>.</p>
<!-- @@@toImage -->
<!-- $$$transformed[overload1]$$$transformedconstQTransform&Qt::TransformationMode -->
<h3 class="fn" translate="no" id="transformed"><span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> QPixmap::<span class="name">transformed</span>(const <span class="type"><a href="qtransform.html" translate="no">QTransform</a></span> &amp;<i>transform</i>, <span class="type"><a href="../qtcore/qt.html#TransformationMode-enum" translate="no">Qt::TransformationMode</a></span> <i>mode</i> = Qt::FastTransformation) const</h3>
<p>Returns a copy of the pixmap that is transformed using the given transformation <i translate="no">transform</i> and transformation <i translate="no">mode</i>. The original pixmap is not changed.</p>
<p>The transformation <i translate="no">transform</i> is internally adjusted to compensate for unwanted translation; i.e. the pixmap produced is the smallest pixmap that contains all the transformed points of the original pixmap. Use the <a href="qpixmap.html#trueMatrix" translate="no">trueMatrix</a>() function to retrieve the actual matrix used for transforming the pixmap.</p>
<p>This function is slow because it involves transformation to a <a href="qimage.html" translate="no">QImage</a>, non-trivial computations and a transformation back to a <a href="qpixmap.html" translate="no">QPixmap</a>.</p>
<p><b>See also </b><a href="qpixmap.html#trueMatrix" translate="no">trueMatrix</a>() and <a href="qpixmap.html#pixmap-transformations" translate="no">Pixmap Transformations</a>.</p>
<!-- @@@transformed -->
<!-- $$$trueMatrix[overload1]$$$trueMatrixconstQTransform&intint -->
<h3 class="fn" translate="no" id="trueMatrix"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qtransform.html" translate="no">QTransform</a></span> QPixmap::<span class="name">trueMatrix</span>(const <span class="type"><a href="qtransform.html" translate="no">QTransform</a></span> &amp;<i>matrix</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>)</h3>
<p>Returns the actual matrix used for transforming a pixmap with the given <i translate="no">width</i>, <i translate="no">height</i> and <i translate="no">matrix</i>.</p>
<p>When transforming a pixmap using the <a href="qpixmap.html#transformed" translate="no">transformed</a>() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. <a href="qpixmap.html#transformed" translate="no">transformed</a>() returns the smallest pixmap containing all transformed points of the original pixmap. This function returns the modified matrix, which maps points correctly from the original pixmap into the new pixmap.</p>
<p><b>See also </b><a href="qpixmap.html#transformed" translate="no">transformed</a>() and <a href="qpixmap.html#pixmap-transformations" translate="no">Pixmap Transformations</a>.</p>
<!-- @@@trueMatrix -->
<!-- $$$width[overload1]$$$width -->
<h3 class="fn" translate="no" id="width"><span class="type">int</span> QPixmap::<span class="name">width</span>() const</h3>
<p>Returns the width of the pixmap.</p>
<p><b>See also </b><a href="qpixmap.html#size" translate="no">size</a>() and <a href="qpixmap.html#pixmap-information" translate="no">Pixmap Information</a>.</p>
<!-- @@@width -->
<!-- $$$operator QVariant[overload1]$$$operator QVariant -->
<h3 class="fn" translate="no" id="operator-QVariant"><span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> QPixmap::<span class="name">operator QVariant</span>() const</h3>
<p>Returns the pixmap as a <a href="../qtcore/qvariant.html" translate="no">QVariant</a>.</p>
<!-- @@@operator QVariant -->
<!-- $$$operator![overload1]$$$operator! -->
<h3 class="fn" translate="no" id="operator-not"><span class="type">bool</span> QPixmap::<span class="name">operator!</span>() const</h3>
<p>Returns <code translate="no">true</code> if this is a null pixmap; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qpixmap.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@operator! -->
<!-- $$$operator=[overload1]$$$operator=constQPixmap& -->
<h3 class="fn" translate="no" id="operator-eq"><span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> &amp;QPixmap::<span class="name">operator=</span>(const <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> &amp;<i>pixmap</i>)</h3>
<p>Assigns the given <i translate="no">pixmap</i> to this pixmap and returns a reference to this pixmap.</p>
<p><b>See also </b><a href="qpixmap.html#copy" translate="no">copy</a>() and <a href="qpixmap.html#QPixmap" translate="no">QPixmap</a>().</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QPixmap&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> &amp;QPixmap::<span class="name">operator=</span>(<span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qpixmap.html" translate="no">QPixmap</a> instance.</p>
<!-- @@@operator= -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$operator<<$$$operator<<QDataStream&constQPixmap& -->
<h3 class="fn" translate="no" id="operator-lt-lt-2"><span class="type"><a href="../qtcore/qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="../qtcore/qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>stream</i>, const <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> &amp;<i>pixmap</i>)</h3>
<p>Writes the given <i translate="no">pixmap</i> to the given <i translate="no">stream</i> as a PNG image. Note that writing the stream to a file will not produce a valid image file.</p>
<p><b>See also </b><a href="qpixmap.html#save" translate="no">QPixmap::save</a>() and <a href="../qtcore/datastreamformat.html" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator>>$$$operator>>QDataStream&QPixmap& -->
<h3 class="fn" translate="no" id="operator-gt-gt-2"><span class="type"><a href="../qtcore/qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="../qtcore/qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>stream</i>, <span class="type"><a href="qpixmap.html#QPixmap" translate="no">QPixmap</a></span> &amp;<i>pixmap</i>)</h3>
<p>Reads an image from the given <i translate="no">stream</i> into the given <i translate="no">pixmap</i>.</p>
<p><b>See also </b><a href="qpixmap.html#load" translate="no">QPixmap::load</a>() and <a href="../qtcore/datastreamformat.html" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator>> -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
