<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Command buffer resource.">
  <title>QRhiCommandBuffer Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiCommandBuffer</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiCommandBuffer Class</h1>
<!-- $$$QRhiCommandBuffer-brief -->
<p>Command buffer resource. <a href="#details">More...</a></p>
<!-- @@@QRhiCommandBuffer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiCommandBuffer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qrhiresource.html" translate="no">QRhiResource</a></td></tr>
</table></div>
<ul>
<li><a href="qrhicommandbuffer-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#BeginPassFlag-enum" translate="no">BeginPassFlag</a></b> { ExternalContent, DoNotTrackResourcesForCompute }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#BeginPassFlag-enum" translate="no">BeginPassFlags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#DynamicOffset-typedef" translate="no">DynamicOffset</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#IndexFormat-enum" translate="no">IndexFormat</a></b> { IndexUInt16, IndexUInt32 }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#VertexInput-typedef" translate="no">VertexInput</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#beginComputePass" translate="no">beginComputePass</a></b>(QRhiResourceUpdateBatch *<i>resourceUpdates</i> = nullptr, QRhiCommandBuffer::BeginPassFlags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#beginExternal" translate="no">beginExternal</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a></b>(QRhiRenderTarget *<i>rt</i>, const QColor &amp;<i>colorClearValue</i>, const QRhiDepthStencilClearValue &amp;<i>depthStencilClearValue</i>, QRhiResourceUpdateBatch *<i>resourceUpdates</i> = nullptr, QRhiCommandBuffer::BeginPassFlags <i>flags</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#debugMarkBegin" translate="no">debugMarkBegin</a></b>(const QByteArray &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#debugMarkEnd" translate="no">debugMarkEnd</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#debugMarkMsg" translate="no">debugMarkMsg</a></b>(const QByteArray &amp;<i>msg</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#dispatch" translate="no">dispatch</a></b>(int <i>x</i>, int <i>y</i>, int <i>z</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#draw" translate="no">draw</a></b>(quint32 <i>vertexCount</i>, quint32 <i>instanceCount</i> = 1, quint32 <i>firstVertex</i> = 0, quint32 <i>firstInstance</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#drawIndexed" translate="no">drawIndexed</a></b>(quint32 <i>indexCount</i>, quint32 <i>instanceCount</i> = 1, quint32 <i>firstIndex</i> = 0, qint32 <i>vertexOffset</i> = 0, quint32 <i>firstInstance</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#endComputePass" translate="no">endComputePass</a></b>(QRhiResourceUpdateBatch *<i>resourceUpdates</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#endExternal" translate="no">endExternal</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a></b>(QRhiResourceUpdateBatch *<i>resourceUpdates</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#lastCompletedGpuTime" translate="no">lastCompletedGpuTime</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiNativeHandles *</td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#nativeHandles" translate="no">nativeHandles</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#resourceUpdate" translate="no">resourceUpdate</a></b>(QRhiResourceUpdateBatch *<i>resourceUpdates</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#setBlendConstants" translate="no">setBlendConstants</a></b>(const QColor &amp;<i>c</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#setComputePipeline" translate="no">setComputePipeline</a></b>(QRhiComputePipeline *<i>ps</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#setGraphicsPipeline" translate="no">setGraphicsPipeline</a></b>(QRhiGraphicsPipeline *<i>ps</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#setScissor" translate="no">setScissor</a></b>(const QRhiScissor &amp;<i>scissor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#setShaderResources" translate="no">setShaderResources</a></b>(QRhiShaderResourceBindings *<i>srb</i> = nullptr, int <i>dynamicOffsetCount</i> = 0, const QRhiCommandBuffer::DynamicOffset *<i>dynamicOffsets</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#setStencilRef" translate="no">setStencilRef</a></b>(quint32 <i>refValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#setVertexInput" translate="no">setVertexInput</a></b>(int <i>startBinding</i>, int <i>bindingCount</i>, const QRhiCommandBuffer::VertexInput *<i>bindings</i>, QRhiBuffer *<i>indexBuf</i> = nullptr, quint32 <i>indexOffset</i> = 0, QRhiCommandBuffer::IndexFormat <i>indexFormat</i> = IndexUInt16)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#setViewport" translate="no">setViewport</a></b>(const QRhiViewport &amp;<i>viewport</i>)</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiResource::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhicommandbuffer.html#resourceType" translate="no">resourceType</a></b>() const override</td></tr>
</table></div>
<!-- $$$QRhiCommandBuffer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Not creatable by applications at the moment. The only ways to obtain a valid QRhiCommandBuffer are to get it from the targeted swapchain via <a href="qrhiswapchain.html#currentFrameCommandBuffer" translate="no">QRhiSwapChain::currentFrameCommandBuffer</a>(), or, in case of rendering completely offscreen, initializing one via <a href="qrhi.html#beginOffscreenFrame" translate="no">QRhi::beginOffscreenFrame</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<!-- @@@QRhiCommandBuffer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$BeginPassFlag$$$ExternalContent$$$DoNotTrackResourcesForCompute -->
<h3 class="flags" id="BeginPassFlag-enum">enum QRhiCommandBuffer::<span class="name">BeginPassFlag</span><br/>flags QRhiCommandBuffer::<span class="name">BeginPassFlags</span></h3>
<p>Flag values for QRhi::beginPass()</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiCommandBuffer::ExternalContent</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Specifies that there will be a call to <a href="qrhicommandbuffer.html#beginExternal" translate="no">QRhiCommandBuffer::beginExternal</a>() in this pass. Some backends, Vulkan in particular, will fail if this flag is not set and <a href="qrhicommandbuffer.html#beginExternal" translate="no">beginExternal</a>() is still called.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiCommandBuffer::DoNotTrackResourcesForCompute</code></td><td class="topAlign tblval"><code translate="no">0x02</code></td><td class="topAlign">Specifies that there is no need to track resources used in this pass if the only purpose of such tracking is to generate barriers for compute. Implies that there are no compute passes in the frame. This is an optimization hint that may be taken into account by certain backends, OpenGL in particular, allowing them to skip certain operations. When this flag is set for a render pass in a frame, calling <a href="qrhicommandbuffer.html#beginComputePass" translate="no">beginComputePass</a>() in that frame may lead to unexpected behavior, depending on the resource dependencies between the render and compute passes.</td></tr>
</table></div>
<p>The BeginPassFlags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;BeginPassFlag&gt;. It stores an OR combination of BeginPassFlag values.</p>
<!-- @@@BeginPassFlag -->
<!-- $$$DynamicOffset -->
<h3 class="fn" translate="no" id="DynamicOffset-typedef"><code class="details extra" translate="no">[alias]</code> QRhiCommandBuffer::<span class="name">DynamicOffset</span></h3>
<p>Synonym for <a href="../qtcore/qpair-qtcore-proxy.html#QPair-typedef" translate="no">QPair</a>&lt;int, quint32&gt;. The first entry is the binding, the second is the offset in the buffer.</p>
<!-- @@@DynamicOffset -->
<!-- $$$IndexFormat$$$IndexUInt16$$$IndexUInt32 -->
<h3 class="fn" translate="no" id="IndexFormat-enum">enum QRhiCommandBuffer::<span class="name">IndexFormat</span></h3>
<p>Specifies the index data type</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiCommandBuffer::IndexUInt16</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Unsigned 16-bit (quint16)</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiCommandBuffer::IndexUInt32</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Unsigned 32-bit (quint32)</td></tr>
</table></div>
<!-- @@@IndexFormat -->
<!-- $$$VertexInput -->
<h3 class="fn" translate="no" id="VertexInput-typedef"><code class="details extra" translate="no">[alias]</code> QRhiCommandBuffer::<span class="name">VertexInput</span></h3>
<p>Synonym for <a href="../qtcore/qpair-qtcore-proxy.html#QPair-typedef" translate="no">QPair</a>&lt;<a href="qrhibuffer.html" translate="no">QRhiBuffer</a> *, quint32&gt;. The second entry is an offset in the buffer specified by the first.</p>
<!-- @@@VertexInput -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$beginComputePass[overload1]$$$beginComputePassQRhiResourceUpdateBatch*QRhiCommandBuffer::BeginPassFlags -->
<h3 class="fn" translate="no" id="beginComputePass"><span class="type">void</span> QRhiCommandBuffer::<span class="name">beginComputePass</span>(<span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> *<i>resourceUpdates</i> = nullptr, <span class="type"><a href="qrhicommandbuffer.html#BeginPassFlag-enum" translate="no">QRhiCommandBuffer::BeginPassFlags</a></span> <i>flags</i> = {})</h3>
<p>Records starting a new compute pass.</p>
<p><i translate="no">resourceUpdates</i>, when not null, specifies a resource update batch that is to be committed and then released.</p>
<div class="admonition note">
<p><b>Note: </b>Do not assume that any state or resource bindings persist between passes.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>A compute pass can record <a href="qrhicommandbuffer.html#setComputePipeline" translate="no">setComputePipeline</a>(), <a href="qrhicommandbuffer.html#setShaderResources" translate="no">setShaderResources</a>(), and <a href="qrhicommandbuffer.html#dispatch" translate="no">dispatch</a>() calls, not graphics ones. General functionality, such as, debug markers and <a href="qrhicommandbuffer.html#beginExternal" translate="no">beginExternal</a>() is available both in render and compute passes.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Compute is only available when the <a href="qrhi.html#Feature-enum" translate="no">Compute</a> feature is reported as supported.</p>
</div>
<p><i translate="no">flags</i> is not currently used.</p>
<!-- @@@beginComputePass -->
<!-- $$$beginExternal[overload1]$$$beginExternal -->
<h3 class="fn" translate="no" id="beginExternal"><span class="type">void</span> QRhiCommandBuffer::<span class="name">beginExternal</span>()</h3>
<p>To be called when the application before the application is about to enqueue commands to the current pass' command buffer by calling graphics API functions directly.</p>
<div class="admonition note">
<p><b>Note: </b>This is only available when the intent was declared upfront in <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() or <a href="qrhicommandbuffer.html#beginComputePass" translate="no">beginComputePass</a>(). Therefore this function must only be called when the pass recording was started with specifying <a href="qrhicommandbuffer.html#BeginPassFlag-enum" translate="no">QRhiCommandBuffer::ExternalContent</a>.</p>
</div>
<p>With Vulkan, Metal, or Direct3D 12 one can query the native command buffer or encoder objects via <a href="qrhicommandbuffer.html#nativeHandles" translate="no">nativeHandles</a>() and enqueue commands to them. With OpenGL or Direct3D 11 the (device) context can be retrieved from <a href="qrhi.html#nativeHandles" translate="no">QRhi::nativeHandles</a>(). However, this must never be done without ensuring the <a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a>'s state stays up-to-date. Hence the requirement for wrapping any externally added command recording between beginExternal() and <a href="qrhicommandbuffer.html#endExternal" translate="no">endExternal</a>(). Conceptually this is the same as <a href="qpainter.html" translate="no">QPainter</a>'s <a href="qpainter.html#beginNativePainting" translate="no">beginNativePainting</a>() and <a href="qpainter.html#endNativePainting" translate="no">endNativePainting</a>() functions.</p>
<p>For OpenGL in particular, this function has an additional task: it makes sure the context is made current on the current thread.</p>
<div class="admonition note">
<p><b>Note: </b>Once beginExternal() is called, no other render pass specific functions (<code translate="no">set*</code> or <code translate="no">draw*</code>) must be called on the <a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> until <a href="qrhicommandbuffer.html#endExternal" translate="no">endExternal</a>().</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>Some backends may return a native command buffer object from <a href="qrhicommandbuffer.html#nativeHandles" translate="no">QRhiCommandBuffer::nativeHandles</a>() that is different from the primary one when inside a beginExternal() - <a href="qrhicommandbuffer.html#endExternal" translate="no">endExternal</a>() block. Therefore it is important to (re)query the native command buffer object after calling beginExternal(). In practical terms this means that with Vulkan for example the externally recorded Vulkan commands are placed onto a secondary command buffer (with VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT). <a href="qrhicommandbuffer.html#nativeHandles" translate="no">nativeHandles</a>() returns this secondary command buffer when called between begin/<a href="qrhicommandbuffer.html#endExternal" translate="no">endExternal</a>.</p>
</div>
<p><b>See also </b><a href="qrhicommandbuffer.html#endExternal" translate="no">endExternal</a>() and <a href="qrhicommandbuffer.html#nativeHandles" translate="no">nativeHandles</a>().</p>
<!-- @@@beginExternal -->
<!-- $$$beginPass[overload1]$$$beginPassQRhiRenderTarget*constQColor&constQRhiDepthStencilClearValue&QRhiResourceUpdateBatch*QRhiCommandBuffer::BeginPassFlags -->
<h3 class="fn" translate="no" id="beginPass"><span class="type">void</span> QRhiCommandBuffer::<span class="name">beginPass</span>(<span class="type"><a href="qrhirendertarget.html" translate="no">QRhiRenderTarget</a></span> *<i>rt</i>, const <span class="type"><a href="qcolor.html" translate="no">QColor</a></span> &amp;<i>colorClearValue</i>, const <span class="type"><a href="qrhidepthstencilclearvalue.html" translate="no">QRhiDepthStencilClearValue</a></span> &amp;<i>depthStencilClearValue</i>, <span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> *<i>resourceUpdates</i> = nullptr, <span class="type"><a href="qrhicommandbuffer.html#BeginPassFlag-enum" translate="no">QRhiCommandBuffer::BeginPassFlags</a></span> <i>flags</i> = {})</h3>
<p>Records starting a new render pass targeting the render target <i translate="no">rt</i>.</p>
<p><i translate="no">resourceUpdates</i>, when not null, specifies a resource update batch that is to be committed and then released.</p>
<p>The color and depth/stencil buffers of the render target are normally cleared. The clear values are specified in <i translate="no">colorClearValue</i> and <i translate="no">depthStencilClearValue</i>. The exception is when the render target was created with <a href="qrhitexturerendertarget.html#Flag-enum" translate="no">QRhiTextureRenderTarget::PreserveColorContents</a> and/or <a href="qrhitexturerendertarget.html#Flag-enum" translate="no">QRhiTextureRenderTarget::PreserveDepthStencilContents</a>. The clear values are ignored then.</p>
<div class="admonition note">
<p><b>Note: </b>Enabling preserved color or depth contents leads to decreased performance depending on the underlying hardware. Mobile GPUs with tiled architecture benefit from not having to reload the previous contents into the tile buffer. Similarly, a <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> with a <a href="qrhitexture.html" translate="no">QRhiTexture</a> as the depth buffer is less efficient than a <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> since using a depth texture triggers requiring writing the data out to it, while with renderbuffers this is not needed (as the API does not allow sampling or reading from a renderbuffer).</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Do not assume that any state or resource bindings persist between passes.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The <a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a>'s <code translate="no">set</code> and <code translate="no">draw</code> functions can only be called inside a pass. Also, with the exception of <a href="qrhicommandbuffer.html#setGraphicsPipeline" translate="no">setGraphicsPipeline</a>(), they expect to have a pipeline set already on the command buffer. Unspecified issues may arise otherwise, depending on the backend.</p>
</div>
<p>If <i translate="no">rt</i> is a <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>, beginPass() performs a check to see if the texture and renderbuffer objects referenced from the render target are up-to-date. This is similar to what <a href="qrhicommandbuffer.html#setShaderResources" translate="no">setShaderResources</a>() does for <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a>. If any of the attachments had been rebuilt since <a href="qrhitexturerendertarget.html#create" translate="no">QRhiTextureRenderTarget::create</a>(), an implicit call to create() is made on <i translate="no">rt</i>. Therefore, if <i translate="no">rt</i> has a <a href="qrhitexture.html" translate="no">QRhiTexture</a> color attachment <code translate="no">texture</code>, and one needs to make the texture a different size, the following is then valid:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a></span> <span class="operator">*</span>rt <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newTextureRenderTarget({ { texture } });
 rt<span class="operator">-</span><span class="operator">&gt;</span>create();
 <span class="comment">// ...</span>
 texture<span class="operator">-</span><span class="operator">&gt;</span>setPixelSize(new_size);
 texture<span class="operator">-</span><span class="operator">&gt;</span>create();
 cb<span class="operator">-</span><span class="operator">&gt;</span>beginPass(rt<span class="operator">,</span> colorClear<span class="operator">,</span> dsClear); <span class="comment">// this is ok, no explicit rt-&gt;create() is required before</span>
</pre>
<p><i translate="no">flags</i> allow controlling certain advanced functionality. One commonly used flag is <code translate="no">ExternalContents</code>. This should be specified whenever <a href="qrhicommandbuffer.html#beginExternal" translate="no">beginExternal</a>() will be called within the pass started by this function.</p>
<p><b>See also </b><a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>() and <a href="qrhicommandbuffer.html#BeginPassFlag-enum" translate="no">BeginPassFlags</a>.</p>
<!-- @@@beginPass -->
<!-- $$$debugMarkBegin[overload1]$$$debugMarkBeginconstQByteArray& -->
<h3 class="fn" translate="no" id="debugMarkBegin"><span class="type">void</span> QRhiCommandBuffer::<span class="name">debugMarkBegin</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>name</i>)</h3>
<p>Records a named debug group on the command buffer with the specified <i translate="no">name</i>. This is shown in graphics debugging tools such as <a href="https://renderdoc.org/" translate="no">RenderDoc</a> and <a href="https://developer.apple.com/xcode/" translate="no">XCode</a>. The end of the grouping is indicated by <a href="qrhicommandbuffer.html#debugMarkEnd" translate="no">debugMarkEnd</a>().</p>
<div class="admonition note">
<p><b>Note: </b>Ignored when <a href="qrhi.html#Feature-enum" translate="no">QRhi::DebugMarkers</a> are not supported or <a href="qrhi.html#Flag-enum" translate="no">QRhi::EnableDebugMarkers</a> is not set.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Can be called anywhere within the frame, both inside and outside of passes.</p>
</div>
<!-- @@@debugMarkBegin -->
<!-- $$$debugMarkEnd[overload1]$$$debugMarkEnd -->
<h3 class="fn" translate="no" id="debugMarkEnd"><span class="type">void</span> QRhiCommandBuffer::<span class="name">debugMarkEnd</span>()</h3>
<p>Records the end of a debug group.</p>
<div class="admonition note">
<p><b>Note: </b>Ignored when <a href="qrhi.html#Feature-enum" translate="no">QRhi::DebugMarkers</a> are not supported or <a href="qrhi.html#Flag-enum" translate="no">QRhi::EnableDebugMarkers</a> is not set.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Can be called anywhere within the frame, both inside and outside of passes.</p>
</div>
<!-- @@@debugMarkEnd -->
<!-- $$$debugMarkMsg[overload1]$$$debugMarkMsgconstQByteArray& -->
<h3 class="fn" translate="no" id="debugMarkMsg"><span class="type">void</span> QRhiCommandBuffer::<span class="name">debugMarkMsg</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>msg</i>)</h3>
<p>Inserts a debug message <i translate="no">msg</i> into the command stream.</p>
<div class="admonition note">
<p><b>Note: </b>Ignored when <a href="qrhi.html#Feature-enum" translate="no">QRhi::DebugMarkers</a> are not supported or <a href="qrhi.html#Flag-enum" translate="no">QRhi::EnableDebugMarkers</a> is not set.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>With some backends debugMarkMsg() is only supported inside a pass and is ignored when called outside a pass. With others it is recorded anywhere within the frame.</p>
</div>
<!-- @@@debugMarkMsg -->
<!-- $$$dispatch[overload1]$$$dispatchintintint -->
<h3 class="fn" translate="no" id="dispatch"><span class="type">void</span> QRhiCommandBuffer::<span class="name">dispatch</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>z</i>)</h3>
<p>Records dispatching compute work items, with <i translate="no">x</i>, <i translate="no">y</i>, and <i translate="no">z</i> specifying the number of local workgroups in the corresponding dimension.</p>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a compute pass, meaning between a <a href="qrhicommandbuffer.html#beginComputePass" translate="no">beginComputePass</a>() and <a href="qrhicommandbuffer.html#endComputePass" translate="no">endComputePass</a>() call.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">x</i>, <i translate="no">y</i>, and <i translate="no">z</i> must fit the limits from the underlying graphics API implementation at run time. The maximum values are typically 65535.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Watch out for possible limits on the local workgroup size as well. This is specified in the shader, for example: <code translate="no">layout(local_size_x = 16, local_size_y = 16) in;</code>. For example, with OpenGL the minimum value mandated by the specification for the number of invocations in a single local work group (the product of <code translate="no">local_size_x</code>, <code translate="no">local_size_y</code>, and <code translate="no">local_size_z</code>) is 1024, while with OpenGL ES (3.1) the value may be as low as 128. This means that the example given above may be rejected by some OpenGL ES implementations as the number of invocations is 256.</p>
</div>
<!-- @@@dispatch -->
<!-- $$$draw[overload1]$$$drawquint32quint32quint32quint32 -->
<h3 class="fn" translate="no" id="draw"><span class="type">void</span> QRhiCommandBuffer::<span class="name">draw</span>(<span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>vertexCount</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>instanceCount</i> = 1, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>firstVertex</i> = 0, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>firstInstance</i> = 0)</h3>
<p>Records a non-indexed draw.</p>
<p>The number of vertices is specified in <i translate="no">vertexCount</i>. For instanced drawing set <i translate="no">instanceCount</i> to a value other than 1. <i translate="no">firstVertex</i> is the index of the first vertex to draw. When drawing multiple instances, the first instance ID is specified by <i translate="no">firstInstance</i>.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">firstInstance</i> may not be supported, and is ignored when the <a href="qrhi.html#Feature-enum" translate="no">QRhi::BaseInstance</a> feature is reported as not supported. The first ID is always 0 in that case.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a render pass, meaning between a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() and <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>() call.</p>
</div>
<!-- @@@draw -->
<!-- $$$drawIndexed[overload1]$$$drawIndexedquint32quint32quint32qint32quint32 -->
<h3 class="fn" translate="no" id="drawIndexed"><span class="type">void</span> QRhiCommandBuffer::<span class="name">drawIndexed</span>(<span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>indexCount</i>, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>instanceCount</i> = 1, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>firstIndex</i> = 0, <span class="type"><a href="../qtcore/qttypes.html#qint32-typedef" translate="no">qint32</a></span> <i>vertexOffset</i> = 0, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>firstInstance</i> = 0)</h3>
<p>Records an indexed draw.</p>
<p>The number of vertices is specified in <i translate="no">indexCount</i>. <i translate="no">firstIndex</i> is the base index. The effective offset in the index buffer is given by <code translate="no">indexOffset + firstIndex * n</code> where <code translate="no">n</code> is 2 or 4 depending on the index element type. <code translate="no">indexOffset</code> is specified in <a href="qrhicommandbuffer.html#setVertexInput" translate="no">setVertexInput</a>().</p>
<div class="admonition note">
<p><b>Note: </b>The effective offset in the index buffer must be 4 byte aligned with some backends (for example, Metal). With these backends the <a href="qrhi.html#Feature-enum" translate="no">NonFourAlignedEffectiveIndexBufferOffset</a> feature will be reported as not-supported.</p>
</div>
<p>For instanced drawing set <i translate="no">instanceCount</i> to a value other than 1. When drawing multiple instances, the first instance ID is specified by <i translate="no">firstInstance</i>.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">firstInstance</i> may not be supported, and is ignored when the <a href="qrhi.html#Feature-enum" translate="no">QRhi::BaseInstance</a> feature is reported as not supported. The first ID is always 0 in that case.</p>
</div>
<p><i translate="no">vertexOffset</i> (also called <code translate="no">base vertex</code>) is a signed value that is added to the element index before indexing into the vertex buffer. Support for this is not always available, and the value is ignored when the feature <a href="qrhi.html#Feature-enum" translate="no">QRhi::BaseVertex</a> is reported as unsupported.</p>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a render pass, meaning between a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() and <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>() call.</p>
</div>
<!-- @@@drawIndexed -->
<!-- $$$endComputePass[overload1]$$$endComputePassQRhiResourceUpdateBatch* -->
<h3 class="fn" translate="no" id="endComputePass"><span class="type">void</span> QRhiCommandBuffer::<span class="name">endComputePass</span>(<span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> *<i>resourceUpdates</i> = nullptr)</h3>
<p>Records ending the current compute pass.</p>
<p><i translate="no">resourceUpdates</i>, when not null, specifies a resource update batch that is to be committed and then released.</p>
<!-- @@@endComputePass -->
<!-- $$$endExternal[overload1]$$$endExternal -->
<h3 class="fn" translate="no" id="endExternal"><span class="type">void</span> QRhiCommandBuffer::<span class="name">endExternal</span>()</h3>
<p>To be called once the externally added commands are recorded to the command buffer or context.</p>
<div class="admonition note">
<p><b>Note: </b>All <a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> state must be assumed as invalid after calling this function. Pipelines, vertex and index buffers, and other state must be set again if more draw calls are recorded after the external commands.</p>
</div>
<p><b>See also </b><a href="qrhicommandbuffer.html#beginExternal" translate="no">beginExternal</a>() and <a href="qrhicommandbuffer.html#nativeHandles" translate="no">nativeHandles</a>().</p>
<!-- @@@endExternal -->
<!-- $$$endPass[overload1]$$$endPassQRhiResourceUpdateBatch* -->
<h3 class="fn" translate="no" id="endPass"><span class="type">void</span> QRhiCommandBuffer::<span class="name">endPass</span>(<span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> *<i>resourceUpdates</i> = nullptr)</h3>
<p>Records ending the current render pass.</p>
<p><i translate="no">resourceUpdates</i>, when not null, specifies a resource update batch that is to be committed and then released.</p>
<p><b>See also </b><a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>().</p>
<!-- @@@endPass -->
<!-- $$$lastCompletedGpuTime[overload1]$$$lastCompletedGpuTime -->
<h3 class="fn" translate="no" id="lastCompletedGpuTime"><span class="type">double</span> QRhiCommandBuffer::<span class="name">lastCompletedGpuTime</span>()</h3>
<p>Returns the last available timestamp, in seconds, when <a href="qrhi.html#Flag-enum" translate="no">QRhi::EnableTimestamps</a> was enabled when creating the <a href="qrhi.html" translate="no">QRhi</a>. The value indicates the elapsed time on the GPU during the last completed frame.</p>
<div class="admonition note">
<p><b>Note: </b>Do not expect results other than 0 when the <a href="qrhi.html#Feature-enum" translate="no">QRhi::Timestamps</a> feature is not reported as supported, or when <a href="qrhi.html#Flag-enum" translate="no">QRhi::EnableTimestamps</a> was not passed to <a href="qrhi.html#create" translate="no">QRhi::create</a>(). There are exceptions to this, because with some graphics APIs (Metal) timings are available without having to perform extra operations (timestamp queries), but portable applications should always consciously opt-in to timestamp collection when they know it is needed, and call this function accordingly.</p>
</div>
<p>Care must be exercised with the interpretation of the value, as its precision and granularity is often not controlled by Qt, and depends on the underlying graphics API and its implementation. In particular, comparing the values between different graphics APIs and hardware is discouraged and may be meaningless.</p>
<p>When the frame was recorded with <a href="qrhi.html#beginFrame" translate="no">beginFrame</a>() and <a href="qrhi.html#endFrame" translate="no">endFrame</a>(), i.e., with a swapchain, the timing values will likely become available asynchronously. The returned value may therefore be 0 (e.g., for the first 1-2 frames) or the last known value referring to some previous frame. The value my also become 0 again under certain conditions, such as when resizing the window. It can be expected that the most up-to-date available value is retrieved in beginFrame() and becomes queriable via this function once beginFrame() returns.</p>
<div class="admonition note">
<p><b>Note: </b>Do not assume that the value refers to the previous (<code translate="no">currently_recorded - 1</code>) frame. It may refer to <code translate="no">currently_recorded - 2</code> or <code translate="no">currently_recorded - 3</code> as well. The exact behavior may depend on the graphics API and its implementation.</p>
</div>
<p>On the other hand, with offscreen frames the returned value is up-to-date once <a href="qrhi.html#endOffscreenFrame" translate="no">endOffscreenFrame</a>() returns, because offscreen frames reduce GPU pipelining and wait the the commands to be complete.</p>
<div class="admonition note">
<p><b>Note: </b>This means that, unlike with swapchain frames, with offscreen frames the returned value is guaranteed to refer to the frame that has just been submitted and completed. (assuming this function is called after endOffscreenFrame() but before the next beginOffscreenFrame())</p>
</div>
<p>Watch out for the consequences of GPU frequency scaling and GPU clock changes, depending on the platform. For example, on Windows the returned timing may vary in a quite wide range between frames with modern graphics cards, even when submitting frames with a similar, or the same workload. This is out of scope for Qt to control and solve, generally speaking. However, the D3D12 backend automatically calls <a href="https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-setstablepowerstate" translate="no">ID3D12Device::SetStablePowerState()</a> whenever the environment variable <code translate="no">QT_D3D_STABLE_POWER_STATE</code> is set to a non-zero value. This can greatly stabilize the result. It can also have a non-insignificant effect on the CPU-side timings measured via <a href="../qtcore/qelapsedtimer.html" translate="no">QElapsedTimer</a> for example, especially when offscreen frames are involved.</p>
<div class="admonition note">
<p><b>Note: </b>Do not and never ship applications to production with <code translate="no">QT_D3D_STABLE_POWER_STATE</code> set. See the Windows API documentation for details.</p>
</div>
<p><b>See also </b><a href="qrhi.html#Feature-enum" translate="no">QRhi::Timestamps</a> and <a href="qrhi.html#Flag-enum" translate="no">QRhi::EnableTimestamps</a>.</p>
<!-- @@@lastCompletedGpuTime -->
<!-- $$$nativeHandles[overload1]$$$nativeHandles -->
<h3 class="fn" translate="no" id="nativeHandles">const <span class="type"><a href="qrhinativehandles.html" translate="no">QRhiNativeHandles</a></span> *QRhiCommandBuffer::<span class="name">nativeHandles</span>()</h3>
<p>Returns a pointer to a backend-specific <a href="qrhinativehandles.html" translate="no">QRhiNativeHandles</a> subclass, such as <a href="qrhivulkancommandbuffernativehandles.html" translate="no">QRhiVulkanCommandBufferNativeHandles</a>. The returned value is <code translate="no">nullptr</code> when exposing the underlying native resources is not supported by, or not applicable to, the backend.</p>
<p><b>See also </b><a href="qrhivulkancommandbuffernativehandles.html" translate="no">QRhiVulkanCommandBufferNativeHandles</a>, <a href="qrhimetalcommandbuffernativehandles.html" translate="no">QRhiMetalCommandBufferNativeHandles</a>, <a href="qrhicommandbuffer.html#beginExternal" translate="no">beginExternal</a>(), and <a href="qrhicommandbuffer.html#endExternal" translate="no">endExternal</a>().</p>
<!-- @@@nativeHandles -->
<!-- $$$resourceType[overload1]$$$resourceType -->
<h3 class="fn" translate="no" id="resourceType"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="qrhiresource.html#Type-enum" translate="no">QRhiResource::Type</a></span> QRhiCommandBuffer::<span class="name">resourceType</span>() const</h3>
<p>Reimplements: <a href="qrhiresource.html#resourceType" translate="no">QRhiResource::resourceType() const</a>.</p>
<p>Returns the resource type.</p>
<!-- @@@resourceType -->
<!-- $$$resourceUpdate[overload1]$$$resourceUpdateQRhiResourceUpdateBatch* -->
<h3 class="fn" translate="no" id="resourceUpdate"><span class="type">void</span> QRhiCommandBuffer::<span class="name">resourceUpdate</span>(<span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> *<i>resourceUpdates</i>)</h3>
<p>Sometimes committing resource updates is necessary or just more convenient without starting a render pass. Calling this function with <i translate="no">resourceUpdates</i> is an alternative to passing <i translate="no">resourceUpdates</i> to a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() call (or <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>(), which would be typical in case of readbacks).</p>
<div class="admonition note">
<p><b>Note: </b>Cannot be called inside a pass.</p>
</div>
<!-- @@@resourceUpdate -->
<!-- $$$setBlendConstants[overload1]$$$setBlendConstantsconstQColor& -->
<h3 class="fn" translate="no" id="setBlendConstants"><span class="type">void</span> QRhiCommandBuffer::<span class="name">setBlendConstants</span>(const <span class="type"><a href="qcolor.html" translate="no">QColor</a></span> &amp;<i>c</i>)</h3>
<p>Records setting the active blend constants to <i translate="no">c</i>.</p>
<p>This can only be called when the bound pipeline has <a href="qrhigraphicspipeline.html#Flag-enum" translate="no">QRhiGraphicsPipeline::UsesBlendConstants</a> set.</p>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a render pass, meaning between a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() and <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>() call.</p>
</div>
<!-- @@@setBlendConstants -->
<!-- $$$setComputePipeline[overload1]$$$setComputePipelineQRhiComputePipeline* -->
<h3 class="fn" translate="no" id="setComputePipeline"><span class="type">void</span> QRhiCommandBuffer::<span class="name">setComputePipeline</span>(<span class="type"><a href="qrhicomputepipeline.html" translate="no">QRhiComputePipeline</a></span> *<i>ps</i>)</h3>
<p>Records setting a new compute pipeline <i translate="no">ps</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before recording <a href="qrhicommandbuffer.html#setShaderResources" translate="no">setShaderResources</a>() or <a href="qrhicommandbuffer.html#dispatch" translate="no">dispatch</a>() commands on the command buffer.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qrhi.html" translate="no">QRhi</a> will optimize out unnecessary invocations within a pass, so therefore overoptimizing to avoid calls to this function is not necessary on the applications' side.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a compute pass, meaning between a <a href="qrhicommandbuffer.html#beginComputePass" translate="no">beginComputePass</a>() and <a href="qrhicommandbuffer.html#endComputePass" translate="no">endComputePass</a>() call.</p>
</div>
<!-- @@@setComputePipeline -->
<!-- $$$setGraphicsPipeline[overload1]$$$setGraphicsPipelineQRhiGraphicsPipeline* -->
<h3 class="fn" translate="no" id="setGraphicsPipeline"><span class="type">void</span> QRhiCommandBuffer::<span class="name">setGraphicsPipeline</span>(<span class="type"><a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a></span> *<i>ps</i>)</h3>
<p>Records setting a new graphics pipeline <i translate="no">ps</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before recording other <code translate="no">set</code> or <code translate="no">draw</code> commands on the command buffer.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qrhi.html" translate="no">QRhi</a> will optimize out unnecessary invocations within a pass, so therefore overoptimizing to avoid calls to this function is not necessary on the applications' side.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a render pass, meaning between a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() and <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>() call.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The new graphics pipeline <i translate="no">ps</i> must be a valid pointer.</p>
</div>
<!-- @@@setGraphicsPipeline -->
<!-- $$$setScissor[overload1]$$$setScissorconstQRhiScissor& -->
<h3 class="fn" translate="no" id="setScissor"><span class="type">void</span> QRhiCommandBuffer::<span class="name">setScissor</span>(const <span class="type"><a href="qrhiscissor.html" translate="no">QRhiScissor</a></span> &amp;<i>scissor</i>)</h3>
<p>Records setting the active scissor rectangle specified in <i translate="no">scissor</i>.</p>
<p>This can only be called when the bound pipeline has <a href="qrhigraphicspipeline.html#Flag-enum" translate="no">UsesScissor</a> set. When the flag is set on the active pipeline, this function must be called because scissor testing will get enabled and so a scissor rectangle must be provided.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhi.html" translate="no">QRhi</a> assumes OpenGL-style viewport coordinates, meaning x and y are bottom-left.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a render pass, meaning between a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() and <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>() call.</p>
</div>
<!-- @@@setScissor -->
<!-- $$$setShaderResources[overload1]$$$setShaderResourcesQRhiShaderResourceBindings*intconstQRhiCommandBuffer::DynamicOffset* -->
<h3 class="fn" translate="no" id="setShaderResources"><span class="type">void</span> QRhiCommandBuffer::<span class="name">setShaderResources</span>(<span class="type"><a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a></span> *<i>srb</i> = nullptr, <span class="type">int</span> <i>dynamicOffsetCount</i> = 0, const <span class="type"><a href="qrhicommandbuffer.html#DynamicOffset-typedef" translate="no">QRhiCommandBuffer::DynamicOffset</a></span> *<i>dynamicOffsets</i> = nullptr)</h3>
<p>Records binding a set of shader resources, such as, uniform buffers or textures, that are made visible to one or more shader stages.</p>
<p><i translate="no">srb</i> can be null in which case the current graphics or compute pipeline's associated <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> is used. When <i translate="no">srb</i> is non-null, it must be <a href="qrhishaderresourcebindings.html#isLayoutCompatible" translate="no">layout-compatible</a>, meaning the layout (number of bindings, the type and binding number of each binding) must fully match the <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> that was associated with the pipeline at the time of calling the pipeline's create().</p>
<p>There are cases when a seemingly unnecessary setShaderResources() call is mandatory: when rebuilding a resource referenced from <i translate="no">srb</i>, for example changing the size of a <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> followed by a <a href="qrhibuffer.html#create" translate="no">QRhiBuffer::create</a>(), this is the place where associated native objects (such as descriptor sets in case of Vulkan) are updated to refer to the current native resources that back the <a href="qrhibuffer.html" translate="no">QRhiBuffer</a>, <a href="qrhitexture.html" translate="no">QRhiTexture</a>, <a href="qrhisampler.html" translate="no">QRhiSampler</a> objects referenced from <i translate="no">srb</i>. In this case setShaderResources() must be called even if <i translate="no">srb</i> is the same as in the last call.</p>
<p>When <i translate="no">srb</i> is not null, the <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> object the pipeline was built with in create() is guaranteed to be not accessed in any form. In fact, it does not need to be valid even at this point: destroying the pipeline's associated srb after create() and instead explicitly specifying another, <a href="qrhishaderresourcebindings.html#isLayoutCompatible" translate="no">layout compatible</a> one in every setShaderResources() call is valid.</p>
<p><i translate="no">dynamicOffsets</i> allows specifying buffer offsets for uniform buffers that were associated with <i translate="no">srb</i> via <a href="qrhishaderresourcebinding.html#uniformBufferWithDynamicOffset" translate="no">QRhiShaderResourceBinding::uniformBufferWithDynamicOffset</a>(). This is different from providing the offset in the <i translate="no">srb</i> itself: dynamic offsets do not require building a new <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a> for every different offset, can avoid writing the underlying descriptors (with backends where applicable), and so they may be more efficient. Each element of <i translate="no">dynamicOffsets</i> is a <code translate="no">binding</code> - <code translate="no">offset</code> pair. <i translate="no">dynamicOffsetCount</i> specifies the number of elements in <i translate="no">dynamicOffsets</i>.</p>
<div class="admonition note">
<p><b>Note: </b>All offsets in <i translate="no">dynamicOffsets</i> must be byte aligned to the value returned from <a href="qrhi.html#ubufAlignment" translate="no">QRhi::ubufAlignment</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Some backends may limit the number of supported dynamic offsets. Avoid using a <i translate="no">dynamicOffsetCount</i> larger than 8.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qrhi.html" translate="no">QRhi</a> will optimize out unnecessary invocations within a pass (taking the conditions described above into account), so therefore overoptimizing to avoid calls to this function is not necessary on the applications' side.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a render or compute pass, meaning between a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() and <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>(), or <a href="qrhicommandbuffer.html#beginComputePass" translate="no">beginComputePass</a>() and <a href="qrhicommandbuffer.html#endComputePass" translate="no">endComputePass</a>().</p>
</div>
<!-- @@@setShaderResources -->
<!-- $$$setStencilRef[overload1]$$$setStencilRefquint32 -->
<h3 class="fn" translate="no" id="setStencilRef"><span class="type">void</span> QRhiCommandBuffer::<span class="name">setStencilRef</span>(<span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>refValue</i>)</h3>
<p>Records setting the active stencil reference value to <i translate="no">refValue</i>.</p>
<p>This can only be called when the bound pipeline has <a href="qrhigraphicspipeline.html#Flag-enum" translate="no">QRhiGraphicsPipeline::UsesStencilRef</a> set.</p>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a render pass, meaning between a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() and <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>() call.</p>
</div>
<!-- @@@setStencilRef -->
<!-- $$$setVertexInput[overload1]$$$setVertexInputintintconstQRhiCommandBuffer::VertexInput*QRhiBuffer*quint32QRhiCommandBuffer::IndexFormat -->
<h3 class="fn" translate="no" id="setVertexInput"><span class="type">void</span> QRhiCommandBuffer::<span class="name">setVertexInput</span>(<span class="type">int</span> <i>startBinding</i>, <span class="type">int</span> <i>bindingCount</i>, const <span class="type"><a href="qrhicommandbuffer.html#VertexInput-typedef" translate="no">QRhiCommandBuffer::VertexInput</a></span> *<i>bindings</i>, <span class="type"><a href="qrhibuffer.html" translate="no">QRhiBuffer</a></span> *<i>indexBuf</i> = nullptr, <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>indexOffset</i> = 0, <span class="type"><a href="qrhicommandbuffer.html#IndexFormat-enum" translate="no">QRhiCommandBuffer::IndexFormat</a></span> <i>indexFormat</i> = IndexUInt16)</h3>
<p>Records vertex input bindings.</p>
<p>The index buffer used by subsequent <a href="qrhicommandbuffer.html#drawIndexed" translate="no">drawIndexed</a>() commands is specified by <i translate="no">indexBuf</i>, <i translate="no">indexOffset</i>, and <i translate="no">indexFormat</i>. <i translate="no">indexBuf</i> can be set to null when indexed drawing is not needed.</p>
<p>Vertex buffer bindings are batched. <i translate="no">startBinding</i> specifies the first binding number. The recorded command then binds each buffer from <i translate="no">bindings</i> to the binding point <code translate="no">startBinding + i</code> where <code translate="no">i</code> is the index in <i translate="no">bindings</i>. Each element in <i translate="no">bindings</i> specifies a <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> and an offset.</p>
<div class="admonition note">
<p><b>Note: </b>Some backends may limit the number of vertex buffer bindings. Avoid using a <i translate="no">bindingCount</i> larger than 8.</p>
</div>
<p>Superfluous vertex input and index changes in the same pass are ignored automatically with most backends and therefore applications do not need to overoptimize to avoid calls to this function.</p>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a render pass, meaning between a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() and <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>() call.</p>
</div>
<p>As a simple example, take a vertex shader with two inputs:</p>
<pre class="cpp plain" translate="no">
 layout(location = 0) in vec4 position;
 layout(location = 1) in vec3 color;
</pre>
<p>and assume we have the data available in interleaved format, using only 2 floats for position (so 5 floats per vertex: x, y, r, g, b). A <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> for this shader can then be created using the input layout:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qrhivertexinputlayout.html" translate="no">QRhiVertexInputLayout</a></span> inputLayout;
 inputLayout<span class="operator">.</span>setBindings({
     { <span class="number">5</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) }
 });
 inputLayout<span class="operator">.</span>setAttributes({
     { <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a></span><span class="operator">::</span>Float2<span class="operator">,</span> <span class="number">0</span> }<span class="operator">,</span>
     { <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a></span><span class="operator">::</span>Float3<span class="operator">,</span> <span class="number">2</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) }
 });
</pre>
<p>Here there is one buffer binding (binding number 0), with two inputs referencing it. When recording the pass, once the pipeline is set, the vertex bindings can be specified simply like the following, assuming vbuf is the <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> with all the interleaved position+color data:</p>
<pre class="cpp" translate="no">
 <span class="keyword">const</span> <span class="type">QRhiCommandBuffer</span><span class="operator">::</span>VertexInput vbufBinding(vbuf<span class="operator">,</span> <span class="number">0</span>);
 cb<span class="operator">-</span><span class="operator">&gt;</span>setVertexInput(<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="operator">&amp;</span>vbufBinding);
</pre>
<!-- @@@setVertexInput -->
<!-- $$$setViewport[overload1]$$$setViewportconstQRhiViewport& -->
<h3 class="fn" translate="no" id="setViewport"><span class="type">void</span> QRhiCommandBuffer::<span class="name">setViewport</span>(const <span class="type"><a href="qrhiviewport.html" translate="no">QRhiViewport</a></span> &amp;<i>viewport</i>)</h3>
<p>Records setting the active viewport rectangle specified in <i translate="no">viewport</i>.</p>
<p>With backends where the underlying graphics API has scissoring always enabled, this function also sets the scissor to match the viewport whenever the active <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> does not have <a href="qrhigraphicspipeline.html#Flag-enum" translate="no">UsesScissor</a> set.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhi.html" translate="no">QRhi</a> assumes OpenGL-style viewport coordinates, meaning x and y are bottom-left.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function can only be called inside a render pass, meaning between a <a href="qrhicommandbuffer.html#beginPass" translate="no">beginPass</a>() and <a href="qrhicommandbuffer.html#endPass" translate="no">endPass</a>() call.</p>
</div>
<!-- @@@setViewport -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
