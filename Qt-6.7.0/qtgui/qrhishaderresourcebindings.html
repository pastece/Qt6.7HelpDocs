<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Encapsulates resources for making buffer, texture, sampler resources visible to shaders.">
  <title>QRhiShaderResourceBindings Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiShaderResourceBindings</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiShaderResourceBindings Class</h1>
<!-- $$$QRhiShaderResourceBindings-brief -->
<p>Encapsulates resources for making buffer, texture, sampler resources visible to shaders. <a href="#details">More...</a></p>
<!-- @@@QRhiShaderResourceBindings -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiShaderResourceBindings&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qrhiresource.html" translate="no">QRhiResource</a></td></tr>
</table></div>
<ul>
<li><a href="qrhishaderresourcebindings-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#UpdateFlag-enum" translate="no">UpdateFlags</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiShaderResourceBinding *</td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#bindingAt" translate="no">bindingAt</a></b>(qsizetype <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#bindingCount" translate="no">bindingCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiShaderResourceBinding *</td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#cbeginBindings" translate="no">cbeginBindings</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRhiShaderResourceBinding *</td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#cendBindings" translate="no">cendBindings</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#isLayoutCompatible" translate="no">isLayoutCompatible</a></b>(const QRhiShaderResourceBindings *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;quint32&gt; </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#serializedLayoutDescription" translate="no">serializedLayoutDescription</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#setBindings" translate="no">setBindings</a></b>(std::initializer_list&lt;QRhiShaderResourceBinding&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#setBindings-1" translate="no">setBindings</a></b>(InputIterator <i>first</i>, InputIterator <i>last</i>)</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiResource::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhishaderresourcebindings.html#resourceType" translate="no">resourceType</a></b>() const override</td></tr>
</table></div>
<!-- $$$QRhiShaderResourceBindings-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>A QRhiShaderResourceBindings is a collection of <a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a> objects, each of which describe a single binding.</p>
<p>Take a fragment shader with the following interface:</p>
<pre class="cpp plain" translate="no">
 layout(std140, binding = 0) uniform buf {
     mat4 mvp;
     int flip;
 } ubuf;

 layout(binding = 1) uniform sampler2D tex;
</pre>
<p>To make resources visible to the shader, the following QRhiShaderResourceBindings could be created and then passed to <a href="qrhigraphicspipeline.html#setShaderResourceBindings" translate="no">QRhiGraphicsPipeline::setShaderResourceBindings</a>():</p>
<pre class="cpp" translate="no">
 <span class="type">QRhiShaderResourceBindings</span> <span class="operator">*</span>srb <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newShaderResourceBindings();
 srb<span class="operator">-</span><span class="operator">&gt;</span>setBindings({
     <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>uniformBuffer(<span class="number">0</span><span class="operator">,</span> <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>VertexStage <span class="operator">|</span> <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>FragmentStage<span class="operator">,</span> ubuf)<span class="operator">,</span>
     <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>sampledTexture(<span class="number">1</span><span class="operator">,</span> <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>FragmentStage<span class="operator">,</span> texture<span class="operator">,</span> sampler)
 });
 srb<span class="operator">-</span><span class="operator">&gt;</span>create();
 <span class="comment">// ...</span>
 <span class="type"><a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a></span> <span class="operator">*</span>ps <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newGraphicsPipeline();
 <span class="comment">// ...</span>
 ps<span class="operator">-</span><span class="operator">&gt;</span>setShaderResourceBindings(srb);
 ps<span class="operator">-</span><span class="operator">&gt;</span>create();
 <span class="comment">// ...</span>
 cb<span class="operator">-</span><span class="operator">&gt;</span>setGraphicsPipeline(ps);
 cb<span class="operator">-</span><span class="operator">&gt;</span>setShaderResources(); <span class="comment">// binds srb</span>
</pre>
<p>This assumes that <code translate="no">ubuf</code> is a <a href="qrhibuffer.html" translate="no">QRhiBuffer</a>, <code translate="no">texture</code> is a <a href="qrhitexture.html" translate="no">QRhiTexture</a>, while <i translate="no">sampler</i> is a <a href="qrhisampler.html" translate="no">QRhiSampler</a>. The example also assumes that the uniform block is present in the vertex shader as well so the same buffer is made visible to the vertex stage too.</p>
<h5 id="advanced-usage">Advanced usage</h5>
<p>Building on the above example, let's assume that a pass now needs to use the exact same pipeline and shaders with a different texture. Creating a whole separate <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> just for this would be an overkill. This is why <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>() allows specifying a <i translate="no">srb</i> argument. As long as the layouts (so the number of bindings and the binding points) match between two QRhiShaderResourceBindings, they can both be used with the same pipeline, assuming the pipeline was created with one of them in the first place. See <a href="qrhishaderresourcebindings.html#isLayoutCompatible" translate="no">isLayoutCompatible</a>() for more details.</p>
<pre class="cpp" translate="no">
 <span class="type">QRhiShaderResourceBindings</span> <span class="operator">*</span>srb2 <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newShaderResourceBindings();
 <span class="comment">// ...</span>
 cb<span class="operator">-</span><span class="operator">&gt;</span>setGraphicsPipeline(ps);
 cb<span class="operator">-</span><span class="operator">&gt;</span>setShaderResources(srb2); <span class="comment">// binds srb2</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<!-- @@@QRhiShaderResourceBindings -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$bindingAt[overload1]$$$bindingAtqsizetype -->
<h3 class="fn" translate="no" id="bindingAt">const <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span> *QRhiShaderResourceBindings::<span class="name">bindingAt</span>(<span class="type"><a href="../qtcore/qttypes.html#qsizetype-typedef" translate="no">qsizetype</a></span> <i>index</i>) const</h3>
<p>Returns the binding at the specified <i translate="no">index</i>.</p>
<!-- @@@bindingAt -->
<!-- $$$bindingCount[overload1]$$$bindingCount -->
<h3 class="fn" translate="no" id="bindingCount"><span class="type"><a href="../qtcore/qttypes.html#qsizetype-typedef" translate="no">qsizetype</a></span> QRhiShaderResourceBindings::<span class="name">bindingCount</span>() const</h3>
<p>Returns the number of bindings.</p>
<!-- @@@bindingCount -->
<!-- $$$cbeginBindings[overload1]$$$cbeginBindings -->
<h3 class="fn" translate="no" id="cbeginBindings">const <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span> *QRhiShaderResourceBindings::<span class="name">cbeginBindings</span>() const</h3>
<p>Returns a const iterator pointing to the first item in the binding list.</p>
<!-- @@@cbeginBindings -->
<!-- $$$cendBindings[overload1]$$$cendBindings -->
<h3 class="fn" translate="no" id="cendBindings">const <span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span> *QRhiShaderResourceBindings::<span class="name">cendBindings</span>() const</h3>
<p>Returns a const iterator pointing just after the last item in the binding list.</p>
<!-- @@@cendBindings -->
<!-- $$$isLayoutCompatible[overload1]$$$isLayoutCompatibleconstQRhiShaderResourceBindings* -->
<h3 class="fn" translate="no" id="isLayoutCompatible"><span class="type">bool</span> QRhiShaderResourceBindings::<span class="name">isLayoutCompatible</span>(const <span class="type">QRhiShaderResourceBindings</span> *<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if the layout is compatible with <i translate="no">other</i>. The layout does not include the actual resource (such as, buffer or texture) and related parameters (such as, offset or size). It does include the binding point, pipeline stage, and resource type, however. The number and order of the bindings must also match in order to be compatible.</p>
<p>When there is a <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> created with this <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a>, and the function returns <code translate="no">true</code>, <i translate="no">other</i> can then safely be passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">QRhiCommandBuffer::setShaderResources</a>(), and so be used with the pipeline in place of this <a href="qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a>.</p>
<div class="admonition note">
<p><b>Note: </b>This function must only be called after a successful create(), because it relies on data generated during the baking of the underlying data structures. This way the function can implement a comparison approach that is more efficient than iterating through two binding lists and calling <a href="qrhishaderresourcebinding.html#isLayoutCompatible" translate="no">QRhiShaderResourceBinding::isLayoutCompatible</a>() on each pair. This becomes relevant especially when this function is called at a high frequency.</p>
</div>
<p><b>See also </b><a href="qrhishaderresourcebindings.html#serializedLayoutDescription" translate="no">serializedLayoutDescription</a>().</p>
<!-- @@@isLayoutCompatible -->
<!-- $$$resourceType[overload1]$$$resourceType -->
<h3 class="fn" translate="no" id="resourceType"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="qrhiresource.html#Type-enum" translate="no">QRhiResource::Type</a></span> QRhiShaderResourceBindings::<span class="name">resourceType</span>() const</h3>
<p>Reimplements: <a href="qrhiresource.html#resourceType" translate="no">QRhiResource::resourceType() const</a>.</p>
<p>Returns the resource type.</p>
<!-- @@@resourceType -->
<!-- $$$serializedLayoutDescription[overload1]$$$serializedLayoutDescription -->
<h3 class="fn" translate="no" id="serializedLayoutDescription"><span class="type"><a href="../qtcore/qvector.html" translate="no">QVector</a></span>&lt;<span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span>&gt; QRhiShaderResourceBindings::<span class="name">serializedLayoutDescription</span>() const</h3>
<p>Returns a vector of integers containing an opaque blob describing the layout of the binding list, i.e. the data relevant for <a href="qrhishaderresourcebindings.html#isLayoutCompatible" translate="no">layout compatibility tests</a>.</p>
<p>Given two objects <code translate="no">srb1</code> and <code translate="no">srb2</code>, if the data returned from this function is identical, then <code translate="no">srb1-&gt;isLayoutCompatible(srb2)</code>, and vice versa hold true as well.</p>
<div class="admonition note">
<p><b>Note: </b>The returned data is meant to be used for storing in memory and comparisons during the lifetime of the <a href="qrhi.html" translate="no">QRhi</a> the object belongs to. It is not meant for storing on disk, reusing between processes, or using with multiple <a href="qrhi.html" translate="no">QRhi</a> instances with potentially different backends.</p>
</div>
<p><b>See also </b><a href="qrhishaderresourcebindings.html#isLayoutCompatible" translate="no">isLayoutCompatible</a>().</p>
<!-- @@@serializedLayoutDescription -->
<!-- $$$setBindings[overload1]$$$setBindingsstd::initializer_list<QRhiShaderResourceBinding> -->
<h3 class="fn" translate="no" id="setBindings"><span class="type">void</span> QRhiShaderResourceBindings::<span class="name">setBindings</span>(<span class="type">std::initializer_list</span>&lt;<span class="type"><a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span>&gt; <i>list</i>)</h3>
<p>Sets the <i translate="no">list</i> of bindings.</p>
<!-- @@@setBindings -->
<!-- $$$setBindings$$$setBindingsInputIteratorInputIterator -->
<h3 class="fn" translate="no" id="setBindings-1">template &lt;typename InputIterator&gt; <span class="type">void</span> QRhiShaderResourceBindings::<span class="name">setBindings</span>(<span class="type">InputIterator</span> <i>first</i>, <span class="type">InputIterator</span> <i>last</i>)</h3>
<p>Sets the list of bindings from the iterators <i translate="no">first</i> and <i translate="no">last</i>.</p>
<!-- @@@setBindings -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
