<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qshader.cpp -->
  <meta name="description" content="Contains multiple versions of a shader translated to multiple shading languages, together with reflection metadata.">
  <title>QShader Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QShader</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QShader Class</h1>
<!-- $$$QShader-brief -->
<p>Contains multiple versions of a shader translated to multiple shading languages, together with reflection metadata. <a href="#details">More...</a></p>
<!-- @@@QShader -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QShader&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
</table></div>
<ul>
<li><a href="qshader-members.html">List of all members, including inherited members</a></li>
<li>QShader is part of <a href="painting-3d.html">Rendering in 3D</a>.</li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="qshader-nativeshaderinfo.html" translate="no">NativeShaderInfo</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="qshader-separatetocombinedimagesamplermapping.html" translate="no">SeparateToCombinedImageSamplerMapping</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#NativeResourceBindingMap-typedef" translate="no">NativeResourceBindingMap</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#SeparateToCombinedImageSamplerMappingList-typedef" translate="no">SeparateToCombinedImageSamplerMappingList</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#SerializedFormatVersion-enum" translate="no">SerializedFormatVersion</a></b> { Latest, Qt_6_5, Qt_6_4 }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#Source-enum" translate="no">Source</a></b> { SpirvShader, GlslShader, HlslShader, DxbcShader, MslShader, &hellip;, WgslShader }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#Stage-enum" translate="no">Stage</a></b> { VertexStage, TessellationControlStage, TessellationEvaluationStage, GeometryStage, FragmentStage, ComputeStage }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#Variant-enum" translate="no">Variant</a></b> { StandardShader, BatchableVertexShader, UInt16IndexedVertexAsComputeShader, UInt32IndexedVertexAsComputeShader, NonIndexedVertexAsComputeShader }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#QShader" translate="no">QShader</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#QShader-1" translate="no">QShader</a></b>(const QShader &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#QShader-2" translate="no">QShader</a></b>(QShader &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#dtor.QShader" translate="no">~QShader</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QShaderKey&gt; </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#availableShaders" translate="no">availableShaders</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShaderDescription </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#description" translate="no">description</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShader::NativeResourceBindingMap </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#nativeResourceBindingMap" translate="no">nativeResourceBindingMap</a></b>(const QShaderKey &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShader::NativeShaderInfo </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#nativeShaderInfo" translate="no">nativeShaderInfo</a></b>(const QShaderKey &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#removeNativeShaderInfo" translate="no">removeNativeShaderInfo</a></b>(const QShaderKey &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#removeResourceBindingMap" translate="no">removeResourceBindingMap</a></b>(const QShaderKey &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#removeSeparateToCombinedImageSamplerMappingList" translate="no">removeSeparateToCombinedImageSamplerMappingList</a></b>(const QShaderKey &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#removeShader" translate="no">removeShader</a></b>(const QShaderKey &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShader::SeparateToCombinedImageSamplerMappingList </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#separateToCombinedImageSamplerMappingList" translate="no">separateToCombinedImageSamplerMappingList</a></b>(const QShaderKey &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#serialized" translate="no">serialized</a></b>(QShader::SerializedFormatVersion <i>version</i> = SerializedFormatVersion::Latest) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#setDescription" translate="no">setDescription</a></b>(const QShaderDescription &amp;<i>desc</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#setNativeShaderInfo" translate="no">setNativeShaderInfo</a></b>(const QShaderKey &amp;<i>key</i>, const QShader::NativeShaderInfo &amp;<i>info</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#setResourceBindingMap" translate="no">setResourceBindingMap</a></b>(const QShaderKey &amp;<i>key</i>, const QShader::NativeResourceBindingMap &amp;<i>map</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#setSeparateToCombinedImageSamplerMappingList" translate="no">setSeparateToCombinedImageSamplerMappingList</a></b>(const QShaderKey &amp;<i>key</i>, const QShader::SeparateToCombinedImageSamplerMappingList &amp;<i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#setShader" translate="no">setShader</a></b>(const QShaderKey &amp;<i>key</i>, const QShaderCode &amp;<i>shader</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#setStage" translate="no">setStage</a></b>(QShader::Stage <i>stage</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShaderCode </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#shader" translate="no">shader</a></b>(const QShaderKey &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShader::Stage </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#stage" translate="no">stage</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#swap" translate="no">swap</a></b>(QShader &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShader &amp;</td><td class="memItemRight bottomAlign"><b><a href="qshader.html#operator-eq" translate="no">operator=</a></b>(const QShader &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> QShader &amp;</td><td class="memItemRight bottomAlign"><b><a href="qshader.html#operator-eq-1" translate="no">operator=</a></b>(QShader &amp;&amp;<i>other</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QShader </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#fromSerialized" translate="no">fromSerialized</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#qHash-3" translate="no">qHash</a></b>(const QShader &amp;<i>s</i>, size_t <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#operator-not-eq-3" translate="no">operator!=</a></b>(const QShader &amp;<i>lhs</i>, const QShader &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#operator-eq-eq-3" translate="no">operator==</a></b>(const QShader &amp;<i>lhs</i>, const QShader &amp;<i>rhs</i>)</td></tr>
</table></div>
<!-- $$$QShader-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QShader is the entry point to shader code in the graphics API agnostic Qt world. Instead of using GLSL shader sources, as was the custom with Qt 5.x, new graphics systems with backends for multiple graphics APIs, such as, Vulkan, Metal, Direct3D, and OpenGL, take QShader as their input whenever a shader needs to be specified.</p>
<div class="admonition warning">
<p><b>Warning: </b>The <a href="qrhi.html" translate="no">QRhi</a> family of classes in the Qt Gui module, including QShader and <a href="qshaderdescription.html" translate="no">QShaderDescription</a>, offer limited compatibility guarantees. There are no source or binary compatibility guarantees for these classes, meaning the API is only guaranteed to work with the Qt version the application was developed against. Source incompatible changes are however aimed to be kept at a minimum and will only be made in minor releases (6.7, 6.8, and so on). To use these classes in an application, link to <code translate="no">Qt::GuiPrivate</code> (if using CMake), and include the headers with the <code translate="no">rhi</code> prefix, for example <code translate="no">#include &lt;rhi/qshader.h&gt;</code>.</p>
</div>
<p>A QShader instance is empty and thus invalid by default. To get a useful instance, the two typical methods are:</p>
<ul>
<li>Generate the contents offline, during build time or earlier, using the <code translate="no">qsb</code> command line tool. The result is a binary file that is shipped with the application, read via <a href="../qtcore/qiodevice.html#readAll" translate="no">QIODevice::readAll</a>(), and then deserialized via <a href="qshader.html#fromSerialized" translate="no">fromSerialized</a>(). For more information, see <a href="../qtshadertools/qshaderbaker.html" translate="no">QShaderBaker</a>.</li>
<li>Generate at run time via <a href="../qtshadertools/qshaderbaker.html" translate="no">QShaderBaker</a>. This is an expensive operation, but allows applications to use user-provided or dynamically generated shader source strings.</li>
</ul>
<p>When used together with the Qt Rendering Hardware Interface and its classes, like <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a>, no further action is needed from the application's side as these classes are prepared to consume a QShader whenever a shader needs to be specified for a given stage of the graphics pipeline.</p>
<p>Alternatively, applications can access</p>
<ul>
<li>the source or byte code for any of the shading language versions that are included in the QShader,</li>
<li>the name of the entry point for the shader,</li>
<li>the reflection metadata containing a description of the shader's inputs, outputs and resources like uniform blocks. This is essential when an application or framework needs to discover the inputs of a shader at runtime due to not having advance knowledge of the vertex attributes or the layout of the uniform buffers used by the shader.</li>
</ul>
<p>QShader makes no assumption about the shading language that was used as the source for generating the various versions and variants that are included in it.</p>
<p>QShader uses implicit sharing similarly to many core Qt types, and so can be returned or passed by value. Detach happens implicitly when calling a setter.</p>
<p>For reference, a typical, portable <a href="qrhi.html" translate="no">QRhi</a> expects that a QShader suitable for all its backends contains at least the following. (this excludes support for core profile OpenGL contexts, add GLSL 150 or newer for that)</p>
<ul>
<li>SPIR-V 1.0 bytecode suitable for Vulkan 1.0 or newer</li>
<li>GLSL/ES 100 source code suitable for OpenGL ES 2.0 or newer</li>
<li>GLSL 120 source code suitable for OpenGL 2.1 or newer</li>
<li>HLSL Shader Model 5.0 source code or the corresponding DXBC bytecode suitable for Direct3D 11/12</li>
<li>Metal Shading Language 1.2 source code or the corresponding bytecode suitable for Metal 1.2 or newer</li>
</ul>
</div>
<p><b>See also </b><a href="../qtshadertools/qshaderbaker.html" translate="no">QShaderBaker</a>.</p>
<!-- @@@QShader -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$NativeResourceBindingMap -->
<h3 class="fn" translate="no" id="NativeResourceBindingMap-typedef"><code class="details extra" translate="no">[alias]</code> QShader::<span class="name">NativeResourceBindingMap</span></h3>
<p>Synonym for <a href="../qtcore/qmap.html" translate="no">QMap</a>&lt;int, <a href="../qtcore/qpair-qtcore-proxy.html#QPair-typedef" translate="no">QPair</a>&lt;int, int&gt;&gt;.</p>
<p>The resource binding model <a href="qrhi.html" translate="no">QRhi</a> assumes is based on SPIR-V. This means that uniform buffers, storage buffers, combined image samplers, and storage images share a common binding point space. The binding numbers in <a href="qshaderdescription.html" translate="no">QShaderDescription</a> and <a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a> are expected to match the <code translate="no">binding</code> layout qualifier in the Vulkan-compatible GLSL shader.</p>
<p>Graphics APIs other than Vulkan may use a resource binding model that is not fully compatible with this. The generator of the shader code translated from SPIR-V may choose not to take the SPIR-V binding qualifiers into account, for various reasons. This is the case with the Metal backend of SPIRV-Cross, for example. In addition, even when an automatic, implicit translation is mostly possible (e.g. by using SPIR-V binding points as HLSL resource register indices), assigning resource bindings without being constrained by the SPIR-V binding points can lead to better results.</p>
<p>Therefore, a <a href="qshader.html" translate="no">QShader</a> may expose an additional map that describes what the native binding point for a given SPIR-V binding is. The <a href="qrhi.html" translate="no">QRhi</a> backends, for which this is relevant, are expected to use this map automatically, as appropriate. The value is a pair, because combined image samplers may map to two native resources (a texture and a sampler) in some shading languages. In that case the second value refers to the sampler.</p>
<div class="admonition note">
<p><b>Note: </b>The native binding may be -1, in case there is no active binding for the resource in the shader. (for example, there is a uniform block declared, but it is not used in the shader code) The map is always complete, meaning there is an entry for all declared uniform blocks, storage blocks, image objects, and combined samplers, but the value will be -1 for those that are not actually referenced in the shader functions.</p>
</div>
<!-- @@@NativeResourceBindingMap -->
<!-- $$$SeparateToCombinedImageSamplerMappingList -->
<h3 class="fn" translate="no" id="SeparateToCombinedImageSamplerMappingList-typedef"><code class="details extra" translate="no">[alias]</code> QShader::<span class="name">SeparateToCombinedImageSamplerMappingList</span></h3>
<p>Synonym for <a href="../qtcore/qlist.html" translate="no">QList</a>&lt;<a href="qshader-separatetocombinedimagesamplermapping.html" translate="no">QShader::SeparateToCombinedImageSamplerMapping</a>&gt;.</p>
<!-- @@@SeparateToCombinedImageSamplerMappingList -->
<!-- $$$SerializedFormatVersion$$$Latest$$$Qt_6_5$$$Qt_6_4 -->
<h3 class="fn" translate="no" id="SerializedFormatVersion-enum">enum class QShader::<span class="name">SerializedFormatVersion</span></h3>
<p>Describes the desired output format when serializing the <a href="qshader.html" translate="no">QShader</a>.</p>
<p>The default value for the <code translate="no">version</code> argument of <a href="qshader.html#serialized" translate="no">serialized</a>() is <code translate="no">Latest</code>. This is sufficient in the vast majority of cases. Specifying another value is needed only when the intention is to generate serialized data that can be loaded by earlier Qt versions. For example, the <code translate="no">qsb</code> tool uses these enum values when the <code translate="no">--qsbversion</code> command-line argument is given.</p>
<div class="admonition note">
<p><b>Note: </b>Targeting earlier versions will make certain features disfunctional with the generated asset. This is not an issue when using the asset with the specified, older Qt version, given that that Qt version does not have the newer features in newer Qt versions that rely on additional data generated in the <a href="qshader.html" translate="no">QShader</a> and the serialized data stream, but may become a problem if the generated asset is then used with a newer Qt version.</p>
</div>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QShader::SerializedFormatVersion::Latest</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The current Qt version</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::SerializedFormatVersion::Qt_6_5</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Qt 6.5</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::SerializedFormatVersion::Qt_6_4</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Qt 6.4</td></tr>
</table></div>
<!-- @@@SerializedFormatVersion -->
<!-- $$$Source$$$SpirvShader$$$GlslShader$$$HlslShader$$$DxbcShader$$$MslShader$$$DxilShader$$$MetalLibShader$$$WgslShader -->
<h3 class="fn" translate="no" id="Source-enum">enum QShader::<span class="name">Source</span></h3>
<p>Describes what kind of shader code an entry contains.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QShader::SpirvShader</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">SPIR-V</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::GlslShader</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">GLSL</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::HlslShader</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">HLSL</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::DxbcShader</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Direct3D bytecode (HLSL compiled by <code translate="no">fxc</code>)</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::MslShader</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">Metal Shading Language</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::DxilShader</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Direct3D bytecode (HLSL compiled by <code translate="no">dxc</code>)</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::MetalLibShader</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">Pre-compiled Metal bytecode</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::WgslShader</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">WGSL</td></tr>
</table></div>
<!-- @@@Source -->
<!-- $$$Stage$$$VertexStage$$$TessellationControlStage$$$TessellationEvaluationStage$$$GeometryStage$$$FragmentStage$$$ComputeStage -->
<h3 class="fn" translate="no" id="Stage-enum">enum QShader::<span class="name">Stage</span></h3>
<p>Describes the stage of the graphics pipeline the shader is suitable for.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QShader::VertexStage</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Vertex shader</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::TessellationControlStage</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Tessellation control (hull) shader</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::TessellationEvaluationStage</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Tessellation evaluation (domain) shader</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::GeometryStage</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Geometry shader</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::FragmentStage</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">Fragment (pixel) shader</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::ComputeStage</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Compute shader</td></tr>
</table></div>
<!-- @@@Stage -->
<!-- $$$Variant$$$StandardShader$$$BatchableVertexShader$$$UInt16IndexedVertexAsComputeShader$$$UInt32IndexedVertexAsComputeShader$$$NonIndexedVertexAsComputeShader -->
<h3 class="fn" translate="no" id="Variant-enum">enum QShader::<span class="name">Variant</span></h3>
<p>Describes what kind of shader code an entry contains.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QShader::StandardShader</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The normal, unmodified version of the shader code.</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::BatchableVertexShader</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Vertex shader rewritten to be suitable for Qt Quick scenegraph batching.</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::UInt16IndexedVertexAsComputeShader</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">A vertex shader meant to be used in a Metal pipeline with tessellation in combination with indexed draw calls sourcing index data from a uint16 index buffer. To support the Metal tessellation pipeline, the vertex shader is translated to a compute shader that may be dependent on the index buffer usage in the draw calls (e.g. if the shader is using gl_VertexIndex), hence the need for three dedicated variants.</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::UInt32IndexedVertexAsComputeShader</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">A vertex shader meant to be used in a Metal pipeline with tessellation in combination with indexed draw calls sourcing index data from a uint32 index buffer. To support the Metal tessellation pipeline, the vertex shader is translated to a compute shader that may be dependent on the index buffer usage in the draw calls (e.g. if the shader is using gl_VertexIndex), hence the need for three dedicated variants.</td></tr>
<tr><td class="topAlign"><code translate="no">QShader::NonIndexedVertexAsComputeShader</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">A vertex shader meant to be used in a Metal pipeline with tessellation in combination with non-indexed draw calls. To support the Metal tessellation pipeline, the vertex shader is translated to a compute shader that may be dependent on the index buffer usage in the draw calls (e.g. if the shader is using gl_VertexIndex), hence the need for three dedicated variants.</td></tr>
</table></div>
<!-- @@@Variant -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QShader[overload1]$$$QShader -->
<h3 class="fn" translate="no" id="QShader">QShader::<span class="name">QShader</span>()</h3>
<p>Constructs a new, empty (and thus invalid) QShader instance.</p>
<!-- @@@QShader -->
<!-- $$$QShader$$$QShaderconstQShader& -->
<h3 class="fn" translate="no" id="QShader-1">QShader::<span class="name">QShader</span>(const <span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<!-- @@@QShader -->
<!-- $$$QShader$$$QShaderQShader&& -->
<h3 class="fn" translate="no" id="QShader-2"><code class="details extra" translate="no">[noexcept, since 6.7]</code> QShader::<span class="name">QShader</span>(<span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a new QShader from <i translate="no">other</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The moved-from object <i translate="no">other</i> is placed in a partially-formed state, in which the only valid operations are destruction and assignment of a new value.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@QShader -->
<!-- $$$~QShader[overload1]$$$~QShader -->
<h3 class="fn" translate="no" id="dtor.QShader"><code class="details extra" translate="no">[noexcept]</code> QShader::<span class="name">~QShader</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QShader -->
<!-- $$$availableShaders[overload1]$$$availableShaders -->
<h3 class="fn" translate="no" id="availableShaders"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span>&gt; QShader::<span class="name">availableShaders</span>() const</h3>
<p>Returns the list of available shader versions</p>
<!-- @@@availableShaders -->
<!-- $$$description[overload1]$$$description -->
<h3 class="fn" translate="no" id="description"><span class="type"><a href="qshaderdescription.html" translate="no">QShaderDescription</a></span> QShader::<span class="name">description</span>() const</h3>
<p>Returns the reflection metadata for the shader.</p>
<p><b>See also </b><a href="qshader.html#setDescription" translate="no">setDescription</a>().</p>
<!-- @@@description -->
<!-- $$$fromSerialized[overload1]$$$fromSerializedconstQByteArray& -->
<h3 class="fn" translate="no" id="fromSerialized"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> QShader::<span class="name">fromSerialized</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Creates a new <a href="qshader.html" translate="no">QShader</a> instance from the given <i translate="no">data</i>.</p>
<p>If <i translate="no">data</i> cannot be deserialized successfully, the result is a default constructed <a href="qshader.html" translate="no">QShader</a> for which <a href="qshader.html#isValid" translate="no">isValid</a>() returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qshader.html#serialized" translate="no">serialized</a>().</p>
<!-- @@@fromSerialized -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QShader::<span class="name">isValid</span>() const</h3>
<p>Returns true if the <a href="qshader.html" translate="no">QShader</a> contains at least one shader version.</p>
<!-- @@@isValid -->
<!-- $$$nativeResourceBindingMap[overload1]$$$nativeResourceBindingMapconstQShaderKey& -->
<h3 class="fn" translate="no" id="nativeResourceBindingMap"><span class="type"><a href="qshader.html#NativeResourceBindingMap-typedef" translate="no">QShader::NativeResourceBindingMap</a></span> QShader::<span class="name">nativeResourceBindingMap</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>) const</h3>
<p>Returns the native binding map for <i translate="no">key</i>. The map is empty if no mapping is available for <i translate="no">key</i> (for example, because the map is not applicable for the API and shading language described by <i translate="no">key</i>).</p>
<!-- @@@nativeResourceBindingMap -->
<!-- $$$nativeShaderInfo[overload1]$$$nativeShaderInfoconstQShaderKey& -->
<h3 class="fn" translate="no" id="nativeShaderInfo"><span class="type"><a href="qshader-nativeshaderinfo.html" translate="no">QShader::NativeShaderInfo</a></span> QShader::<span class="name">nativeShaderInfo</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>) const</h3>
<p>Returns the native shader info struct for <i translate="no">key</i>, or an empty object if there is no data available for <i translate="no">key</i>, for example because such a mapping is not applicable for the shading language or the shader stage.</p>
<p><b>See also </b><a href="qshader.html#setNativeShaderInfo" translate="no">setNativeShaderInfo</a>().</p>
<!-- @@@nativeShaderInfo -->
<!-- $$$removeNativeShaderInfo[overload1]$$$removeNativeShaderInfoconstQShaderKey& -->
<h3 class="fn" translate="no" id="removeNativeShaderInfo"><span class="type">void</span> QShader::<span class="name">removeNativeShaderInfo</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>)</h3>
<p>Removes the native shader information for <i translate="no">key</i>.</p>
<!-- @@@removeNativeShaderInfo -->
<!-- $$$removeResourceBindingMap[overload1]$$$removeResourceBindingMapconstQShaderKey& -->
<h3 class="fn" translate="no" id="removeResourceBindingMap"><span class="type">void</span> QShader::<span class="name">removeResourceBindingMap</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>)</h3>
<p>Removes the native resource binding map for <i translate="no">key</i>.</p>
<!-- @@@removeResourceBindingMap -->
<!-- $$$removeSeparateToCombinedImageSamplerMappingList[overload1]$$$removeSeparateToCombinedImageSamplerMappingListconstQShaderKey& -->
<h3 class="fn" translate="no" id="removeSeparateToCombinedImageSamplerMappingList"><span class="type">void</span> QShader::<span class="name">removeSeparateToCombinedImageSamplerMappingList</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>)</h3>
<p>Removes the combined image sampler mapping list for <i translate="no">key</i>.</p>
<!-- @@@removeSeparateToCombinedImageSamplerMappingList -->
<!-- $$$removeShader[overload1]$$$removeShaderconstQShaderKey& -->
<h3 class="fn" translate="no" id="removeShader"><span class="type">void</span> QShader::<span class="name">removeShader</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>)</h3>
<p>Removes the source or binary shader code for a given <i translate="no">key</i>. Does nothing when not found.</p>
<!-- @@@removeShader -->
<!-- $$$separateToCombinedImageSamplerMappingList[overload1]$$$separateToCombinedImageSamplerMappingListconstQShaderKey& -->
<h3 class="fn" translate="no" id="separateToCombinedImageSamplerMappingList"><span class="type"><a href="qshader.html#SeparateToCombinedImageSamplerMappingList-typedef" translate="no">QShader::SeparateToCombinedImageSamplerMappingList</a></span> QShader::<span class="name">separateToCombinedImageSamplerMappingList</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>) const</h3>
<p>Returns the combined image sampler mapping list for <i translate="no">key</i>, or an empty list if there is no data available for <i translate="no">key</i>, for example because such a mapping is not applicable for the shading language.</p>
<p><b>See also </b><a href="qshader.html#setSeparateToCombinedImageSamplerMappingList" translate="no">setSeparateToCombinedImageSamplerMappingList</a>().</p>
<!-- @@@separateToCombinedImageSamplerMappingList -->
<!-- $$$serialized[overload1]$$$serializedQShader::SerializedFormatVersion -->
<h3 class="fn" translate="no" id="serialized"><span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> QShader::<span class="name">serialized</span>(<span class="type"><a href="qshader.html#SerializedFormatVersion-enum" translate="no">QShader::SerializedFormatVersion</a></span> <i>version</i> = SerializedFormatVersion::Latest) const</h3>
<p>Returns a serialized binary version of all the data held by the <a href="qshader.html" translate="no">QShader</a>, suitable for writing to files or other I/O devices.</p>
<p>By default the latest serialization format is used. Use <i translate="no">version</i> parameter to serialize for a compatibility Qt version. Only when it is known that the generated data stream must be made compatible with an older Qt version at the expense of making it incompatible with features introduced since that Qt version, should another value (for example, <a href="qshader.html#SerializedFormatVersion-enum" translate="no">Qt_6_5</a> for Qt 6.5) be used.</p>
<p><b>See also </b><a href="qshader.html#fromSerialized" translate="no">fromSerialized</a>().</p>
<!-- @@@serialized -->
<!-- $$$setDescription[overload1]$$$setDescriptionconstQShaderDescription& -->
<h3 class="fn" translate="no" id="setDescription"><span class="type">void</span> QShader::<span class="name">setDescription</span>(const <span class="type"><a href="qshaderdescription.html" translate="no">QShaderDescription</a></span> &amp;<i>desc</i>)</h3>
<p>Sets the reflection metadata to <i translate="no">desc</i>.</p>
<p><b>See also </b><a href="qshader.html#description" translate="no">description</a>().</p>
<!-- @@@setDescription -->
<!-- $$$setNativeShaderInfo[overload1]$$$setNativeShaderInfoconstQShaderKey&constQShader::NativeShaderInfo& -->
<h3 class="fn" translate="no" id="setNativeShaderInfo"><span class="type">void</span> QShader::<span class="name">setNativeShaderInfo</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>, const <span class="type"><a href="qshader-nativeshaderinfo.html" translate="no">QShader::NativeShaderInfo</a></span> &amp;<i>info</i>)</h3>
<p>Stores the given native shader <i translate="no">info</i> associated with <i translate="no">key</i>.</p>
<p><b>See also </b><a href="qshader.html#nativeShaderInfo" translate="no">nativeShaderInfo</a>().</p>
<!-- @@@setNativeShaderInfo -->
<!-- $$$setResourceBindingMap[overload1]$$$setResourceBindingMapconstQShaderKey&constQShader::NativeResourceBindingMap& -->
<h3 class="fn" translate="no" id="setResourceBindingMap"><span class="type">void</span> QShader::<span class="name">setResourceBindingMap</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>, const <span class="type"><a href="qshader.html#NativeResourceBindingMap-typedef" translate="no">QShader::NativeResourceBindingMap</a></span> &amp;<i>map</i>)</h3>
<p>Stores the given native resource binding <i translate="no">map</i> associated with <i translate="no">key</i>.</p>
<p><b>See also </b><a href="qshader.html#nativeResourceBindingMap" translate="no">nativeResourceBindingMap</a>().</p>
<!-- @@@setResourceBindingMap -->
<!-- $$$setSeparateToCombinedImageSamplerMappingList[overload1]$$$setSeparateToCombinedImageSamplerMappingListconstQShaderKey&constQShader::SeparateToCombinedImageSamplerMappingList& -->
<h3 class="fn" translate="no" id="setSeparateToCombinedImageSamplerMappingList"><span class="type">void</span> QShader::<span class="name">setSeparateToCombinedImageSamplerMappingList</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>, const <span class="type"><a href="qshader.html#SeparateToCombinedImageSamplerMappingList-typedef" translate="no">QShader::SeparateToCombinedImageSamplerMappingList</a></span> &amp;<i>list</i>)</h3>
<p>Stores the given combined image sampler mapping <i translate="no">list</i> associated with <i translate="no">key</i>.</p>
<p><b>See also </b><a href="qshader.html#separateToCombinedImageSamplerMappingList" translate="no">separateToCombinedImageSamplerMappingList</a>().</p>
<!-- @@@setSeparateToCombinedImageSamplerMappingList -->
<!-- $$$setShader[overload1]$$$setShaderconstQShaderKey&constQShaderCode& -->
<h3 class="fn" translate="no" id="setShader"><span class="type">void</span> QShader::<span class="name">setShader</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>, const <span class="type"><a href="qshadercode.html" translate="no">QShaderCode</a></span> &amp;<i>shader</i>)</h3>
<p>Stores the source or binary <i translate="no">shader</i> code for a given shader version specified by <i translate="no">key</i>.</p>
<p><b>See also </b><a href="qshader.html#shader" translate="no">shader</a>().</p>
<!-- @@@setShader -->
<!-- $$$setStage[overload1]$$$setStageQShader::Stage -->
<h3 class="fn" translate="no" id="setStage"><span class="type">void</span> QShader::<span class="name">setStage</span>(<span class="type"><a href="qshader.html#Stage-enum" translate="no">QShader::Stage</a></span> <i>stage</i>)</h3>
<p>Sets the pipeline <i translate="no">stage</i>.</p>
<p><b>See also </b><a href="qshader.html#stage" translate="no">stage</a>().</p>
<!-- @@@setStage -->
<!-- $$$shader[overload1]$$$shaderconstQShaderKey& -->
<h3 class="fn" translate="no" id="shader"><span class="type"><a href="qshadercode.html" translate="no">QShaderCode</a></span> QShader::<span class="name">shader</span>(const <span class="type"><a href="qshaderkey.html" translate="no">QShaderKey</a></span> &amp;<i>key</i>) const</h3>
<p>Returns the source or binary code for a given shader version specified by <i translate="no">key</i>.</p>
<p><b>See also </b><a href="qshader.html#setShader" translate="no">setShader</a>().</p>
<!-- @@@shader -->
<!-- $$$stage[overload1]$$$stage -->
<h3 class="fn" translate="no" id="stage"><span class="type"><a href="qshader.html#Stage-enum" translate="no">QShader::Stage</a></span> QShader::<span class="name">stage</span>() const</h3>
<p>Returns the pipeline stage the shader is meant for.</p>
<p><b>See also </b><a href="qshader.html#setStage" translate="no">setStage</a>().</p>
<!-- @@@stage -->
<!-- $$$swap[overload1]$$$swapQShader& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept, since 6.7]</code> <span class="type">void</span> QShader::<span class="name">swap</span>(<span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;<i>other</i>)</h3>
<p>Swaps shader <i translate="no">other</i> with this shader. This operation is very fast and never fails.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@swap -->
<!-- $$$operator=[overload1]$$$operator=constQShader& -->
<h3 class="fn" translate="no" id="operator-eq"><span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;QShader::<span class="name">operator=</span>(const <span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;<i>other</i>)</h3>
<p>Assigns <i translate="no">other</i> to this object.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QShader&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[noexcept, since 6.7]</code> <span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;QShader::<span class="name">operator=</span>(<span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qshader.html" translate="no">QShader</a> instance.</p>
<div class="admonition note">
<p><b>Note: </b>The moved-from object <i translate="no">other</i> is placed in a partially-formed state, in which the only valid operations are destruction and assignment of a new value.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@operator= -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash$$$qHashconstQShader&size_t -->
<h3 class="fn" translate="no" id="qHash-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;<i>s</i>, <span class="type">size_t</span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for <i translate="no">s</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<!-- @@@qHash -->
<!-- $$$operator!=$$$operator!=constQShader&constQShader& -->
<h3 class="fn" translate="no" id="operator-not-eq-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;<i>lhs</i>, const <span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">false</code> if the values in the two <a href="qshader.html" translate="no">QShader</a> objects <i translate="no">lhs</i> and <i translate="no">rhs</i> are equal; otherwise returns <code translate="no">true</code>.</p>
<!-- @@@operator!= -->
<!-- $$$operator==$$$operator==constQShader&constQShader& -->
<h3 class="fn" translate="no" id="operator-eq-eq-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;<i>lhs</i>, const <span class="type"><a href="qshader.html#QShader" translate="no">QShader</a></span> &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if the two <a href="qshader.html" translate="no">QShader</a> objects <i translate="no">lhs</i> and <i translate="no">rhs</i> are equal, meaning they are for the same stage with matching sets of shader source or binary code.</p>
<!-- @@@operator== -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
