<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Vertex, index, or uniform (constant) buffer resource.">
  <title>QRhiBuffer Class | Qt GUI 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtgui-index.html" translate="no">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li>QRhiBuffer</li>
<li id="buildversion"><a href="qtgui-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#example-usage">Example usage</a></li>
<li class="level2"><a href="#common-patterns">Common patterns</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiBuffer Class</h1>
<!-- $$$QRhiBuffer-brief -->
<p>Vertex, index, or uniform (constant) buffer resource. <a href="#details">More...</a></p>
<!-- @@@QRhiBuffer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiBuffer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Gui) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Gui)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qrhiresource.html" translate="no">QRhiResource</a></td></tr>
</table></div>
<ul>
<li><a href="qrhibuffer-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer-nativebuffer.html" translate="no">NativeBuffer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#Type-enum" translate="no">Type</a></b> { Immutable, Static, Dynamic }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#UsageFlag-enum" translate="no">UsageFlag</a></b> { VertexBuffer, IndexBuffer, UniformBuffer, StorageBuffer }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#UsageFlag-enum" translate="no">UsageFlags</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual char *</td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#beginFullDynamicBufferUpdateForCurrentFrame" translate="no">beginFullDynamicBufferUpdateForCurrentFrame</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#create" translate="no">create</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#endFullDynamicBufferUpdateForCurrentFrame" translate="no">endFullDynamicBufferUpdateForCurrentFrame</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiBuffer::NativeBuffer </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#nativeBuffer" translate="no">nativeBuffer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#setSize" translate="no">setSize</a></b>(quint32 <i>sz</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#setType" translate="no">setType</a></b>(QRhiBuffer::Type <i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#setUsage" translate="no">setUsage</a></b>(QRhiBuffer::UsageFlags <i>u</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint32 </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiBuffer::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#type" translate="no">type</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiBuffer::UsageFlags </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#usage" translate="no">usage</a></b>() const</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiResource::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#resourceType" translate="no">resourceType</a></b>() const override</td></tr>
</table></div>
<!-- $$$QRhiBuffer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
<p>A QRhiBuffer encapsulates zero, one, or more native buffer objects (such as a <code translate="no">VkBuffer</code> or <code translate="no">MTLBuffer</code>). With some graphics APIs and backends certain types of buffers may not use a native buffer object at all (e.g. OpenGL if uniform buffer objects are not used), but this is transparent to the user of the QRhiBuffer API. Similarly, the fact that some types of buffers may use two or three native buffers underneath, in order to allow efficient per-frame content update without stalling the GPU pipeline, is mostly invisible to the applications and libraries.</p>
<p>A QRhiBuffer instance is always created by calling <a href="qrhi.html#newBuffer" translate="no">the QRhi's newBuffer() function</a>. This creates no native graphics resources. To do that, call <a href="qrhibuffer.html#create" translate="no">create</a>() after setting the appropriate options, such as the type, usage flags, size, although in most cases these are already set based on the arguments passed to <a href="qrhi.html#newBuffer" translate="no">newBuffer</a>().</p>
<h4 id="example-usage">Example usage</h4>
<p>To create a uniform buffer for a shader where the GLSL uniform block contains a single <code translate="no">mat4</code> member, and update the contents:</p>
<pre class="cpp" translate="no">
 <span class="type">QRhiBuffer</span> <span class="operator">*</span>ubuf <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type">QRhiBuffer</span><span class="operator">::</span>Dynamic<span class="operator">,</span> <span class="type">QRhiBuffer</span><span class="operator">::</span>UniformBuffer<span class="operator">,</span> <span class="number">64</span>);
 <span class="keyword">if</span> (<span class="operator">!</span>ubuf<span class="operator">-</span><span class="operator">&gt;</span>create()) { error(); }
 <span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>batch <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
 QMatrix4x4 mvp;
 <span class="comment">// ... set up the modelview-projection matrix</span>
 batch<span class="operator">-</span><span class="operator">&gt;</span>updateDynamicBuffer(ubuf<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">64</span><span class="operator">,</span> mvp<span class="operator">.</span>constData());
 <span class="comment">// ...</span>
 commandBuffer<span class="operator">-</span><span class="operator">&gt;</span>resourceUpdate(batch); <span class="comment">// or, alternatively, pass 'batch' to a beginPass() call</span>
</pre>
<p>An example of creating a buffer with vertex data:</p>
<pre class="cpp" translate="no">
 <span class="keyword">const</span> <span class="type">float</span> vertices<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> { <span class="operator">-</span><span class="number">1.0f</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1.0f</span><span class="operator">,</span> <span class="number">1.0f</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span> <span class="number">1.0f</span> };
 <span class="type">QRhiBuffer</span> <span class="operator">*</span>vbuf <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type">QRhiBuffer</span><span class="operator">::</span>Immutable<span class="operator">,</span> <span class="type">QRhiBuffer</span><span class="operator">::</span>VertexBuffer<span class="operator">,</span> <span class="keyword">sizeof</span>(vertices));
 <span class="keyword">if</span> (<span class="operator">!</span>vbuf<span class="operator">-</span><span class="operator">&gt;</span>create()) { error(); }
 <span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>batch <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
 batch<span class="operator">-</span><span class="operator">&gt;</span>uploadStaticBuffer(vbuf<span class="operator">,</span> vertices);
 <span class="comment">// ...</span>
 commandBuffer<span class="operator">-</span><span class="operator">&gt;</span>resourceUpdate(batch); <span class="comment">// or, alternatively, pass 'batch' to a beginPass() call</span>
</pre>
<p>An index buffer:</p>
<pre class="cpp" translate="no">
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> indices<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> { <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span> };
 <span class="type">QRhiBuffer</span> <span class="operator">*</span>ibuf <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type">QRhiBuffer</span><span class="operator">::</span>Immutable<span class="operator">,</span> <span class="type">QRhiBuffer</span><span class="operator">::</span>IndexBuffer<span class="operator">,</span> <span class="keyword">sizeof</span>(indices));
 <span class="keyword">if</span> (<span class="operator">!</span>ibuf<span class="operator">-</span><span class="operator">&gt;</span>create()) { error(); }
 <span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>batch <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
 batch<span class="operator">-</span><span class="operator">&gt;</span>uploadStaticBuffer(ibuf<span class="operator">,</span> indices);
 <span class="comment">// ...</span>
 commandBuffer<span class="operator">-</span><span class="operator">&gt;</span>resourceUpdate(batch); <span class="comment">// or, alternatively, pass 'batch' to a beginPass() call</span>
</pre>
<h4 id="common-patterns">Common patterns</h4>
<p>A call to <a href="qrhibuffer.html#create" translate="no">create</a>() destroys any existing native resources if <a href="qrhibuffer.html#create" translate="no">create</a>() was successfully called before. If those native resources are still in use by an in-flight frame (i.e., there's a chance they are still read by the GPU), the destroying of those resources is deferred automatically. Thus a very common and convenient pattern to safely increase the size of an already initialized buffer is the following. In practice this drops and creates a whole new set of native resources underneath, so it is not necessarily a cheap operation, but is more convenient and still faster than the alternatives, because by not destroying the <code translate="no">buf</code> object itself, all references to it stay valid in other data structures (e.g., in any <a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a> the QRhiBuffer is referenced from).</p>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (buf<span class="operator">-</span><span class="operator">&gt;</span>size() <span class="operator">&lt;</span> newSize) {
     buf<span class="operator">-</span><span class="operator">&gt;</span>setSize(newSize);
     <span class="keyword">if</span> (<span class="operator">!</span>buf<span class="operator">-</span><span class="operator">&gt;</span>create()) { error(); }
 }
 <span class="comment">// continue using buf, fill it with new data</span>
</pre>
<p>When working with uniform buffers, it will sometimes be necessary to combine data for multiple draw calls into a single buffer for efficiency reasons. Be aware of the aligment requirements: with some graphics APIs offsets for a uniform buffer must be aligned to 256 bytes. This applies both to <a href="qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a> and to the dynamic offsets passed to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">setShaderResources</a>(). Use the <a href="qrhi.html#ubufAlignment" translate="no">ubufAlignment</a>() and <a href="qrhi.html#ubufAligned" translate="no">ubufAligned</a>() functions to create portable code. As an example, the following is an outline for issuing multiple (<code translate="no">N</code>) draw calls with the same pipeline and geometry, but with a different data in the uniform buffers exposed at binding point 0. This assumes the buffer is exposed via <a href="qrhishaderresourcebinding.html#uniformBufferWithDynamicOffset" translate="no">uniformBufferWithDynamicOffset</a>() which allows passing a <a href="qrhicommandbuffer.html#DynamicOffset-typedef" translate="no">QRhiCommandBuffer::DynamicOffset</a> list to <a href="qrhicommandbuffer.html#setShaderResources" translate="no">setShaderResources</a>().</p>
<pre class="cpp" translate="no">
 <span class="keyword">const</span> <span class="type">int</span> N <span class="operator">=</span> <span class="number">2</span>;
 <span class="keyword">const</span> <span class="type">int</span> UB_SIZE <span class="operator">=</span> <span class="number">64</span> <span class="operator">+</span> <span class="number">4</span>; <span class="comment">// assuming a uniform block with { mat4 matrix; float opacity; }</span>
 <span class="keyword">const</span> <span class="type">int</span> ONE_UBUF_SIZE <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>ubufAligned(UB_SIZE);
 <span class="keyword">const</span> <span class="type">int</span> TOTAL_UBUF_SIZE <span class="operator">=</span> N <span class="operator">*</span> ONE_UBUF_SIZE;
 <span class="type">QRhiBuffer</span> <span class="operator">*</span>ubuf <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type">QRhiBuffer</span><span class="operator">::</span>Dynamic<span class="operator">,</span> <span class="type">QRhiBuffer</span><span class="operator">::</span>UniformBuffer<span class="operator">,</span> TOTAL_UBUF_SIZE);
 <span class="keyword">if</span> (<span class="operator">!</span>ubuf<span class="operator">-</span><span class="operator">&gt;</span>create()) { error(); }
 <span class="type"><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>batch <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
 <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> N; <span class="operator">+</span><span class="operator">+</span>i) {
     batch<span class="operator">-</span><span class="operator">&gt;</span>updateDynamicBuffer(ubuf<span class="operator">,</span> i <span class="operator">*</span> ONE_UBUF_SIZE<span class="operator">,</span> <span class="number">64</span><span class="operator">,</span> matrix<span class="operator">.</span>constData());
     updates<span class="operator">-</span><span class="operator">&gt;</span>updateDynamicBuffer(ubuf<span class="operator">,</span> i <span class="operator">*</span> ONE_UBUF_SIZE <span class="operator">+</span> <span class="number">64</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="operator">&amp;</span>opacity);
 }
 <span class="comment">// ...</span>
 <span class="comment">// beginPass(), set pipeline, etc., and then:</span>
 <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> N; <span class="operator">+</span><span class="operator">+</span>i) {
     <span class="type"><a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span><span class="operator">::</span>DynamicOffset dynOfs<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> { { <span class="number">0</span><span class="operator">,</span> i <span class="operator">*</span> ONE_UBUF_SIZE } };
     cb<span class="operator">-</span><span class="operator">&gt;</span>setShaderResources(srb<span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> dynOfs);
     cb<span class="operator">-</span><span class="operator">&gt;</span>draw(<span class="number">36</span>);
 }
</pre>
</div>
<p><b>See also </b><a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a>, <a href="qrhi.html" translate="no">QRhi</a>, and <a href="qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a>.</p>
<!-- @@@QRhiBuffer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Type$$$Immutable$$$Static$$$Dynamic -->
<h3 class="fn" translate="no" id="Type-enum">enum QRhiBuffer::<span class="name">Type</span></h3>
<p>Specifies storage type of buffer resource.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiBuffer::Immutable</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Indicates that the data is not expected to change ever after the initial upload. Under the hood such buffer resources are typically placed in device local (GPU) memory (on systems where applicable). Uploading new data is possible, but may be expensive. The upload typically happens by copying to a separate, host visible staging buffer from which a GPU buffer-to-buffer copy is issued into the actual GPU-only buffer.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiBuffer::Static</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Indicates that the data is expected to change only infrequently. Typically placed in device local (GPU) memory, where applicable. On backends where host visible staging buffers are used for uploading, the staging buffers are kept around for this type, unlike with Immutable, so subsequent uploads do not suffer in performance. Frequent updates, especially updates in consecutive frames, should be avoided.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiBuffer::Dynamic</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Indicates that the data is expected to change frequently. Not recommended for large buffers. Typically backed by host visible memory in 2 copies in order to allow for changing without stalling the graphics pipeline. The double buffering is managed transparently to the applications and is not exposed in the API here in any form. This is the recommended, and, with some backends, the only possible, type for buffers with <a href="qrhibuffer.html#UsageFlag-enum" translate="no">UniformBuffer</a> usage.</td></tr>
</table></div>
<!-- @@@Type -->
<!-- $$$UsageFlag$$$VertexBuffer$$$IndexBuffer$$$UniformBuffer$$$StorageBuffer -->
<h3 class="flags" id="UsageFlag-enum">enum QRhiBuffer::<span class="name">UsageFlag</span><br/>flags QRhiBuffer::<span class="name">UsageFlags</span></h3>
<p>Flag values to specify how the buffer is going to be used.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiBuffer::VertexBuffer</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td><td class="topAlign">Vertex buffer. This allows the <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> to be used in <a href="qrhicommandbuffer.html#setVertexInput" translate="no">setVertexInput</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiBuffer::IndexBuffer</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 1</code></td><td class="topAlign">Index buffer. This allows the <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> to be used in <a href="qrhicommandbuffer.html#setVertexInput" translate="no">setVertexInput</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiBuffer::UniformBuffer</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 2</code></td><td class="topAlign">Uniform buffer (also called constant buffer). This allows the <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> to be used in combination with <a href="qrhishaderresourcebinding.html#Type-enum" translate="no">UniformBuffer</a>. When <a href="qrhi.html#Feature-enum" translate="no">NonDynamicUniformBuffers</a> is reported as not supported, this usage can only be combined with the type Dynamic.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiBuffer::StorageBuffer</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 3</code></td><td class="topAlign">Storage buffer. This allows the <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> to be used in combination with <a href="qrhishaderresourcebinding.html#Type-enum" translate="no">BufferLoad</a>, <a href="qrhishaderresourcebinding.html#Type-enum" translate="no">BufferStore</a>, or <a href="qrhishaderresourcebinding.html#Type-enum" translate="no">BufferLoadStore</a>. This usage can only be combined with the types Immutable or Static, and is only available when the <a href="qrhi.html#Feature-enum" translate="no">Compute feature</a> is reported as supported.</td></tr>
</table></div>
<p>The UsageFlags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;UsageFlag&gt;. It stores an OR combination of UsageFlag values.</p>
<!-- @@@UsageFlag -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$beginFullDynamicBufferUpdateForCurrentFrame[overload1]$$$beginFullDynamicBufferUpdateForCurrentFrame -->
<h3 class="fn" translate="no" id="beginFullDynamicBufferUpdateForCurrentFrame"><code class="details extra" translate="no">[virtual]</code> <span class="type">char</span> *QRhiBuffer::<span class="name">beginFullDynamicBufferUpdateForCurrentFrame</span>()</h3>
<p>Returns a pointer to a memory block with the host visible buffer data.</p>
<p>This is a shortcut for medium-to-large dynamic uniform buffers that have their <b>entire</b> contents (or at least all regions that are read by the shaders in the current frame) changed <b>in every frame</b> and the <a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a>-based update mechanism is seen too heavy due to the amount of data copying involved.</p>
<p>The call to this function must be eventually followed by a call to endFullDynamicUniformBufferUpdateForCurrentFrame(), before recording any render or compute pass that relies on this buffer.</p>
<div class="admonition warning">
<p><b>Warning: </b>Updating data via this method is not compatible with <a href="qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a>-based updates and readbacks. Unexpected behavior may occur when attempting to combine the two update models for the same buffer. Similarly, the data updated this direct way may not be visible to <a href="qrhiresourceupdatebatch.html#readBackBuffer" translate="no">readBackBuffer operations</a>, depending on the backend.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>When updating buffer data via this method, the update must be done in every frame, otherwise backends that perform double or triple buffering of resources may end up in unexpected behavior.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>Partial updates are not possible with this approach since some backends may choose a strategy where the previous contents of the buffer is lost upon calling this function. Data must be written to all regions that are read by shaders in the frame currently being prepared.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called when recording a frame, so between <a href="qrhi.html#beginFrame" translate="no">QRhi::beginFrame</a>() and <a href="qrhi.html#endFrame" translate="no">QRhi::endFrame</a>().</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called on Dynamic buffers.</p>
</div>
<!-- @@@beginFullDynamicBufferUpdateForCurrentFrame -->
<!-- $$$create[overload1]$$$create -->
<h3 class="fn" translate="no" id="create"><code class="details extra" translate="no">[pure virtual]</code> <span class="type">bool</span> QRhiBuffer::<span class="name">create</span>()</h3>
<p>Creates the corresponding native graphics resources. If there are already resources present due to an earlier create() with no corresponding <a href="qrhiresource.html#destroy" translate="no">destroy</a>(), then <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is called implicitly first.</p>
<p>Returns <code translate="no">true</code> when successful, <code translate="no">false</code> when a graphics operation failed. Regardless of the return value, calling <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is always safe.</p>
<!-- @@@create -->
<!-- $$$endFullDynamicBufferUpdateForCurrentFrame[overload1]$$$endFullDynamicBufferUpdateForCurrentFrame -->
<h3 class="fn" translate="no" id="endFullDynamicBufferUpdateForCurrentFrame"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QRhiBuffer::<span class="name">endFullDynamicBufferUpdateForCurrentFrame</span>()</h3>
<p>To be called when the entire contents of the buffer data has been updated in the memory block returned from <a href="qrhibuffer.html#beginFullDynamicBufferUpdateForCurrentFrame" translate="no">beginFullDynamicBufferUpdateForCurrentFrame</a>().</p>
<!-- @@@endFullDynamicBufferUpdateForCurrentFrame -->
<!-- $$$nativeBuffer[overload1]$$$nativeBuffer -->
<h3 class="fn" translate="no" id="nativeBuffer"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="qrhibuffer-nativebuffer.html" translate="no">QRhiBuffer::NativeBuffer</a></span> QRhiBuffer::<span class="name">nativeBuffer</span>()</h3>
<p>Returns the underlying native resources for this buffer. The returned value will be empty if exposing the underlying native resources is not supported by the backend.</p>
<p>A <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> may be backed by multiple native buffer objects, depending on the <a href="qrhibuffer.html#type" translate="no">type</a>() and the <a href="qrhi.html" translate="no">QRhi</a> backend in use. When this is the case, all of them are returned in the objects array in the returned struct, with slotCount specifying the number of native buffer objects. While <a href="qrhi.html#beginFrame" translate="no">recording a frame</a>, <a href="qrhi.html#currentFrameSlot" translate="no">QRhi::currentFrameSlot</a>() can be used to determine which of the native buffers <a href="qrhi.html" translate="no">QRhi</a> is using for operations that read or write from this <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> within the frame being recorded.</p>
<p>In some cases a <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> will not be backed by a native buffer object at all. In this case slotCount will be set to 0 and no valid native objects are returned. This is not an error, and is perfectly valid when a given backend does not use native buffers for QRhiBuffers with certain types or usages.</p>
<div class="admonition note">
<p><b>Note: </b>Be aware that <a href="qrhi.html" translate="no">QRhi</a> backends may employ various buffer update strategies. Unlike textures, where uploading image data always means recording a buffer-to-image (or similar) copy command on the command buffer, buffers, in particular Dynamic and <a href="qrhibuffer.html#UsageFlag-enum" translate="no">UniformBuffer</a> ones, can operate in many different ways. For example, a <a href="qrhibuffer.html" translate="no">QRhiBuffer</a> with usage type <a href="qrhibuffer.html#UsageFlag-enum" translate="no">UniformBuffer</a> may not even be backed by a native buffer object at all if uniform buffers are not used or supported by a given backend and graphics API. There are also differences to how data is written to the buffer and the type of backing memory used. For buffers backed by host visible memory, calling this function guarantees that pending host writes are executed for all the returned native buffers.</p>
</div>
<p><b>See also </b><a href="qrhi.html#currentFrameSlot" translate="no">QRhi::currentFrameSlot</a>() and <a href="qrhi.html#ResourceLimit-enum" translate="no">QRhi::FramesInFlight</a>.</p>
<!-- @@@nativeBuffer -->
<!-- $$$resourceType[overload1]$$$resourceType -->
<h3 class="fn" translate="no" id="resourceType"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="qrhiresource.html#Type-enum" translate="no">QRhiResource::Type</a></span> QRhiBuffer::<span class="name">resourceType</span>() const</h3>
<p>Reimplements: <a href="qrhiresource.html#resourceType" translate="no">QRhiResource::resourceType() const</a>.</p>
<p>Returns the resource type.</p>
<!-- @@@resourceType -->
<!-- $$$setSize[overload1]$$$setSizequint32 -->
<h3 class="fn" translate="no" id="setSize"><span class="type">void</span> QRhiBuffer::<span class="name">setSize</span>(<span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>sz</i>)</h3>
<p>Sets the size of the buffer in bytes. The size is normally specified in <a href="qrhi.html#newBuffer" translate="no">QRhi::newBuffer</a>() so this function is only used when the size has to be changed. As with other setters, the size only takes effect when calling <a href="qrhibuffer.html#create" translate="no">create</a>(), and for already created buffers this involves releasing the previous native resource and creating new ones under the hood.</p>
<p>Backends may choose to allocate buffers bigger than <i translate="no">sz</i> in order to fulfill alignment requirements. This is hidden from the applications and <a href="qrhibuffer.html#size" translate="no">size</a>() will always report the size requested in <i translate="no">sz</i>.</p>
<p><b>See also </b><a href="qrhibuffer.html#size" translate="no">size</a>().</p>
<!-- @@@setSize -->
<!-- $$$setType[overload1]$$$setTypeQRhiBuffer::Type -->
<h3 class="fn" translate="no" id="setType"><span class="type">void</span> QRhiBuffer::<span class="name">setType</span>(<span class="type"><a href="qrhibuffer.html#Type-enum" translate="no">QRhiBuffer::Type</a></span> <i>t</i>)</h3>
<p>Sets the buffer's type to <i translate="no">t</i>.</p>
<p><b>See also </b><a href="qrhibuffer.html#type" translate="no">type</a>().</p>
<!-- @@@setType -->
<!-- $$$setUsage[overload1]$$$setUsageQRhiBuffer::UsageFlags -->
<h3 class="fn" translate="no" id="setUsage"><span class="type">void</span> QRhiBuffer::<span class="name">setUsage</span>(<span class="type"><a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::UsageFlags</a></span> <i>u</i>)</h3>
<p>Sets the buffer's usage flags to <i translate="no">u</i>.</p>
<p><b>See also </b><a href="qrhibuffer.html#usage" translate="no">usage</a>().</p>
<!-- @@@setUsage -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> QRhiBuffer::<span class="name">size</span>() const</h3>
<p>Returns the buffer's size in bytes.</p>
<p>This is always the value that was passed to <a href="qrhibuffer.html#setSize" translate="no">setSize</a>() or <a href="qrhi.html#newBuffer" translate="no">QRhi::newBuffer</a>(). Internally, the native buffers may be bigger if that is required by the underlying graphics API.</p>
<p><b>See also </b><a href="qrhibuffer.html#setSize" translate="no">setSize</a>().</p>
<!-- @@@size -->
<!-- $$$type[overload1]$$$type -->
<h3 class="fn" translate="no" id="type"><span class="type"><a href="qrhibuffer.html#Type-enum" translate="no">QRhiBuffer::Type</a></span> QRhiBuffer::<span class="name">type</span>() const</h3>
<p>Returns the buffer type.</p>
<p><b>See also </b><a href="qrhibuffer.html#setType" translate="no">setType</a>().</p>
<!-- @@@type -->
<!-- $$$usage[overload1]$$$usage -->
<h3 class="fn" translate="no" id="usage"><span class="type"><a href="qrhibuffer.html#UsageFlag-enum" translate="no">QRhiBuffer::UsageFlags</a></span> QRhiBuffer::<span class="name">usage</span>() const</h3>
<p>Returns the buffer's usage flags.</p>
<p><b>See also </b><a href="qrhibuffer.html#setUsage" translate="no">setUsage</a>().</p>
<!-- @@@usage -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
