<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qopenglwidget.cpp -->
  <meta name="description" content="The QOpenGLWidget class is a widget for rendering OpenGL graphics.">
  <title>QOpenGLWidget Class | Qt OpenGL</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtopengl-index.html" translate="no">Qt OpenGL</a></li>
<li><a href="qtopengl-module.html" translate="no">C++ Classes</a></li>
<li><a href="qtopenglwidgets-module.html" translate="no">QtOpenGLWidgets</a></li>
<li>QOpenGLWidget</li>
<li id="buildversion"><a href="qtopengl-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#painting-techniques">Painting Techniques</a></li>
<li class="level2"><a href="#opengl-function-calls-headers-and-qopenglfunctions">OpenGL Function Calls, Headers and QOpenGLFunctions</a></li>
<li class="level2"><a href="#code-examples">Code Examples</a></li>
<li class="level2"><a href="#multisampling">Multisampling</a></li>
<li class="level2"><a href="#threading">Threading</a></li>
<li class="level2"><a href="#context-sharing">Context Sharing</a></li>
<li class="level2"><a href="#resource-initialization-and-cleanup">Resource Initialization and Cleanup</a></li>
<li class="level2"><a href="#limitations-and-other-considerations">Limitations and Other Considerations</a></li>
<li class="level2"><a href="#alternatives">Alternatives</a></li>
<li class="level2"><a href="#stereoscopic-rendering">Stereoscopic rendering</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QOpenGLWidget Class</h1>
<!-- $$$QOpenGLWidget-brief -->
<p>The QOpenGLWidget class is a widget for rendering OpenGL graphics. <a href="#details">More...</a></p>
<!-- @@@QOpenGLWidget -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QOpenGLWidget&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS OpenGLWidgets) <br/>
target_link_libraries(mytarget PRIVATE Qt6::OpenGLWidgets)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += openglwidgets</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></td></tr>
</table></div>
<ul>
<li><a href="qopenglwidget-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> enum </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#TargetBuffer-enum" translate="no">TargetBuffer</a></b> { LeftBuffer, RightBuffer }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#UpdateBehavior-enum" translate="no">UpdateBehavior</a></b> { NoPartialUpdate, PartialUpdate }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#QOpenGLWidget" translate="no">QOpenGLWidget</a></b>(QWidget *<i>parent</i> = nullptr, Qt::WindowFlags <i>f</i> = Qt::WindowFlags())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#dtor.QOpenGLWidget" translate="no">~QOpenGLWidget</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContext *</td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#context" translate="no">context</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QOpenGLWidget::TargetBuffer </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#currentTargetBuffer" translate="no">currentTargetBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#defaultFramebufferObject" translate="no">defaultFramebufferObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#defaultFramebufferObject-1" translate="no">defaultFramebufferObject</a></b>(QOpenGLWidget::TargetBuffer <i>targetBuffer</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#doneCurrent" translate="no">doneCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSurfaceFormat </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#format" translate="no">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#grabFramebuffer" translate="no">grabFramebuffer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QImage </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#grabFramebuffer-1" translate="no">grabFramebuffer</a></b>(QOpenGLWidget::TargetBuffer <i>targetBuffer</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#makeCurrent-1" translate="no">makeCurrent</a></b>(QOpenGLWidget::TargetBuffer <i>targetBuffer</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#setFormat" translate="no">setFormat</a></b>(const QSurfaceFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#setTextureFormat" translate="no">setTextureFormat</a></b>(GLenum <i>texFormat</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#setUpdateBehavior" translate="no">setUpdateBehavior</a></b>(QOpenGLWidget::UpdateBehavior <i>updateBehavior</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLenum </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#textureFormat" translate="no">textureFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLWidget::UpdateBehavior </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#updateBehavior" translate="no">updateBehavior</a></b>() const</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#aboutToCompose" translate="no">aboutToCompose</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#aboutToResize" translate="no">aboutToResize</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#frameSwapped" translate="no">frameSwapped</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#resized" translate="no">resized</a></b>()</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#paintGL" translate="no">paintGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#resizeGL" translate="no">resizeGL</a></b>(int <i>w</i>, int <i>h</i>)</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#event" translate="no">event</a></b>(QEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#metric" translate="no">metric</a></b>(QPaintDevice::PaintDeviceMetric <i>metric</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QPaintEngine *</td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#paintEngine" translate="no">paintEngine</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#paintEvent" translate="no">paintEvent</a></b>(QPaintEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QPaintDevice *</td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#redirected" translate="no">redirected</a></b>(QPoint *<i>p</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qopenglwidget.html#resizeEvent" translate="no">resizeEvent</a></b>(QResizeEvent *<i>e</i>) override</td></tr>
</table></div>
<!-- $$$QOpenGLWidget-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QOpenGLWidget provides functionality for displaying OpenGL graphics integrated into a Qt application. It is very simple to use: Make your class inherit from it and use the subclass like any other <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>, except that you have the choice between using <a href="../qtgui/qpainter.html" translate="no">QPainter</a> and standard OpenGL rendering commands.</p>
<p>QOpenGLWidget provides three convenient virtual functions that you can reimplement in your subclass to perform the typical OpenGL tasks:</p>
<ul>
<li><a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() - Renders the OpenGL scene. Gets called whenever the widget needs to be updated.</li>
<li><a href="qopenglwidget.html#resizeGL" translate="no">resizeGL</a>() - Sets up the OpenGL viewport, projection, etc. Gets called whenever the widget has been resized (and also when it is shown for the first time because all newly created widgets get a resize event automatically).</li>
<li><a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>() - Sets up the OpenGL resources and state. Gets called once before the first time <a href="qopenglwidget.html#resizeGL" translate="no">resizeGL</a>() or <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() is called.</li>
</ul>
<p>If you need to trigger a repaint from places other than <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() (a typical example is when using <a href="../qtcore/qtimer.html" translate="no">timers</a> to animate scenes), you should call the widget's <a href="../qtwidgets/qwidget.html#update" translate="no">update</a>() function to schedule an update.</p>
<p>Your widget's OpenGL rendering context is made current when <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>(), <a href="qopenglwidget.html#resizeGL" translate="no">resizeGL</a>(), or <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>() is called. If you need to call the standard OpenGL API functions from other places (e.g. in your widget's constructor or in your own paint functions), you must call <a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>() first.</p>
<p>All rendering happens into an OpenGL framebuffer object. <a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>() ensure that it is bound in the context. Keep this in mind when creating and binding additional framebuffer objects in the rendering code in <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>(). Never re-bind the framebuffer with ID 0. Instead, call <a href="qopenglwidget.html#defaultFramebufferObject" translate="no">defaultFramebufferObject</a>() to get the ID that should be bound.</p>
<p>QOpenGLWidget allows using different OpenGL versions and profiles when the platform supports it. Just set the requested format via <a href="qopenglwidget.html#setFormat" translate="no">setFormat</a>(). Keep in mind however that having multiple QOpenGLWidget instances in the same window requires that they all use the same format, or at least formats that do not make the contexts non-sharable. To overcome this issue, prefer using <a href="../qtgui/qsurfaceformat.html#setDefaultFormat" translate="no">QSurfaceFormat::setDefaultFormat</a>() instead of <a href="qopenglwidget.html#setFormat" translate="no">setFormat</a>().</p>
<div class="admonition note">
<p><b>Note: </b>Calling <a href="../qtgui/qsurfaceformat.html#setDefaultFormat" translate="no">QSurfaceFormat::setDefaultFormat</a>() before constructing the <a href="../qtwidgets/qapplication.html" translate="no">QApplication</a> instance is mandatory on some platforms (for example, macOS) when an OpenGL core profile context is requested. This is to ensure that resource sharing between contexts stays functional as all internal contexts are created using the correct version and profile.</p>
</div>
<h3 id="painting-techniques">Painting Techniques</h3>
<p>As described above, subclass QOpenGLWidget to render pure 3D content in the following way:</p>
<ul>
<li>Reimplement the <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>() and <a href="qopenglwidget.html#resizeGL" translate="no">resizeGL</a>() functions to set up the OpenGL state and provide a perspective transformation.</li>
<li>Reimplement <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() to paint the 3D scene, calling only OpenGL functions.</li>
</ul>
<p>It is also possible to draw 2D graphics onto a QOpenGLWidget subclass using <a href="../qtgui/qpainter.html" translate="no">QPainter</a>:</p>
<ul>
<li>In <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>(), instead of issuing OpenGL commands, construct a <a href="../qtgui/qpainter.html" translate="no">QPainter</a> object for use on the widget.</li>
<li>Draw primitives using <a href="../qtgui/qpainter.html" translate="no">QPainter</a>'s member functions.</li>
<li>Direct OpenGL commands can still be issued. However, you must make sure these are enclosed by a call to the painter's beginNativePainting() and endNativePainting().</li>
</ul>
<p>When performing drawing using <a href="../qtgui/qpainter.html" translate="no">QPainter</a> only, it is also possible to perform the painting like it is done for ordinary widgets: by reimplementing <a href="qopenglwidget.html#paintEvent" translate="no">paintEvent</a>().</p>
<ul>
<li>Reimplement the <a href="qopenglwidget.html#paintEvent" translate="no">paintEvent</a>() function.</li>
<li>Construct a <a href="../qtgui/qpainter.html" translate="no">QPainter</a> object targeting the widget. Either pass the widget to the constructor or the <a href="../qtgui/qpainter.html#begin" translate="no">QPainter::begin</a>() function.</li>
<li>Draw primitives using <a href="../qtgui/qpainter.html" translate="no">QPainter</a>'s member functions.</li>
<li>Painting finishes then the <a href="../qtgui/qpainter.html" translate="no">QPainter</a> instance is destroyed. Alternatively, call <a href="../qtgui/qpainter.html#end" translate="no">QPainter::end</a>() explicitly.</li>
</ul>
<h3 id="opengl-function-calls-headers-and-qopenglfunctions">OpenGL Function Calls, Headers and QOpenGLFunctions</h3>
<p>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using <a href="../qtgui/qopenglfunctions.html" translate="no">QOpenGLFunctions</a> (when making portable applications) or the versioned variants (for example, <a href="qopenglfunctions-3-2-core.html" translate="no">QOpenGLFunctions_3_2_Core</a> and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</p>
<p>In <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() the current context is always accessible by calling <a href="../qtgui/qopenglcontext.html#currentContext" translate="no">QOpenGLContext::currentContext</a>(). From this context an already initialized, ready-to-be-used <a href="../qtgui/qopenglfunctions.html" translate="no">QOpenGLFunctions</a> instance is retrievable by calling <a href="../qtgui/qopenglcontext.html#functions" translate="no">QOpenGLContext::functions</a>(). An alternative to prefixing every GL call is to inherit from <a href="../qtgui/qopenglfunctions.html" translate="no">QOpenGLFunctions</a> and call <a href="../qtgui/qopenglfunctions.html#initializeOpenGLFunctions" translate="no">QOpenGLFunctions::initializeOpenGLFunctions</a>() in <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>().</p>
<p>As for the OpenGL headers, note that in most cases there will be no need to directly include any headers like GL.h. The OpenGL-related Qt headers will include qopengl.h which will in turn include an appropriate header for the system. This might be an OpenGL ES 3.x or 2.0 header, the highest version that is available, or a system-provided gl.h. In addition, a copy of the extension headers (called glext.h on some systems) is provided as part of Qt both for OpenGL and OpenGL ES. These will get included automatically on platforms where feasible. This means that constants and function pointer typedefs from ARB, EXT, OES extensions are automatically available.</p>
<h3 id="code-examples">Code Examples</h3>
<p>To get started, the simplest QOpenGLWidget subclass could look like the following:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyGLWidget : <span class="keyword">public</span> <span class="type"><a href="qopenglwidget.html#QOpenGLWidget" translate="no">QOpenGLWidget</a></span>
 {
 <span class="keyword">public</span>:
     MyGLWidget(<span class="type"><a href="../qtwidgets/qwidget.html#QWidget" translate="no">QWidget</a></span> <span class="operator">*</span>parent) : <span class="type"><a href="qopenglwidget.html#QOpenGLWidget" translate="no">QOpenGLWidget</a></span>(parent) { }

 <span class="keyword">protected</span>:
     <span class="type">void</span> initializeGL() override
     {
         <span class="comment">// Set up the rendering context, load shaders and other resources, etc.:</span>
         <span class="type"><a href="../qtgui/qopenglfunctions.html" translate="no">QOpenGLFunctions</a></span> <span class="operator">*</span>f <span class="operator">=</span> <span class="type"><a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a></span><span class="operator">::</span>currentContext()<span class="operator">-</span><span class="operator">&gt;</span>functions();
         f<span class="operator">-</span><span class="operator">&gt;</span>glClearColor(<span class="number">1.0f</span><span class="operator">,</span> <span class="number">1.0f</span><span class="operator">,</span> <span class="number">1.0f</span><span class="operator">,</span> <span class="number">1.0f</span>);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     }

     <span class="type">void</span> resizeGL(<span class="type">int</span> w<span class="operator">,</span> <span class="type">int</span> h) override
     {
         <span class="comment">// Update projection matrix and other size related settings:</span>
         m_projection<span class="operator">.</span>setToIdentity();
         m_projection<span class="operator">.</span>perspective(<span class="number">45.0f</span><span class="operator">,</span> w <span class="operator">/</span> <span class="type">float</span>(h)<span class="operator">,</span> <span class="number">0.01f</span><span class="operator">,</span> <span class="number">100.0f</span>);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     }

     <span class="type">void</span> paintGL() override
     {
         <span class="comment">// Draw the scene:</span>
         <span class="type"><a href="../qtgui/qopenglfunctions.html" translate="no">QOpenGLFunctions</a></span> <span class="operator">*</span>f <span class="operator">=</span> <span class="type"><a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a></span><span class="operator">::</span>currentContext()<span class="operator">-</span><span class="operator">&gt;</span>functions();
         f<span class="operator">-</span><span class="operator">&gt;</span>glClear(GL_COLOR_BUFFER_BIT);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     }

 };
</pre>
<p>Alternatively, the prefixing of each and every OpenGL call can be avoided by deriving from <a href="../qtgui/qopenglfunctions.html" translate="no">QOpenGLFunctions</a> instead:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyGLWidget : <span class="keyword">public</span> <span class="type"><a href="qopenglwidget.html#QOpenGLWidget" translate="no">QOpenGLWidget</a></span><span class="operator">,</span> <span class="keyword">protected</span> <span class="type"><a href="../qtgui/qopenglfunctions.html" translate="no">QOpenGLFunctions</a></span>
 {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="type">void</span> initializeGL() override
     {
         initializeOpenGLFunctions();
         glClearColor(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     }
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 };
</pre>
<p>To get a context compatible with a given OpenGL version or profile, or to request depth and stencil buffers, call <a href="qopenglwidget.html#setFormat" translate="no">setFormat</a>():</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qopenglwidget.html#QOpenGLWidget" translate="no">QOpenGLWidget</a></span> <span class="operator">*</span>widget <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qopenglwidget.html#QOpenGLWidget" translate="no">QOpenGLWidget</a></span>(parent);
 <span class="type"><a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a></span> format;
 format<span class="operator">.</span>setDepthBufferSize(<span class="number">24</span>);
 format<span class="operator">.</span>setStencilBufferSize(<span class="number">8</span>);
 format<span class="operator">.</span>setVersion(<span class="number">3</span><span class="operator">,</span> <span class="number">2</span>);
 format<span class="operator">.</span>setProfile(<span class="type"><a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a></span><span class="operator">::</span>CoreProfile);
 widget<span class="operator">-</span><span class="operator">&gt;</span>setFormat(format); <span class="comment">// must be called before the widget or its parent window gets shown</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>It is up to the application to ensure depth and stencil buffers are requested from the underlying windowing system interface. Without requesting a non-zero depth buffer size there is no guarantee that a depth buffer will be available, and as a result depth testing related OpenGL operations may fail to function as expected. Commonly used depth and stencil buffer size requests are 24 and 8, respectively.</p>
</div>
<p>With OpenGL 3.0+ contexts, when portability is not important, the versioned <a href="../qtgui/qopenglfunctions.html" translate="no">QOpenGLFunctions</a> variants give easy access to all the modern OpenGL functions available in a given version:</p>
<pre class="cpp" translate="no">
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="type">void</span> paintGL() override
     {
         QOpenGLFunctions_3_2_Core <span class="operator">*</span>f <span class="operator">=</span> <span class="type"><a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a></span><span class="operator">::</span>currentContext()<span class="operator">-</span><span class="operator">&gt;</span>versionFunctions<span class="operator">&lt;</span>QOpenGLFunctions_3_2_Core<span class="operator">&gt;</span>();
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         f<span class="operator">-</span><span class="operator">&gt;</span>glDrawArraysInstanced(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     }
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>As described above, it is simpler and more robust to set the requested format globally so that it applies to all windows and contexts during the lifetime of the application. Below is an example of this:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span><span class="operator">*</span>argv)
 {
     <span class="type"><a href="../qtwidgets/qapplication.html" translate="no">QApplication</a></span> app(argc<span class="operator">,</span> argv);

     <span class="type"><a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a></span> format;
     format<span class="operator">.</span>setDepthBufferSize(<span class="number">24</span>);
     format<span class="operator">.</span>setStencilBufferSize(<span class="number">8</span>);
     format<span class="operator">.</span>setVersion(<span class="number">3</span><span class="operator">,</span> <span class="number">2</span>);
     format<span class="operator">.</span>setProfile(<span class="type"><a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a></span><span class="operator">::</span>CoreProfile);
     <span class="type"><a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a></span><span class="operator">::</span>setDefaultFormat(format);

     MyWidget widget;
     widget<span class="operator">.</span>show();

     <span class="keyword">return</span> app<span class="operator">.</span>exec();
 }
</pre>
<h3 id="multisampling">Multisampling</h3>
<p>To enable multisampling, set the number of requested samples on the <a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a> that is passed to <a href="qopenglwidget.html#setFormat" translate="no">setFormat</a>(). On systems that do not support it the request may get ignored.</p>
<p>Multisampling support requires support for multisampled renderbuffers and framebuffer blits. On OpenGL ES 2.0 implementations it is likely that these will not be present. This means that multisampling will not be available. With modern OpenGL versions and OpenGL ES 3.0 and up this is usually not a problem anymore.</p>
<h3 id="threading">Threading</h3>
<p>Performing offscreen rendering on worker threads, for example to generate textures that are then used in the GUI/main thread in <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>(), are supported by exposing the widget's <a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a> so that additional contexts sharing with it can be created on each thread.</p>
<p>Drawing directly to the QOpenGLWidget's framebuffer outside the GUI/main thread is possible by reimplementing <a href="qopenglwidget.html#paintEvent" translate="no">paintEvent</a>() to do nothing. The context's thread affinity has to be changed via <a href="../qtcore/qobject.html#moveToThread" translate="no">QObject::moveToThread</a>(). After that, <a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>() and <a href="qopenglwidget.html#doneCurrent" translate="no">doneCurrent</a>() are usable on the worker thread. Be careful to move the context back to the GUI/main thread afterwards.</p>
<p>Triggering a buffer swap just for the QOpenGLWidget is not possible since there is no real, onscreen native surface for it. It is up to the widget stack to manage composition and buffer swaps on the gui thread. When a thread is done updating the framebuffer, call <a href="../qtwidgets/qwidget.html#update" translate="no">update</a>() <b>on the GUI/main thread</b> to schedule composition.</p>
<p>Extra care has to be taken to avoid using the framebuffer when the GUI/main thread is performing compositing. The signals <a href="qopenglwidget.html#aboutToCompose" translate="no">aboutToCompose</a>() and <a href="qopenglwidget.html#frameSwapped" translate="no">frameSwapped</a>() will be emitted when the composition is starting and ending. They are emitted on the GUI/main thread. This means that by using a direct connection <a href="qopenglwidget.html#aboutToCompose" translate="no">aboutToCompose</a>() can block the GUI/main thread until the worker thread has finished its rendering. After that, the worker thread must perform no further rendering until the <a href="qopenglwidget.html#frameSwapped" translate="no">frameSwapped</a>() signal is emitted. If this is not acceptable, the worker thread has to implement a double buffering mechanism. This involves drawing using an alternative render target, that is fully controlled by the thread, e.g. an additional framebuffer object, and blitting to the QOpenGLWidget's framebuffer at a suitable time.</p>
<h3 id="context-sharing">Context Sharing</h3>
<p>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for QOpenGLWidget instances that belong to different windows.</p>
<p>This means that all QOpenGLWidgets in the same window can access each other's sharable resources, like textures, and there is no need for an extra &quot;global share&quot; context.</p>
<p>To set up sharing between QOpenGLWidget instances belonging to different windows, set the <a href="../qtcore/qt.html#ApplicationAttribute-enum" translate="no">Qt::AA_ShareOpenGLContexts</a> application attribute before instantiating <a href="../qtwidgets/qapplication.html" translate="no">QApplication</a>. This will trigger sharing between all QOpenGLWidget instances without any further steps.</p>
<p>Creating extra <a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a> instances that share resources like textures with the QOpenGLWidget's context is also possible. Simply pass the pointer returned from <a href="qopenglwidget.html#context" translate="no">context</a>() to <a href="../qtgui/qopenglcontext.html#setShareContext" translate="no">QOpenGLContext::setShareContext</a>() before calling <a href="../qtgui/qopenglcontext.html#create" translate="no">QOpenGLContext::create</a>(). The resulting context can also be used on a different thread, allowing threaded generation of textures and asynchronous texture uploads.</p>
<p>Note that QOpenGLWidget expects a standard conformant implementation of resource sharing when it comes to the underlying graphics drivers. For example, some drivers, in particular for mobile and embedded hardware, have issues with setting up sharing between an existing context and others that are created later. Some other drivers may behave in unexpected ways when trying to utilize shared resources between different threads.</p>
<h3 id="resource-initialization-and-cleanup">Resource Initialization and Cleanup</h3>
<p>The QOpenGLWidget's associated OpenGL context is guaranteed to be current whenever <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>() and <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() are invoked. Do not attempt to create OpenGL resources before <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>() is called. For example, attempting to compile shaders, initialize vertex buffer objects or upload texture data will fail when done in a subclass's constructor. These operations must be deferred to <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>(). Some of Qt's OpenGL helper classes, like <a href="qopenglbuffer.html" translate="no">QOpenGLBuffer</a> or <a href="qopenglvertexarrayobject.html" translate="no">QOpenGLVertexArrayObject</a>, have a matching deferred behavior: they can be instantiated without a context, but all initialization is deferred until a <a href="../qtwidgets/qwidget.html#create" translate="no">create</a>(), or similar, call. This means that they can be used as normal (non-pointer) member variables in a QOpenGLWidget subclass, but the <a href="../qtwidgets/qwidget.html#create" translate="no">create</a>() or similar function can only be called from <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>(). Be aware however that not all classes are designed like this. When in doubt, make the member variable a pointer and create and destroy the instance dynamically in <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>() and the destructor, respectively.</p>
<p>Releasing the resources also needs the context to be current. Therefore destructors that perform such cleanup are expected to call <a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>() before moving on to destroy any OpenGL resources or wrappers. Avoid deferred deletion via <a href="../qtcore/qobject.html#deleteLater" translate="no">deleteLater</a>() or the parenting mechanism of <a href="../qtcore/qobject.html" translate="no">QObject</a>. There is no guarantee the correct context will be current at the time the instance in question is really destroyed.</p>
<p>A typical subclass will therefore often look like the following when it comes to resource initialization and destruction:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyGLWidget : <span class="keyword">public</span> <span class="type"><a href="qopenglwidget.html#QOpenGLWidget" translate="no">QOpenGLWidget</a></span>
 {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

 <span class="keyword">private</span>:
     <span class="type"><a href="qopenglvertexarrayobject.html" translate="no">QOpenGLVertexArrayObject</a></span> m_vao;
     <span class="type"><a href="qopenglbuffer.html" translate="no">QOpenGLBuffer</a></span> m_vbo;
     <span class="type"><a href="qopenglshaderprogram.html" translate="no">QOpenGLShaderProgram</a></span> <span class="operator">*</span>m_program;
     <span class="type"><a href="qopenglshader.html" translate="no">QOpenGLShader</a></span> <span class="operator">*</span>m_shader;
     <span class="type"><a href="qopengltexture.html" translate="no">QOpenGLTexture</a></span> <span class="operator">*</span>m_texture;
 };

 MyGLWidget<span class="operator">::</span>MyGLWidget()
     : m_program(<span class="number">0</span>)<span class="operator">,</span> m_shader(<span class="number">0</span>)<span class="operator">,</span> m_texture(<span class="number">0</span>)
 {
     <span class="comment">// No OpenGL resource initialization is done here.</span>
 }

 MyGLWidget<span class="operator">::</span><span class="operator">~</span>MyGLWidget()
 {
     <span class="comment">// Make sure the context is current and then explicitly</span>
     <span class="comment">// destroy all underlying OpenGL resources.</span>
     makeCurrent();

     <span class="keyword">delete</span> m_texture;
     <span class="keyword">delete</span> m_shader;
     <span class="keyword">delete</span> m_program;

     m_vbo<span class="operator">.</span>destroy();
     m_vao<span class="operator">.</span>destroy();

     doneCurrent();
 }

 <span class="type">void</span> MyGLWidget<span class="operator">::</span>initializeGL()
 {
     m_vao<span class="operator">.</span>create();
     <span class="keyword">if</span> (m_vao<span class="operator">.</span>isCreated())
         m_vao<span class="operator">.</span>bind();

     m_vbo<span class="operator">.</span>create();
     m_vbo<span class="operator">.</span>bind();
     m_vbo<span class="operator">.</span>allocate(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);

     m_texture <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qopengltexture.html" translate="no">QOpenGLTexture</a></span>(<span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span>(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>));

     m_shader <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qopenglshader.html" translate="no">QOpenGLShader</a></span>(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
     m_program <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qopenglshaderprogram.html" translate="no">QOpenGLShaderProgram</a></span>(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);

     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 }
</pre>
<p>This works for most cases, but not fully ideal as a generic solution. When the widget is reparented so that it ends up in an entirely different top-level window, something more is needed: by connecting to the <a href="../qtgui/qopenglcontext.html#aboutToBeDestroyed" translate="no">aboutToBeDestroyed</a>() signal of <a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a>, cleanup can be performed whenever the OpenGL context is about to be released.</p>
<div class="admonition note">
<p><b>Note: </b>For widgets that change their associated top-level window multiple times during their lifetime, a combined cleanup approach, as demonstrated in the code snippet below, is essential. Whenever the widget or a parent of it gets reparented so that the top-level window becomes different, the widget's associated context is destroyed and a new one is created. This is then followed by a call to <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>() where all OpenGL resources must get reinitialized. Due to this the only option to perform proper cleanup is to connect to the context's aboutToBeDestroyed() signal. Note that the context in question may not be the current one when the signal gets emitted. Therefore it is good practice to call <a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>() in the connected slot. Additionally, the same cleanup steps must be performed from the derived class' destructor, since the slot or lambda connected to the signal may not invoked when the widget is being destroyed.</p>
</div>
<pre class="cpp" translate="no">
 MyGLWidget<span class="operator">::</span><span class="operator">~</span>MyGLWidget()
 {
     cleanup();
 }

 <span class="type">void</span> MyGLWidget<span class="operator">::</span>initializeGL()
 {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     connect(context()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a></span><span class="operator">::</span>aboutToBeDestroyed<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyGLWidget<span class="operator">::</span>cleanup);
 }

 <span class="type">void</span> MyGLWidget<span class="operator">::</span>cleanup()
 {
     makeCurrent();
     <span class="keyword">delete</span> m_texture;
     m_texture <span class="operator">=</span> <span class="number">0</span>;
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     doneCurrent();
     disconnect(context()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a></span><span class="operator">::</span>aboutToBeDestroyed<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyGLWidget<span class="operator">::</span>cleanup);
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>When <a href="../qtcore/qt.html#ApplicationAttribute-enum" translate="no">Qt::AA_ShareOpenGLContexts</a> is set, the widget's context never changes, not even when reparenting because the widget's associated texture is going to be accessible also from the new top-level's context. Therefore, acting on the aboutToBeDestroyed() signal of the context is not mandatory with this flag set.</p>
</div>
<p>Proper cleanup is especially important due to context sharing. Even though each QOpenGLWidget's associated context is destroyed together with the QOpenGLWidget, the sharable resources in that context, like textures, will stay valid until the top-level window, in which the QOpenGLWidget lived, is destroyed. Additionally, settings like <a href="../qtcore/qt.html#ApplicationAttribute-enum" translate="no">Qt::AA_ShareOpenGLContexts</a> and some Qt modules may trigger an even wider scope for sharing contexts, potentially leading to keeping the resources in question alive for the entire lifetime of the application. Therefore the safest and most robust is always to perform explicit cleanup for all resources and resource wrappers used in the QOpenGLWidget.</p>
<h3 id="limitations-and-other-considerations">Limitations and Other Considerations</h3>
<p>Putting other widgets underneath and making the QOpenGLWidget transparent will not lead to the expected results: The widgets underneath will not be visible. This is because in practice the QOpenGLWidget is drawn before all other regular, non-OpenGL widgets, and so see-through type of solutions are not feasible. Other type of layouts, like having widgets on top of the QOpenGLWidget, will function as expected.</p>
<p>When absolutely necessary, this limitation can be overcome by setting the <a href="../qtcore/qt.html#WidgetAttribute-enum" translate="no">Qt::WA_AlwaysStackOnTop</a> attribute on the QOpenGLWidget. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the QOpenGLWidget, so it should only be used in situations where a semi-transparent QOpenGLWidget with other widgets visible underneath is required.</p>
<p>Note that this does not apply when there are no other widgets underneath and the intention is to have a semi-transparent window. In that case the traditional approach of setting <a href="../qtcore/qt.html#WidgetAttribute-enum" translate="no">Qt::WA_TranslucentBackground</a> on the top-level window is sufficient. Note that if the transparent areas are only desired in the QOpenGLWidget, then <a href="../qtcore/qt.html#WidgetAttribute-enum" translate="no">Qt::WA_NoSystemBackground</a> will need to be turned back to <code translate="no">false</code> after enabling <a href="../qtcore/qt.html#WidgetAttribute-enum" translate="no">Qt::WA_TranslucentBackground</a>. Additionally, requesting an alpha channel for the QOpenGLWidget's context via <a href="qopenglwidget.html#setFormat" translate="no">setFormat</a>() may be necessary too, depending on the system.</p>
<p>QOpenGLWidget supports multiple update behaviors, just like <a href="qopenglwindow.html" translate="no">QOpenGLWindow</a>. In preserved mode the rendered content from the previous <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() call is available in the next one, allowing incremental rendering. In non-preserved mode the content is lost and <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() implementations are expected to redraw everything in the view.</p>
<p>Before Qt 5.5 the default behavior of QOpenGLWidget was to preserve the rendered contents between <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() calls. Since Qt 5.5 the default behavior is non-preserved because this provides better performance and the majority of applications have no need for the previous content. This also resembles the semantics of an OpenGL-based <a href="../qtgui/qwindow.html" translate="no">QWindow</a> and matches the default behavior of <a href="qopenglwindow.html" translate="no">QOpenGLWindow</a> in that the color and ancillary buffers are invalidated for each frame. To restore the preserved behavior, call <a href="qopenglwidget.html#setUpdateBehavior" translate="no">setUpdateBehavior</a>() with <code translate="no">PartialUpdate</code>.</p>
<div class="admonition note">
<p><b>Note: </b>When dynamically adding a QOpenGLWidget into a widget hierarchy, e.g. by parenting a new QOpenGLWidget to a widget where the corresponding top-level widget is already shown on screen, the associated native window may get implicitly destroyed and recreated if the QOpenGLWidget is the first of its kind within its window. This is because the window type changes from <a href="../qtgui/qsurface.html#SurfaceType-enum" translate="no">RasterSurface</a> to <a href="../qtgui/qsurface.html#SurfaceType-enum" translate="no">OpenGLSurface</a> and that has platform-specific implications. This behavior is new in Qt 6.4.</p>
</div>
<p>Once a QOpenGLWidget is added to a widget hierarchy, the contents of the top-level window is flushed via OpenGL-based rendering. Widgets other than the QOpenGLWidget continue to draw their content using a software-based painter, but the final composition is done through the 3D API.</p>
<div class="admonition note">
<p><b>Note: </b>Displaying a QOpenGLWidget requires an alpha channel in the associated top-level window's backing store due to the way composition with other <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>-based content works. If there is no alpha channel, the content rendered by the QOpenGLWidget will not be visible. This can become particularly relevant on Linux/X11 in remote display setups (such as, with Xvnc), when using a color depth lower than 24. For example, a color depth of 16 will typically map to using a backing store image with the format <a href="../qtgui/qimage.html#Format-enum" translate="no">QImage::Format_RGB16</a> (RGB565), leaving no room for an alpha channel. Therefore, if experiencing problems with getting the contents of a QOpenGLWidget composited correctly with other the widgets in the window, make sure the server (such as, vncserver) is configured with a 24 or 32 bit depth instead of 16.</p>
</div>
<h3 id="alternatives">Alternatives</h3>
<p>Adding a QOpenGLWidget into a window turns on OpenGL-based compositing for the entire window. In some special cases this may not be ideal, and the old QGLWidget-style behavior with a separate, native child window is desired. Desktop applications that understand the limitations of this approach (for example when it comes to overlaps, transparency, scroll views and MDI areas), can use <a href="qopenglwindow.html" translate="no">QOpenGLWindow</a> with <a href="../qtwidgets/qwidget.html#createWindowContainer" translate="no">QWidget::createWindowContainer</a>(). This is a modern alternative to QGLWidget and is faster than QOpenGLWidget due to the lack of the additional composition step. It is strongly recommended to limit the usage of this approach to cases where there is no other choice. Note that this option is not suitable for most embedded and mobile platforms, and it is known to have issues on certain desktop platforms (e.g. macOS) too. The stable, cross-platform solution is always QOpenGLWidget.</p>
<h3 id="stereoscopic-rendering">Stereoscopic rendering</h3>
<p>Starting from 6.5 QOpenGLWidget has support for stereoscopic rendering. To enable it, set the <a href="../qtgui/qsurfaceformat.html#FormatOption-enum" translate="no">QSurfaceFormat::StereoBuffers</a> flag globally before the window is created, using QSurfaceFormat::SetDefaultFormat().</p>
<div class="admonition note">
<p><b>Note: </b>Using <a href="qopenglwidget.html#setFormat" translate="no">setFormat</a>() will not necessarily work because of how the flag is handled internally.</p>
</div>
<p>This will trigger <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() to be called twice each frame, once for each <a href="qopenglwidget.html#TargetBuffer-enum" translate="no">QOpenGLWidget::TargetBuffer</a>. In <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>(), call <a href="qopenglwidget.html#currentTargetBuffer" translate="no">currentTargetBuffer</a>() to query which one is currently being drawn to.</p>
<div class="admonition note">
<p><b>Note: </b>For more control over the left and right color buffers, consider using <a href="qopenglwindow.html" translate="no">QOpenGLWindow</a> + <a href="../qtwidgets/qwidget.html#createWindowContainer" translate="no">QWidget::createWindowContainer</a>() instead.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This type of 3D rendering has certain hardware requirements, like the graphics card needs to be setup with stereo support.</p>
</div>
<p><i>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</i></p>
</div>
<p><b>See also </b><a href="../qtgui/qopenglfunctions.html" translate="no">QOpenGLFunctions</a>, <a href="qopenglwindow.html" translate="no">QOpenGLWindow</a>, <a href="../qtcore/qt.html#ApplicationAttribute-enum" translate="no">Qt::AA_ShareOpenGLContexts</a>, and <a href="qopenglwidget.html#UpdateBehavior-enum" translate="no">UpdateBehavior</a>.</p>
<!-- @@@QOpenGLWidget -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$TargetBuffer$$$LeftBuffer$$$RightBuffer -->
<h3 class="fn" translate="no" id="TargetBuffer-enum"><code class="details extra" translate="no">[since 6.5]</code> enum QOpenGLWidget::<span class="name">TargetBuffer</span></h3>
<p>Specifies the buffer to use when stereoscopic rendering is enabled, which is toggled by setting <a href="../qtgui/qsurfaceformat.html#FormatOption-enum" translate="no">QSurfaceFormat::StereoBuffers</a>.</p>
<div class="admonition note">
<p><b>Note: </b>LeftBuffer is always the default and used as fallback value when stereoscopic rendering is disabled or not supported by the graphics driver.</p>
</div>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLWidget::LeftBuffer</code></td><td class="topAlign tblval"><code translate="no">0</code></td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLWidget::RightBuffer</code></td><td class="topAlign tblval"><code translate="no">1</code></td></tr>
</table></div>
<p>This enum was introduced in Qt 6.5.</p>
<!-- @@@TargetBuffer -->
<!-- $$$UpdateBehavior$$$NoPartialUpdate$$$PartialUpdate -->
<h3 class="fn" translate="no" id="UpdateBehavior-enum">enum QOpenGLWidget::<span class="name">UpdateBehavior</span></h3>
<p>This enum describes the update semantics of <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLWidget::NoPartialUpdate</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign"><a href="qopenglwidget.html" translate="no">QOpenGLWidget</a> will discard the contents of the color buffer and the ancillary buffers after the <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a> is rendered to screen. This is the same behavior that can be expected by calling <a href="../qtgui/qopenglcontext.html#swapBuffers" translate="no">QOpenGLContext::swapBuffers</a> with a default opengl enabled <a href="../qtgui/qwindow.html" translate="no">QWindow</a> as the argument. NoPartialUpdate can have some performance benefits on certain hardware architectures common in the mobile and embedded space when a framebuffer object is used as the rendering target. The framebuffer object is invalidated between frames with glInvalidateFramebuffer (if supported), or, as fallbacks, glDiscardFramebufferEXT (if supported) or a call to glClear.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLWidget::PartialUpdate</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The framebuffer objects color buffer and ancillary buffers are not invalidated between frames.</td></tr>
</table></div>
<p><b>See also </b><a href="qopenglwidget.html#updateBehavior" translate="no">updateBehavior</a>() and <a href="qopenglwidget.html#setUpdateBehavior" translate="no">setUpdateBehavior</a>().</p>
<!-- @@@UpdateBehavior -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QOpenGLWidget[overload1]$$$QOpenGLWidgetQWidget*Qt::WindowFlags -->
<h3 class="fn" translate="no" id="QOpenGLWidget"><code class="details extra" translate="no">[explicit]</code> QOpenGLWidget::<span class="name">QOpenGLWidget</span>(<span class="type"><a href="../qtwidgets/qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>parent</i> = nullptr, <span class="type"><a href="../qtcore/qt.html#WindowType-enum" translate="no">Qt::WindowFlags</a></span> <i>f</i> = Qt::WindowFlags())</h3>
<p>Constructs a widget which is a child of <i translate="no">parent</i>, with widget flags set to <i translate="no">f</i>.</p>
<!-- @@@QOpenGLWidget -->
<!-- $$$~QOpenGLWidget[overload1]$$$~QOpenGLWidget -->
<h3 class="fn" translate="no" id="dtor.QOpenGLWidget"><code class="details extra" translate="no">[virtual noexcept]</code> QOpenGLWidget::<span class="name">~QOpenGLWidget</span>()</h3>
<p>Destroys the <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a> instance, freeing its resources.</p>
<p>The <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a>'s context is made current in the destructor, allowing for safe destruction of any child object that may need to release OpenGL resources belonging to the context provided by this widget.</p>
<div class="admonition warning">
<p><b>Warning: </b>if you have objects wrapping OpenGL resources (such as <a href="qopenglbuffer.html" translate="no">QOpenGLBuffer</a>, <a href="qopenglshaderprogram.html" translate="no">QOpenGLShaderProgram</a>, etc.) as members of a OpenGLWidget subclass, you may need to add a call to <a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>() in that subclass' destructor as well. Due to the rules of C++ object destruction, those objects will be destroyed <i>before</i> calling this function (but after that the destructor of the subclass has run), therefore making the OpenGL context current in this function happens too late for their safe disposal.</p>
</div>
<p><b>See also </b><a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>.</p>
<!-- @@@~QOpenGLWidget -->
<!-- $$$aboutToCompose[overload1]$$$aboutToCompose -->
<h3 class="fn" translate="no" id="aboutToCompose"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">aboutToCompose</span>()</h3>
<p>This signal is emitted when the widget's top-level window is about to begin composing the textures of its <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a> children and the other widgets.</p>
<!-- @@@aboutToCompose -->
<!-- $$$aboutToResize[overload1]$$$aboutToResize -->
<h3 class="fn" translate="no" id="aboutToResize"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">aboutToResize</span>()</h3>
<p>This signal is emitted when the widget's size is changed and therefore the framebuffer object is going to be recreated.</p>
<!-- @@@aboutToResize -->
<!-- $$$context[overload1]$$$context -->
<h3 class="fn" translate="no" id="context"><span class="type"><a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a></span> *QOpenGLWidget::<span class="name">context</span>() const</h3>
<p>Returns The <a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a> used by this widget or <code translate="no">0</code> if not yet initialized.</p>
<div class="admonition note">
<p><b>Note: </b>The context and the framebuffer object used by the widget changes when reparenting the widget via <a href="../qtwidgets/qwidget.html#setParent" translate="no">setParent</a>().</p>
</div>
<p><b>See also </b><a href="../qtgui/qopenglcontext.html#setShareContext" translate="no">QOpenGLContext::setShareContext</a>() and <a href="qopenglwidget.html#defaultFramebufferObject" translate="no">defaultFramebufferObject</a>().</p>
<!-- @@@context -->
<!-- $$$currentTargetBuffer[overload1]$$$currentTargetBuffer -->
<h3 class="fn" translate="no" id="currentTargetBuffer"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qopenglwidget.html#TargetBuffer-enum" translate="no">QOpenGLWidget::TargetBuffer</a></span> QOpenGLWidget::<span class="name">currentTargetBuffer</span>() const</h3>
<p>Returns the currently active target buffer. This will be the left buffer by default, the right buffer is only used when <a href="../qtgui/qsurfaceformat.html#FormatOption-enum" translate="no">QSurfaceFormat::StereoBuffers</a> is enabled. When stereoscopic rendering is enabled, this can be queried in <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() to know what buffer is currently in use. <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() will be called twice, once for each target.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>().</p>
<!-- @@@currentTargetBuffer -->
<!-- $$$defaultFramebufferObject[overload1]$$$defaultFramebufferObject -->
<h3 class="fn" translate="no" id="defaultFramebufferObject"><span class="type">GLuint</span> QOpenGLWidget::<span class="name">defaultFramebufferObject</span>() const</h3>
<p>Returns The framebuffer object handle or <code translate="no">0</code> if not yet initialized.</p>
<div class="admonition note">
<p><b>Note: </b>The framebuffer object belongs to the context returned by <a href="qopenglwidget.html#context" translate="no">context</a>() and may not be accessible from other contexts.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The context and the framebuffer object used by the widget changes when reparenting the widget via <a href="../qtwidgets/qwidget.html#setParent" translate="no">setParent</a>(). In addition, the framebuffer object changes on each resize.</p>
</div>
<p><b>See also </b><a href="qopenglwidget.html#context" translate="no">context</a>().</p>
<!-- @@@defaultFramebufferObject -->
<!-- $$$defaultFramebufferObject$$$defaultFramebufferObjectQOpenGLWidget::TargetBuffer -->
<h3 class="fn" translate="no" id="defaultFramebufferObject-1"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">GLuint</span> QOpenGLWidget::<span class="name">defaultFramebufferObject</span>(<span class="type"><a href="qopenglwidget.html#TargetBuffer-enum" translate="no">QOpenGLWidget::TargetBuffer</a></span> <i>targetBuffer</i>) const</h3>
<p>Returns The framebuffer object handle of the specified target buffer or <code translate="no">0</code> if not yet initialized.</p>
<p>Calling this overload only makes sense if <a href="../qtgui/qsurfaceformat.html#FormatOption-enum" translate="no">QSurfaceFormat::StereoBuffers</a> is enabled and supported by the hardware. If not, this method will return the default buffer.</p>
<div class="admonition note">
<p><b>Note: </b>The framebuffer object belongs to the context returned by <a href="qopenglwidget.html#context" translate="no">context</a>() and may not be accessible from other contexts. The context and the framebuffer object used by the widget changes when reparenting the widget via <a href="../qtwidgets/qwidget.html#setParent" translate="no">setParent</a>(). In addition, the framebuffer object changes on each resize.</p>
</div>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qopenglwidget.html#context" translate="no">context</a>().</p>
<!-- @@@defaultFramebufferObject -->
<!-- $$$doneCurrent[overload1]$$$doneCurrent -->
<h3 class="fn" translate="no" id="doneCurrent"><span class="type">void</span> QOpenGLWidget::<span class="name">doneCurrent</span>()</h3>
<p>Releases the context.</p>
<p>It is not necessary to call this function in most cases, since the widget will make sure the context is bound and released properly when invoking <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>().</p>
<!-- @@@doneCurrent -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" translate="no" id="event"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">bool</span> QOpenGLWidget::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#event" translate="no">QWidget::event</a>(QEvent *event).</p>
<!-- @@@event -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" translate="no" id="format"><span class="type"><a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a></span> QOpenGLWidget::<span class="name">format</span>() const</h3>
<p>Returns the context and surface format used by this widget and its toplevel window.</p>
<p>After the widget and its toplevel have both been created, resized and shown, this function will return the actual format of the context. This may differ from the requested format if the request could not be fulfilled by the platform. It is also possible to get larger color buffer sizes than requested.</p>
<p>When the widget's window and the related OpenGL resources are not yet initialized, the return value is the format that has been set via <a href="qopenglwidget.html#setFormat" translate="no">setFormat</a>().</p>
<p><b>See also </b><a href="qopenglwidget.html#setFormat" translate="no">setFormat</a>() and <a href="qopenglwidget.html#context" translate="no">context</a>().</p>
<!-- @@@format -->
<!-- $$$frameSwapped[overload1]$$$frameSwapped -->
<h3 class="fn" translate="no" id="frameSwapped"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">frameSwapped</span>()</h3>
<p>This signal is emitted after the widget's top-level window has finished composition and returned from its potentially blocking <a href="../qtgui/qopenglcontext.html#swapBuffers" translate="no">QOpenGLContext::swapBuffers</a>() call.</p>
<!-- @@@frameSwapped -->
<!-- $$$grabFramebuffer[overload1]$$$grabFramebuffer -->
<h3 class="fn" translate="no" id="grabFramebuffer"><span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span> QOpenGLWidget::<span class="name">grabFramebuffer</span>()</h3>
<p>Renders and returns a 32-bit RGB image of the framebuffer.</p>
<div class="admonition note">
<p><b>Note: </b>This is a potentially expensive operation because it relies on glReadPixels() to read back the pixels. This may be slow and can stall the GPU pipeline.</p>
</div>
<!-- @@@grabFramebuffer -->
<!-- $$$grabFramebuffer$$$grabFramebufferQOpenGLWidget::TargetBuffer -->
<h3 class="fn" translate="no" id="grabFramebuffer-1"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span> QOpenGLWidget::<span class="name">grabFramebuffer</span>(<span class="type"><a href="qopenglwidget.html#TargetBuffer-enum" translate="no">QOpenGLWidget::TargetBuffer</a></span> <i>targetBuffer</i>)</h3>
<p>Renders and returns a 32-bit RGB image of the framebuffer of the specified target buffer. This overload only makes sense to call when <a href="../qtgui/qsurfaceformat.html#FormatOption-enum" translate="no">QSurfaceFormat::StereoBuffers</a> is enabled. Grabbing the framebuffer of the right target buffer will return the default image if stereoscopic rendering is disabled or if not supported by the hardware.</p>
<div class="admonition note">
<p><b>Note: </b>This is a potentially expensive operation because it relies on glReadPixels() to read back the pixels. This may be slow and can stall the GPU pipeline.</p>
</div>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@grabFramebuffer -->
<!-- $$$initializeGL[overload1]$$$initializeGL -->
<h3 class="fn" translate="no" id="initializeGL"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">initializeGL</span>()</h3>
<p>This virtual function is called once before the first call to <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() or <a href="qopenglwidget.html#resizeGL" translate="no">resizeGL</a>(). Reimplement it in a subclass.</p>
<p>This function should set up any required OpenGL resources.</p>
<p>There is no need to call <a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>() because this has already been done when this function is called. Note however that the framebuffer is not yet available at this stage, so avoid issuing draw calls from here. Defer such calls to <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() instead.</p>
<p><b>See also </b><a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() and <a href="qopenglwidget.html#resizeGL" translate="no">resizeGL</a>().</p>
<!-- @@@initializeGL -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QOpenGLWidget::<span class="name">isValid</span>() const</h3>
<p>Returns <i>true</i> if the widget and OpenGL resources, like the context, have been successfully initialized. Note that the return value is always false until the widget is shown.</p>
<!-- @@@isValid -->
<!-- $$$makeCurrent[overload1]$$$makeCurrent -->
<h3 class="fn" translate="no" id="makeCurrent"><span class="type">void</span> QOpenGLWidget::<span class="name">makeCurrent</span>()</h3>
<p>Prepares for rendering OpenGL content for this widget by making the corresponding context current and binding the framebuffer object in that context.</p>
<p>It is not necessary to call this function in most cases, because it is called automatically before invoking <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>().</p>
<p><b>See also </b><a href="qopenglwidget.html#context" translate="no">context</a>(), <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>(), and <a href="qopenglwidget.html#doneCurrent" translate="no">doneCurrent</a>().</p>
<!-- @@@makeCurrent -->
<!-- $$$makeCurrent$$$makeCurrentQOpenGLWidget::TargetBuffer -->
<h3 class="fn" translate="no" id="makeCurrent-1"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">makeCurrent</span>(<span class="type"><a href="qopenglwidget.html#TargetBuffer-enum" translate="no">QOpenGLWidget::TargetBuffer</a></span> <i>targetBuffer</i>)</h3>
<p>Prepares for rendering OpenGL content for this widget by making the context for the passed in buffer current and binding the framebuffer object in that context.</p>
<div class="admonition note">
<p><b>Note: </b>This only makes sense to call when stereoscopic rendering is enabled. Nothing will happen if the right buffer is requested when it's disabled.</p>
</div>
<p>It is not necessary to call this function in most cases, because it is called automatically before invoking <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>().</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qopenglwidget.html#context" translate="no">context</a>(), <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>(), and <a href="qopenglwidget.html#doneCurrent" translate="no">doneCurrent</a>().</p>
<!-- @@@makeCurrent -->
<!-- $$$metric[overload1]$$$metricQPaintDevice::PaintDeviceMetric -->
<h3 class="fn" translate="no" id="metric"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">int</span> QOpenGLWidget::<span class="name">metric</span>(<span class="type"><a href="../qtgui/qpaintdevice.html#PaintDeviceMetric-enum" translate="no">QPaintDevice::PaintDeviceMetric</a></span> <i>metric</i>) const</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#metric" translate="no">QWidget::metric(QPaintDevice::PaintDeviceMetric m) const</a>.</p>
<!-- @@@metric -->
<!-- $$$paintEngine[overload1]$$$paintEngine -->
<h3 class="fn" translate="no" id="paintEngine"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type"><a href="../qtgui/qpaintengine.html" translate="no">QPaintEngine</a></span> *QOpenGLWidget::<span class="name">paintEngine</span>() const</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#paintEngine" translate="no">QWidget::paintEngine() const</a>.</p>
<!-- @@@paintEngine -->
<!-- $$$paintEvent[overload1]$$$paintEventQPaintEvent* -->
<h3 class="fn" translate="no" id="paintEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">paintEvent</span>(<span class="type"><a href="../qtgui/qpaintevent.html" translate="no">QPaintEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#paintEvent" translate="no">QWidget::paintEvent</a>(QPaintEvent *event).</p>
<p>Handles paint events.</p>
<p>Calling <a href="../qtwidgets/qwidget.html#update" translate="no">QWidget::update</a>() will lead to sending a paint event <i translate="no">e</i>, and thus invoking this function. (NB this is asynchronous and will happen at some point after returning from <a href="../qtwidgets/qwidget.html#update" translate="no">update</a>()). This function will then, after some preparation, call the virtual <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>() to update the contents of the <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a>'s framebuffer. The widget's top-level window will then composite the framebuffer's texture with the rest of the window.</p>
<!-- @@@paintEvent -->
<!-- $$$paintGL[overload1]$$$paintGL -->
<h3 class="fn" translate="no" id="paintGL"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">paintGL</span>()</h3>
<p>This virtual function is called whenever the widget needs to be painted. Reimplement it in a subclass.</p>
<p>There is no need to call <a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>() because this has already been done when this function is called.</p>
<p>Before invoking this function, the context and the framebuffer are bound, and the viewport is set up by a call to glViewport(). No other state is set and no clearing or drawing is performed by the framework.</p>
<p>The default implementation performs a glClear(). Subclasses are not expected to invoke the base class implementation and should perform clearing on their own.</p>
<div class="admonition note">
<p><b>Note: </b>To ensure portability, do not expect that state set in <a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>() persists. Rather, set all necessary state, for example, by calling glEnable(), in paintGL(). This is because some platforms, such as WebAssembly with WebGL, may have limitations on OpenGL contexts in some situations, which can lead to using the context used with the <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a> for other purposes as well.</p>
</div>
<p>When <a href="../qtgui/qsurfaceformat.html#FormatOption-enum" translate="no">QSurfaceFormat::StereoBuffers</a> is enabled, this function will be called twice - once for each buffer. Query what buffer is currently bound by calling <a href="qopenglwidget.html#currentTargetBuffer" translate="no">currentTargetBuffer</a>().</p>
<div class="admonition note">
<p><b>Note: </b>The framebuffer of each target will be drawn to even when stereoscopic rendering is not supported by the hardware. Only the left buffer will actually be visible in the window.</p>
</div>
<p><b>See also </b><a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>(), <a href="qopenglwidget.html#resizeGL" translate="no">resizeGL</a>(), and <a href="qopenglwidget.html#currentTargetBuffer" translate="no">currentTargetBuffer</a>().</p>
<!-- @@@paintGL -->
<!-- $$$redirected[overload1]$$$redirectedQPoint* -->
<h3 class="fn" translate="no" id="redirected"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type"><a href="../qtgui/qpaintdevice.html#QPaintDevice" translate="no">QPaintDevice</a></span> *QOpenGLWidget::<span class="name">redirected</span>(<span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> *<i>p</i>) const</h3>
<!-- @@@redirected -->
<!-- $$$resizeEvent[overload1]$$$resizeEventQResizeEvent* -->
<h3 class="fn" translate="no" id="resizeEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">resizeEvent</span>(<span class="type"><a href="../qtgui/qresizeevent.html" translate="no">QResizeEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#resizeEvent" translate="no">QWidget::resizeEvent</a>(QResizeEvent *event).</p>
<p>Handles resize events that are passed in the <i translate="no">e</i> event parameter. Calls the virtual function <a href="qopenglwidget.html#resizeGL" translate="no">resizeGL</a>().</p>
<div class="admonition note">
<p><b>Note: </b>Avoid overriding this function in derived classes. If that is not feasible, make sure that <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a>'s implementation is invoked too. Otherwise the underlying framebuffer object and related resources will not get resized properly and will lead to incorrect rendering.</p>
</div>
<!-- @@@resizeEvent -->
<!-- $$$resizeGL[overload1]$$$resizeGLintint -->
<h3 class="fn" translate="no" id="resizeGL"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">resizeGL</span>(<span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>)</h3>
<p>This virtual function is called whenever the widget has been resized. Reimplement it in a subclass. The new size is passed in <i translate="no">w</i> and <i translate="no">h</i>.</p>
<p>There is no need to call <a href="qopenglwidget.html#makeCurrent" translate="no">makeCurrent</a>() because this has already been done when this function is called. Additionally, the framebuffer is also bound.</p>
<p><b>See also </b><a href="qopenglwidget.html#initializeGL" translate="no">initializeGL</a>() and <a href="qopenglwidget.html#paintGL" translate="no">paintGL</a>().</p>
<!-- @@@resizeGL -->
<!-- $$$resized[overload1]$$$resized -->
<h3 class="fn" translate="no" id="resized"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QOpenGLWidget::<span class="name">resized</span>()</h3>
<p>This signal is emitted right after the framebuffer object has been recreated due to resizing the widget.</p>
<!-- @@@resized -->
<!-- $$$setFormat[overload1]$$$setFormatconstQSurfaceFormat& -->
<h3 class="fn" translate="no" id="setFormat"><span class="type">void</span> QOpenGLWidget::<span class="name">setFormat</span>(const <span class="type"><a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a></span> &amp;<i>format</i>)</h3>
<p>Sets the requested surface <i translate="no">format</i>.</p>
<p>When the format is not explicitly set via this function, the format returned by <a href="../qtgui/qsurfaceformat.html#defaultFormat" translate="no">QSurfaceFormat::defaultFormat</a>() will be used. This means that when having multiple OpenGL widgets, individual calls to this function can be replaced by one single call to <a href="../qtgui/qsurfaceformat.html#setDefaultFormat" translate="no">QSurfaceFormat::setDefaultFormat</a>() before creating the first widget.</p>
<div class="admonition note">
<p><b>Note: </b>Requesting an alpha buffer via this function will not lead to the desired results when the intention is to make other widgets beneath visible. Instead, use <a href="../qtcore/qt.html#WidgetAttribute-enum" translate="no">Qt::WA_AlwaysStackOnTop</a> to enable semi-transparent <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a> instances with other widgets visible underneath. Keep in mind however that this breaks the stacking order, so it will no longer be possible to have other widgets on top of the <a href="qopenglwidget.html" translate="no">QOpenGLWidget</a>.</p>
</div>
<p><b>See also </b><a href="qopenglwidget.html#format" translate="no">format</a>(), <a href="../qtcore/qt.html#WidgetAttribute-enum" translate="no">Qt::WA_AlwaysStackOnTop</a>, and <a href="../qtgui/qsurfaceformat.html#setDefaultFormat" translate="no">QSurfaceFormat::setDefaultFormat</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setTextureFormat[overload1]$$$setTextureFormatGLenum -->
<h3 class="fn" translate="no" id="setTextureFormat"><span class="type">void</span> QOpenGLWidget::<span class="name">setTextureFormat</span>(<span class="type">GLenum</span> <i>texFormat</i>)</h3>
<p>Sets a custom internal texture format of <i translate="no">texFormat</i>.</p>
<p>When working with sRGB framebuffers, it will be necessary to specify a format like <code translate="no">GL_SRGB8_ALPHA8</code>. This can be achieved by calling this function.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect if called after the widget has already been shown and thus it performed initialization.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function will typically have to be used in combination with a <a href="../qtgui/qsurfaceformat.html#setDefaultFormat" translate="no">QSurfaceFormat::setDefaultFormat</a>() call that sets the color space to <a href="../qtgui/qsurfaceformat.html#ColorSpace-enum" translate="no">QSurfaceFormat::sRGBColorSpace</a>.</p>
</div>
<p><b>See also </b><a href="qopenglwidget.html#textureFormat" translate="no">textureFormat</a>().</p>
<!-- @@@setTextureFormat -->
<!-- $$$setUpdateBehavior[overload1]$$$setUpdateBehaviorQOpenGLWidget::UpdateBehavior -->
<h3 class="fn" translate="no" id="setUpdateBehavior"><span class="type">void</span> QOpenGLWidget::<span class="name">setUpdateBehavior</span>(<span class="type"><a href="qopenglwidget.html#UpdateBehavior-enum" translate="no">QOpenGLWidget::UpdateBehavior</a></span> <i>updateBehavior</i>)</h3>
<p>Sets this widget's update behavior to <i translate="no">updateBehavior</i>.</p>
<p><b>See also </b><a href="qopenglwidget.html#updateBehavior" translate="no">updateBehavior</a>().</p>
<!-- @@@setUpdateBehavior -->
<!-- $$$textureFormat[overload1]$$$textureFormat -->
<h3 class="fn" translate="no" id="textureFormat"><span class="type">GLenum</span> QOpenGLWidget::<span class="name">textureFormat</span>() const</h3>
<p>Returns the active internal texture format if the widget has already initialized, the requested format if one was set but the widget has not yet been made visible, or <code translate="no">nullptr</code> if <a href="qopenglwidget.html#setTextureFormat" translate="no">setTextureFormat</a>() was not called and the widget has not yet been made visible.</p>
<p><b>See also </b><a href="qopenglwidget.html#setTextureFormat" translate="no">setTextureFormat</a>().</p>
<!-- @@@textureFormat -->
<!-- $$$updateBehavior[overload1]$$$updateBehavior -->
<h3 class="fn" translate="no" id="updateBehavior"><span class="type"><a href="qopenglwidget.html#UpdateBehavior-enum" translate="no">QOpenGLWidget::UpdateBehavior</a></span> QOpenGLWidget::<span class="name">updateBehavior</span>() const</h3>
<p>Returns the update behavior of the widget.</p>
<p><b>See also </b><a href="qopenglwidget.html#setUpdateBehavior" translate="no">setUpdateBehavior</a>().</p>
<!-- @@@updateBehavior -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
