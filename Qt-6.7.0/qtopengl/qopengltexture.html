<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qopengltexture.cpp -->
  <meta name="description" content="The QOpenGLTexture class encapsulates an OpenGL texture object.">
  <title>QOpenGLTexture Class | Qt OpenGL</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtopengl-index.html" translate="no">Qt OpenGL</a></li>
<li><a href="qtopengl-module.html" translate="no">C++ Classes</a></li>
<li>QtGui</li>
<li>QOpenGLTexture</li>
<li id="buildversion"><a href="qtopengl-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QOpenGLTexture Class</h1>
<!-- $$$QOpenGLTexture-brief -->
<p>The QOpenGLTexture class encapsulates an OpenGL texture object. <a href="#details">More...</a></p>
<!-- @@@QOpenGLTexture -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QOpenGLTexture&gt;</span></td></tr>
</table></div>
<ul>
<li><a href="qopengltexture-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#BindingTarget-enum" translate="no">BindingTarget</a></b> { BindingTarget1D, BindingTarget1DArray, BindingTarget2D, BindingTarget2DArray, BindingTarget3D, &hellip;, BindingTargetBuffer }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#ComparisonFunction-enum" translate="no">ComparisonFunction</a></b> { CompareLessEqual, CompareGreaterEqual, CompareLess, CompareGreater, CompareEqual, &hellip;, CompareNever }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#ComparisonMode-enum" translate="no">ComparisonMode</a></b> { CompareRefToTexture, CompareNone }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#CoordinateDirection-enum" translate="no">CoordinateDirection</a></b> { DirectionS, DirectionT, DirectionR }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#CubeMapFace-enum" translate="no">CubeMapFace</a></b> { CubeMapPositiveX, CubeMapNegativeX, CubeMapPositiveY, CubeMapNegativeY, CubeMapPositiveZ, CubeMapNegativeZ }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#DepthStencilMode-enum" translate="no">DepthStencilMode</a></b> { DepthMode, StencilMode }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#Feature-enum" translate="no">Feature</a></b> { ImmutableStorage, ImmutableMultisampleStorage, TextureRectangle, TextureArrays, Texture3D, &hellip;, TextureMipMapLevel }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#Feature-enum" translate="no">Features</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#Filter-enum" translate="no">Filter</a></b> { Nearest, Linear, NearestMipMapNearest, NearestMipMapLinear, LinearMipMapNearest, LinearMipMapLinear }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#MipMapGeneration-enum" translate="no">MipMapGeneration</a></b> { GenerateMipMaps, DontGenerateMipMaps }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#PixelFormat-enum" translate="no">PixelFormat</a></b> { NoSourceFormat, Red, RG, RGB, BGR, &hellip;, LuminanceAlpha }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#PixelType-enum" translate="no">PixelType</a></b> { NoPixelType, Int8, UInt8, Int16, UInt16, &hellip;, Float32_D32_UInt32_S8_X24 }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#SwizzleComponent-enum" translate="no">SwizzleComponent</a></b> { SwizzleRed, SwizzleGreen, SwizzleBlue, SwizzleAlpha }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#SwizzleValue-enum" translate="no">SwizzleValue</a></b> { RedValue, GreenValue, BlueValue, AlphaValue, ZeroValue, OneValue }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#Target-enum" translate="no">Target</a></b> { Target1D, Target1DArray, Target2D, Target2DArray, Target3D, &hellip;, TargetBuffer }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#TextureFormat-enum" translate="no">TextureFormat</a></b> { NoFormat, R8_UNorm, RG8_UNorm, RGB8_UNorm, RGBA8_UNorm, &hellip;, LuminanceAlphaFormat }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#TextureUnitReset-enum" translate="no">TextureUnitReset</a></b> { ResetTextureUnit, DontResetTextureUnit }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#WrapMode-enum" translate="no">WrapMode</a></b> { Repeat, MirroredRepeat, ClampToEdge, ClampToBorder }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#QOpenGLTexture" translate="no">QOpenGLTexture</a></b>(QOpenGLTexture::Target <i>target</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#QOpenGLTexture-1" translate="no">QOpenGLTexture</a></b>(const QImage &amp;<i>image</i>, QOpenGLTexture::MipMapGeneration <i>genMipMaps</i> = GenerateMipMaps)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#allocateStorage" translate="no">allocateStorage</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#allocateStorage-1" translate="no">allocateStorage</a></b>(QOpenGLTexture::PixelFormat <i>pixelFormat</i>, QOpenGLTexture::PixelType <i>pixelType</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#bind" translate="no">bind</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#bind-1" translate="no">bind</a></b>(uint <i>unit</i>, QOpenGLTexture::TextureUnitReset <i>reset</i> = DontResetTextureUnit)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QColor </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#borderColor" translate="no">borderColor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#borderColor-1" translate="no">borderColor</a></b>(float *<i>border</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#borderColor-2" translate="no">borderColor</a></b>(int *<i>border</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#borderColor-3" translate="no">borderColor</a></b>(unsigned int *<i>border</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture::ComparisonFunction </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#comparisonFunction" translate="no">comparisonFunction</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture::ComparisonMode </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#comparisonMode" translate="no">comparisonMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#create" translate="no">create</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture *</td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#createTextureView" translate="no">createTextureView</a></b>(QOpenGLTexture::Target <i>target</i>, QOpenGLTexture::TextureFormat <i>viewFormat</i>, int <i>minimumMipmapLevel</i>, int <i>maximumMipmapLevel</i>, int <i>minimumLayer</i>, int <i>maximumLayer</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#depth" translate="no">depth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture::DepthStencilMode </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#depthStencilMode" translate="no">depthStencilMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#destroy" translate="no">destroy</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#faces" translate="no">faces</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture::TextureFormat </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#format" translate="no">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#generateMipMaps" translate="no">generateMipMaps</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#generateMipMaps-1" translate="no">generateMipMaps</a></b>(int <i>baseLevel</i>, bool <i>resetBaseLevel</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#height" translate="no">height</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#isAutoMipMapGenerationEnabled" translate="no">isAutoMipMapGenerationEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#isBound" translate="no">isBound</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#isBound-1" translate="no">isBound</a></b>(uint <i>unit</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#isCreated" translate="no">isCreated</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#isFixedSamplePositions" translate="no">isFixedSamplePositions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#isTextureView" translate="no">isTextureView</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#layers" translate="no">layers</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPair&lt;float, float&gt; </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#levelOfDetailRange" translate="no">levelOfDetailRange</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#levelofDetailBias" translate="no">levelofDetailBias</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture::Filter </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#magnificationFilter" translate="no">magnificationFilter</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#maximumAnisotropy" translate="no">maximumAnisotropy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#maximumLevelOfDetail" translate="no">maximumLevelOfDetail</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#maximumMipLevels" translate="no">maximumMipLevels</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPair&lt;QOpenGLTexture::Filter, QOpenGLTexture::Filter&gt; </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#minMagFilters" translate="no">minMagFilters</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture::Filter </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#minificationFilter" translate="no">minificationFilter</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#minimumLevelOfDetail" translate="no">minimumLevelOfDetail</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#mipBaseLevel" translate="no">mipBaseLevel</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPair&lt;int, int&gt; </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#mipLevelRange" translate="no">mipLevelRange</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#mipLevels" translate="no">mipLevels</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#mipMaxLevel" translate="no">mipMaxLevel</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#release" translate="no">release</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#release-1" translate="no">release</a></b>(uint <i>unit</i>, QOpenGLTexture::TextureUnitReset <i>reset</i> = DontResetTextureUnit)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#samples" translate="no">samples</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setAutoMipMapGenerationEnabled" translate="no">setAutoMipMapGenerationEnabled</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setBorderColor" translate="no">setBorderColor</a></b>(const QColor &amp;<i>color</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setBorderColor-1" translate="no">setBorderColor</a></b>(float <i>r</i>, float <i>g</i>, float <i>b</i>, float <i>a</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setBorderColor-2" translate="no">setBorderColor</a></b>(int <i>r</i>, int <i>g</i>, int <i>b</i>, int <i>a</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setBorderColor-3" translate="no">setBorderColor</a></b>(uint <i>r</i>, uint <i>g</i>, uint <i>b</i>, uint <i>a</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setComparisonFunction" translate="no">setComparisonFunction</a></b>(QOpenGLTexture::ComparisonFunction <i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setComparisonMode" translate="no">setComparisonMode</a></b>(QOpenGLTexture::ComparisonMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setCompressedData" translate="no">setCompressedData</a></b>(int <i>mipLevel</i>, int <i>layer</i>, QOpenGLTexture::CubeMapFace <i>cubeFace</i>, int <i>dataSize</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setCompressedData-1" translate="no">setCompressedData</a></b>(int <i>mipLevel</i>, int <i>layer</i>, int <i>layerCount</i>, QOpenGLTexture::CubeMapFace <i>cubeFace</i>, int <i>dataSize</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setCompressedData-2" translate="no">setCompressedData</a></b>(int <i>mipLevel</i>, int <i>layer</i>, int <i>dataSize</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setCompressedData-3" translate="no">setCompressedData</a></b>(int <i>mipLevel</i>, int <i>dataSize</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setCompressedData-4" translate="no">setCompressedData</a></b>(int <i>dataSize</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData" translate="no">setData</a></b>(int <i>mipLevel</i>, int <i>layer</i>, QOpenGLTexture::CubeMapFace <i>cubeFace</i>, QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-1" translate="no">setData</a></b>(int <i>mipLevel</i>, int <i>layer</i>, int <i>layerCount</i>, QOpenGLTexture::CubeMapFace <i>cubeFace</i>, QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-2" translate="no">setData</a></b>(int <i>mipLevel</i>, int <i>layer</i>, QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-3" translate="no">setData</a></b>(int <i>mipLevel</i>, QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-4" translate="no">setData</a></b>(QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-5" translate="no">setData</a></b>(int <i>xOffset</i>, int <i>yOffset</i>, int <i>zOffset</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-6" translate="no">setData</a></b>(int <i>xOffset</i>, int <i>yOffset</i>, int <i>zOffset</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>mipLevel</i>, QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-7" translate="no">setData</a></b>(int <i>xOffset</i>, int <i>yOffset</i>, int <i>zOffset</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>mipLevel</i>, int <i>layer</i>, QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-8" translate="no">setData</a></b>(int <i>xOffset</i>, int <i>yOffset</i>, int <i>zOffset</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>mipLevel</i>, int <i>layer</i>, QOpenGLTexture::CubeMapFace <i>face</i>, QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-9" translate="no">setData</a></b>(int <i>xOffset</i>, int <i>yOffset</i>, int <i>zOffset</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>mipLevel</i>, int <i>layer</i>, QOpenGLTexture::CubeMapFace <i>face</i>, int <i>layerCount</i>, QOpenGLTexture::PixelFormat <i>sourceFormat</i>, QOpenGLTexture::PixelType <i>sourceType</i>, const void *<i>data</i>, const QOpenGLPixelTransferOptions *const <i>options</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setData-10" translate="no">setData</a></b>(const QImage &amp;<i>image</i>, QOpenGLTexture::MipMapGeneration <i>genMipMaps</i> = GenerateMipMaps)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setDepthStencilMode" translate="no">setDepthStencilMode</a></b>(QOpenGLTexture::DepthStencilMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setFixedSamplePositions" translate="no">setFixedSamplePositions</a></b>(bool <i>fixed</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setFormat" translate="no">setFormat</a></b>(QOpenGLTexture::TextureFormat <i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setLayers" translate="no">setLayers</a></b>(int <i>layers</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setLevelOfDetailRange" translate="no">setLevelOfDetailRange</a></b>(float <i>min</i>, float <i>max</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setLevelofDetailBias" translate="no">setLevelofDetailBias</a></b>(float <i>bias</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMagnificationFilter" translate="no">setMagnificationFilter</a></b>(QOpenGLTexture::Filter <i>filter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMaximumAnisotropy" translate="no">setMaximumAnisotropy</a></b>(float <i>anisotropy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMaximumLevelOfDetail" translate="no">setMaximumLevelOfDetail</a></b>(float <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMinMagFilters" translate="no">setMinMagFilters</a></b>(QOpenGLTexture::Filter <i>minificationFilter</i>, QOpenGLTexture::Filter <i>magnificationFilter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMinificationFilter" translate="no">setMinificationFilter</a></b>(QOpenGLTexture::Filter <i>filter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMinimumLevelOfDetail" translate="no">setMinimumLevelOfDetail</a></b>(float <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMipBaseLevel" translate="no">setMipBaseLevel</a></b>(int <i>baseLevel</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMipLevelRange" translate="no">setMipLevelRange</a></b>(int <i>baseLevel</i>, int <i>maxLevel</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMipLevels" translate="no">setMipLevels</a></b>(int <i>levels</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setMipMaxLevel" translate="no">setMipMaxLevel</a></b>(int <i>maxLevel</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setSamples" translate="no">setSamples</a></b>(int <i>samples</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setSize" translate="no">setSize</a></b>(int <i>width</i>, int <i>height</i> = 1, int <i>depth</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setSwizzleMask" translate="no">setSwizzleMask</a></b>(QOpenGLTexture::SwizzleComponent <i>component</i>, QOpenGLTexture::SwizzleValue <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setSwizzleMask-1" translate="no">setSwizzleMask</a></b>(QOpenGLTexture::SwizzleValue <i>r</i>, QOpenGLTexture::SwizzleValue <i>g</i>, QOpenGLTexture::SwizzleValue <i>b</i>, QOpenGLTexture::SwizzleValue <i>a</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setWrapMode" translate="no">setWrapMode</a></b>(QOpenGLTexture::WrapMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#setWrapMode-1" translate="no">setWrapMode</a></b>(QOpenGLTexture::CoordinateDirection <i>direction</i>, QOpenGLTexture::WrapMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture::SwizzleValue </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#swizzleMask" translate="no">swizzleMask</a></b>(QOpenGLTexture::SwizzleComponent <i>component</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture::Target </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#target" translate="no">target</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#textureId" translate="no">textureId</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#width" translate="no">width</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLTexture::WrapMode </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#wrapMode" translate="no">wrapMode</a></b>(QOpenGLTexture::CoordinateDirection <i>direction</i>) const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#boundTextureId" translate="no">boundTextureId</a></b>(QOpenGLTexture::BindingTarget <i>target</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#boundTextureId-1" translate="no">boundTextureId</a></b>(uint <i>unit</i>, QOpenGLTexture::BindingTarget <i>target</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengltexture.html#hasFeature" translate="no">hasFeature</a></b>(QOpenGLTexture::Feature <i>feature</i>)</td></tr>
</table></div>
<!-- $$$QOpenGLTexture-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QOpenGLTexture makes it easy to work with OpenGL textures and the myriad features and targets that they offer depending upon the capabilities of your OpenGL implementation.</p>
<p>The typical usage pattern for QOpenGLTexture is</p>
<ul>
<li>Instantiate the object specifying the texture target type</li>
<li>Set properties that affect the storage requirements e.g. storage format, dimensions</li>
<li>Allocate the server-side storage</li>
<li>Optionally upload pixel data</li>
<li>Optionally set any additional properties e.g. filtering and border options</li>
<li>Render with texture or render to texture</li>
</ul>
<p>In the common case of simply using a <a href="../qtgui/qimage.html" translate="no">QImage</a> as the source of texture pixel data most of the above steps are performed automatically.</p>
<pre class="cpp" translate="no">
 <span class="comment">// Prepare texture</span>
 <span class="type"><a href="qopengltexture.html#QOpenGLTexture" translate="no">QOpenGLTexture</a></span> <span class="operator">*</span>texture <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qopengltexture.html#QOpenGLTexture" translate="no">QOpenGLTexture</a></span>(<span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span>(fileName)<span class="operator">.</span>mirrored());
 texture<span class="operator">-</span><span class="operator">&gt;</span>setMinificationFilter(<span class="type"><a href="qopengltexture.html#QOpenGLTexture" translate="no">QOpenGLTexture</a></span><span class="operator">::</span>LinearMipMapLinear);
 texture<span class="operator">-</span><span class="operator">&gt;</span>setMagnificationFilter(<span class="type"><a href="qopengltexture.html#QOpenGLTexture" translate="no">QOpenGLTexture</a></span><span class="operator">::</span>Linear);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="comment">// Render with texture</span>
 texture<span class="operator">-</span><span class="operator">&gt;</span>bind();
 glDrawArrays(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
</pre>
<p>Note that the <a href="../qtgui/qimage.html" translate="no">QImage</a> is mirrored vertically to account for the fact that OpenGL and <a href="../qtgui/qimage.html" translate="no">QImage</a> use opposite directions for the y axis. Another option would be to transform your texture coordinates.</p>
</div>
<!-- @@@QOpenGLTexture -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$BindingTarget$$$BindingTarget1D$$$BindingTarget1DArray$$$BindingTarget2D$$$BindingTarget2DArray$$$BindingTarget3D$$$BindingTargetCubeMap$$$BindingTargetCubeMapArray$$$BindingTarget2DMultisample$$$BindingTarget2DMultisampleArray$$$BindingTargetRectangle$$$BindingTargetBuffer -->
<h3 class="fn" translate="no" id="BindingTarget-enum">enum QOpenGLTexture::<span class="name">BindingTarget</span></h3>
<p>This enum defines the possible binding targets of texture units.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTarget1D</code></td><td class="topAlign tblval"><code translate="no">0x8068</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_1D</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTarget1DArray</code></td><td class="topAlign tblval"><code translate="no">0x8C1C</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_1D_ARRAY</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTarget2D</code></td><td class="topAlign tblval"><code translate="no">0x8069</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_2D</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTarget2DArray</code></td><td class="topAlign tblval"><code translate="no">0x8C1D</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_2D_ARRAY</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTarget3D</code></td><td class="topAlign tblval"><code translate="no">0x806A</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_3D</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTargetCubeMap</code></td><td class="topAlign tblval"><code translate="no">0x8514</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_CUBE_MAP</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTargetCubeMapArray</code></td><td class="topAlign tblval"><code translate="no">0x900A</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_CUBE_MAP_ARRAY</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTarget2DMultisample</code></td><td class="topAlign tblval"><code translate="no">0x9104</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_2D_MULTISAMPLE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTarget2DMultisampleArray</code></td><td class="topAlign tblval"><code translate="no">0x9105</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTargetRectangle</code></td><td class="topAlign tblval"><code translate="no">0x84F6</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_RECTANGLE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BindingTargetBuffer</code></td><td class="topAlign tblval"><code translate="no">0x8C2C</code></td><td class="topAlign">Equivalent to GL_TEXTURE_BINDING_BUFFER</td></tr>
</table></div>
<!-- @@@BindingTarget -->
<!-- $$$ComparisonFunction$$$CompareLessEqual$$$CompareGreaterEqual$$$CompareLess$$$CompareGreater$$$CompareEqual$$$CompareNotEqual$$$CompareAlways$$$CompareNever$$$CommpareNotEqual -->
<h3 class="fn" translate="no" id="ComparisonFunction-enum">enum QOpenGLTexture::<span class="name">ComparisonFunction</span></h3>
<p>This enum specifies which comparison operator is used when texture comparison is enabled on this texture.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareLessEqual</code></td><td class="topAlign tblval"><code translate="no">0x0203</code></td><td class="topAlign">Equivalent to GL_LEQUAL.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareGreaterEqual</code></td><td class="topAlign tblval"><code translate="no">0x0206</code></td><td class="topAlign">Equivalent to GL_GEQUAL.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareLess</code></td><td class="topAlign tblval"><code translate="no">0x0201</code></td><td class="topAlign">Equivalent to GL_LESS.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareGreater</code></td><td class="topAlign tblval"><code translate="no">0x0204</code></td><td class="topAlign">Equivalent to GL_GREATER.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareEqual</code></td><td class="topAlign tblval"><code translate="no">0x0202</code></td><td class="topAlign">Equivalent to GL_EQUAL.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareNotEqual</code></td><td class="topAlign tblval"><code translate="no">0x0205</code></td><td class="topAlign">Equivalent to GL_NOTEQUAL.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareAlways</code></td><td class="topAlign tblval"><code translate="no">0x0207</code></td><td class="topAlign">Equivalent to GL_ALWAYS.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareNever</code></td><td class="topAlign tblval"><code translate="no">0x0200</code></td><td class="topAlign">Equivalent to GL_NEVER.</td></tr>
</table></div>
<!-- @@@ComparisonFunction -->
<!-- $$$ComparisonMode$$$CompareRefToTexture$$$CompareNone -->
<h3 class="fn" translate="no" id="ComparisonMode-enum">enum QOpenGLTexture::<span class="name">ComparisonMode</span></h3>
<p>This enum specifies which comparison mode is used when sampling this texture.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareRefToTexture</code></td><td class="topAlign tblval"><code translate="no">0x884E</code></td><td class="topAlign">Equivalent to GL_COMPARE_REF_TO_TEXTURE.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CompareNone</code></td><td class="topAlign tblval"><code translate="no">0x0000</code></td><td class="topAlign">Equivalent to GL_NONE.</td></tr>
</table></div>
<!-- @@@ComparisonMode -->
<!-- $$$CoordinateDirection$$$DirectionS$$$DirectionT$$$DirectionR -->
<h3 class="fn" translate="no" id="CoordinateDirection-enum">enum QOpenGLTexture::<span class="name">CoordinateDirection</span></h3>
<p>This enum defines the possible texture coordinate directions</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::DirectionS</code></td><td class="topAlign tblval"><code translate="no">0x2802</code></td><td class="topAlign">The horizontal direction. Equivalent to GL_TEXTURE_WRAP_S</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::DirectionT</code></td><td class="topAlign tblval"><code translate="no">0x2803</code></td><td class="topAlign">The vertical direction. Equivalent to GL_TEXTURE_WRAP_T</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::DirectionR</code></td><td class="topAlign tblval"><code translate="no">0x8072</code></td><td class="topAlign">The depth direction. Equivalent to GL_TEXTURE_WRAP_R</td></tr>
</table></div>
<!-- @@@CoordinateDirection -->
<!-- $$$CubeMapFace$$$CubeMapPositiveX$$$CubeMapNegativeX$$$CubeMapPositiveY$$$CubeMapNegativeY$$$CubeMapPositiveZ$$$CubeMapNegativeZ -->
<h3 class="fn" translate="no" id="CubeMapFace-enum">enum QOpenGLTexture::<span class="name">CubeMapFace</span></h3>
<p>This enum defines the possible CubeMap faces.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CubeMapPositiveX</code></td><td class="topAlign tblval"><code translate="no">0x8515</code></td><td class="topAlign">Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_X</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CubeMapNegativeX</code></td><td class="topAlign tblval"><code translate="no">0x8516</code></td><td class="topAlign">Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_X</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CubeMapPositiveY</code></td><td class="topAlign tblval"><code translate="no">0x8517</code></td><td class="topAlign">Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_Y</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CubeMapNegativeY</code></td><td class="topAlign tblval"><code translate="no">0x8518</code></td><td class="topAlign">Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CubeMapPositiveZ</code></td><td class="topAlign tblval"><code translate="no">0x8519</code></td><td class="topAlign">Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_Z</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::CubeMapNegativeZ</code></td><td class="topAlign tblval"><code translate="no">0x851A</code></td><td class="topAlign">Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</td></tr>
</table></div>
<!-- @@@CubeMapFace -->
<!-- $$$DepthStencilMode$$$DepthMode$$$StencilMode -->
<h3 class="fn" translate="no" id="DepthStencilMode-enum">enum QOpenGLTexture::<span class="name">DepthStencilMode</span></h3>
<p>This enum specifies which component of a depth/stencil texture is accessed when the texture is sampled.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::DepthMode</code></td><td class="topAlign tblval"><code translate="no">0x1902</code></td><td class="topAlign">Equivalent to GL_DEPTH_COMPONENT.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::StencilMode</code></td><td class="topAlign tblval"><code translate="no">0x1901</code></td><td class="topAlign">Equivalent to GL_STENCIL_INDEX.</td></tr>
</table></div>
<!-- @@@DepthStencilMode -->
<!-- $$$Feature$$$ImmutableStorage$$$ImmutableMultisampleStorage$$$TextureRectangle$$$TextureArrays$$$Texture3D$$$TextureMultisample$$$TextureBuffer$$$TextureCubeMapArrays$$$Swizzle$$$StencilTexturing$$$AnisotropicFiltering$$$NPOTTextures$$$NPOTTextureRepeat$$$Texture1D$$$TextureComparisonOperators$$$TextureMipMapLevel -->
<h3 class="flags" id="Feature-enum">enum QOpenGLTexture::<span class="name">Feature</span><br/>flags QOpenGLTexture::<span class="name">Features</span></h3>
<p>This enum defines the OpenGL texture-related features that can be tested for.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::ImmutableStorage</code></td><td class="topAlign tblval"><code translate="no">0x00000001</code></td><td class="topAlign">Support for immutable texture storage</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::ImmutableMultisampleStorage</code></td><td class="topAlign tblval"><code translate="no">0x00000002</code></td><td class="topAlign">Support for immutable texture storage with multisample targets</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TextureRectangle</code></td><td class="topAlign tblval"><code translate="no">0x00000004</code></td><td class="topAlign">Support for the GL_TEXTURE_RECTANGLE target</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TextureArrays</code></td><td class="topAlign tblval"><code translate="no">0x00000008</code></td><td class="topAlign">Support for texture targets with array layers</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Texture3D</code></td><td class="topAlign tblval"><code translate="no">0x00000010</code></td><td class="topAlign">Support for the 3 dimensional texture target</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TextureMultisample</code></td><td class="topAlign tblval"><code translate="no">0x00000020</code></td><td class="topAlign">Support for texture targets that have multisample capabilities</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TextureBuffer</code></td><td class="topAlign tblval"><code translate="no">0x00000040</code></td><td class="topAlign">Support for textures that use OpenGL buffer objects as their data source</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TextureCubeMapArrays</code></td><td class="topAlign tblval"><code translate="no">0x00000080</code></td><td class="topAlign">Support for cubemap array texture target</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Swizzle</code></td><td class="topAlign tblval"><code translate="no">0x00000100</code></td><td class="topAlign">Support for texture component swizzle masks</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::StencilTexturing</code></td><td class="topAlign tblval"><code translate="no">0x00000200</code></td><td class="topAlign">Support for stencil texturing (i.e. looking up depth or stencil components of a combined depth/stencil format texture in GLSL shaders).</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::AnisotropicFiltering</code></td><td class="topAlign tblval"><code translate="no">0x00000400</code></td><td class="topAlign">Support for anisotropic texture filtering</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::NPOTTextures</code></td><td class="topAlign tblval"><code translate="no">0x00000800</code></td><td class="topAlign">Basic support for non-power-of-two textures</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::NPOTTextureRepeat</code></td><td class="topAlign tblval"><code translate="no">0x00001000</code></td><td class="topAlign">Full support for non-power-of-two textures including texture repeat modes</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Texture1D</code></td><td class="topAlign tblval"><code translate="no">0x00002000</code></td><td class="topAlign">Support for the 1 dimensional texture target</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TextureComparisonOperators</code></td><td class="topAlign tblval"><code translate="no">0x00004000</code></td><td class="topAlign">Support for texture comparison operators</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TextureMipMapLevel</code></td><td class="topAlign tblval"><code translate="no">0x00008000</code></td><td class="topAlign">Support for setting the base and maximum mipmap levels</td></tr>
</table></div>
<p>The Features type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Feature&gt;. It stores an OR combination of Feature values.</p>
<!-- @@@Feature -->
<!-- $$$Filter$$$Nearest$$$Linear$$$NearestMipMapNearest$$$NearestMipMapLinear$$$LinearMipMapNearest$$$LinearMipMapLinear -->
<h3 class="fn" translate="no" id="Filter-enum">enum QOpenGLTexture::<span class="name">Filter</span></h3>
<p>This enum defines the filtering parameters for a <a href="qopengltexture.html" translate="no">QOpenGLTexture</a> object.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Nearest</code></td><td class="topAlign tblval"><code translate="no">0x2600</code></td><td class="topAlign">Equivalent to GL_NEAREST</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Linear</code></td><td class="topAlign tblval"><code translate="no">0x2601</code></td><td class="topAlign">Equivalent to GL_LINEAR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::NearestMipMapNearest</code></td><td class="topAlign tblval"><code translate="no">0x2700</code></td><td class="topAlign">Equivalent to GL_NEAREST_MIPMAP_NEAREST</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::NearestMipMapLinear</code></td><td class="topAlign tblval"><code translate="no">0x2702</code></td><td class="topAlign">Equivalent to GL_NEAREST_MIPMAP_LINEAR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::LinearMipMapNearest</code></td><td class="topAlign tblval"><code translate="no">0x2701</code></td><td class="topAlign">Equivalent to GL_LINEAR_MIPMAP_NEAREST</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::LinearMipMapLinear</code></td><td class="topAlign tblval"><code translate="no">0x2703</code></td><td class="topAlign">Equivalent to GL_LINEAR_MIPMAP_LINEAR</td></tr>
</table></div>
<!-- @@@Filter -->
<!-- $$$MipMapGeneration$$$GenerateMipMaps$$$DontGenerateMipMaps -->
<h3 class="fn" translate="no" id="MipMapGeneration-enum">enum QOpenGLTexture::<span class="name">MipMapGeneration</span></h3>
<p>This enum defines the options to control mipmap generation.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::GenerateMipMaps</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Mipmaps should be generated</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::DontGenerateMipMaps</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Mipmaps should not be generated</td></tr>
</table></div>
<!-- @@@MipMapGeneration -->
<!-- $$$PixelFormat$$$NoSourceFormat$$$Red$$$RG$$$RGB$$$BGR$$$RGBA$$$BGRA$$$Red_Integer$$$RG_Integer$$$RGB_Integer$$$BGR_Integer$$$RGBA_Integer$$$BGRA_Integer$$$Stencil$$$Depth$$$DepthStencil$$$Alpha$$$Luminance$$$LuminanceAlpha -->
<h3 class="fn" translate="no" id="PixelFormat-enum">enum QOpenGLTexture::<span class="name">PixelFormat</span></h3>
<p>This enum defines the possible client-side pixel formats for a pixel transfer operation.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::NoSourceFormat</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Equivalent to GL_NONE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Red</code></td><td class="topAlign tblval"><code translate="no">0x1903</code></td><td class="topAlign">Equivalent to GL_RED</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG</code></td><td class="topAlign tblval"><code translate="no">0x8227</code></td><td class="topAlign">Equivalent to GL_RG</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB</code></td><td class="topAlign tblval"><code translate="no">0x1907</code></td><td class="topAlign">Equivalent to GL_RGB</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BGR</code></td><td class="topAlign tblval"><code translate="no">0x80E0</code></td><td class="topAlign">Equivalent to GL_BGR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA</code></td><td class="topAlign tblval"><code translate="no">0x1908</code></td><td class="topAlign">Equivalent to GL_RGBA</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BGRA</code></td><td class="topAlign tblval"><code translate="no">0x80E1</code></td><td class="topAlign">Equivalent to GL_BGRA</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Red_Integer</code></td><td class="topAlign tblval"><code translate="no">0x8D94</code></td><td class="topAlign">Equivalent to GL_RED_INTEGER</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG_Integer</code></td><td class="topAlign tblval"><code translate="no">0x8228</code></td><td class="topAlign">Equivalent to GL_RG_INTEGER</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB_Integer</code></td><td class="topAlign tblval"><code translate="no">0x8D98</code></td><td class="topAlign">Equivalent to GL_RGB_INTEGER</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BGR_Integer</code></td><td class="topAlign tblval"><code translate="no">0x8D9A</code></td><td class="topAlign">Equivalent to GL_BGR_INTEGER</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_Integer</code></td><td class="topAlign tblval"><code translate="no">0x8D99</code></td><td class="topAlign">Equivalent to GL_RGBA_INTEGER</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BGRA_Integer</code></td><td class="topAlign tblval"><code translate="no">0x8D9B</code></td><td class="topAlign">Equivalent to GL_BGRA_INTEGER</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Stencil</code></td><td class="topAlign tblval"><code translate="no">0x1901</code></td><td class="topAlign">Equivalent to GL_STENCIL_INDEX. Introduced in Qt 5.4</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Depth</code></td><td class="topAlign tblval"><code translate="no">0x1902</code></td><td class="topAlign">Equivalent to GL_DEPTH_COMPONENT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::DepthStencil</code></td><td class="topAlign tblval"><code translate="no">0x84F9</code></td><td class="topAlign">Equivalent to GL_DEPTH_STENCIL</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Alpha</code></td><td class="topAlign tblval"><code translate="no">0x1906</code></td><td class="topAlign">Equivalent to GL_ALPHA (OpenGL ES 2 only)</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Luminance</code></td><td class="topAlign tblval"><code translate="no">0x1909</code></td><td class="topAlign">Equivalent to GL_LUMINANCE (OpenGL ES 2 only)</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::LuminanceAlpha</code></td><td class="topAlign tblval"><code translate="no">0x190A</code></td><td class="topAlign">Equivalent to GL_LUMINANCE_ALPHA (OpenGL ES 2 only)</td></tr>
</table></div>
<!-- @@@PixelFormat -->
<!-- $$$PixelType$$$NoPixelType$$$Int8$$$UInt8$$$Int16$$$UInt16$$$Int32$$$UInt32$$$Float16$$$Float16OES$$$Float32$$$UInt32_RGB9_E5$$$UInt32_RG11B10F$$$UInt8_RG3B2$$$UInt8_RG3B2_Rev$$$UInt16_RGB5A1$$$UInt16_RGB5A1_Rev$$$UInt16_R5G6B5$$$UInt16_R5G6B5_Rev$$$UInt16_RGBA4$$$UInt16_RGBA4_Rev$$$UInt32_RGBA8$$$UInt32_RGBA8_Rev$$$UInt32_RGB10A2$$$UInt32_RGB10A2_Rev$$$UInt32_D24S8$$$Float32_D32_UInt32_S8_X24 -->
<h3 class="fn" translate="no" id="PixelType-enum">enum QOpenGLTexture::<span class="name">PixelType</span></h3>
<p>This enum defines the possible pixel data types for a pixel transfer operation</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::NoPixelType</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Equivalent to GL_NONE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Int8</code></td><td class="topAlign tblval"><code translate="no">0x1400</code></td><td class="topAlign">Equivalent to GL_BYTE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt8</code></td><td class="topAlign tblval"><code translate="no">0x1401</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_BYTE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Int16</code></td><td class="topAlign tblval"><code translate="no">0x1402</code></td><td class="topAlign">Equivalent to GL_SHORT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt16</code></td><td class="topAlign tblval"><code translate="no">0x1403</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_SHORT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Int32</code></td><td class="topAlign tblval"><code translate="no">0x1404</code></td><td class="topAlign">Equivalent to GL_INT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt32</code></td><td class="topAlign tblval"><code translate="no">0x1405</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_INT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Float16</code></td><td class="topAlign tblval"><code translate="no">0x140B</code></td><td class="topAlign">Equivalent to GL_HALF_FLOAT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Float16OES</code></td><td class="topAlign tblval"><code translate="no">0x8D61</code></td><td class="topAlign">Equivalent to GL_HALF_FLOAT_OES</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Float32</code></td><td class="topAlign tblval"><code translate="no">0x1406</code></td><td class="topAlign">Equivalent to GL_FLOAT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt32_RGB9_E5</code></td><td class="topAlign tblval"><code translate="no">0x8C3E</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_INT_5_9_9_9_REV</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt32_RG11B10F</code></td><td class="topAlign tblval"><code translate="no">0x8C3B</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_INT_10F_11F_11F_REV</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt8_RG3B2</code></td><td class="topAlign tblval"><code translate="no">0x8032</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_BYTE_3_3_2</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt8_RG3B2_Rev</code></td><td class="topAlign tblval"><code translate="no">0x8362</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_BYTE_2_3_3_REV</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt16_RGB5A1</code></td><td class="topAlign tblval"><code translate="no">0x8034</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_SHORT_5_5_5_1</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt16_RGB5A1_Rev</code></td><td class="topAlign tblval"><code translate="no">0x8366</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_SHORT_1_5_5_5_REV</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt16_R5G6B5</code></td><td class="topAlign tblval"><code translate="no">0x8363</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_SHORT_5_6_5</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt16_R5G6B5_Rev</code></td><td class="topAlign tblval"><code translate="no">0x8364</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_SHORT_5_6_5_REV</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt16_RGBA4</code></td><td class="topAlign tblval"><code translate="no">0x8033</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_SHORT_4_4_4_4</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt16_RGBA4_Rev</code></td><td class="topAlign tblval"><code translate="no">0x8365</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_SHORT_4_4_4_4_REV</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt32_RGBA8</code></td><td class="topAlign tblval"><code translate="no">0x8035</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_INT_8_8_8_8</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt32_RGBA8_Rev</code></td><td class="topAlign tblval"><code translate="no">0x8367</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_INT_8_8_8_8_REV</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt32_RGB10A2</code></td><td class="topAlign tblval"><code translate="no">0x8036</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_INT_10_10_10_2</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt32_RGB10A2_Rev</code></td><td class="topAlign tblval"><code translate="no">0x8368</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_INT_2_10_10_10_REV</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::UInt32_D24S8</code></td><td class="topAlign tblval"><code translate="no">0x84FA</code></td><td class="topAlign">Equivalent to GL_UNSIGNED_INT_24_8. Introduced in Qt 5.4</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Float32_D32_UInt32_S8_X24</code></td><td class="topAlign tblval"><code translate="no">0x8DAD</code></td><td class="topAlign">Equivalent to GL_FLOAT_32_UNSIGNED_INT_24_8_REV. Introduced in Qt 5.4</td></tr>
</table></div>
<!-- @@@PixelType -->
<!-- $$$SwizzleComponent$$$SwizzleRed$$$SwizzleGreen$$$SwizzleBlue$$$SwizzleAlpha -->
<h3 class="fn" translate="no" id="SwizzleComponent-enum">enum QOpenGLTexture::<span class="name">SwizzleComponent</span></h3>
<p>This enum defines the texture color components that can be assigned a swizzle mask.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SwizzleRed</code></td><td class="topAlign tblval"><code translate="no">0x8E42</code></td><td class="topAlign">The red component. Equivalent to GL_TEXTURE_SWIZZLE_R</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SwizzleGreen</code></td><td class="topAlign tblval"><code translate="no">0x8E43</code></td><td class="topAlign">The green component. Equivalent to GL_TEXTURE_SWIZZLE_G</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SwizzleBlue</code></td><td class="topAlign tblval"><code translate="no">0x8E44</code></td><td class="topAlign">The blue component. Equivalent to GL_TEXTURE_SWIZZLE_B</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SwizzleAlpha</code></td><td class="topAlign tblval"><code translate="no">0x8E45</code></td><td class="topAlign">The alpha component. Equivalent to GL_TEXTURE_SWIZZLE_A</td></tr>
</table></div>
<!-- @@@SwizzleComponent -->
<!-- $$$SwizzleValue$$$RedValue$$$GreenValue$$$BlueValue$$$AlphaValue$$$ZeroValue$$$OneValue -->
<h3 class="fn" translate="no" id="SwizzleValue-enum">enum QOpenGLTexture::<span class="name">SwizzleValue</span></h3>
<p>This enum defines the possible mask values for texture swizzling.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RedValue</code></td><td class="topAlign tblval"><code translate="no">0x1903</code></td><td class="topAlign">Maps the component to the red channel. Equivalent to GL_RED</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::GreenValue</code></td><td class="topAlign tblval"><code translate="no">0x1904</code></td><td class="topAlign">Maps the component to the green channel. Equivalent to GL_GREEN</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::BlueValue</code></td><td class="topAlign tblval"><code translate="no">0x1905</code></td><td class="topAlign">Maps the component to the blue channel. Equivalent to GL_BLUE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::AlphaValue</code></td><td class="topAlign tblval"><code translate="no">0x1906</code></td><td class="topAlign">Maps the component to the alpha channel. Equivalent to GL_ALPHA</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::ZeroValue</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Maps the component to a fixed value of 0. Equivalent to GL_ZERO</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::OneValue</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Maps the component to a fixed value of 1. Equivalent to GL_ONE</td></tr>
</table></div>
<!-- @@@SwizzleValue -->
<!-- $$$Target$$$Target1D$$$Target1DArray$$$Target2D$$$Target2DArray$$$Target3D$$$TargetCubeMap$$$TargetCubeMapArray$$$Target2DMultisample$$$Target2DMultisampleArray$$$TargetRectangle$$$TargetBuffer -->
<h3 class="fn" translate="no" id="Target-enum">enum QOpenGLTexture::<span class="name">Target</span></h3>
<p>This enum defines the texture target of a <a href="qopengltexture.html" translate="no">QOpenGLTexture</a> object. For more information on creating array textures, see <a href="https://www.khronos.org/opengl/wiki/Array_Texture" translate="no">Array Texture</a>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Target1D</code></td><td class="topAlign tblval"><code translate="no">0x0DE0</code></td><td class="topAlign">A 1-dimensional texture. Equivalent to GL_TEXTURE_1D.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Target1DArray</code></td><td class="topAlign tblval"><code translate="no">0x8C18</code></td><td class="topAlign">An array of 1-dimensional textures. Equivalent to GL_TEXTURE_1D_ARRAY</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Target2D</code></td><td class="topAlign tblval"><code translate="no">0x0DE1</code></td><td class="topAlign">A 2-dimensional texture. Equivalent to GL_TEXTURE_2D</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Target2DArray</code></td><td class="topAlign tblval"><code translate="no">0x8C1A</code></td><td class="topAlign">An array of 2-dimensional textures. Equivalent to GL_TEXTURE_2D_ARRAY</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Target3D</code></td><td class="topAlign tblval"><code translate="no">0x806F</code></td><td class="topAlign">A 3-dimensional texture. Equivalent to GL_TEXTURE_3D</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TargetCubeMap</code></td><td class="topAlign tblval"><code translate="no">0x8513</code></td><td class="topAlign">A cubemap texture. Equivalent to GL_TEXTURE_CUBE_MAP</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TargetCubeMapArray</code></td><td class="topAlign tblval"><code translate="no">0x9009</code></td><td class="topAlign">An array of cubemap textures. Equivalent to GL_TEXTURE_CUBE_MAP_ARRAY</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Target2DMultisample</code></td><td class="topAlign tblval"><code translate="no">0x9100</code></td><td class="topAlign">A 2-dimensional texture with multisample support. Equivalent to GL_TEXTURE_2D_MULTISAMPLE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Target2DMultisampleArray</code></td><td class="topAlign tblval"><code translate="no">0x9102</code></td><td class="topAlign">An array of 2-dimensional textures with multisample support. Equivalent to GL_TEXTURE_2D_MULTISAMPLE_ARRAY</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TargetRectangle</code></td><td class="topAlign tblval"><code translate="no">0x84F5</code></td><td class="topAlign">A rectangular 2-dimensional texture. Equivalent to GL_TEXTURE_RECTANGLE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::TargetBuffer</code></td><td class="topAlign tblval"><code translate="no">0x8C2A</code></td><td class="topAlign">A texture with data from an OpenGL buffer object. Equivalent to GL_TEXTURE_BUFFER</td></tr>
</table></div>
<!-- @@@Target -->
<!-- $$$TextureFormat$$$NoFormat$$$R8_UNorm$$$RG8_UNorm$$$RGB8_UNorm$$$RGBA8_UNorm$$$R16_UNorm$$$RG16_UNorm$$$RGB16_UNorm$$$RGBA16_UNorm$$$R8_SNorm$$$RG8_SNorm$$$RGB8_SNorm$$$RGBA8_SNorm$$$R16_SNorm$$$RG16_SNorm$$$RGB16_SNorm$$$RGBA16_SNorm$$$R8U$$$RG8U$$$RGB8U$$$RGBA8U$$$R16U$$$RG16U$$$RGB16U$$$RGBA16U$$$R32U$$$RG32U$$$RGB32U$$$RGBA32U$$$R8I$$$RG8I$$$RGB8I$$$RGBA8I$$$R16I$$$RG16I$$$RGB16I$$$RGBA16I$$$R32I$$$RG32I$$$RGB32I$$$RGBA32I$$$R16F$$$RG16F$$$RGB16F$$$RGBA16F$$$R32F$$$RG32F$$$RGB32F$$$RGBA32F$$$RGB9E5$$$RG11B10F$$$RG3B2$$$R5G6B5$$$RGB5A1$$$RGBA4$$$RGB10A2$$$D16$$$D24$$$D24S8$$$D32$$$D32F$$$D32FS8X24$$$S8$$$RGB_DXT1$$$RGBA_DXT1$$$RGBA_DXT3$$$RGBA_DXT5$$$R_ATI1N_UNorm$$$R_ATI1N_SNorm$$$RG_ATI2N_UNorm$$$RG_ATI2N_SNorm$$$RGB_BP_UNSIGNED_FLOAT$$$RGB_BP_SIGNED_FLOAT$$$RGB_BP_UNorm$$$R11_EAC_UNorm$$$R11_EAC_SNorm$$$RG11_EAC_UNorm$$$RG11_EAC_SNorm$$$RGB8_ETC2$$$SRGB8_ETC2$$$RGB8_PunchThrough_Alpha1_ETC2$$$SRGB8_PunchThrough_Alpha1_ETC2$$$RGBA8_ETC2_EAC$$$SRGB8_Alpha8_ETC2_EAC$$$RGB8_ETC1$$$RGBA_ASTC_4x4$$$RGBA_ASTC_5x4$$$RGBA_ASTC_5x5$$$RGBA_ASTC_6x5$$$RGBA_ASTC_6x6$$$RGBA_ASTC_8x5$$$RGBA_ASTC_8x6$$$RGBA_ASTC_8x8$$$RGBA_ASTC_10x5$$$RGBA_ASTC_10x6$$$RGBA_ASTC_10x8$$$RGBA_ASTC_10x10$$$RGBA_ASTC_12x10$$$RGBA_ASTC_12x12$$$SRGB8_Alpha8_ASTC_4x4$$$SRGB8_Alpha8_ASTC_5x4$$$SRGB8_Alpha8_ASTC_5x5$$$SRGB8_Alpha8_ASTC_6x5$$$SRGB8_Alpha8_ASTC_6x6$$$SRGB8_Alpha8_ASTC_8x5$$$SRGB8_Alpha8_ASTC_8x6$$$SRGB8_Alpha8_ASTC_8x8$$$SRGB8_Alpha8_ASTC_10x5$$$SRGB8_Alpha8_ASTC_10x6$$$SRGB8_Alpha8_ASTC_10x8$$$SRGB8_Alpha8_ASTC_10x10$$$SRGB8_Alpha8_ASTC_12x10$$$SRGB8_Alpha8_ASTC_12x12$$$SRGB8$$$SRGB8_Alpha8$$$SRGB_DXT1$$$SRGB_Alpha_DXT1$$$SRGB_Alpha_DXT3$$$SRGB_Alpha_DXT5$$$SRGB_BP_UNorm$$$DepthFormat$$$AlphaFormat$$$RGBFormat$$$RGBAFormat$$$LuminanceFormat$$$LuminanceAlphaFormat -->
<h3 class="fn" translate="no" id="TextureFormat-enum">enum QOpenGLTexture::<span class="name">TextureFormat</span></h3>
<p>This enum defines the possible texture formats. Depending upon your OpenGL implementation only a subset of these may be supported.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::NoFormat</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Equivalent to GL_NONE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R8_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x8229</code></td><td class="topAlign">Equivalent to GL_R8</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG8_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x822B</code></td><td class="topAlign">Equivalent to GL_RG8</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB8_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x8051</code></td><td class="topAlign">Equivalent to GL_RGB8</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA8_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x8058</code></td><td class="topAlign">Equivalent to GL_RGBA8</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R16_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x822A</code></td><td class="topAlign">Equivalent to GL_R16</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG16_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x822C</code></td><td class="topAlign">Equivalent to GL_RG16</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB16_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x8054</code></td><td class="topAlign">Equivalent to GL_RGB16</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA16_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x805B</code></td><td class="topAlign">Equivalent to GL_RGBA16</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R8_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8F94</code></td><td class="topAlign">Equivalent to GL_R8_SNORM</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG8_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8F95</code></td><td class="topAlign">Equivalent to GL_RG8_SNORM</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB8_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8F96</code></td><td class="topAlign">Equivalent to GL_RGB8_SNORM</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA8_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8F97</code></td><td class="topAlign">Equivalent to GL_RGBA8_SNORM</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R16_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8F98</code></td><td class="topAlign">Equivalent to GL_R16_SNORM</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG16_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8F99</code></td><td class="topAlign">Equivalent to GL_RG16_SNORM</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB16_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8F9A</code></td><td class="topAlign">Equivalent to GL_RGB16_SNORM</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA16_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8F9B</code></td><td class="topAlign">Equivalent to GL_RGBA16_SNORM</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R8U</code></td><td class="topAlign tblval"><code translate="no">0x8232</code></td><td class="topAlign">Equivalent to GL_R8UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG8U</code></td><td class="topAlign tblval"><code translate="no">0x8238</code></td><td class="topAlign">Equivalent to GL_RG8UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB8U</code></td><td class="topAlign tblval"><code translate="no">0x8D7D</code></td><td class="topAlign">Equivalent to GL_RGB8UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA8U</code></td><td class="topAlign tblval"><code translate="no">0x8D7C</code></td><td class="topAlign">Equivalent to GL_RGBA8UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R16U</code></td><td class="topAlign tblval"><code translate="no">0x8234</code></td><td class="topAlign">Equivalent to GL_R16UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG16U</code></td><td class="topAlign tblval"><code translate="no">0x823A</code></td><td class="topAlign">Equivalent to GL_RG16UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB16U</code></td><td class="topAlign tblval"><code translate="no">0x8D77</code></td><td class="topAlign">Equivalent to GL_RGB16UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA16U</code></td><td class="topAlign tblval"><code translate="no">0x8D76</code></td><td class="topAlign">Equivalent to GL_RGBA16UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R32U</code></td><td class="topAlign tblval"><code translate="no">0x8236</code></td><td class="topAlign">Equivalent to GL_R32UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG32U</code></td><td class="topAlign tblval"><code translate="no">0x823C</code></td><td class="topAlign">Equivalent to GL_RG32UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB32U</code></td><td class="topAlign tblval"><code translate="no">0x8D71</code></td><td class="topAlign">Equivalent to GL_RGB32UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA32U</code></td><td class="topAlign tblval"><code translate="no">0x8D70</code></td><td class="topAlign">Equivalent to GL_RGBA32UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R8I</code></td><td class="topAlign tblval"><code translate="no">0x8231</code></td><td class="topAlign">Equivalent to GL_R8I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG8I</code></td><td class="topAlign tblval"><code translate="no">0x8237</code></td><td class="topAlign">Equivalent to GL_RG8I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB8I</code></td><td class="topAlign tblval"><code translate="no">0x8D8F</code></td><td class="topAlign">Equivalent to GL_RGB8I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA8I</code></td><td class="topAlign tblval"><code translate="no">0x8D8E</code></td><td class="topAlign">Equivalent to GL_RGBA8I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R16I</code></td><td class="topAlign tblval"><code translate="no">0x8233</code></td><td class="topAlign">Equivalent to GL_R16I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG16I</code></td><td class="topAlign tblval"><code translate="no">0x8239</code></td><td class="topAlign">Equivalent to GL_RG16I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB16I</code></td><td class="topAlign tblval"><code translate="no">0x8D89</code></td><td class="topAlign">Equivalent to GL_RGB16I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA16I</code></td><td class="topAlign tblval"><code translate="no">0x8D88</code></td><td class="topAlign">Equivalent to GL_RGBA16I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R32I</code></td><td class="topAlign tblval"><code translate="no">0x8235</code></td><td class="topAlign">Equivalent to GL_R32I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG32I</code></td><td class="topAlign tblval"><code translate="no">0x823B</code></td><td class="topAlign">Equivalent to GL_RG32I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB32I</code></td><td class="topAlign tblval"><code translate="no">0x8D83</code></td><td class="topAlign">Equivalent to GL_RGB32I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA32I</code></td><td class="topAlign tblval"><code translate="no">0x8D82</code></td><td class="topAlign">Equivalent to GL_RGBA32I</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R16F</code></td><td class="topAlign tblval"><code translate="no">0x822D</code></td><td class="topAlign">Equivalent to GL_R16F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG16F</code></td><td class="topAlign tblval"><code translate="no">0x822F</code></td><td class="topAlign">Equivalent to GL_RG16F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB16F</code></td><td class="topAlign tblval"><code translate="no">0x881B</code></td><td class="topAlign">Equivalent to GL_RGB16F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA16F</code></td><td class="topAlign tblval"><code translate="no">0x881A</code></td><td class="topAlign">Equivalent to GL_RGBA16F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R32F</code></td><td class="topAlign tblval"><code translate="no">0x822E</code></td><td class="topAlign">Equivalent to GL_R32F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG32F</code></td><td class="topAlign tblval"><code translate="no">0x8230</code></td><td class="topAlign">Equivalent to GL_RG32F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB32F</code></td><td class="topAlign tblval"><code translate="no">0x8815</code></td><td class="topAlign">Equivalent to GL_RGB32F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA32F</code></td><td class="topAlign tblval"><code translate="no">0x8814</code></td><td class="topAlign">Equivalent to GL_RGBA32F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB9E5</code></td><td class="topAlign tblval"><code translate="no">0x8C3D</code></td><td class="topAlign">Equivalent to GL_RGB9_E5</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG11B10F</code></td><td class="topAlign tblval"><code translate="no">0x8C3A</code></td><td class="topAlign">Equivalent to GL_R11F_G11F_B10F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG3B2</code></td><td class="topAlign tblval"><code translate="no">0x2A10</code></td><td class="topAlign">Equivalent to GL_R3_G3_B2</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R5G6B5</code></td><td class="topAlign tblval"><code translate="no">0x8D62</code></td><td class="topAlign">Equivalent to GL_RGB565</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB5A1</code></td><td class="topAlign tblval"><code translate="no">0x8057</code></td><td class="topAlign">Equivalent to GL_RGB5_A1</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA4</code></td><td class="topAlign tblval"><code translate="no">0x8056</code></td><td class="topAlign">Equivalent to GL_RGBA4</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB10A2</code></td><td class="topAlign tblval"><code translate="no">0x906F</code></td><td class="topAlign">Equivalent to GL_RGB10_A2UI</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::D16</code></td><td class="topAlign tblval"><code translate="no">0x81A5</code></td><td class="topAlign">Equivalent to GL_DEPTH_COMPONENT16</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::D24</code></td><td class="topAlign tblval"><code translate="no">0x81A6</code></td><td class="topAlign">Equivalent to GL_DEPTH_COMPONENT24</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::D24S8</code></td><td class="topAlign tblval"><code translate="no">0x88F0</code></td><td class="topAlign">Equivalent to GL_DEPTH24_STENCIL8</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::D32</code></td><td class="topAlign tblval"><code translate="no">0x81A7</code></td><td class="topAlign">Equivalent to GL_DEPTH_COMPONENT32</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::D32F</code></td><td class="topAlign tblval"><code translate="no">0x8CAC</code></td><td class="topAlign">Equivalent to GL_DEPTH_COMPONENT32F</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::D32FS8X24</code></td><td class="topAlign tblval"><code translate="no">0x8CAD</code></td><td class="topAlign">Equivalent to GL_DEPTH32F_STENCIL8</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::S8</code></td><td class="topAlign tblval"><code translate="no">0x8D48</code></td><td class="topAlign">Equivalent to GL_STENCIL_INDEX8. Introduced in Qt 5.4</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB_DXT1</code></td><td class="topAlign tblval"><code translate="no">0x83F0</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGB_S3TC_DXT1_EXT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_DXT1</code></td><td class="topAlign tblval"><code translate="no">0x83F1</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT1_EXT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_DXT3</code></td><td class="topAlign tblval"><code translate="no">0x83F2</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT3_EXT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_DXT5</code></td><td class="topAlign tblval"><code translate="no">0x83F3</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT5_EXT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R_ATI1N_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x8DBB</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RED_RGTC1</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R_ATI1N_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8DBC</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SIGNED_RED_RGTC1</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG_ATI2N_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x8DBD</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RG_RGTC2</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG_ATI2N_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x8DBE</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SIGNED_RG_RGTC2</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB_BP_UNSIGNED_FLOAT</code></td><td class="topAlign tblval"><code translate="no">0x8E8F</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB_BP_SIGNED_FLOAT</code></td><td class="topAlign tblval"><code translate="no">0x8E8E</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB_BP_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x8E8C</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_BPTC_UNORM_ARB</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R11_EAC_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x9270</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_R11_EAC</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::R11_EAC_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x9271</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SIGNED_R11_EAC</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG11_EAC_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x9272</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RG11_EAC</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RG11_EAC_SNorm</code></td><td class="topAlign tblval"><code translate="no">0x9273</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SIGNED_RG11_EAC</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB8_ETC2</code></td><td class="topAlign tblval"><code translate="no">0x9274</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGB8_ETC2</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_ETC2</code></td><td class="topAlign tblval"><code translate="no">0x9275</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ETC2</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB8_PunchThrough_Alpha1_ETC2</code></td><td class="topAlign tblval"><code translate="no">0x9276</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_PunchThrough_Alpha1_ETC2</code></td><td class="topAlign tblval"><code translate="no">0x9277</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA8_ETC2_EAC</code></td><td class="topAlign tblval"><code translate="no">0x9278</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA8_ETC2_EAC</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ETC2_EAC</code></td><td class="topAlign tblval"><code translate="no">0x9279</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGB8_ETC1</code></td><td class="topAlign tblval"><code translate="no">0x8D64</code></td><td class="topAlign">Equivalent to GL_ETC1_RGB8_OES</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_4x4</code></td><td class="topAlign tblval"><code translate="no">0x93B0</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_4x4_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_5x4</code></td><td class="topAlign tblval"><code translate="no">0x93B1</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_5x4_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_5x5</code></td><td class="topAlign tblval"><code translate="no">0x93B2</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_5x5_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_6x5</code></td><td class="topAlign tblval"><code translate="no">0x93B3</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_6x5_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_6x6</code></td><td class="topAlign tblval"><code translate="no">0x93B4</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_6x6_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_8x5</code></td><td class="topAlign tblval"><code translate="no">0x93B5</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_8x5_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_8x6</code></td><td class="topAlign tblval"><code translate="no">0x93B6</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_8x6_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_8x8</code></td><td class="topAlign tblval"><code translate="no">0x93B7</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_8x8_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_10x5</code></td><td class="topAlign tblval"><code translate="no">0x93B8</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_10x5_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_10x6</code></td><td class="topAlign tblval"><code translate="no">0x93B9</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_10x6_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_10x8</code></td><td class="topAlign tblval"><code translate="no">0x93BA</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_10x8_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_10x10</code></td><td class="topAlign tblval"><code translate="no">0x93BB</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_10x10_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_12x10</code></td><td class="topAlign tblval"><code translate="no">0x93BC</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_12x10_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBA_ASTC_12x12</code></td><td class="topAlign tblval"><code translate="no">0x93BD</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_RGBA_ASTC_12x12_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_4x4</code></td><td class="topAlign tblval"><code translate="no">0x93D0</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_5x4</code></td><td class="topAlign tblval"><code translate="no">0x93D1</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_5x5</code></td><td class="topAlign tblval"><code translate="no">0x93D2</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_6x5</code></td><td class="topAlign tblval"><code translate="no">0x93D3</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_6x6</code></td><td class="topAlign tblval"><code translate="no">0x93D4</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_8x5</code></td><td class="topAlign tblval"><code translate="no">0x93D5</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_8x6</code></td><td class="topAlign tblval"><code translate="no">0x93D6</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_8x8</code></td><td class="topAlign tblval"><code translate="no">0x93D7</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_10x5</code></td><td class="topAlign tblval"><code translate="no">0x93D8</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_10x6</code></td><td class="topAlign tblval"><code translate="no">0x93D9</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_10x8</code></td><td class="topAlign tblval"><code translate="no">0x93DA</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_10x10</code></td><td class="topAlign tblval"><code translate="no">0x93DB</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_12x10</code></td><td class="topAlign tblval"><code translate="no">0x93DC</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8_ASTC_12x12</code></td><td class="topAlign tblval"><code translate="no">0x93DD</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8</code></td><td class="topAlign tblval"><code translate="no">0x8C41</code></td><td class="topAlign">Equivalent to GL_SRGB8</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB8_Alpha8</code></td><td class="topAlign tblval"><code translate="no">0x8C43</code></td><td class="topAlign">Equivalent to GL_SRGB8_ALPHA8</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB_DXT1</code></td><td class="topAlign tblval"><code translate="no">0x8C4C</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB_S3TC_DXT1_EXT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB_Alpha_DXT1</code></td><td class="topAlign tblval"><code translate="no">0x8C4D</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB_Alpha_DXT3</code></td><td class="topAlign tblval"><code translate="no">0x8C4E</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB_Alpha_DXT5</code></td><td class="topAlign tblval"><code translate="no">0x8C4F</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::SRGB_BP_UNorm</code></td><td class="topAlign tblval"><code translate="no">0x8E8D</code></td><td class="topAlign">Equivalent to GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::DepthFormat</code></td><td class="topAlign tblval"><code translate="no">0x1902</code></td><td class="topAlign">Equivalent to GL_DEPTH_COMPONENT (only OpenGL ES 3 or ES 2 with OES_depth_texture)</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::AlphaFormat</code></td><td class="topAlign tblval"><code translate="no">0x1906</code></td><td class="topAlign">Equivalent to GL_ALPHA (OpenGL ES 2 only)</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBFormat</code></td><td class="topAlign tblval"><code translate="no">0x1907</code></td><td class="topAlign">Equivalent to GL_RGB (OpenGL ES 2 only)</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::RGBAFormat</code></td><td class="topAlign tblval"><code translate="no">0x1908</code></td><td class="topAlign">Equivalent to GL_RGBA (OpenGL ES 2 only)</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::LuminanceFormat</code></td><td class="topAlign tblval"><code translate="no">0x1909</code></td><td class="topAlign">Equivalent to GL_LUMINANCE (OpenGL ES 2 only)</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::LuminanceAlphaFormat</code></td><td class="topAlign tblval"><code translate="no">0x190A</code></td><td class="topAlign">Equivalent to GL_LUMINANCE_ALPHA (OpenGL ES 2 only)</td></tr>
</table></div>
<!-- @@@TextureFormat -->
<!-- $$$TextureUnitReset$$$ResetTextureUnit$$$DontResetTextureUnit -->
<h3 class="fn" translate="no" id="TextureUnitReset-enum">enum QOpenGLTexture::<span class="name">TextureUnitReset</span></h3>
<p>This enum defines options ot control texture unit activation.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::ResetTextureUnit</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The previous active texture unit will be reset</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::DontResetTextureUnit</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The previous active texture unit will not be rest</td></tr>
</table></div>
<!-- @@@TextureUnitReset -->
<!-- $$$WrapMode$$$Repeat$$$MirroredRepeat$$$ClampToEdge$$$ClampToBorder -->
<h3 class="fn" translate="no" id="WrapMode-enum">enum QOpenGLTexture::<span class="name">WrapMode</span></h3>
<p>This enum defines the possible texture coordinate wrapping modes.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::Repeat</code></td><td class="topAlign tblval"><code translate="no">0x2901</code></td><td class="topAlign">Texture coordinate is repeated. Equivalent to GL_REPEAT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::MirroredRepeat</code></td><td class="topAlign tblval"><code translate="no">0x8370</code></td><td class="topAlign">Texture coordinate is reflected about 0 and 1. Equivalent to GL_MIRRORED_REPEAT</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::ClampToEdge</code></td><td class="topAlign tblval"><code translate="no">0x812F</code></td><td class="topAlign">Clamps the texture coordinates to [0,1]. Equivalent to GL_CLAMP_TO_EDGE</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLTexture::ClampToBorder</code></td><td class="topAlign tblval"><code translate="no">0x812D</code></td><td class="topAlign">As for ClampToEdge but also blends samples at 0 and 1 with a fixed border color. Equivalent to GL_CLAMP_TO_BORDER</td></tr>
</table></div>
<!-- @@@WrapMode -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QOpenGLTexture[overload1]$$$QOpenGLTextureQOpenGLTexture::Target -->
<h3 class="fn" translate="no" id="QOpenGLTexture"><code class="details extra" translate="no">[explicit]</code> QOpenGLTexture::<span class="name">QOpenGLTexture</span>(<span class="type"><a href="qopengltexture.html#Target-enum" translate="no">QOpenGLTexture::Target</a></span> <i>target</i>)</h3>
<p>Creates a QOpenGLTexture object that can later be bound to <i translate="no">target</i>.</p>
<p>This does not create the underlying OpenGL texture object. Therefore, construction using this constructor does not require a valid current OpenGL context.</p>
<!-- @@@QOpenGLTexture -->
<!-- $$$QOpenGLTexture$$$QOpenGLTextureconstQImage&QOpenGLTexture::MipMapGeneration -->
<h3 class="fn" translate="no" id="QOpenGLTexture-1"><code class="details extra" translate="no">[explicit]</code> QOpenGLTexture::<span class="name">QOpenGLTexture</span>(const <span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span> &amp;<i>image</i>, <span class="type"><a href="qopengltexture.html#MipMapGeneration-enum" translate="no">QOpenGLTexture::MipMapGeneration</a></span> <i>genMipMaps</i> = GenerateMipMaps)</h3>
<p>Creates a QOpenGLTexture object that can later be bound to the 2D texture target and contains the pixel data contained in <i translate="no">image</i>. If you wish to have a chain of mipmaps generated then set <i translate="no">genMipMaps</i> to <code translate="no">true</code> (this is the default).</p>
<p>This does create the underlying OpenGL texture object. Therefore, construction using this constructor does require a valid current OpenGL context.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">image</i> is automatically converted to <a href="../qtgui/qimage.html#Format-enum" translate="no">QImage::Format_RGBA8888</a> which may have performance implications for large images with a different format.</p>
</div>
<!-- @@@QOpenGLTexture -->
<!-- $$$allocateStorage[overload1]$$$allocateStorage -->
<h3 class="fn" translate="no" id="allocateStorage"><span class="type">void</span> QOpenGLTexture::<span class="name">allocateStorage</span>()</h3>
<p>Allocates server-side storage for this texture object taking into account, the format, dimensions, mipmap levels, array layers and cubemap faces.</p>
<p>Once storage has been allocated it is no longer possible to change these properties.</p>
<p>If supported <a href="qopengltexture.html" translate="no">QOpenGLTexture</a> makes use of immutable texture storage.</p>
<p>Once storage has been allocated for the texture then pixel data can be uploaded via one of the <a href="qopengltexture.html#setData" translate="no">setData</a>() overloads.</p>
<div class="admonition note">
<p><b>Note: </b>If immutable texture storage is not available, then a default pixel format and pixel type will be used to create the mutable storage. You can use the other allocateStorage() overload to specify exactly the pixel format and the pixel type to use when allocating mutable storage; this is particularly useful under certain OpenGL ES implementations (notably, OpenGL ES 2), where the pixel format and the pixel type used at allocation time must perfectly match the format and the type passed to any subsequent <a href="qopengltexture.html#setData" translate="no">setData</a>() call.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>() and <a href="qopengltexture.html#setData" translate="no">setData</a>().</p>
<!-- @@@allocateStorage -->
<!-- $$$allocateStorage$$$allocateStorageQOpenGLTexture::PixelFormatQOpenGLTexture::PixelType -->
<h3 class="fn" translate="no" id="allocateStorage-1"><span class="type">void</span> QOpenGLTexture::<span class="name">allocateStorage</span>(<span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>pixelFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>pixelType</i>)</h3>
<p>Allocates server-side storage for this texture object taking into account, the format, dimensions, mipmap levels, array layers and cubemap faces.</p>
<p>Once storage has been allocated it is no longer possible to change these properties.</p>
<p>If supported <a href="qopengltexture.html" translate="no">QOpenGLTexture</a> makes use of immutable texture storage. However, if immutable texture storage is not available, then the specified <i translate="no">pixelFormat</i> and <i translate="no">pixelType</i> will be used to allocate mutable storage; note that in certain OpenGL implementations (notably, OpenGL ES 2) they must perfectly match the format and the type passed to any subsequent <a href="qopengltexture.html#setData" translate="no">setData</a>() call.</p>
<p>Once storage has been allocated for the texture then pixel data can be uploaded via one of the <a href="qopengltexture.html#setData" translate="no">setData</a>() overloads.</p>
<p><b>See also </b><a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>() and <a href="qopengltexture.html#setData" translate="no">setData</a>().</p>
<!-- @@@allocateStorage -->
<!-- $$$bind[overload1]$$$bind -->
<h3 class="fn" translate="no" id="bind"><span class="type">void</span> QOpenGLTexture::<span class="name">bind</span>()</h3>
<p>Binds this texture to the currently active texture unit ready for rendering. Note that you do not need to bind <a href="qopengltexture.html" translate="no">QOpenGLTexture</a> objects in order to modify them as the implementation makes use of the EXT_direct_state_access extension where available and simulates it where it is not.</p>
<p><b>See also </b><a href="qopengltexture.html#release" translate="no">release</a>().</p>
<!-- @@@bind -->
<!-- $$$bind$$$binduintQOpenGLTexture::TextureUnitReset -->
<h3 class="fn" translate="no" id="bind-1"><span class="type">void</span> QOpenGLTexture::<span class="name">bind</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>unit</i>, <span class="type"><a href="qopengltexture.html#TextureUnitReset-enum" translate="no">QOpenGLTexture::TextureUnitReset</a></span> <i>reset</i> = DontResetTextureUnit)</h3>
<p>Binds this texture to texture unit <i translate="no">unit</i> ready for rendering. Note that you do not need to bind <a href="qopengltexture.html" translate="no">QOpenGLTexture</a> objects in order to modify them as the implementation makes use of the EXT_direct_state_access extension where available and simulates it where it is not.</p>
<p>If parameter <i translate="no">reset</i> is <code translate="no">true</code> then this function will restore the active unit to the texture unit that was active upon entry.</p>
<p><b>See also </b><a href="qopengltexture.html#release" translate="no">release</a>().</p>
<!-- @@@bind -->
<!-- $$$borderColor[overload1]$$$borderColor -->
<h3 class="fn" translate="no" id="borderColor"><span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> QOpenGLTexture::<span class="name">borderColor</span>() const</h3>
<p>Returns the borderColor of this texture.</p>
<p><b>See also </b><a href="qopengltexture.html#setBorderColor" translate="no">setBorderColor</a>().</p>
<!-- @@@borderColor -->
<!-- $$$borderColor$$$borderColorfloat* -->
<h3 class="fn" translate="no" id="borderColor-1"><span class="type">void</span> QOpenGLTexture::<span class="name">borderColor</span>(<span class="type">float</span> *<i>border</i>) const</h3>
<p>Writes the texture border color into the first four elements of the array pointed to by <i translate="no">border</i>.</p>
<p><b>See also </b><a href="qopengltexture.html#setBorderColor" translate="no">setBorderColor</a>().</p>
<!-- @@@borderColor -->
<!-- $$$borderColor$$$borderColorint* -->
<h3 class="fn" translate="no" id="borderColor-2"><span class="type">void</span> QOpenGLTexture::<span class="name">borderColor</span>(<span class="type">int</span> *<i>border</i>) const</h3>
<p>Writes the texture border color into the first four elements of the array pointed to by <i translate="no">border</i>.</p>
<p>This is an overloaded function.</p>
<!-- @@@borderColor -->
<!-- $$$borderColor$$$borderColorunsignedint* -->
<h3 class="fn" translate="no" id="borderColor-3"><span class="type">void</span> QOpenGLTexture::<span class="name">borderColor</span>(<span class="type">unsigned</span> <span class="type">int</span> *<i>border</i>) const</h3>
<p>Writes the texture border color into the first four elements of the array pointed to by <i translate="no">border</i>.</p>
<p>This is an overloaded function.</p>
<!-- @@@borderColor -->
<!-- $$$boundTextureId[overload1]$$$boundTextureIdQOpenGLTexture::BindingTarget -->
<h3 class="fn" translate="no" id="boundTextureId"><code class="details extra" translate="no">[static]</code> <span class="type">GLuint</span> QOpenGLTexture::<span class="name">boundTextureId</span>(<span class="type"><a href="qopengltexture.html#BindingTarget-enum" translate="no">QOpenGLTexture::BindingTarget</a></span> <i>target</i>)</h3>
<p>Returns the <a href="qopengltexture.html#textureId" translate="no">textureId</a> of the texture that is bound to the <i translate="no">target</i> of the currently active texture unit.</p>
<!-- @@@boundTextureId -->
<!-- $$$boundTextureId$$$boundTextureIduintQOpenGLTexture::BindingTarget -->
<h3 class="fn" translate="no" id="boundTextureId-1"><code class="details extra" translate="no">[static]</code> <span class="type">GLuint</span> QOpenGLTexture::<span class="name">boundTextureId</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>unit</i>, <span class="type"><a href="qopengltexture.html#BindingTarget-enum" translate="no">QOpenGLTexture::BindingTarget</a></span> <i>target</i>)</h3>
<p>Returns the <a href="qopengltexture.html#textureId" translate="no">textureId</a> of the texture that is bound to the <i translate="no">target</i> of the texture unit <i translate="no">unit</i>.</p>
<!-- @@@boundTextureId -->
<!-- $$$comparisonFunction[overload1]$$$comparisonFunction -->
<h3 class="fn" translate="no" id="comparisonFunction"><span class="type"><a href="qopengltexture.html#ComparisonFunction-enum" translate="no">QOpenGLTexture::ComparisonFunction</a></span> QOpenGLTexture::<span class="name">comparisonFunction</span>() const</h3>
<p>Returns the texture comparison operator set on this texture. By default, a texture has a <a href="qopengltexture.html#ComparisonFunction-enum" translate="no">CompareLessEqual</a> comparison function.</p>
<p><b>See also </b><a href="qopengltexture.html#setComparisonFunction" translate="no">setComparisonFunction</a>().</p>
<!-- @@@comparisonFunction -->
<!-- $$$comparisonMode[overload1]$$$comparisonMode -->
<h3 class="fn" translate="no" id="comparisonMode"><span class="type"><a href="qopengltexture.html#ComparisonMode-enum" translate="no">QOpenGLTexture::ComparisonMode</a></span> QOpenGLTexture::<span class="name">comparisonMode</span>() const</h3>
<p>Returns the texture comparison mode set on this texture. By default, a texture has a <a href="qopengltexture.html#ComparisonMode-enum" translate="no">CompareNone</a> comparison mode (i.e. comparisons are disabled).</p>
<p><b>See also </b><a href="qopengltexture.html#setComparisonMode" translate="no">setComparisonMode</a>().</p>
<!-- @@@comparisonMode -->
<!-- $$$create[overload1]$$$create -->
<h3 class="fn" translate="no" id="create"><span class="type">bool</span> QOpenGLTexture::<span class="name">create</span>()</h3>
<p>Creates the underlying OpenGL texture object. This requires a current valid OpenGL context. If the texture object already exists, this function does nothing.</p>
<p>Once the texture object is created you can obtain the object name from the <a href="qopengltexture.html#textureId" translate="no">textureId</a>() function. This may be useful if you wish to make some raw OpenGL calls related to this texture.</p>
<p>Normally it should not be necessary to call this function directly as all functions that set properties of the texture object implicitly call create() on your behalf.</p>
<p>Returns <code translate="no">true</code> if the creation succeeded, otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qopengltexture.html#destroy" translate="no">destroy</a>(), <a href="qopengltexture.html#isCreated" translate="no">isCreated</a>(), and <a href="qopengltexture.html#textureId" translate="no">textureId</a>().</p>
<!-- @@@create -->
<!-- $$$createTextureView[overload1]$$$createTextureViewQOpenGLTexture::TargetQOpenGLTexture::TextureFormatintintintint -->
<h3 class="fn" translate="no" id="createTextureView"><span class="type"><a href="qopengltexture.html#QOpenGLTexture" translate="no">QOpenGLTexture</a></span> *QOpenGLTexture::<span class="name">createTextureView</span>(<span class="type"><a href="qopengltexture.html#Target-enum" translate="no">QOpenGLTexture::Target</a></span> <i>target</i>, <span class="type"><a href="qopengltexture.html#TextureFormat-enum" translate="no">QOpenGLTexture::TextureFormat</a></span> <i>viewFormat</i>, <span class="type">int</span> <i>minimumMipmapLevel</i>, <span class="type">int</span> <i>maximumMipmapLevel</i>, <span class="type">int</span> <i>minimumLayer</i>, <span class="type">int</span> <i>maximumLayer</i>) const</h3>
<p>Attempts to create a texture view onto this texture. A texture view is somewhat analogous to a view in SQL in that it presents a restricted or reinterpreted view of the original data. Texture views do not allocate any more server-side storage, instead relying on the storage buffer of the source texture.</p>
<p>Texture views are only available when using immutable storage. For more information on texture views see http://www.opengl.org/wiki/Texture_Storage#Texture_views.</p>
<p>The <i translate="no">target</i> argument specifies the target to use for the view. Only some targets can be used depending upon the target of the original target. For e.g. a view onto a <a href="qopengltexture.html#Target-enum" translate="no">Target1DArray</a> texture can specify either <a href="qopengltexture.html#Target-enum" translate="no">Target1DArray</a> or <a href="qopengltexture.html#Target-enum" translate="no">Target1D</a> but for the latter the number of array layers specified with <i translate="no">minimumLayer</i> and <i translate="no">maximumLayer</i> must be exactly 1.</p>
<p>Simpliar constraints apply for the <i translate="no">viewFormat</i>. See the above link and the specification for more details.</p>
<p>The <i translate="no">minimumMipmapLevel</i>, <i translate="no">maximumMipmapLevel</i>, <i translate="no">minimumLayer</i>, and <i translate="no">maximumLayer</i> arguments serve to restrict the parts of the texture accessible by the texture view.</p>
<p>If creation of the texture view fails this function will return 0. If the function succeeds it will return a pointer to a new <a href="qopengltexture.html" translate="no">QOpenGLTexture</a> object that will return <code translate="no">true</code> from its <a href="qopengltexture.html#isTextureView" translate="no">isTextureView</a>() function.</p>
<p><b>See also </b><a href="qopengltexture.html#isTextureView" translate="no">isTextureView</a>().</p>
<!-- @@@createTextureView -->
<!-- $$$depth[overload1]$$$depth -->
<h3 class="fn" translate="no" id="depth"><span class="type">int</span> QOpenGLTexture::<span class="name">depth</span>() const</h3>
<p>Returns the depth of a 3D texture.</p>
<p><b>See also </b><a href="qopengltexture.html#width" translate="no">width</a>(), <a href="qopengltexture.html#height" translate="no">height</a>(), and <a href="qopengltexture.html#setSize" translate="no">setSize</a>().</p>
<!-- @@@depth -->
<!-- $$$depthStencilMode[overload1]$$$depthStencilMode -->
<h3 class="fn" translate="no" id="depthStencilMode"><span class="type"><a href="qopengltexture.html#DepthStencilMode-enum" translate="no">QOpenGLTexture::DepthStencilMode</a></span> QOpenGLTexture::<span class="name">depthStencilMode</span>() const</h3>
<p>Returns the depth stencil mode for textures using a combined depth/stencil format.</p>
<p><b>See also </b><a href="qopengltexture.html#setDepthStencilMode" translate="no">setDepthStencilMode</a>().</p>
<!-- @@@depthStencilMode -->
<!-- $$$destroy[overload1]$$$destroy -->
<h3 class="fn" translate="no" id="destroy"><span class="type">void</span> QOpenGLTexture::<span class="name">destroy</span>()</h3>
<p>Destroys the underlying OpenGL texture object. This requires a current valid OpenGL context.</p>
<p><b>See also </b><a href="qopengltexture.html#create" translate="no">create</a>(), <a href="qopengltexture.html#isCreated" translate="no">isCreated</a>(), and <a href="qopengltexture.html#textureId" translate="no">textureId</a>().</p>
<!-- @@@destroy -->
<!-- $$$faces[overload1]$$$faces -->
<h3 class="fn" translate="no" id="faces"><span class="type">int</span> QOpenGLTexture::<span class="name">faces</span>() const</h3>
<p>Returns the number of faces for this texture. For cubemap and cubemap array type targets this will be 6.</p>
<p>For non-cubemap type targets this will return 1.</p>
<!-- @@@faces -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" translate="no" id="format"><span class="type"><a href="qopengltexture.html#TextureFormat-enum" translate="no">QOpenGLTexture::TextureFormat</a></span> QOpenGLTexture::<span class="name">format</span>() const</h3>
<p>Returns the format of this texture object.</p>
<p><b>See also </b><a href="qopengltexture.html#setFormat" translate="no">setFormat</a>().</p>
<!-- @@@format -->
<!-- $$$generateMipMaps[overload1]$$$generateMipMaps -->
<h3 class="fn" translate="no" id="generateMipMaps"><span class="type">void</span> QOpenGLTexture::<span class="name">generateMipMaps</span>()</h3>
<p>Generates mipmaps for this texture object from mipmap level 0. If you are using a texture target and filtering option that requires mipmaps and you have disabled automatic mipmap generation then you need to call this function or the overload to create the mipmap chain.</p>
<div class="admonition note">
<p><b>Note: </b>Mipmap generation is not supported for compressed textures with OpenGL ES.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#setAutoMipMapGenerationEnabled" translate="no">setAutoMipMapGenerationEnabled</a>(), <a href="qopengltexture.html#setMipLevels" translate="no">setMipLevels</a>(), and <a href="qopengltexture.html#mipLevels" translate="no">mipLevels</a>().</p>
<!-- @@@generateMipMaps -->
<!-- $$$generateMipMaps$$$generateMipMapsintbool -->
<h3 class="fn" translate="no" id="generateMipMaps-1"><span class="type">void</span> QOpenGLTexture::<span class="name">generateMipMaps</span>(<span class="type">int</span> <i>baseLevel</i>, <span class="type">bool</span> <i>resetBaseLevel</i> = true)</h3>
<p>Generates mipmaps for this texture object from mipmap level <i translate="no">baseLevel</i>. If you are using a texture target and filtering option that requires mipmaps and you have disabled automatic mipmap generation then you need to call this function or the overload to create the mipmap chain.</p>
<p>The generation of mipmaps to above <i translate="no">baseLevel</i> is achieved by setting the mipmap base level to <i translate="no">baseLevel</i> and then generating the mipmap chain. If <i translate="no">resetBaseLevel</i> is <code translate="no">true</code>, then the baseLevel of the texture will be reset to its previous value.</p>
<p><b>See also </b><a href="qopengltexture.html#setAutoMipMapGenerationEnabled" translate="no">setAutoMipMapGenerationEnabled</a>(), <a href="qopengltexture.html#setMipLevels" translate="no">setMipLevels</a>(), and <a href="qopengltexture.html#mipLevels" translate="no">mipLevels</a>().</p>
<!-- @@@generateMipMaps -->
<!-- $$$hasFeature[overload1]$$$hasFeatureQOpenGLTexture::Feature -->
<h3 class="fn" translate="no" id="hasFeature"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QOpenGLTexture::<span class="name">hasFeature</span>(<span class="type"><a href="qopengltexture.html#Feature-enum" translate="no">QOpenGLTexture::Feature</a></span> <i>feature</i>)</h3>
<p>Returns <code translate="no">true</code> if your OpenGL implementation and version supports the texture feature <i translate="no">feature</i>.</p>
<!-- @@@hasFeature -->
<!-- $$$height[overload1]$$$height -->
<h3 class="fn" translate="no" id="height"><span class="type">int</span> QOpenGLTexture::<span class="name">height</span>() const</h3>
<p>Returns the height of a 2D or 3D texture.</p>
<p><b>See also </b><a href="qopengltexture.html#width" translate="no">width</a>(), <a href="qopengltexture.html#depth" translate="no">depth</a>(), and <a href="qopengltexture.html#setSize" translate="no">setSize</a>().</p>
<!-- @@@height -->
<!-- $$$isAutoMipMapGenerationEnabled[overload1]$$$isAutoMipMapGenerationEnabled -->
<h3 class="fn" translate="no" id="isAutoMipMapGenerationEnabled"><span class="type">bool</span> QOpenGLTexture::<span class="name">isAutoMipMapGenerationEnabled</span>() const</h3>
<p>Returns whether auto mipmap generation is enabled for this texture object.</p>
<p><b>See also </b><a href="qopengltexture.html#setAutoMipMapGenerationEnabled" translate="no">setAutoMipMapGenerationEnabled</a>() and <a href="qopengltexture.html#generateMipMaps" translate="no">generateMipMaps</a>().</p>
<!-- @@@isAutoMipMapGenerationEnabled -->
<!-- $$$isBound[overload1]$$$isBound -->
<h3 class="fn" translate="no" id="isBound"><span class="type">bool</span> QOpenGLTexture::<span class="name">isBound</span>() const</h3>
<p>Returns <code translate="no">true</code> if this texture is bound to the corresponding target of the currently active texture unit.</p>
<p><b>See also </b><a href="qopengltexture.html#bind" translate="no">bind</a>() and <a href="qopengltexture.html#release" translate="no">release</a>().</p>
<!-- @@@isBound -->
<!-- $$$isBound$$$isBounduint -->
<h3 class="fn" translate="no" id="isBound-1"><span class="type">bool</span> QOpenGLTexture::<span class="name">isBound</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>unit</i>)</h3>
<p>Returns <code translate="no">true</code> if this texture is bound to the corresponding target of texture unit <i translate="no">unit</i>.</p>
<p><b>See also </b><a href="qopengltexture.html#bind" translate="no">bind</a>() and <a href="qopengltexture.html#release" translate="no">release</a>().</p>
<!-- @@@isBound -->
<!-- $$$isCreated[overload1]$$$isCreated -->
<h3 class="fn" translate="no" id="isCreated"><span class="type">bool</span> QOpenGLTexture::<span class="name">isCreated</span>() const</h3>
<p>Returns <code translate="no">true</code> if the underlying OpenGL texture object has been created.</p>
<p><b>See also </b><a href="qopengltexture.html#create" translate="no">create</a>(), <a href="qopengltexture.html#destroy" translate="no">destroy</a>(), and <a href="qopengltexture.html#textureId" translate="no">textureId</a>().</p>
<!-- @@@isCreated -->
<!-- $$$isFixedSamplePositions[overload1]$$$isFixedSamplePositions -->
<h3 class="fn" translate="no" id="isFixedSamplePositions"><span class="type">bool</span> QOpenGLTexture::<span class="name">isFixedSamplePositions</span>() const</h3>
<p>Returns whether this texture uses a fixed pattern of multisample samples. If storage has not yet been allocated for this texture then this function returns the requested fixed sample position setting.</p>
<p>For texture targets that do not support multisampling this will return <code translate="no">true</code>.</p>
<p><b>See also </b><a href="qopengltexture.html#setFixedSamplePositions" translate="no">setFixedSamplePositions</a>() and <a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>().</p>
<!-- @@@isFixedSamplePositions -->
<!-- $$$isStorageAllocated[overload1]$$$isStorageAllocated -->
<h3 class="fn" translate="no" id="isStorageAllocated"><span class="type">bool</span> QOpenGLTexture::<span class="name">isStorageAllocated</span>() const</h3>
<p>Returns <code translate="no">true</code> if server-side storage for this texture as been allocated.</p>
<p>The texture format, dimensions, mipmap levels and array layers cannot be altered once storage ihas been allocated.</p>
<p><b>See also </b><a href="qopengltexture.html#allocateStorage" translate="no">allocateStorage</a>(), <a href="qopengltexture.html#setSize" translate="no">setSize</a>(), <a href="qopengltexture.html#setMipLevels" translate="no">setMipLevels</a>(), <a href="qopengltexture.html#setLayers" translate="no">setLayers</a>(), and <a href="qopengltexture.html#setFormat" translate="no">setFormat</a>().</p>
<!-- @@@isStorageAllocated -->
<!-- $$$isTextureView[overload1]$$$isTextureView -->
<h3 class="fn" translate="no" id="isTextureView"><span class="type">bool</span> QOpenGLTexture::<span class="name">isTextureView</span>() const</h3>
<p>Returns <code translate="no">true</code> if this texture object is actually a view onto another texture object.</p>
<p><b>See also </b><a href="qopengltexture.html#createTextureView" translate="no">createTextureView</a>().</p>
<!-- @@@isTextureView -->
<!-- $$$layers[overload1]$$$layers -->
<h3 class="fn" translate="no" id="layers"><span class="type">int</span> QOpenGLTexture::<span class="name">layers</span>() const</h3>
<p>Returns the number of array layers for this texture. If storage has not yet been allocated for this texture then this function returns the requested number of array layers.</p>
<p>For texture targets that do not support array layers this will return 1.</p>
<p><b>See also </b><a href="qopengltexture.html#setLayers" translate="no">setLayers</a>() and <a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>().</p>
<!-- @@@layers -->
<!-- $$$levelOfDetailRange[overload1]$$$levelOfDetailRange -->
<h3 class="fn" translate="no" id="levelOfDetailRange"><span class="type"><a href="../qtcore/qpair-qtcore-proxy.html#QPair-typedef" translate="no">QPair</a></span>&lt;<span class="type">float</span>, <span class="type">float</span>&gt; QOpenGLTexture::<span class="name">levelOfDetailRange</span>() const</h3>
<p>Returns the minimum and maximum level of detail parameters.</p>
<p><b>See also </b><a href="qopengltexture.html#setLevelOfDetailRange" translate="no">setLevelOfDetailRange</a>(), <a href="qopengltexture.html#minimumLevelOfDetail" translate="no">minimumLevelOfDetail</a>(), and <a href="qopengltexture.html#maximumLevelOfDetail" translate="no">maximumLevelOfDetail</a>().</p>
<!-- @@@levelOfDetailRange -->
<!-- $$$levelofDetailBias[overload1]$$$levelofDetailBias -->
<h3 class="fn" translate="no" id="levelofDetailBias"><span class="type">float</span> QOpenGLTexture::<span class="name">levelofDetailBias</span>() const</h3>
<p>Returns the level of detail bias parameter.</p>
<p><b>See also </b><a href="qopengltexture.html#setLevelofDetailBias" translate="no">setLevelofDetailBias</a>().</p>
<!-- @@@levelofDetailBias -->
<!-- $$$magnificationFilter[overload1]$$$magnificationFilter -->
<h3 class="fn" translate="no" id="magnificationFilter"><span class="type"><a href="qopengltexture.html#Filter-enum" translate="no">QOpenGLTexture::Filter</a></span> QOpenGLTexture::<span class="name">magnificationFilter</span>() const</h3>
<p>Returns the magnification filter.</p>
<p><b>See also </b><a href="qopengltexture.html#setMagnificationFilter" translate="no">setMagnificationFilter</a>().</p>
<!-- @@@magnificationFilter -->
<!-- $$$maximumAnisotropy[overload1]$$$maximumAnisotropy -->
<h3 class="fn" translate="no" id="maximumAnisotropy"><span class="type">float</span> QOpenGLTexture::<span class="name">maximumAnisotropy</span>() const</h3>
<p>Returns the maximum level of anisotropy to be accounted for when performing texture lookups. This requires the GL_EXT_texture_filter_anisotropic extension.</p>
<p><b>See also </b><a href="qopengltexture.html#setMaximumAnisotropy" translate="no">setMaximumAnisotropy</a>().</p>
<!-- @@@maximumAnisotropy -->
<!-- $$$maximumLevelOfDetail[overload1]$$$maximumLevelOfDetail -->
<h3 class="fn" translate="no" id="maximumLevelOfDetail"><span class="type">float</span> QOpenGLTexture::<span class="name">maximumLevelOfDetail</span>() const</h3>
<p>Returns the maximum level of detail parameter.</p>
<p><b>See also </b><a href="qopengltexture.html#setMaximumLevelOfDetail" translate="no">setMaximumLevelOfDetail</a>(), <a href="qopengltexture.html#minimumLevelOfDetail" translate="no">minimumLevelOfDetail</a>(), and <a href="qopengltexture.html#levelOfDetailRange" translate="no">levelOfDetailRange</a>().</p>
<!-- @@@maximumLevelOfDetail -->
<!-- $$$maximumMipLevels[overload1]$$$maximumMipLevels -->
<h3 class="fn" translate="no" id="maximumMipLevels"><span class="type">int</span> QOpenGLTexture::<span class="name">maximumMipLevels</span>() const</h3>
<p>Returns the maximum number of mipmap levels that this texture can have given the current dimensions.</p>
<p><b>See also </b><a href="qopengltexture.html#setMipLevels" translate="no">setMipLevels</a>(), <a href="qopengltexture.html#mipLevels" translate="no">mipLevels</a>(), and <a href="qopengltexture.html#setSize" translate="no">setSize</a>().</p>
<!-- @@@maximumMipLevels -->
<!-- $$$minMagFilters[overload1]$$$minMagFilters -->
<h3 class="fn" translate="no" id="minMagFilters"><span class="type"><a href="../qtcore/qpair-qtcore-proxy.html#QPair-typedef" translate="no">QPair</a></span>&lt;<span class="type"><a href="qopengltexture.html#Filter-enum" translate="no">QOpenGLTexture::Filter</a></span>, <span class="type"><a href="qopengltexture.html#Filter-enum" translate="no">QOpenGLTexture::Filter</a></span>&gt; QOpenGLTexture::<span class="name">minMagFilters</span>() const</h3>
<p>Returns the current minification and magnification filters.</p>
<p><b>See also </b><a href="qopengltexture.html#setMinMagFilters" translate="no">setMinMagFilters</a>().</p>
<!-- @@@minMagFilters -->
<!-- $$$minificationFilter[overload1]$$$minificationFilter -->
<h3 class="fn" translate="no" id="minificationFilter"><span class="type"><a href="qopengltexture.html#Filter-enum" translate="no">QOpenGLTexture::Filter</a></span> QOpenGLTexture::<span class="name">minificationFilter</span>() const</h3>
<p>Returns the minification filter.</p>
<p><b>See also </b><a href="qopengltexture.html#setMinificationFilter" translate="no">setMinificationFilter</a>().</p>
<!-- @@@minificationFilter -->
<!-- $$$minimumLevelOfDetail[overload1]$$$minimumLevelOfDetail -->
<h3 class="fn" translate="no" id="minimumLevelOfDetail"><span class="type">float</span> QOpenGLTexture::<span class="name">minimumLevelOfDetail</span>() const</h3>
<p>Returns the minimum level of detail parameter.</p>
<p><b>See also </b><a href="qopengltexture.html#setMinimumLevelOfDetail" translate="no">setMinimumLevelOfDetail</a>(), <a href="qopengltexture.html#maximumLevelOfDetail" translate="no">maximumLevelOfDetail</a>(), and <a href="qopengltexture.html#levelOfDetailRange" translate="no">levelOfDetailRange</a>().</p>
<!-- @@@minimumLevelOfDetail -->
<!-- $$$mipBaseLevel[overload1]$$$mipBaseLevel -->
<h3 class="fn" translate="no" id="mipBaseLevel"><span class="type">int</span> QOpenGLTexture::<span class="name">mipBaseLevel</span>() const</h3>
<p>Returns the mipmap base level used for all texture lookups with this texture. The default is 0.</p>
<p><b>See also </b><a href="qopengltexture.html#setMipBaseLevel" translate="no">setMipBaseLevel</a>(), <a href="qopengltexture.html#mipMaxLevel" translate="no">mipMaxLevel</a>(), and <a href="qopengltexture.html#mipLevelRange" translate="no">mipLevelRange</a>().</p>
<!-- @@@mipBaseLevel -->
<!-- $$$mipLevelRange[overload1]$$$mipLevelRange -->
<h3 class="fn" translate="no" id="mipLevelRange"><span class="type"><a href="../qtcore/qpair-qtcore-proxy.html#QPair-typedef" translate="no">QPair</a></span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; QOpenGLTexture::<span class="name">mipLevelRange</span>() const</h3>
<p>Returns the range of mipmap levels that can be used for texture lookups with this texture.</p>
<p><b>See also </b><a href="qopengltexture.html#setMipLevelRange" translate="no">setMipLevelRange</a>(), <a href="qopengltexture.html#mipBaseLevel" translate="no">mipBaseLevel</a>(), and <a href="qopengltexture.html#mipMaxLevel" translate="no">mipMaxLevel</a>().</p>
<!-- @@@mipLevelRange -->
<!-- $$$mipLevels[overload1]$$$mipLevels -->
<h3 class="fn" translate="no" id="mipLevels"><span class="type">int</span> QOpenGLTexture::<span class="name">mipLevels</span>() const</h3>
<p>Returns the number of mipmap levels for this texture. If storage has not yet been allocated for this texture it returns the requested number of mipmap levels.</p>
<p><b>See also </b><a href="qopengltexture.html#setMipLevels" translate="no">setMipLevels</a>(), <a href="qopengltexture.html#maximumMipLevels" translate="no">maximumMipLevels</a>(), and <a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>().</p>
<!-- @@@mipLevels -->
<!-- $$$mipMaxLevel[overload1]$$$mipMaxLevel -->
<h3 class="fn" translate="no" id="mipMaxLevel"><span class="type">int</span> QOpenGLTexture::<span class="name">mipMaxLevel</span>() const</h3>
<p>Returns the mipmap maximum level used for all texture lookups with this texture.</p>
<p><b>See also </b><a href="qopengltexture.html#setMipMaxLevel" translate="no">setMipMaxLevel</a>(), <a href="qopengltexture.html#mipBaseLevel" translate="no">mipBaseLevel</a>(), and <a href="qopengltexture.html#mipLevelRange" translate="no">mipLevelRange</a>().</p>
<!-- @@@mipMaxLevel -->
<!-- $$$release[overload1]$$$release -->
<h3 class="fn" translate="no" id="release"><span class="type">void</span> QOpenGLTexture::<span class="name">release</span>()</h3>
<p>Unbinds this texture from the currently active texture unit.</p>
<p><b>See also </b><a href="qopengltexture.html#bind" translate="no">bind</a>().</p>
<!-- @@@release -->
<!-- $$$release$$$releaseuintQOpenGLTexture::TextureUnitReset -->
<h3 class="fn" translate="no" id="release-1"><span class="type">void</span> QOpenGLTexture::<span class="name">release</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>unit</i>, <span class="type"><a href="qopengltexture.html#TextureUnitReset-enum" translate="no">QOpenGLTexture::TextureUnitReset</a></span> <i>reset</i> = DontResetTextureUnit)</h3>
<p>Unbinds this texture from texture unit <i translate="no">unit</i>.</p>
<p>If parameter <i translate="no">reset</i> is <code translate="no">true</code> then this function will restore the active unit to the texture unit that was active upon entry.</p>
<!-- @@@release -->
<!-- $$$samples[overload1]$$$samples -->
<h3 class="fn" translate="no" id="samples"><span class="type">int</span> QOpenGLTexture::<span class="name">samples</span>() const</h3>
<p>Returns the number of multisample sample points for this texture. If storage has not yet been allocated for this texture then this function returns the requested number of samples.</p>
<p>For texture targets that do not support multisampling this will return 0.</p>
<p><b>See also </b><a href="qopengltexture.html#setSamples" translate="no">setSamples</a>() and <a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>().</p>
<!-- @@@samples -->
<!-- $$$setAutoMipMapGenerationEnabled[overload1]$$$setAutoMipMapGenerationEnabledbool -->
<h3 class="fn" translate="no" id="setAutoMipMapGenerationEnabled"><span class="type">void</span> QOpenGLTexture::<span class="name">setAutoMipMapGenerationEnabled</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>If <i translate="no">enabled</i> is <code translate="no">true</code>, enables automatic mipmap generation for this texture object to occur whenever the level 0 mipmap data is set via <a href="qopengltexture.html#setData" translate="no">setData</a>().</p>
<p>The automatic mipmap generation is enabled by default.</p>
<div class="admonition note">
<p><b>Note: </b>Mipmap generation is not supported for compressed textures with OpenGL ES 2.0.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#isAutoMipMapGenerationEnabled" translate="no">isAutoMipMapGenerationEnabled</a>() and <a href="qopengltexture.html#generateMipMaps" translate="no">generateMipMaps</a>().</p>
<!-- @@@setAutoMipMapGenerationEnabled -->
<!-- $$$setBorderColor[overload1]$$$setBorderColorconstQColor& -->
<h3 class="fn" translate="no" id="setBorderColor"><span class="type">void</span> QOpenGLTexture::<span class="name">setBorderColor</span>(const <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> &amp;<i>color</i>)</h3>
<p>Sets the border color of the texture to <i translate="no">color</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Mac and Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#borderColor" translate="no">borderColor</a>().</p>
<!-- @@@setBorderColor -->
<!-- $$$setBorderColor$$$setBorderColorfloatfloatfloatfloat -->
<h3 class="fn" translate="no" id="setBorderColor-1"><span class="type">void</span> QOpenGLTexture::<span class="name">setBorderColor</span>(<span class="type">float</span> <i>r</i>, <span class="type">float</span> <i>g</i>, <span class="type">float</span> <i>b</i>, <span class="type">float</span> <i>a</i>)</h3>
<p>Sets the color red to <i translate="no">r</i>, green to <i translate="no">g</i>, blue to <i translate="no">b</i>, and <i translate="no">a</i> to the alpha value.</p>
<p>This is an overloaded function.</p>
<!-- @@@setBorderColor -->
<!-- $$$setBorderColor$$$setBorderColorintintintint -->
<h3 class="fn" translate="no" id="setBorderColor-2"><span class="type">void</span> QOpenGLTexture::<span class="name">setBorderColor</span>(<span class="type">int</span> <i>r</i>, <span class="type">int</span> <i>g</i>, <span class="type">int</span> <i>b</i>, <span class="type">int</span> <i>a</i>)</h3>
<p>Sets the color red to <i translate="no">r</i>, green to <i translate="no">g</i>, blue to <i translate="no">b</i>, and the alpha value to <i translate="no">a</i>.</p>
<p>This is an overloaded function.</p>
<!-- @@@setBorderColor -->
<!-- $$$setBorderColor$$$setBorderColoruintuintuintuint -->
<h3 class="fn" translate="no" id="setBorderColor-3"><span class="type">void</span> QOpenGLTexture::<span class="name">setBorderColor</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>r</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>g</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>b</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>a</i>)</h3>
<p>Sets the color red to <i translate="no">r</i>, green to <i translate="no">g</i>, blue to <i translate="no">b</i>, and the alpha value to <i translate="no">a</i>.</p>
<p>This is an overloaded function.</p>
<!-- @@@setBorderColor -->
<!-- $$$setComparisonFunction[overload1]$$$setComparisonFunctionQOpenGLTexture::ComparisonFunction -->
<h3 class="fn" translate="no" id="setComparisonFunction"><span class="type">void</span> QOpenGLTexture::<span class="name">setComparisonFunction</span>(<span class="type"><a href="qopengltexture.html#ComparisonFunction-enum" translate="no">QOpenGLTexture::ComparisonFunction</a></span> <i>function</i>)</h3>
<p>Sets the texture comparison function on this texture to <i translate="no">function</i>. The texture comparison function is used by shadow samplers when sampling a depth texture.</p>
<p><b>See also </b><a href="qopengltexture.html#comparisonFunction" translate="no">comparisonFunction</a>().</p>
<!-- @@@setComparisonFunction -->
<!-- $$$setComparisonMode[overload1]$$$setComparisonModeQOpenGLTexture::ComparisonMode -->
<h3 class="fn" translate="no" id="setComparisonMode"><span class="type">void</span> QOpenGLTexture::<span class="name">setComparisonMode</span>(<span class="type"><a href="qopengltexture.html#ComparisonMode-enum" translate="no">QOpenGLTexture::ComparisonMode</a></span> <i>mode</i>)</h3>
<p>Sets the texture comparison mode on this texture to <i translate="no">mode</i>. The texture comparison mode is used by shadow samplers when sampling a depth texture.</p>
<p><b>See also </b><a href="qopengltexture.html#comparisonMode" translate="no">comparisonMode</a>().</p>
<!-- @@@setComparisonMode -->
<!-- $$$setCompressedData[overload1]$$$setCompressedDataintintQOpenGLTexture::CubeMapFaceintconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setCompressedData"><span class="type">void</span> QOpenGLTexture::<span class="name">setCompressedData</span>(<span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>layer</i>, <span class="type"><a href="qopengltexture.html#CubeMapFace-enum" translate="no">QOpenGLTexture::CubeMapFace</a></span> <i>cubeFace</i>, <span class="type">int</span> <i>dataSize</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>Uploads compressed pixel <i translate="no">data</i> to <i translate="no">mipLevel</i>, array <i translate="no">layer</i>, and <i translate="no">cubeFace</i>. The pixel transfer can optionally be controlled with <i translate="no">options</i>. The <i translate="no">dataSize</i> argument should specify the size of the data pointed to by <i translate="no">data</i>.</p>
<p>If not using a compressed <a href="qopengltexture.html#format" translate="no">format</a>() then you should use <a href="qopengltexture.html#setData" translate="no">setData</a>() instead of this function.</p>
<!-- @@@setCompressedData -->
<!-- $$$setCompressedData$$$setCompressedDataintintintQOpenGLTexture::CubeMapFaceintconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setCompressedData-1"><span class="type">void</span> QOpenGLTexture::<span class="name">setCompressedData</span>(<span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>layer</i>, <span class="type">int</span> <i>layerCount</i>, <span class="type"><a href="qopengltexture.html#CubeMapFace-enum" translate="no">QOpenGLTexture::CubeMapFace</a></span> <i>cubeFace</i>, <span class="type">int</span> <i>dataSize</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<p>Parameter <i translate="no">layerCount</i> is the number of layers in a texture array that are being uploaded/populated by this call.</p>
<!-- @@@setCompressedData -->
<!-- $$$setCompressedData$$$setCompressedDataintintintconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setCompressedData-2"><span class="type">void</span> QOpenGLTexture::<span class="name">setCompressedData</span>(<span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>layer</i>, <span class="type">int</span> <i>dataSize</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setCompressedData -->
<!-- $$$setCompressedData$$$setCompressedDataintintconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setCompressedData-3"><span class="type">void</span> QOpenGLTexture::<span class="name">setCompressedData</span>(<span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>dataSize</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setCompressedData -->
<!-- $$$setCompressedData$$$setCompressedDataintconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setCompressedData-4"><span class="type">void</span> QOpenGLTexture::<span class="name">setCompressedData</span>(<span class="type">int</span> <i>dataSize</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setCompressedData -->
<!-- $$$setData[overload1]$$$setDataintintQOpenGLTexture::CubeMapFaceQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>layer</i>, <span class="type"><a href="qopengltexture.html#CubeMapFace-enum" translate="no">QOpenGLTexture::CubeMapFace</a></span> <i>cubeFace</i>, <span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>Uploads pixel <i translate="no">data</i> for this texture object <i translate="no">mipLevel</i>, array <i translate="no">layer</i>, and <i translate="no">cubeFace</i>. Storage must have been allocated before uploading pixel data. Some overloads of setData() will set appropriate dimensions, mipmap levels, and array layers and then allocate storage for you if they have enough information to do so. This will be noted in the function documentation.</p>
<p>The structure of the pixel data pointed to by <i translate="no">data</i> is specified by <i translate="no">sourceFormat</i> and <i translate="no">sourceType</i>. The pixel data upload can optionally be controlled by <i translate="no">options</i>.</p>
<p>If using a compressed <a href="qopengltexture.html#format" translate="no">format</a>() then you should use <a href="qopengltexture.html#setCompressedData" translate="no">setCompressedData</a>() instead of this function.</p>
<p><b>See also </b><a href="qopengltexture.html#setCompressedData" translate="no">setCompressedData</a>().</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataintintintQOpenGLTexture::CubeMapFaceQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData-1"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>layer</i>, <span class="type">int</span> <i>layerCount</i>, <span class="type"><a href="qopengltexture.html#CubeMapFace-enum" translate="no">QOpenGLTexture::CubeMapFace</a></span> <i>cubeFace</i>, <span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<p>Parameter <i translate="no">layerCount</i> is the number of layers in a texture array that are being uploaded/populated by this call.</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataintintQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData-2"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>layer</i>, <span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataintQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData-3"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type">int</span> <i>mipLevel</i>, <span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData-4"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataintintintintintintQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData-5"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type">int</span> <i>xOffset</i>, <span class="type">int</span> <i>yOffset</i>, <span class="type">int</span> <i>zOffset</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<p>This overload is to be used to update a part of the texture. Parameters <i translate="no">xOffset</i>, <i translate="no">yOffset</i>, <i translate="no">zOffset</i> specify the texel offsets within the texture. Parameters <i translate="no">width</i>, <i translate="no">height</i> and <i translate="no">depth</i> specify the dimensions of the sub image.</p>
<p>The structure of the pixel data pointed to by <i translate="no">data</i> is specified by <i translate="no">sourceFormat</i> and <i translate="no">sourceType</i>. The pixel data upload can optionally be controlled by <i translate="no">options</i>.</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataintintintintintintintQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData-6"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type">int</span> <i>xOffset</i>, <span class="type">int</span> <i>yOffset</i>, <span class="type">int</span> <i>zOffset</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>mipLevel</i>, <span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<p>This overload is to be used to update a part of the texture. Parameters <i translate="no">xOffset</i>, <i translate="no">yOffset</i>, <i translate="no">zOffset</i> specify the texel offsets within the texture. Parameters <i translate="no">width</i>, <i translate="no">height</i> and <i translate="no">depth</i> specify the dimensions of the sub image. The mip map level the sub image we want to update is specified with <i translate="no">mipLevel</i>.</p>
<p>The structure of the pixel data pointed to by <i translate="no">data</i> is specified by <i translate="no">sourceFormat</i> and <i translate="no">sourceType</i>. The pixel data upload can optionally be controlled by <i translate="no">options</i>.</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataintintintintintintintintQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData-7"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type">int</span> <i>xOffset</i>, <span class="type">int</span> <i>yOffset</i>, <span class="type">int</span> <i>zOffset</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>layer</i>, <span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<p>This overload is to be used to update a part of the texture. Parameters <i translate="no">xOffset</i>, <i translate="no">yOffset</i>, <i translate="no">zOffset</i> specify the texel offsets within the texture. Parameters <i translate="no">width</i>, <i translate="no">height</i> and <i translate="no">depth</i> specify the dimensions of the sub image. The mip map level and layerof the sub image we want to update are specified with <i translate="no">mipLevel</i> and <i translate="no">layer</i>.</p>
<p>The structure of the pixel data pointed to by <i translate="no">data</i> is specified by <i translate="no">sourceFormat</i> and <i translate="no">sourceType</i>. The pixel data upload can optionally be controlled by <i translate="no">options</i>.</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataintintintintintintintintQOpenGLTexture::CubeMapFaceQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData-8"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type">int</span> <i>xOffset</i>, <span class="type">int</span> <i>yOffset</i>, <span class="type">int</span> <i>zOffset</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>layer</i>, <span class="type"><a href="qopengltexture.html#CubeMapFace-enum" translate="no">QOpenGLTexture::CubeMapFace</a></span> <i>face</i>, <span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<p>This overload is to be used to update a part of the texture. Parameters <i translate="no">xOffset</i>, <i translate="no">yOffset</i>, <i translate="no">zOffset</i> specify the texel offsets within the texture. Parameters <i translate="no">width</i>, <i translate="no">height</i> and <i translate="no">depth</i> specify the dimensions of the sub image.The mip map level, layer and cube map face of the sub image we want to update are specified with <i translate="no">mipLevel</i>, <i translate="no">layer</i> and <i translate="no">face</i>.</p>
<p>The structure of the pixel data pointed to by <i translate="no">data</i> is specified by <i translate="no">sourceFormat</i> and <i translate="no">sourceType</i>. The pixel data upload can optionally be controlled by <i translate="no">options</i>.</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataintintintintintintintintQOpenGLTexture::CubeMapFaceintQOpenGLTexture::PixelFormatQOpenGLTexture::PixelTypeconstvoid*constQOpenGLPixelTransferOptions*const -->
<h3 class="fn" translate="no" id="setData-9"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(<span class="type">int</span> <i>xOffset</i>, <span class="type">int</span> <i>yOffset</i>, <span class="type">int</span> <i>zOffset</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>mipLevel</i>, <span class="type">int</span> <i>layer</i>, <span class="type"><a href="qopengltexture.html#CubeMapFace-enum" translate="no">QOpenGLTexture::CubeMapFace</a></span> <i>face</i>, <span class="type">int</span> <i>layerCount</i>, <span class="type"><a href="qopengltexture.html#PixelFormat-enum" translate="no">QOpenGLTexture::PixelFormat</a></span> <i>sourceFormat</i>, <span class="type"><a href="qopengltexture.html#PixelType-enum" translate="no">QOpenGLTexture::PixelType</a></span> <i>sourceType</i>, const <span class="type">void</span> *<i>data</i>, const <span class="type"><a href="qopenglpixeltransferoptions.html" translate="no">QOpenGLPixelTransferOptions</a></span> *const <i>options</i> = nullptr)</h3>
<p>This is an overloaded function.</p>
<p>This overload is to be used to update a part of the texture. Parameters <i translate="no">xOffset</i>, <i translate="no">yOffset</i>, <i translate="no">zOffset</i> specify the texel offsets within the texture. Parameters <i translate="no">width</i>, <i translate="no">height</i> and <i translate="no">depth</i> specify the dimensions of the sub image.The mip map level, starting layer, cube map face and number of layers of the sub image we want to update are specified with <i translate="no">mipLevel</i>, <i translate="no">layer</i>, <i translate="no">face</i> and <i translate="no">layerCount</i>.</p>
<p>The structure of the pixel data pointed to by <i translate="no">data</i> is specified by <i translate="no">sourceFormat</i> and <i translate="no">sourceType</i>. The pixel data upload can optionally be controlled by <i translate="no">options</i>.</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataconstQImage&QOpenGLTexture::MipMapGeneration -->
<h3 class="fn" translate="no" id="setData-10"><span class="type">void</span> QOpenGLTexture::<span class="name">setData</span>(const <span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span> &amp;<i>image</i>, <span class="type"><a href="qopengltexture.html#MipMapGeneration-enum" translate="no">QOpenGLTexture::MipMapGeneration</a></span> <i>genMipMaps</i> = GenerateMipMaps)</h3>
<p>This overload of setData() will allocate storage for you. The pixel data is contained in <i translate="no">image</i>. Mipmaps are generated by default. Set <i translate="no">genMipMaps</i> to <a href="qopengltexture.html#MipMapGeneration-enum" translate="no">DontGenerateMipMaps</a> to turn off mipmap generation.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">image</i> is automatically converted to <a href="../qtgui/qimage.html#Format-enum" translate="no">QImage::Format_RGBA8888</a> which may have performance implications for large images with a different format.</p>
</div>
<p>This is an overloaded function.</p>
<!-- @@@setData -->
<!-- $$$setDepthStencilMode[overload1]$$$setDepthStencilModeQOpenGLTexture::DepthStencilMode -->
<h3 class="fn" translate="no" id="setDepthStencilMode"><span class="type">void</span> QOpenGLTexture::<span class="name">setDepthStencilMode</span>(<span class="type"><a href="qopengltexture.html#DepthStencilMode-enum" translate="no">QOpenGLTexture::DepthStencilMode</a></span> <i>mode</i>)</h3>
<p>If using a texture that has a combined depth/stencil format this function sets which component of the texture is accessed to <i translate="no">mode</i>.</p>
<p>When the parameter is set to <a href="qopengltexture.html#DepthStencilMode-enum" translate="no">DepthMode</a>, then accessing it from the shader will access the depth component as a single float, as normal. But when the parameter is set to <a href="qopengltexture.html#DepthStencilMode-enum" translate="no">StencilMode</a>, the shader will access the stencil component.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Mac and Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#depthStencilMode" translate="no">depthStencilMode</a>().</p>
<!-- @@@setDepthStencilMode -->
<!-- $$$setFixedSamplePositions[overload1]$$$setFixedSamplePositionsbool -->
<h3 class="fn" translate="no" id="setFixedSamplePositions"><span class="type">void</span> QOpenGLTexture::<span class="name">setFixedSamplePositions</span>(<span class="type">bool</span> <i>fixed</i>)</h3>
<p>Sets whether the sample positions and number of samples used with a multisample capable texture target to <i translate="no">fixed</i>. If set to <code translate="no">true</code> the sample positions and number of samples used are the same for all texels in the image and will not depend upon the image size or internal format. This function should be called before storage is allocated for the texture.</p>
<p>For targets that do not support multisampling this function has no effect.</p>
<p>The default value is <code translate="no">true</code>.</p>
<p><b>See also </b><a href="qopengltexture.html#isFixedSamplePositions" translate="no">isFixedSamplePositions</a>() and <a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>().</p>
<!-- @@@setFixedSamplePositions -->
<!-- $$$setFormat[overload1]$$$setFormatQOpenGLTexture::TextureFormat -->
<h3 class="fn" translate="no" id="setFormat"><span class="type">void</span> QOpenGLTexture::<span class="name">setFormat</span>(<span class="type"><a href="qopengltexture.html#TextureFormat-enum" translate="no">QOpenGLTexture::TextureFormat</a></span> <i>format</i>)</h3>
<p>Sets the format of this texture object to <i translate="no">format</i>. This function must be called before texture storage is allocated.</p>
<p>Note that all formats may not be supported. The exact set of supported formats is dependent upon your OpenGL implementation and version.</p>
<p><b>See also </b><a href="qopengltexture.html#format" translate="no">format</a>() and <a href="qopengltexture.html#allocateStorage" translate="no">allocateStorage</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setLayers[overload1]$$$setLayersint -->
<h3 class="fn" translate="no" id="setLayers"><span class="type">void</span> QOpenGLTexture::<span class="name">setLayers</span>(<span class="type">int</span> <i>layers</i>)</h3>
<p>Sets the number of array <i translate="no">layers</i> to allocate storage for. This function should be called before storage is allocated for the texture.</p>
<p>For targets that do not support array layers this function has no effect.</p>
<p><b>See also </b><a href="qopengltexture.html#layers" translate="no">layers</a>() and <a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>().</p>
<!-- @@@setLayers -->
<!-- $$$setLevelOfDetailRange[overload1]$$$setLevelOfDetailRangefloatfloat -->
<h3 class="fn" translate="no" id="setLevelOfDetailRange"><span class="type">void</span> QOpenGLTexture::<span class="name">setLevelOfDetailRange</span>(<span class="type">float</span> <i>min</i>, <span class="type">float</span> <i>max</i>)</h3>
<p>Sets the minimum level of detail parameters to <i translate="no">min</i> and the maximum level to <i translate="no">max</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#levelOfDetailRange" translate="no">levelOfDetailRange</a>(), <a href="qopengltexture.html#setMinimumLevelOfDetail" translate="no">setMinimumLevelOfDetail</a>(), and <a href="qopengltexture.html#setMaximumLevelOfDetail" translate="no">setMaximumLevelOfDetail</a>().</p>
<!-- @@@setLevelOfDetailRange -->
<!-- $$$setLevelofDetailBias[overload1]$$$setLevelofDetailBiasfloat -->
<h3 class="fn" translate="no" id="setLevelofDetailBias"><span class="type">void</span> QOpenGLTexture::<span class="name">setLevelofDetailBias</span>(<span class="type">float</span> <i>bias</i>)</h3>
<p>Sets the level of detail bias to <i translate="no">bias</i>. Level of detail bias affects the point at which mipmapping levels change. Increasing values for level of detail bias makes the overall images blurrier or smoother. Decreasing values make the overall images sharper.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#levelofDetailBias" translate="no">levelofDetailBias</a>().</p>
<!-- @@@setLevelofDetailBias -->
<!-- $$$setMagnificationFilter[overload1]$$$setMagnificationFilterQOpenGLTexture::Filter -->
<h3 class="fn" translate="no" id="setMagnificationFilter"><span class="type">void</span> QOpenGLTexture::<span class="name">setMagnificationFilter</span>(<span class="type"><a href="qopengltexture.html#Filter-enum" translate="no">QOpenGLTexture::Filter</a></span> <i>filter</i>)</h3>
<p>Sets the magnification filter to <i translate="no">filter</i>.</p>
<p><b>See also </b><a href="qopengltexture.html#magnificationFilter" translate="no">magnificationFilter</a>(), <a href="qopengltexture.html#setMinificationFilter" translate="no">setMinificationFilter</a>(), and <a href="qopengltexture.html#setMinMagFilters" translate="no">setMinMagFilters</a>().</p>
<!-- @@@setMagnificationFilter -->
<!-- $$$setMaximumAnisotropy[overload1]$$$setMaximumAnisotropyfloat -->
<h3 class="fn" translate="no" id="setMaximumAnisotropy"><span class="type">void</span> QOpenGLTexture::<span class="name">setMaximumAnisotropy</span>(<span class="type">float</span> <i>anisotropy</i>)</h3>
<p>If your OpenGL implementation supports the GL_EXT_texture_filter_anisotropic extension this function sets the maximum anisotropy level to <i translate="no">anisotropy</i>.</p>
<p><b>See also </b><a href="qopengltexture.html#maximumAnisotropy" translate="no">maximumAnisotropy</a>().</p>
<!-- @@@setMaximumAnisotropy -->
<!-- $$$setMaximumLevelOfDetail[overload1]$$$setMaximumLevelOfDetailfloat -->
<h3 class="fn" translate="no" id="setMaximumLevelOfDetail"><span class="type">void</span> QOpenGLTexture::<span class="name">setMaximumLevelOfDetail</span>(<span class="type">float</span> <i>value</i>)</h3>
<p>Sets the maximum level of detail to <i translate="no">value</i>. This limits the selection of lowest resolution mipmap (highest mipmap level). The default value is 1000.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#maximumLevelOfDetail" translate="no">maximumLevelOfDetail</a>(), <a href="qopengltexture.html#setMinimumLevelOfDetail" translate="no">setMinimumLevelOfDetail</a>(), and <a href="qopengltexture.html#setLevelOfDetailRange" translate="no">setLevelOfDetailRange</a>().</p>
<!-- @@@setMaximumLevelOfDetail -->
<!-- $$$setMinMagFilters[overload1]$$$setMinMagFiltersQOpenGLTexture::FilterQOpenGLTexture::Filter -->
<h3 class="fn" translate="no" id="setMinMagFilters"><span class="type">void</span> QOpenGLTexture::<span class="name">setMinMagFilters</span>(<span class="type"><a href="qopengltexture.html#Filter-enum" translate="no">QOpenGLTexture::Filter</a></span> <i>minificationFilter</i>, <span class="type"><a href="qopengltexture.html#Filter-enum" translate="no">QOpenGLTexture::Filter</a></span> <i>magnificationFilter</i>)</h3>
<p>Sets the minification filter to <i translate="no">minificationFilter</i> and the magnification filter to <i translate="no">magnificationFilter</i>.</p>
<p><b>See also </b><a href="qopengltexture.html#minMagFilters" translate="no">minMagFilters</a>(), <a href="qopengltexture.html#setMinificationFilter" translate="no">setMinificationFilter</a>(), and <a href="qopengltexture.html#setMagnificationFilter" translate="no">setMagnificationFilter</a>().</p>
<!-- @@@setMinMagFilters -->
<!-- $$$setMinificationFilter[overload1]$$$setMinificationFilterQOpenGLTexture::Filter -->
<h3 class="fn" translate="no" id="setMinificationFilter"><span class="type">void</span> QOpenGLTexture::<span class="name">setMinificationFilter</span>(<span class="type"><a href="qopengltexture.html#Filter-enum" translate="no">QOpenGLTexture::Filter</a></span> <i>filter</i>)</h3>
<p>Sets the filter used for minification to <i translate="no">filter</i>.</p>
<p><b>See also </b><a href="qopengltexture.html#minificationFilter" translate="no">minificationFilter</a>(), <a href="qopengltexture.html#setMagnificationFilter" translate="no">setMagnificationFilter</a>(), and <a href="qopengltexture.html#setMinMagFilters" translate="no">setMinMagFilters</a>().</p>
<!-- @@@setMinificationFilter -->
<!-- $$$setMinimumLevelOfDetail[overload1]$$$setMinimumLevelOfDetailfloat -->
<h3 class="fn" translate="no" id="setMinimumLevelOfDetail"><span class="type">void</span> QOpenGLTexture::<span class="name">setMinimumLevelOfDetail</span>(<span class="type">float</span> <i>value</i>)</h3>
<p>Sets the minimum level of detail to <i translate="no">value</i>. This limits the selection of highest resolution mipmap (lowest mipmap level). The default value is -1000.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#minimumLevelOfDetail" translate="no">minimumLevelOfDetail</a>(), <a href="qopengltexture.html#setMaximumLevelOfDetail" translate="no">setMaximumLevelOfDetail</a>(), and <a href="qopengltexture.html#setLevelOfDetailRange" translate="no">setLevelOfDetailRange</a>().</p>
<!-- @@@setMinimumLevelOfDetail -->
<!-- $$$setMipBaseLevel[overload1]$$$setMipBaseLevelint -->
<h3 class="fn" translate="no" id="setMipBaseLevel"><span class="type">void</span> QOpenGLTexture::<span class="name">setMipBaseLevel</span>(<span class="type">int</span> <i>baseLevel</i>)</h3>
<p>Sets the base mipmap level used for all texture lookups with this texture to <i translate="no">baseLevel</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#mipBaseLevel" translate="no">mipBaseLevel</a>(), <a href="qopengltexture.html#setMipMaxLevel" translate="no">setMipMaxLevel</a>(), and <a href="qopengltexture.html#setMipLevelRange" translate="no">setMipLevelRange</a>().</p>
<!-- @@@setMipBaseLevel -->
<!-- $$$setMipLevelRange[overload1]$$$setMipLevelRangeintint -->
<h3 class="fn" translate="no" id="setMipLevelRange"><span class="type">void</span> QOpenGLTexture::<span class="name">setMipLevelRange</span>(<span class="type">int</span> <i>baseLevel</i>, <span class="type">int</span> <i>maxLevel</i>)</h3>
<p>Sets the range of mipmap levels that can be used for texture lookups with this texture to range from <i translate="no">baseLevel</i> to <i translate="no">maxLevel</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#setMipBaseLevel" translate="no">setMipBaseLevel</a>(), <a href="qopengltexture.html#setMipMaxLevel" translate="no">setMipMaxLevel</a>(), and <a href="qopengltexture.html#mipLevelRange" translate="no">mipLevelRange</a>().</p>
<!-- @@@setMipLevelRange -->
<!-- $$$setMipLevels[overload1]$$$setMipLevelsint -->
<h3 class="fn" translate="no" id="setMipLevels"><span class="type">void</span> QOpenGLTexture::<span class="name">setMipLevels</span>(<span class="type">int</span> <i>levels</i>)</h3>
<p>For texture targets that support mipmaps, this function sets the requested number of mipmap <i translate="no">levels</i> to allocate storage for. This function should be called before storage is allocated for the texture.</p>
<p>If the texture target does not support mipmaps this function has no effect.</p>
<p><b>See also </b><a href="qopengltexture.html#mipLevels" translate="no">mipLevels</a>(), <a href="qopengltexture.html#maximumMipLevels" translate="no">maximumMipLevels</a>(), and <a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>().</p>
<!-- @@@setMipLevels -->
<!-- $$$setMipMaxLevel[overload1]$$$setMipMaxLevelint -->
<h3 class="fn" translate="no" id="setMipMaxLevel"><span class="type">void</span> QOpenGLTexture::<span class="name">setMipMaxLevel</span>(<span class="type">int</span> <i>maxLevel</i>)</h3>
<p>Sets the maximum mipmap level used for all texture lookups with this texture to <i translate="no">maxLevel</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#mipMaxLevel" translate="no">mipMaxLevel</a>(), <a href="qopengltexture.html#setMipBaseLevel" translate="no">setMipBaseLevel</a>(), and <a href="qopengltexture.html#setMipLevelRange" translate="no">setMipLevelRange</a>().</p>
<!-- @@@setMipMaxLevel -->
<!-- $$$setSamples[overload1]$$$setSamplesint -->
<h3 class="fn" translate="no" id="setSamples"><span class="type">void</span> QOpenGLTexture::<span class="name">setSamples</span>(<span class="type">int</span> <i>samples</i>)</h3>
<p>Sets the number of <i translate="no">samples</i> to allocate storage for when rendering to a multisample capable texture target. This function should be called before storage is allocated for the texture.</p>
<p>For targets that do not support multisampling this function has no effect.</p>
<p><b>See also </b><a href="qopengltexture.html#samples" translate="no">samples</a>() and <a href="qopengltexture.html#isStorageAllocated" translate="no">isStorageAllocated</a>().</p>
<!-- @@@setSamples -->
<!-- $$$setSize[overload1]$$$setSizeintintint -->
<h3 class="fn" translate="no" id="setSize"><span class="type">void</span> QOpenGLTexture::<span class="name">setSize</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i> = 1, <span class="type">int</span> <i>depth</i> = 1)</h3>
<p>Sets the dimensions of this texture object to <i translate="no">width</i>, <i translate="no">height</i>, and <i translate="no">depth</i>. The default for each dimension is 1. The maximum allowable texture size is dependent upon your OpenGL implementation. Allocating storage for a texture less than the maximum size can still fail if your system is low on resources.</p>
<p>If a non-power-of-two <i translate="no">width</i>, <i translate="no">height</i> or <i translate="no">depth</i> is provided and your OpenGL implementation doesn't have support for repeating non-power-of-two textures, then the wrap mode is automatically set to <a href="qopengltexture.html#WrapMode-enum" translate="no">ClampToEdge</a>.</p>
<p><b>See also </b><a href="qopengltexture.html#width" translate="no">width</a>(), <a href="qopengltexture.html#height" translate="no">height</a>(), and <a href="qopengltexture.html#depth" translate="no">depth</a>().</p>
<!-- @@@setSize -->
<!-- $$$setSwizzleMask[overload1]$$$setSwizzleMaskQOpenGLTexture::SwizzleComponentQOpenGLTexture::SwizzleValue -->
<h3 class="fn" translate="no" id="setSwizzleMask"><span class="type">void</span> QOpenGLTexture::<span class="name">setSwizzleMask</span>(<span class="type"><a href="qopengltexture.html#SwizzleComponent-enum" translate="no">QOpenGLTexture::SwizzleComponent</a></span> <i>component</i>, <span class="type"><a href="qopengltexture.html#SwizzleValue-enum" translate="no">QOpenGLTexture::SwizzleValue</a></span> <i>value</i>)</h3>
<p>GLSL shaders are able to reorder the components of the vec4 returned by texture functions. It is also desirable to be able to control this reordering from CPU side code. This is made possible by swizzle masks since OpenGL 3.3.</p>
<p>Each component of the texture can be mapped to one of the <a href="qopengltexture.html#SwizzleValue-enum" translate="no">SwizzleValue</a> options.</p>
<p>This function maps <i translate="no">component</i> to the output <i translate="no">value</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect on Mac and Qt built for OpenGL ES 2.</p>
</div>
<p><b>See also </b><a href="qopengltexture.html#swizzleMask" translate="no">swizzleMask</a>().</p>
<!-- @@@setSwizzleMask -->
<!-- $$$setSwizzleMask$$$setSwizzleMaskQOpenGLTexture::SwizzleValueQOpenGLTexture::SwizzleValueQOpenGLTexture::SwizzleValueQOpenGLTexture::SwizzleValue -->
<h3 class="fn" translate="no" id="setSwizzleMask-1"><span class="type">void</span> QOpenGLTexture::<span class="name">setSwizzleMask</span>(<span class="type"><a href="qopengltexture.html#SwizzleValue-enum" translate="no">QOpenGLTexture::SwizzleValue</a></span> <i>r</i>, <span class="type"><a href="qopengltexture.html#SwizzleValue-enum" translate="no">QOpenGLTexture::SwizzleValue</a></span> <i>g</i>, <span class="type"><a href="qopengltexture.html#SwizzleValue-enum" translate="no">QOpenGLTexture::SwizzleValue</a></span> <i>b</i>, <span class="type"><a href="qopengltexture.html#SwizzleValue-enum" translate="no">QOpenGLTexture::SwizzleValue</a></span> <i>a</i>)</h3>
<p>Parameters <i translate="no">r</i>, <i translate="no">g</i>, <i translate="no">b</i>, and <i translate="no">a</i> are values used for setting the colors red, green, blue, and the alpha value.</p>
<p>This is an overloaded function.</p>
<!-- @@@setSwizzleMask -->
<!-- $$$setWrapMode[overload1]$$$setWrapModeQOpenGLTexture::WrapMode -->
<h3 class="fn" translate="no" id="setWrapMode"><span class="type">void</span> QOpenGLTexture::<span class="name">setWrapMode</span>(<span class="type"><a href="qopengltexture.html#WrapMode-enum" translate="no">QOpenGLTexture::WrapMode</a></span> <i>mode</i>)</h3>
<p>Sets the wrap (or repeat mode) for all texture dimensions to <i translate="no">mode</i>.</p>
<p><b>See also </b><a href="qopengltexture.html#wrapMode" translate="no">wrapMode</a>().</p>
<!-- @@@setWrapMode -->
<!-- $$$setWrapMode$$$setWrapModeQOpenGLTexture::CoordinateDirectionQOpenGLTexture::WrapMode -->
<h3 class="fn" translate="no" id="setWrapMode-1"><span class="type">void</span> QOpenGLTexture::<span class="name">setWrapMode</span>(<span class="type"><a href="qopengltexture.html#CoordinateDirection-enum" translate="no">QOpenGLTexture::CoordinateDirection</a></span> <i>direction</i>, <span class="type"><a href="qopengltexture.html#WrapMode-enum" translate="no">QOpenGLTexture::WrapMode</a></span> <i>mode</i>)</h3>
<p>Holds the texture dimension <i translate="no">direction</i>.</p>
<p>This is an overloaded function.</p>
<!-- @@@setWrapMode -->
<!-- $$$swizzleMask[overload1]$$$swizzleMaskQOpenGLTexture::SwizzleComponent -->
<h3 class="fn" translate="no" id="swizzleMask"><span class="type"><a href="qopengltexture.html#SwizzleValue-enum" translate="no">QOpenGLTexture::SwizzleValue</a></span> QOpenGLTexture::<span class="name">swizzleMask</span>(<span class="type"><a href="qopengltexture.html#SwizzleComponent-enum" translate="no">QOpenGLTexture::SwizzleComponent</a></span> <i>component</i>) const</h3>
<p>Returns the swizzle mask for texture <i translate="no">component</i>.</p>
<p><b>See also </b><a href="qopengltexture.html#setSwizzleMask" translate="no">setSwizzleMask</a>().</p>
<!-- @@@swizzleMask -->
<!-- $$$target[overload1]$$$target -->
<h3 class="fn" translate="no" id="target"><span class="type"><a href="qopengltexture.html#Target-enum" translate="no">QOpenGLTexture::Target</a></span> QOpenGLTexture::<span class="name">target</span>() const</h3>
<p>Returns the binding target of this texture.</p>
<!-- @@@target -->
<!-- $$$textureId[overload1]$$$textureId -->
<h3 class="fn" translate="no" id="textureId"><span class="type">GLuint</span> QOpenGLTexture::<span class="name">textureId</span>() const</h3>
<p>Returns the name of the underlying OpenGL texture object or 0 if it has not yet been created.</p>
<p><b>See also </b><a href="qopengltexture.html#create" translate="no">create</a>(), <a href="qopengltexture.html#destroy" translate="no">destroy</a>(), and <a href="qopengltexture.html#isCreated" translate="no">isCreated</a>().</p>
<!-- @@@textureId -->
<!-- $$$width[overload1]$$$width -->
<h3 class="fn" translate="no" id="width"><span class="type">int</span> QOpenGLTexture::<span class="name">width</span>() const</h3>
<p>Returns the width of a 1D, 2D or 3D texture.</p>
<p><b>See also </b><a href="qopengltexture.html#height" translate="no">height</a>(), <a href="qopengltexture.html#depth" translate="no">depth</a>(), and <a href="qopengltexture.html#setSize" translate="no">setSize</a>().</p>
<!-- @@@width -->
<!-- $$$wrapMode[overload1]$$$wrapModeQOpenGLTexture::CoordinateDirection -->
<h3 class="fn" translate="no" id="wrapMode"><span class="type"><a href="qopengltexture.html#WrapMode-enum" translate="no">QOpenGLTexture::WrapMode</a></span> QOpenGLTexture::<span class="name">wrapMode</span>(<span class="type"><a href="qopengltexture.html#CoordinateDirection-enum" translate="no">QOpenGLTexture::CoordinateDirection</a></span> <i>direction</i>) const</h3>
<p>Returns the wrap mode for the texture dimension <i translate="no">direction</i>.</p>
<p><b>See also </b><a href="qopengltexture.html#setWrapMode" translate="no">setWrapMode</a>().</p>
<!-- @@@wrapMode -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
