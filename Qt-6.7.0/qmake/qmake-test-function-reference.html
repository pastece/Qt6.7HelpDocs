<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qmake-manual.qdoc -->
  <title>Test Functions | qmake Manual</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qmake-manual.html" translate="no">qmake Manual</a></li>
<li>Test Functions</li>
<li id="buildversion"><a href="qmake-manual.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
  <link rel="prev" href="qmake-function-reference.html" />
<p class="naviNextPrevious headerNavi">
<a class="prevPage" href="qmake-function-reference.html">Replace Functions</a>
</p>
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#built-in-test-functions">Built-in Test Functions</a></li>
<li class="level2"><a href="#cache-variablename-set-add-sub-transient-super-stash-source-variablename">cache(variablename, [set|add|sub] [transient] [super|stash], [source variablename])</a></li>
<li class="level2"><a href="#config-config">CONFIG(config)</a></li>
<li class="level2"><a href="#contains-variablename-value">contains(variablename, value)</a></li>
<li class="level2"><a href="#count-variablename-number">count(variablename, number)</a></li>
<li class="level2"><a href="#debug-level-message">debug(level, message)</a></li>
<li class="level2"><a href="#defined-name-type">defined(name[, type])</a></li>
<li class="level2"><a href="#equals-variablename-value">equals(variablename, value)</a></li>
<li class="level2"><a href="#error-string">error(string)</a></li>
<li class="level2"><a href="#eval-string">eval(string)</a></li>
<li class="level2"><a href="#exists-filename">exists(filename)</a></li>
<li class="level2"><a href="#export-variablename">export(variablename)</a></li>
<li class="level2"><a href="#for-iterate-list">for(iterate, list)</a></li>
<li class="level2"><a href="#greaterthan-variablename-value">greaterThan(variablename, value)</a></li>
<li class="level2"><a href="#if-condition">if(condition)</a></li>
<li class="level2"><a href="#include-filename">include(filename)</a></li>
<li class="level2"><a href="#infile-filename-var-val">infile(filename, var, val)</a></li>
<li class="level2"><a href="#isactiveconfig">isActiveConfig</a></li>
<li class="level2"><a href="#isempty-variablename">isEmpty(variablename)</a></li>
<li class="level2"><a href="#isequal">isEqual</a></li>
<li class="level2"><a href="#lessthan-variablename-value">lessThan(variablename, value)</a></li>
<li class="level2"><a href="#load-feature">load(feature)</a></li>
<li class="level2"><a href="#log-message">log(message)</a></li>
<li class="level2"><a href="#message-string">message(string)</a></li>
<li class="level2"><a href="#mkpath-dirpath">mkpath(dirPath)</a></li>
<li class="level2"><a href="#requires-condition">requires(condition)</a></li>
<li class="level2"><a href="#system-command">system(command)</a></li>
<li class="level2"><a href="#touch-filename-reference-filename">touch(filename, reference_filename)</a></li>
<li class="level2"><a href="#unset-variablename">unset(variablename)</a></li>
<li class="level2"><a href="#versionatleast-variablename-versionnumber">versionAtLeast(variablename, versionNumber)</a></li>
<li class="level2"><a href="#versionatmost-variablename-versionnumber">versionAtMost(variablename, versionNumber)</a></li>
<li class="level2"><a href="#warning-string">warning(string)</a></li>
<li class="level2"><a href="#write-file-filename-variablename-mode">write_file(filename, [variablename, [mode]])</a></li>
<li class="level1"><a href="#test-function-library">Test Function Library</a></li>
<li class="level2"><a href="#packagesexist-packages">packagesExist(packages)</a></li>
<li class="level2"><a href="#preparerecursivetarget-target">prepareRecursiveTarget(target)</a></li>
<li class="level2"><a href="#qtcompiletest-test">qtCompileTest(test)</a></li>
<li class="level2"><a href="#qthavemodule-name">qtHaveModule(name)</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Test Functions</h1>
<!-- $$$qmake-test-function-reference.html-description -->
<div class="descr" id="details">
<p>Test functions return a boolean value that you can test for in the conditional parts of scopes. Test functions can be divided into built-in functions and function libraries.</p>
<p>See also <a href="qmake-function-reference.html" translate="no">Replace Functions</a>.</p>
<h2 id="built-in-test-functions">Built-in Test Functions</h2>
<p>Basic test functions are implemented as built-in functions.</p>
<h3 id="cache-variablename-set-add-sub-transient-super-stash-source-variablename">cache(variablename, [set|add|sub] [transient] [super|stash], [source variablename])</h3>
<p>This is an internal function that you will typically not need.</p>
<p>This function was introduced in Qt 5.0.</p>
<h3 id="config-config">CONFIG(config)</h3>
<p>This function can be used to test for variables placed into the <a href="qmake-variable-reference.html#config" translate="no">CONFIG</a> variable. This is the same as scopes, but has the added advantage that a second parameter can be passed to test for the active config. As the order of values is important in <code translate="no">CONFIG</code> variables (that is, the last one set will be considered the active config for mutually exclusive values) a second parameter can be used to specify a set of values to consider. For example:</p>
<pre class="cpp" translate="no">
 CONFIG = debug
 CONFIG += release
 CONFIG(release, debug|release):message(Release build!) #will print
 CONFIG(debug, debug|release):message(Debug build!) #no print
</pre>
<p>Because release is considered the active setting (for feature parsing) it will be the CONFIG used to generate the build file. In the common case a second parameter is not needed, but for specific mutual exclusive tests it is invaluable.</p>
<h3 id="contains-variablename-value">contains(variablename, value)</h3>
<p>Succeeds if the variable <code translate="no">variablename</code> contains the value <code translate="no">value</code>; otherwise fails. It is possible to specify a regular expression for parameter <i>value</i>.</p>
<p>You can check the return value of this function using a scope.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 contains( drivers, network ) {
     # drivers contains 'network'
     message( &quot;Configuring for network build...&quot; )
     HEADERS += network.h
     SOURCES += network.cpp
 }
</pre>
<p>The contents of the scope are only processed if the <code translate="no">drivers</code> variable contains the value <code translate="no">network</code>. If this is the case, the appropriate files are added to the <a href="qmake-variable-reference.html#sources" translate="no">SOURCES</a> and <a href="qmake-variable-reference.html#headers" translate="no">HEADERS</a> variables.</p>
<h3 id="count-variablename-number">count(variablename, number)</h3>
<p>Succeeds if the variable <code translate="no">variablename</code> contains a list with the specified <code translate="no">number</code> of values; otherwise fails.</p>
<p>This function is used to ensure that declarations inside a scope are only processed if the variable contains the correct number of values. For example:</p>
<pre class="cpp" translate="no">
 options = $$find(CONFIG, &quot;debug&quot;) $$find(CONFIG, &quot;release&quot;)
 count(options, 2) {
     message(Both release and debug specified.)
 }
</pre>
<h3 id="debug-level-message">debug(level, message)</h3>
<p>Checks whether qmake runs at the specified debug level. If yes, it returns true and prints a debug message.</p>
<h3 id="defined-name-type">defined(name[, type])</h3>
<p>Tests whether the function or variable <code translate="no">name</code> is defined. If <code translate="no">type</code> is omitted, checks all functions. To check only variables or particular type of functions, specify <code translate="no">type</code>. It can have the following values:</p>
<ul>
<li><code translate="no">test</code> only checks test functions</li>
<li><code translate="no">replace</code> only checks replace functions</li>
<li><code translate="no">var</code> only checks variables</li>
</ul>
<h3 id="equals-variablename-value">equals(variablename, value)</h3>
<p>Tests whether <code translate="no">variablename</code> equals the string <code translate="no">value</code>.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 TARGET = helloworld
 equals(TARGET, &quot;helloworld&quot;) {
     message(&quot;The target assignment was successful.&quot;)
 }
</pre>
<h3 id="error-string">error(string)</h3>
<p>This function never returns a value. qmake displays <code translate="no">string</code> as an error message to the user and exits. This function should only be used for unrecoverable errors.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 error(An error has occurred in the configuration process.)
</pre>
<h3 id="eval-string">eval(string)</h3>
<p>Evaluates the contents of the string using qmake syntax rules and returns true. Definitions and assignments can be used in the string to modify the values of existing variables or create new definitions.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 eval(TARGET = myapp) {
     message($$TARGET)
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>Quotation marks can be used to delimit the string, and the return value can be discarded if it is not needed.</p>
</div>
<h3 id="exists-filename">exists(filename)</h3>
<p>Tests whether a file with the given <code translate="no">filename</code> exists. If the file exists, the function succeeds; otherwise it fails.</p>
<p>The <code translate="no">filename</code> argument may contain wildcards. In that case, this function succeeds if any file matches.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 exists( $(QTDIR)/lib/libqt-mt* ) {
       message( &quot;Configuring for multi-threaded Qt...&quot; )
       CONFIG += thread
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>&quot;/&quot; should be used as a directory separator, regardless of the platform in use.</p>
</div>
<h3 id="export-variablename">export(variablename)</h3>
<p>Exports the current value of <code translate="no">variablename</code> from the local context of a function to the global context.</p>
<h3 id="for-iterate-list">for(iterate, list)</h3>
<p>Starts a loop that iterates over all values in <code translate="no">list</code>, setting <code translate="no">iterate</code> to each value in turn. As a convenience, if <code translate="no">list</code> is 1..10 then iterate will iterate over the values 1 through 10.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 LIST = 1 2 3
 for(a, LIST):exists(file.$${a}):message(I see a file.$${a}!)
</pre>
<p>Loops can be interrupted with <code translate="no">break()</code>. The <code translate="no">next()</code> statement skips the remainder of the loop's body and continues execution with the next iteration.</p>
<h3 id="greaterthan-variablename-value">greaterThan(variablename, value)</h3>
<p>Tests that the value of <code translate="no">variablename</code> is greater than <code translate="no">value</code>. First, this function attempts a numerical comparison. If at least one of the operands fails to convert, this function does a string comparison.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 ANSWER = 42
 greaterThan(ANSWER, 1) {
     message(&quot;The answer might be correct.&quot;)
 }
</pre>
<p>It is impossible to compare two numbers as strings directly. As a workaround, construct temporary values with a non-numeric prefix and compare these.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 VALUE = 123
 TMP_VALUE = x$$VALUE
 greaterThan(TMP_VALUE, x456): message(&quot;Condition may be true.&quot;)
</pre>
<p>See also <a href="qmake-test-function-reference.html#lessthan-variablename-value" translate="no">lessThan()</a>.</p>
<h3 id="if-condition">if(condition)</h3>
<p>Evaluates <code translate="no">condition</code>. It is used to group boolean expressions.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 if(linux-g++*|macx-g++*):CONFIG(debug, debug|release) {
     message(&quot;We are on Linux or Mac OS, and we are in debug mode.&quot;)
 }
</pre>
<h3 id="include-filename">include(filename)</h3>
<p>Includes the contents of the file specified by <code translate="no">filename</code> into the current project at the point where it is included. This function succeeds if <code translate="no">filename</code> is included; otherwise it fails. The included file is processed immediately.</p>
<p>You can check whether the file was included by using this function as the condition for a scope. For example:</p>
<pre class="cpp" translate="no">
 include( shared.pri )
 OPTIONS = standard custom
 !include( options.pri ) {
     message( &quot;No custom build options specified&quot; )
 OPTIONS -= custom
 }
</pre>
<h3 id="infile-filename-var-val">infile(filename, var, val)</h3>
<p>Succeeds if the file <code translate="no">filename</code> (when parsed by qmake itself) contains the variable <code translate="no">var</code> with a value of <code translate="no">val</code>; otherwise fails. If you do not specify <code translate="no">val</code>, the function tests whether <code translate="no">var</code> has been assigned in the file.</p>
<h3 id="isactiveconfig">isActiveConfig</h3>
<p>This is an alias for the <code translate="no">CONFIG</code> function.</p>
<h3 id="isempty-variablename">isEmpty(variablename)</h3>
<p>Succeeds if the variable <code translate="no">variablename</code> is empty; otherwise fails. This is the equivalent of <code translate="no">count( variablename, 0 )</code>.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 isEmpty( CONFIG ) {
 CONFIG += warn_on debug
 }
</pre>
<h3 id="isequal">isEqual</h3>
<p>This is an alias for the <code translate="no">equals</code> function.</p>
<h3 id="lessthan-variablename-value">lessThan(variablename, value)</h3>
<p>Tests that the value of <code translate="no">variablename</code> is less than <code translate="no">value</code>. Works as <a href="qmake-test-function-reference.html#greaterthan-variablename-value" translate="no">greaterThan()</a>.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 ANSWER = 42
 lessThan(ANSWER, 1) {
     message(&quot;The answer might be wrong.&quot;)
 }
</pre>
<h3 id="load-feature">load(feature)</h3>
<p>Loads the feature file (<code translate="no">.prf</code>) specified by <code translate="no">feature</code>, unless the feature has already been loaded.</p>
<h3 id="log-message">log(message)</h3>
<p>Prints a message on the console. Unlike the <code translate="no">message</code> function, neither prepends text nor appends a line break.</p>
<p>This function was introduced in Qt 5.0.</p>
<p>See also <a href="qmake-test-function-reference.html#message-string" translate="no">message()</a>.</p>
<h3 id="message-string">message(string)</h3>
<p>Always succeeds, and displays <code translate="no">string</code> as a general message to the user. Unlike the <code translate="no">error()</code> function, this function allows processing to continue.</p>
<pre class="cpp" translate="no">
 message( &quot;This is a message&quot; )
</pre>
<p>The above line causes &quot;This is a message&quot; to be written to the console. The use of quotation marks is optional, but recommended.</p>
<div class="admonition note">
<p><b>Note: </b>By default, messages are written out for each Makefile generated by qmake for a given project. If you want to ensure that messages only appear once for each project, test the <code translate="no">build_pass</code> variable <a href="qmake-language.html#scopes" translate="no">in conjunction with a scope</a> to filter out messages during builds. For example:</p>
</div>
<pre class="cpp" translate="no">
 !build_pass:message( &quot;This is a message&quot; )
</pre>
<h3 id="mkpath-dirpath">mkpath(dirPath)</h3>
<p>Creates the directory path <code translate="no">dirPath</code>. This function is a wrapper around the <a href="../qtcore/qdir.html#mkpath" translate="no">QDir::mkpath</a> function.</p>
<p>This function was introduced in Qt 5.0.</p>
<h3 id="requires-condition">requires(condition)</h3>
<p>Evaluates <code translate="no">condition</code>. If the condition is false, qmake skips this project (and its <a href="qmake-variable-reference.html#subdirs" translate="no">SUBDIRS</a>) when building.</p>
<div class="admonition note">
<p><b>Note: </b>You can also use the <a href="qmake-variable-reference.html#requires" translate="no">REQUIRES</a> variable for this purpose. However, we recommend using this function, instead.</p>
</div>
<h3 id="system-command">system(command)</h3>
<p>Executes the given <code translate="no">command</code> in a secondary shell. Succeeds if the command returns with a zero exit status; otherwise fails. You can check the return value of this function using a scope.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 system(&quot;ls /bin&quot;): HAS_BIN = TRUE
</pre>
<p>See also the replace variant of <a href="qmake-function-reference.html#system-command-mode-stsvar" translate="no">system()</a>.</p>
<h3 id="touch-filename-reference-filename">touch(filename, reference_filename)</h3>
<p>Updates the time stamp of <code translate="no">filename</code> to match the time stamp of <code translate="no">reference_filename</code>.</p>
<p>This function was introduced in Qt 5.0.</p>
<h3 id="unset-variablename">unset(variablename)</h3>
<p>Removes <code translate="no">variablename</code> from the current context.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 NARF = zort
 unset(NARF)
 !defined(NARF, var) {
     message(&quot;NARF is not defined.&quot;)
 }
</pre>
<h3 id="versionatleast-variablename-versionnumber">versionAtLeast(variablename, versionNumber)</h3>
<p>Tests that the version number from <code translate="no">variablename</code> is greater than or equal to <code translate="no">versionNumber</code>. The version number is considered to be a sequence of non-negative decimal numbers delimited by '.'; any non-numerical tail of the string will be ignored. Comparison is performed segment-wise from left to right; if one version is a prefix of the other, it is considered smaller.</p>
<p>This function was introduced in Qt 5.10.</p>
<h3 id="versionatmost-variablename-versionnumber">versionAtMost(variablename, versionNumber)</h3>
<p>Tests that the version number from <code translate="no">variablename</code> is less than or equal to <code translate="no">versionNumber</code>. Works as <a href="qmake-test-function-reference.html#versionatleast-variablename-versionnumber" translate="no">versionAtLeast()</a>.</p>
<p>This function was introduced in Qt 5.10.</p>
<h3 id="warning-string">warning(string)</h3>
<p>Always succeeds, and displays <code translate="no">string</code> as a warning message to the user.</p>
<h3 id="write-file-filename-variablename-mode">write_file(filename, [variablename, [mode]])</h3>
<p>Writes the values of <code translate="no">variablename</code> to a file with the name <code translate="no">filename</code>, each value on a separate line. If <code translate="no">variablename</code> is not specified, creates an empty file. If <code translate="no">mode</code> is <code translate="no">append</code> and the file already exists, appends to it instead of replacing it.</p>
<p>This function was introduced in Qt 5.0.</p>
<h2 id="test-function-library">Test Function Library</h2>
<p>Complex test functions are implemented in a library of .prf files.</p>
<h3 id="packagesexist-packages">packagesExist(packages)</h3>
<p>Uses the PKGCONFIG mechanism to determine whether or not the given packages exist at the time of project parsing.</p>
<p>This can be useful to optionally enable or disable features. For example:</p>
<pre class="cpp" translate="no">
 packagesExist(sqlite3 QtNetwork QtDeclarative) {
     DEFINES += USE_FANCY_UI
 }
</pre>
<p>And then, in the code:</p>
<pre class="cpp" translate="no">
 #ifdef USE_FANCY_UI
     // Use the fancy UI, as we have extra packages available
 #endif
</pre>
<h3 id="preparerecursivetarget-target">prepareRecursiveTarget(target)</h3>
<p>Facilitates the creation of project-wide targets similar to the <code translate="no">install</code> target by preparing a target that iterates through all subdirectories. For example:</p>
<pre class="cpp" translate="no">
 TEMPLATE = subdirs
 SUBDIRS = one two three
 prepareRecursiveTarget(check)
</pre>
<p>Subdirs that have <code translate="no">have_no_default</code> or <code translate="no">no_&lt;target&gt;_target</code> specified in their .CONFIG are excluded from this target:</p>
<pre class="cpp" translate="no">
 two.CONFIG += no_check_target
</pre>
<p>You must add the prepared target manually to <a href="qmake-variable-reference.html#qmake-extra-targets" translate="no">QMAKE_EXTRA_TARGETS</a>:</p>
<pre class="cpp" translate="no">
 QMAKE_EXTRA_TARGETS += check
</pre>
<p>To make the target global, the code above needs to be included into every subdirs subproject. In addition, to make these targets do anything, non-subdirs subprojects need to include respective code. The easiest way to achieve this is creating a custom feature file. For example:</p>
<pre class="cpp" translate="no">
 # &lt;project root&gt;/features/mycheck.prf
 equals(TEMPLATE, subdirs) {
     prepareRecursiveTarget(check)
 } else {
     check.commands = echo hello user
 }
 QMAKE_EXTRA_TARGETS += check
</pre>
<p>The feature file needs to be injected into each subproject, for example by .qmake.conf:</p>
<pre class="cpp" translate="no">
 # &lt;project root&gt;/.qmake.conf
 CONFIG += mycheck
</pre>
<p>This function was introduced in Qt 5.0.</p>
<h3 id="qtcompiletest-test">qtCompileTest(test)</h3>
<p>Builds a test project. If the test passes, true is returned and <code translate="no">config_&lt;test&gt;</code> is added to the <a href="qmake-variable-reference.html#config" translate="no">CONFIG</a> variable. Otherwise, false is returned.</p>
<p>To make this function available, you need to load the respective feature file:</p>
<pre class="cpp" translate="no">
 # &lt;project root&gt;/project.pro
 load(configure)
</pre>
<p>This also sets the variable QMAKE_CONFIG_TESTS_DIR to the <code translate="no">config.tests</code> subdirectory of the project's parent directory. It is possible to override this value after loading the feature file.</p>
<p>Inside the tests directory, there has to be one subdirectory per test that contains a simple qmake project. The following code snippet illustrates the .pro file of the project:</p>
<pre class="cpp" translate="no">
 # &lt;project root&gt;/config.tests/test/test.pro
 SOURCES = main.cpp
 LIBS += -ltheFeature
 # Note that the test project is built without Qt by default.
</pre>
<p>The following code snippet illustrates the main .cpp file of the project:</p>
<pre class="cpp" translate="no">
 // &lt;project root&gt;/config.tests/test/main.cpp
 #include &lt;TheFeature/MainHeader.h&gt;
 int main() { return featureFunction(); }
</pre>
<p>The following code snippet shows the invocation of the test:</p>
<pre class="cpp" translate="no">
 # &lt;project root&gt;/project.pro
 qtCompileTest(test)
</pre>
<p>If the test project is built successfully, the test passes.</p>
<p>The test results are automatically cached, which also makes them available to all subprojects. It is therefore recommended to run all configuration tests in the top-level project file.</p>
<p>To suppress the re-use of cached results, pass <code translate="no">CONFIG+=recheck</code> to qmake.</p>
<p>See also <a href="qmake-test-function-reference.html#load-feature" translate="no">load()</a>.</p>
<p>This function was introduced in Qt 5.0.</p>
<h3 id="qthavemodule-name">qtHaveModule(name)</h3>
<p>Checks whether the Qt module specified by <code translate="no">name</code> is present. For a list of possible values, see <a href="qmake-variable-reference.html#qt" translate="no">QT</a>.</p>
<p>This function was introduced in Qt 5.0.1.</p>
</div>
<!-- @@@qmake-test-function-reference.html -->
<p class="naviNextPrevious footerNavi">
<a class="prevPage" href="qmake-function-reference.html">Replace Functions</a>
</p>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
