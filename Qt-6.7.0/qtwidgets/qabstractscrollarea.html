<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qabstractscrollarea.cpp -->
  <meta name="description" content="The QAbstractScrollArea widget provides a scrolling area with on-demand scroll bars.">
  <title>QAbstractScrollArea Class | Qt Widgets 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtwidgets-index.html" translate="no">Qt Widgets</a></li>
<li><a href="qtwidgets-module.html" translate="no">C++ Classes</a></li>
<li>QAbstractScrollArea</li>
<li id="buildversion"><a href="qtwidgets-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QAbstractScrollArea Class</h1>
<!-- $$$QAbstractScrollArea-brief -->
<p>The QAbstractScrollArea widget provides a scrolling area with on-demand scroll bars. <a href="#details">More...</a></p>
<!-- @@@QAbstractScrollArea -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QAbstractScrollArea&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Widgets) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Widgets)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += widgets</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qframe.html" translate="no">QFrame</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qabstractitemview.html" translate="no">QAbstractItemView</a>, <a href="qgraphicsview.html" translate="no">QGraphicsView</a>, <a href="qmdiarea.html" translate="no">QMdiArea</a>, <a href="qplaintextedit.html" translate="no">QPlainTextEdit</a>, <a href="qscrollarea.html" translate="no">QScrollArea</a>, and <a href="qtextedit.html" translate="no">QTextEdit</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qabstractscrollarea-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#SizeAdjustPolicy-enum" translate="no">SizeAdjustPolicy</a></b> { AdjustIgnored, AdjustToContents, AdjustToContentsOnFirstShow }</td></tr>
</table></div>
<h2 id="properties">Properties</h2>
<ul>
<li class="fn" translate="no"><b><a href="qabstractscrollarea.html#horizontalScrollBarPolicy-prop" translate="no">horizontalScrollBarPolicy</a></b> : Qt::ScrollBarPolicy</li>
<li class="fn" translate="no"><b><a href="qabstractscrollarea.html#sizeAdjustPolicy-prop" translate="no">sizeAdjustPolicy</a></b> : SizeAdjustPolicy</li>
<li class="fn" translate="no"><b><a href="qabstractscrollarea.html#verticalScrollBarPolicy-prop" translate="no">verticalScrollBarPolicy</a></b> : Qt::ScrollBarPolicy</li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#QAbstractScrollArea" translate="no">QAbstractScrollArea</a></b>(QWidget *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#dtor.QAbstractScrollArea" translate="no">~QAbstractScrollArea</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#addScrollBarWidget" translate="no">addScrollBarWidget</a></b>(QWidget *<i>widget</i>, Qt::Alignment <i>alignment</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#cornerWidget" translate="no">cornerWidget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QScrollBar *</td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#horizontalScrollBar" translate="no">horizontalScrollBar</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::ScrollBarPolicy </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#horizontalScrollBarPolicy-prop" translate="no">horizontalScrollBarPolicy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#maximumViewportSize" translate="no">maximumViewportSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidgetList </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#scrollBarWidgets" translate="no">scrollBarWidgets</a></b>(Qt::Alignment <i>alignment</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#setCornerWidget" translate="no">setCornerWidget</a></b>(QWidget *<i>widget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#setHorizontalScrollBar" translate="no">setHorizontalScrollBar</a></b>(QScrollBar *<i>scrollBar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#horizontalScrollBarPolicy-prop" translate="no">setHorizontalScrollBarPolicy</a></b>(Qt::ScrollBarPolicy)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#sizeAdjustPolicy-prop" translate="no">setSizeAdjustPolicy</a></b>(QAbstractScrollArea::SizeAdjustPolicy <i>policy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#setVerticalScrollBar" translate="no">setVerticalScrollBar</a></b>(QScrollBar *<i>scrollBar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#verticalScrollBarPolicy-prop" translate="no">setVerticalScrollBarPolicy</a></b>(Qt::ScrollBarPolicy)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#setViewport" translate="no">setViewport</a></b>(QWidget *<i>widget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#setupViewport" translate="no">setupViewport</a></b>(QWidget *<i>viewport</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractScrollArea::SizeAdjustPolicy </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#sizeAdjustPolicy-prop" translate="no">sizeAdjustPolicy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QScrollBar *</td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#verticalScrollBar" translate="no">verticalScrollBar</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::ScrollBarPolicy </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#verticalScrollBarPolicy-prop" translate="no">verticalScrollBarPolicy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#viewport" translate="no">viewport</a></b>() const</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#minimumSizeHint" translate="no">minimumSizeHint</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#sizeHint" translate="no">sizeHint</a></b>() const override</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#scrollContentsBy" translate="no">scrollContentsBy</a></b>(int <i>dx</i>, int <i>dy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#setViewportMargins" translate="no">setViewportMargins</a></b>(int <i>left</i>, int <i>top</i>, int <i>right</i>, int <i>bottom</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#setViewportMargins-1" translate="no">setViewportMargins</a></b>(const QMargins &amp;<i>margins</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#viewportEvent" translate="no">viewportEvent</a></b>(QEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMargins </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#viewportMargins" translate="no">viewportMargins</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#viewportSizeHint" translate="no">viewportSizeHint</a></b>() const</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#contextMenuEvent" translate="no">contextMenuEvent</a></b>(QContextMenuEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#dragEnterEvent" translate="no">dragEnterEvent</a></b>(QDragEnterEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#dragLeaveEvent" translate="no">dragLeaveEvent</a></b>(QDragLeaveEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#dragMoveEvent" translate="no">dragMoveEvent</a></b>(QDragMoveEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#dropEvent" translate="no">dropEvent</a></b>(QDropEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#event" translate="no">event</a></b>(QEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#keyPressEvent" translate="no">keyPressEvent</a></b>(QKeyEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#mouseDoubleClickEvent" translate="no">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#mouseMoveEvent" translate="no">mouseMoveEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#mousePressEvent" translate="no">mousePressEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#mouseReleaseEvent" translate="no">mouseReleaseEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#paintEvent" translate="no">paintEvent</a></b>(QPaintEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#resizeEvent" translate="no">resizeEvent</a></b>(QResizeEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractscrollarea.html#wheelEvent" translate="no">wheelEvent</a></b>(QWheelEvent *<i>e</i>) override</td></tr>
</table></div>
<!-- $$$QAbstractScrollArea-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QAbstractScrollArea is a low-level abstraction of a scrolling area. The area provides a central widget called the viewport, in which the contents of the area is to be scrolled (i.e, the visible parts of the contents are rendered in the viewport).</p>
<p>Next to the viewport is a vertical scroll bar, and below is a horizontal scroll bar. When all of the area contents fits in the viewport, each scroll bar can be either visible or hidden depending on the scroll bar's <a href="../qtcore/qt.html#ScrollBarPolicy-enum" translate="no">Qt::ScrollBarPolicy</a>. When a scroll bar is hidden, the viewport expands in order to cover all available space. When a scroll bar becomes visible again, the viewport shrinks in order to make room for the scroll bar.</p>
<p>It is possible to reserve a margin area around the viewport, see <a href="qabstractscrollarea.html#setViewportMargins" translate="no">setViewportMargins</a>(). The feature is mostly used to place a <a href="qheaderview.html" translate="no">QHeaderView</a> widget above or beside the scrolling area. Subclasses of QAbstractScrollArea should implement margins.</p>
<p>When inheriting QAbstractScrollArea, you need to do the following:</p>
<ul>
<li>Control the scroll bars by setting their range, value, page step, and tracking their movements.</li>
<li>Draw the contents of the area in the viewport according to the values of the scroll bars.</li>
<li>Handle events received by the viewport in <a href="qabstractscrollarea.html#viewportEvent" translate="no">viewportEvent</a>() - notably resize events.</li>
<li>Use <code translate="no">viewport-&gt;update()</code> to update the contents of the viewport instead of <a href="qwidget.html#update" translate="no">update</a>() as all painting operations take place on the viewport.</li>
</ul>
<p>With a scroll bar policy of <a href="../qtcore/qt.html#ScrollBarPolicy-enum" translate="no">Qt::ScrollBarAsNeeded</a> (the default), QAbstractScrollArea shows scroll bars when they provide a non-zero scrolling range, and hides them otherwise.</p>
<p>The scroll bars and viewport should be updated whenever the viewport receives a resize event or the size of the contents changes. The viewport also needs to be updated when the scroll bars values change. The initial values of the scroll bars are often set when the area receives new contents.</p>
<p>We give a simple example, in which we have implemented a scroll area that can scroll any <a href="qwidget.html" translate="no">QWidget</a>. We make the widget a child of the viewport; this way, we do not have to calculate which part of the widget to draw but can simply move the widget with <a href="qwidget.html#pos-prop" translate="no">QWidget::move</a>(). When the area contents or the viewport size changes, we do the following:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> areaSize <span class="operator">=</span> viewport()<span class="operator">-</span><span class="operator">&gt;</span>size();
     <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span>  widgetSize <span class="operator">=</span> widget<span class="operator">-</span><span class="operator">&gt;</span>size();

     verticalScrollBar()<span class="operator">-</span><span class="operator">&gt;</span>setPageStep(areaSize<span class="operator">.</span>height());
     horizontalScrollBar()<span class="operator">-</span><span class="operator">&gt;</span>setPageStep(areaSize<span class="operator">.</span>width());
     verticalScrollBar()<span class="operator">-</span><span class="operator">&gt;</span>setRange(<span class="number">0</span><span class="operator">,</span> widgetSize<span class="operator">.</span>height() <span class="operator">-</span> areaSize<span class="operator">.</span>height());
     horizontalScrollBar()<span class="operator">-</span><span class="operator">&gt;</span>setRange(<span class="number">0</span><span class="operator">,</span> widgetSize<span class="operator">.</span>width() <span class="operator">-</span> areaSize<span class="operator">.</span>width());
     updateWidgetPosition();
</pre>
<p>When the scroll bars change value, we need to update the widget position, i.e., find the part of the widget that is to be drawn in the viewport:</p>
<pre class="cpp" translate="no">
     <span class="type">int</span> hvalue <span class="operator">=</span> horizontalScrollBar()<span class="operator">-</span><span class="operator">&gt;</span>value();
     <span class="type">int</span> vvalue <span class="operator">=</span> verticalScrollBar()<span class="operator">-</span><span class="operator">&gt;</span>value();
     <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> topLeft <span class="operator">=</span> viewport()<span class="operator">-</span><span class="operator">&gt;</span>rect()<span class="operator">.</span>topLeft();

     widget<span class="operator">-</span><span class="operator">&gt;</span>move(topLeft<span class="operator">.</span>x() <span class="operator">-</span> hvalue<span class="operator">,</span> topLeft<span class="operator">.</span>y() <span class="operator">-</span> vvalue);
</pre>
<p>In order to track scroll bar movements, reimplement the virtual function <a href="qabstractscrollarea.html#scrollContentsBy" translate="no">scrollContentsBy</a>(). In order to fine-tune scrolling behavior, connect to a scroll bar's <a href="qabstractslider.html#actionTriggered" translate="no">QAbstractSlider::actionTriggered</a>() signal and adjust the <a href="qabstractslider.html#sliderPosition-prop" translate="no">QAbstractSlider::sliderPosition</a> as you wish.</p>
<p>For convenience, QAbstractScrollArea makes all viewport events available in the virtual <a href="qabstractscrollarea.html#viewportEvent" translate="no">viewportEvent</a>() handler. <a href="qwidget.html" translate="no">QWidget</a>'s specialized handlers are remapped to viewport events in the cases where this makes sense. The remapped specialized handlers are: <a href="qabstractscrollarea.html#paintEvent" translate="no">paintEvent</a>(), <a href="qabstractscrollarea.html#mousePressEvent" translate="no">mousePressEvent</a>(), <a href="qabstractscrollarea.html#mouseReleaseEvent" translate="no">mouseReleaseEvent</a>(), <a href="qabstractscrollarea.html#mouseDoubleClickEvent" translate="no">mouseDoubleClickEvent</a>(), <a href="qabstractscrollarea.html#mouseMoveEvent" translate="no">mouseMoveEvent</a>(), <a href="qabstractscrollarea.html#wheelEvent" translate="no">wheelEvent</a>(), <a href="qabstractscrollarea.html#dragEnterEvent" translate="no">dragEnterEvent</a>(), <a href="qabstractscrollarea.html#dragMoveEvent" translate="no">dragMoveEvent</a>(), <a href="qabstractscrollarea.html#dragLeaveEvent" translate="no">dragLeaveEvent</a>(), <a href="qabstractscrollarea.html#dropEvent" translate="no">dropEvent</a>(), <a href="qabstractscrollarea.html#contextMenuEvent" translate="no">contextMenuEvent</a>(), and <a href="qabstractscrollarea.html#resizeEvent" translate="no">resizeEvent</a>().</p>
<p><a href="qscrollarea.html" translate="no">QScrollArea</a>, which inherits QAbstractScrollArea, provides smooth scrolling for any <a href="qwidget.html" translate="no">QWidget</a> (i.e., the widget is scrolled pixel by pixel). You only need to subclass QAbstractScrollArea if you need more specialized behavior. This is, for instance, true if the entire contents of the area is not suitable for being drawn on a <a href="qwidget.html" translate="no">QWidget</a> or if you do not want smooth scrolling.</p>
</div>
<p><b>See also </b><a href="qscrollarea.html" translate="no">QScrollArea</a>.</p>
<!-- @@@QAbstractScrollArea -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$SizeAdjustPolicy$$$AdjustIgnored$$$AdjustToContentsOnFirstShow$$$AdjustToContents -->
<h3 class="fn" translate="no" id="SizeAdjustPolicy-enum">enum QAbstractScrollArea::<span class="name">SizeAdjustPolicy</span></h3>
<p>This enum specifies how the size hint of the <a href="qabstractscrollarea.html" translate="no">QAbstractScrollArea</a> should adjust when the size of the viewport changes.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractScrollArea::AdjustIgnored</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The scroll area will behave like before - and not do any adjust.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractScrollArea::AdjustToContents</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The scroll area will always adjust to the viewport</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractScrollArea::AdjustToContentsOnFirstShow</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The scroll area will adjust to its viewport the first time it is shown.</td></tr>
</table></div>
<!-- @@@SizeAdjustPolicy -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$horizontalScrollBarPolicy-prop$$$horizontalScrollBarPolicy$$$setHorizontalScrollBarPolicyQt::ScrollBarPolicy -->
<h3 class="fn" translate="no" id="horizontalScrollBarPolicy-prop"><span class="name">horizontalScrollBarPolicy</span> : <span class="type"><a href="../qtcore/qt.html#ScrollBarPolicy-enum" translate="no">Qt::ScrollBarPolicy</a></span></h3>
<p>This property holds the policy for the horizontal scroll bar</p>
<p>The default policy is <a href="../qtcore/qt.html#ScrollBarPolicy-enum" translate="no">Qt::ScrollBarAsNeeded</a>.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::ScrollBarPolicy </td><td class="memItemRight bottomAlign"><span class="name"><b>horizontalScrollBarPolicy</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setHorizontalScrollBarPolicy</b></span>(Qt::ScrollBarPolicy)</td></tr>
</table></div>
<p><b>See also </b><a href="qabstractscrollarea.html#verticalScrollBarPolicy-prop" translate="no">verticalScrollBarPolicy</a>.</p>
<!-- @@@horizontalScrollBarPolicy -->
<!-- $$$sizeAdjustPolicy-prop$$$sizeAdjustPolicy$$$setSizeAdjustPolicyQAbstractScrollArea::SizeAdjustPolicy -->
<h3 class="fn" translate="no" id="sizeAdjustPolicy-prop"><span class="name">sizeAdjustPolicy</span> : <span class="type"><a href="qabstractscrollarea.html#SizeAdjustPolicy-enum" translate="no">SizeAdjustPolicy</a></span></h3>
<p>This property holds the policy describing how the size of the scroll area changes when the size of the viewport changes.</p>
<p>The default policy is <a href="qabstractscrollarea.html#SizeAdjustPolicy-enum" translate="no">QAbstractScrollArea::AdjustIgnored</a>. Changing this property might actually resize the scrollarea.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QAbstractScrollArea::SizeAdjustPolicy </td><td class="memItemRight bottomAlign"><span class="name"><b>sizeAdjustPolicy</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSizeAdjustPolicy</b></span>(QAbstractScrollArea::SizeAdjustPolicy <i>policy</i>)</td></tr>
</table></div>
<!-- @@@sizeAdjustPolicy -->
<!-- $$$verticalScrollBarPolicy-prop$$$verticalScrollBarPolicy$$$setVerticalScrollBarPolicyQt::ScrollBarPolicy -->
<h3 class="fn" translate="no" id="verticalScrollBarPolicy-prop"><span class="name">verticalScrollBarPolicy</span> : <span class="type"><a href="../qtcore/qt.html#ScrollBarPolicy-enum" translate="no">Qt::ScrollBarPolicy</a></span></h3>
<p>This property holds the policy for the vertical scroll bar</p>
<p>The default policy is <a href="../qtcore/qt.html#ScrollBarPolicy-enum" translate="no">Qt::ScrollBarAsNeeded</a>.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::ScrollBarPolicy </td><td class="memItemRight bottomAlign"><span class="name"><b>verticalScrollBarPolicy</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setVerticalScrollBarPolicy</b></span>(Qt::ScrollBarPolicy)</td></tr>
</table></div>
<p><b>See also </b><a href="qabstractscrollarea.html#horizontalScrollBarPolicy-prop" translate="no">horizontalScrollBarPolicy</a>.</p>
<!-- @@@verticalScrollBarPolicy -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QAbstractScrollArea[overload1]$$$QAbstractScrollAreaQWidget* -->
<h3 class="fn" translate="no" id="QAbstractScrollArea"><code class="details extra" translate="no">[explicit]</code> QAbstractScrollArea::<span class="name">QAbstractScrollArea</span>(<span class="type"><a href="qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a viewport.</p>
<p>The <i translate="no">parent</i> argument is sent to the <a href="qwidget.html" translate="no">QWidget</a> constructor.</p>
<!-- @@@QAbstractScrollArea -->
<!-- $$$~QAbstractScrollArea[overload1]$$$~QAbstractScrollArea -->
<h3 class="fn" translate="no" id="dtor.QAbstractScrollArea"><code class="details extra" translate="no">[virtual noexcept]</code> QAbstractScrollArea::<span class="name">~QAbstractScrollArea</span>()</h3>
<p>Destroys the viewport.</p>
<!-- @@@~QAbstractScrollArea -->
<!-- $$$addScrollBarWidget[overload1]$$$addScrollBarWidgetQWidget*Qt::Alignment -->
<h3 class="fn" translate="no" id="addScrollBarWidget"><span class="type">void</span> QAbstractScrollArea::<span class="name">addScrollBarWidget</span>(<span class="type"><a href="qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qt.html#AlignmentFlag-enum" translate="no">Qt::Alignment</a></span> <i>alignment</i>)</h3>
<p>Adds <i translate="no">widget</i> as a scroll bar widget in the location specified by <i translate="no">alignment</i>.</p>
<p>Scroll bar widgets are shown next to the horizontal or vertical scroll bar, and can be placed on either side of it. If you want the scroll bar widgets to be always visible, set the scrollBarPolicy for the corresponding scroll bar to <code translate="no">AlwaysOn</code>.</p>
<p><i translate="no">alignment</i> must be one of Qt::Alignleft and <a href="../qtcore/qt.html#AlignmentFlag-enum" translate="no">Qt::AlignRight</a>, which maps to the horizontal scroll bar, or <a href="../qtcore/qt.html#AlignmentFlag-enum" translate="no">Qt::AlignTop</a> and <a href="../qtcore/qt.html#AlignmentFlag-enum" translate="no">Qt::AlignBottom</a>, which maps to the vertical scroll bar.</p>
<p>A scroll bar widget can be removed by either re-parenting the widget or deleting it. It's also possible to hide a widget with <a href="qwidget.html#hide" translate="no">QWidget::hide</a>()</p>
<p>The scroll bar widget will be resized to fit the scroll bar geometry for the current style. The following describes the case for scroll bar widgets on the horizontal scroll bar:</p>
<p>The height of the widget will be set to match the height of the scroll bar. To control the width of the widget, use <a href="qwidget.html#minimumWidth-prop" translate="no">QWidget::setMinimumWidth</a> and <a href="qwidget.html#maximumWidth-prop" translate="no">QWidget::setMaximumWidth</a>, or implement <a href="qwidget.html#sizeHint-prop" translate="no">QWidget::sizeHint</a>() and set a horizontal size policy. If you want a square widget, call <a href="qstyle.html#pixelMetric" translate="no">QStyle::pixelMetric</a>(<a href="qstyle.html#PixelMetric-enum" translate="no">QStyle::PM_ScrollBarExtent</a>) and set the width to this value.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#scrollBarWidgets" translate="no">scrollBarWidgets</a>().</p>
<!-- @@@addScrollBarWidget -->
<!-- $$$contextMenuEvent[overload1]$$$contextMenuEventQContextMenuEvent* -->
<h3 class="fn" translate="no" id="contextMenuEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">contextMenuEvent</span>(<span class="type"><a href="../qtgui/qcontextmenuevent.html" translate="no">QContextMenuEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#contextMenuEvent" translate="no">QWidget::contextMenuEvent</a>(QContextMenuEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive context menu events for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget. The event is passed in <i translate="no">e</i>.</p>
<p><b>See also </b><a href="qwidget.html#contextMenuEvent" translate="no">QWidget::contextMenuEvent</a>().</p>
<!-- @@@contextMenuEvent -->
<!-- $$$cornerWidget[overload1]$$$cornerWidget -->
<h3 class="fn" translate="no" id="cornerWidget"><span class="type"><a href="qwidget.html#QWidget" translate="no">QWidget</a></span> *QAbstractScrollArea::<span class="name">cornerWidget</span>() const</h3>
<p>Returns the widget in the corner between the two scroll bars.</p>
<p>By default, no corner widget is present.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#setCornerWidget" translate="no">setCornerWidget</a>().</p>
<!-- @@@cornerWidget -->
<!-- $$$dragEnterEvent[overload1]$$$dragEnterEventQDragEnterEvent* -->
<h3 class="fn" translate="no" id="dragEnterEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">dragEnterEvent</span>(<span class="type"><a href="../qtgui/qdragenterevent.html" translate="no">QDragEnterEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="qwidget.html#dragEnterEvent" translate="no">QWidget::dragEnterEvent</a>(QDragEnterEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive drag enter events (passed in <i translate="no">event</i>), for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget.</p>
<p><b>See also </b><a href="qwidget.html#dragEnterEvent" translate="no">QWidget::dragEnterEvent</a>().</p>
<!-- @@@dragEnterEvent -->
<!-- $$$dragLeaveEvent[overload1]$$$dragLeaveEventQDragLeaveEvent* -->
<h3 class="fn" translate="no" id="dragLeaveEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">dragLeaveEvent</span>(<span class="type"><a href="../qtgui/qdragleaveevent.html" translate="no">QDragLeaveEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="qwidget.html#dragLeaveEvent" translate="no">QWidget::dragLeaveEvent</a>(QDragLeaveEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive drag leave events (passed in <i translate="no">event</i>), for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget.</p>
<p><b>See also </b><a href="qwidget.html#dragLeaveEvent" translate="no">QWidget::dragLeaveEvent</a>().</p>
<!-- @@@dragLeaveEvent -->
<!-- $$$dragMoveEvent[overload1]$$$dragMoveEventQDragMoveEvent* -->
<h3 class="fn" translate="no" id="dragMoveEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">dragMoveEvent</span>(<span class="type"><a href="../qtgui/qdragmoveevent.html" translate="no">QDragMoveEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="qwidget.html#dragMoveEvent" translate="no">QWidget::dragMoveEvent</a>(QDragMoveEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive drag move events (passed in <i translate="no">event</i>), for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget.</p>
<p><b>See also </b><a href="qwidget.html#dragMoveEvent" translate="no">QWidget::dragMoveEvent</a>().</p>
<!-- @@@dragMoveEvent -->
<!-- $$$dropEvent[overload1]$$$dropEventQDropEvent* -->
<h3 class="fn" translate="no" id="dropEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">dropEvent</span>(<span class="type"><a href="../qtgui/qdropevent.html" translate="no">QDropEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="qwidget.html#dropEvent" translate="no">QWidget::dropEvent</a>(QDropEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive drop events (passed in <i translate="no">event</i>), for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget.</p>
<p><b>See also </b><a href="qwidget.html#dropEvent" translate="no">QWidget::dropEvent</a>().</p>
<!-- @@@dropEvent -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" translate="no" id="event"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">bool</span> QAbstractScrollArea::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="qframe.html#event" translate="no">QFrame::event</a>(QEvent *e).</p>
<p>This is the main event handler for the <a href="qabstractscrollarea.html" translate="no">QAbstractScrollArea</a> widget (<i>not</i> the scrolling area <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>()). The specified <i translate="no">event</i> is a general event object that may need to be cast to the appropriate class depending on its type.</p>
<p><b>See also </b><a href="../qtcore/qevent.html#type" translate="no">QEvent::type</a>().</p>
<!-- @@@event -->
<!-- $$$horizontalScrollBar[overload1]$$$horizontalScrollBar -->
<h3 class="fn" translate="no" id="horizontalScrollBar"><span class="type"><a href="qscrollbar.html" translate="no">QScrollBar</a></span> *QAbstractScrollArea::<span class="name">horizontalScrollBar</span>() const</h3>
<p>Returns the horizontal scroll bar.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#setHorizontalScrollBar" translate="no">setHorizontalScrollBar</a>(), <a href="qabstractscrollarea.html#horizontalScrollBarPolicy-prop" translate="no">horizontalScrollBarPolicy</a>, and <a href="qabstractscrollarea.html#verticalScrollBar" translate="no">verticalScrollBar</a>().</p>
<!-- @@@horizontalScrollBar -->
<!-- $$$keyPressEvent[overload1]$$$keyPressEventQKeyEvent* -->
<h3 class="fn" translate="no" id="keyPressEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">keyPressEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#keyPressEvent" translate="no">QWidget::keyPressEvent</a>(QKeyEvent *event).</p>
<p>This function is called with key event <i translate="no">e</i> when key presses occur. It handles PageUp, PageDown, Up, Down, Left, and Right, and ignores all other key presses.</p>
<!-- @@@keyPressEvent -->
<!-- $$$maximumViewportSize[overload1]$$$maximumViewportSize -->
<h3 class="fn" translate="no" id="maximumViewportSize"><span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QAbstractScrollArea::<span class="name">maximumViewportSize</span>() const</h3>
<p>Returns the size of the viewport as if the scroll bars had no valid scrolling range.</p>
<!-- @@@maximumViewportSize -->
<!-- $$$minimumSizeHint[overload1]$$$minimumSizeHint -->
<h3 class="fn" translate="no" id="minimumSizeHint"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QAbstractScrollArea::<span class="name">minimumSizeHint</span>() const</h3>
<p>Reimplements an access function for property: <a href="qwidget.html#minimumSizeHint-prop" translate="no">QWidget::minimumSizeHint</a>.</p>
<!-- @@@minimumSizeHint -->
<!-- $$$mouseDoubleClickEvent[overload1]$$$mouseDoubleClickEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mouseDoubleClickEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#mouseDoubleClickEvent" translate="no">QWidget::mouseDoubleClickEvent</a>(QMouseEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive mouse double click events for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget. The event is passed in <i translate="no">e</i>.</p>
<p><b>See also </b><a href="qwidget.html#mouseDoubleClickEvent" translate="no">QWidget::mouseDoubleClickEvent</a>().</p>
<!-- @@@mouseDoubleClickEvent -->
<!-- $$$mouseMoveEvent[overload1]$$$mouseMoveEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mouseMoveEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#mouseMoveEvent" translate="no">QWidget::mouseMoveEvent</a>(QMouseEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive mouse move events for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget. The event is passed in <i translate="no">e</i>.</p>
<p><b>See also </b><a href="qwidget.html#mouseMoveEvent" translate="no">QWidget::mouseMoveEvent</a>().</p>
<!-- @@@mouseMoveEvent -->
<!-- $$$mousePressEvent[overload1]$$$mousePressEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mousePressEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">mousePressEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#mousePressEvent" translate="no">QWidget::mousePressEvent</a>(QMouseEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive mouse press events for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget. The event is passed in <i translate="no">e</i>.</p>
<p>The default implementation calls <a href="qwidget.html#mousePressEvent" translate="no">QWidget::mousePressEvent</a>() for default popup handling.</p>
<p><b>See also </b><a href="qwidget.html#mousePressEvent" translate="no">QWidget::mousePressEvent</a>().</p>
<!-- @@@mousePressEvent -->
<!-- $$$mouseReleaseEvent[overload1]$$$mouseReleaseEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mouseReleaseEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#mouseReleaseEvent" translate="no">QWidget::mouseReleaseEvent</a>(QMouseEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive mouse release events for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget. The event is passed in <i translate="no">e</i>.</p>
<p><b>See also </b><a href="qwidget.html#mouseReleaseEvent" translate="no">QWidget::mouseReleaseEvent</a>().</p>
<!-- @@@mouseReleaseEvent -->
<!-- $$$paintEvent[overload1]$$$paintEventQPaintEvent* -->
<h3 class="fn" translate="no" id="paintEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">paintEvent</span>(<span class="type"><a href="../qtgui/qpaintevent.html" translate="no">QPaintEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="qframe.html#paintEvent" translate="no">QFrame::paintEvent</a>(QPaintEvent *).</p>
<p>This event handler can be reimplemented in a subclass to receive paint events (passed in <i translate="no">event</i>), for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget.</p>
<div class="admonition note">
<p><b>Note: </b>If you create a <a href="../qtgui/qpainter.html" translate="no">QPainter</a>, it must operate on the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>().</p>
</div>
<p><b>See also </b><a href="qwidget.html#paintEvent" translate="no">QWidget::paintEvent</a>().</p>
<!-- @@@paintEvent -->
<!-- $$$resizeEvent[overload1]$$$resizeEventQResizeEvent* -->
<h3 class="fn" translate="no" id="resizeEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">resizeEvent</span>(<span class="type"><a href="../qtgui/qresizeevent.html" translate="no">QResizeEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="qwidget.html#resizeEvent" translate="no">QWidget::resizeEvent</a>(QResizeEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive resize events (passed in <i translate="no">event</i>), for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget.</p>
<p>When resizeEvent() is called, the viewport already has its new geometry: Its new size is accessible through the <a href="../qtgui/qresizeevent.html#size" translate="no">QResizeEvent::size</a>() function, and the old size through <a href="../qtgui/qresizeevent.html#oldSize" translate="no">QResizeEvent::oldSize</a>().</p>
<p><b>See also </b><a href="qwidget.html#resizeEvent" translate="no">QWidget::resizeEvent</a>().</p>
<!-- @@@resizeEvent -->
<!-- $$$scrollBarWidgets[overload1]$$$scrollBarWidgetsQt::Alignment -->
<h3 class="fn" translate="no" id="scrollBarWidgets"><span class="type">QWidgetList</span> QAbstractScrollArea::<span class="name">scrollBarWidgets</span>(<span class="type"><a href="../qtcore/qt.html#AlignmentFlag-enum" translate="no">Qt::Alignment</a></span> <i>alignment</i>)</h3>
<p>Returns a list of the currently set scroll bar widgets. <i translate="no">alignment</i> can be any combination of the four location flags.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#addScrollBarWidget" translate="no">addScrollBarWidget</a>().</p>
<!-- @@@scrollBarWidgets -->
<!-- $$$scrollContentsBy[overload1]$$$scrollContentsByintint -->
<h3 class="fn" translate="no" id="scrollContentsBy"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">scrollContentsBy</span>(<span class="type">int</span> <i>dx</i>, <span class="type">int</span> <i>dy</i>)</h3>
<p>This virtual handler is called when the scroll bars are moved by <i translate="no">dx</i>, <i translate="no">dy</i>, and consequently the viewport's contents should be scrolled accordingly.</p>
<p>The default implementation simply calls <a href="qwidget.html#update" translate="no">update</a>() on the entire <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>(), subclasses can reimplement this handler for optimization purposes, or - like <a href="qscrollarea.html" translate="no">QScrollArea</a> - to move a contents widget. The parameters <i translate="no">dx</i> and <i translate="no">dy</i> are there for convenience, so that the class knows how much should be scrolled (useful e.g. when doing pixel-shifts). You may just as well ignore these values and scroll directly to the position the scroll bars indicate.</p>
<p>Calling this function in order to scroll programmatically is an error, use the scroll bars instead (e.g. by calling <a href="qabstractslider.html#value-prop" translate="no">QScrollBar::setValue</a>() directly).</p>
<!-- @@@scrollContentsBy -->
<!-- $$$setCornerWidget[overload1]$$$setCornerWidgetQWidget* -->
<h3 class="fn" translate="no" id="setCornerWidget"><span class="type">void</span> QAbstractScrollArea::<span class="name">setCornerWidget</span>(<span class="type"><a href="qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>widget</i>)</h3>
<p>Sets the widget in the corner between the two scroll bars to be <i translate="no">widget</i>.</p>
<p>You will probably also want to set at least one of the scroll bar modes to <code translate="no">AlwaysOn</code>.</p>
<p>Passing <code translate="no">nullptr</code> shows no widget in the corner.</p>
<p>Any previous corner widget is hidden.</p>
<p>You may call setCornerWidget() with the same widget at different times.</p>
<p>All widgets set here will be deleted by the scroll area when it is destroyed unless you separately reparent the widget after setting some other corner widget (or <code translate="no">nullptr</code>).</p>
<p>Any <i>newly</i> set widget should have no current parent.</p>
<p>By default, no corner widget is present.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#cornerWidget" translate="no">cornerWidget</a>(), <a href="qabstractscrollarea.html#horizontalScrollBarPolicy-prop" translate="no">horizontalScrollBarPolicy</a>, and <a href="qabstractscrollarea.html#horizontalScrollBarPolicy-prop" translate="no">horizontalScrollBarPolicy</a>.</p>
<!-- @@@setCornerWidget -->
<!-- $$$setHorizontalScrollBar[overload1]$$$setHorizontalScrollBarQScrollBar* -->
<h3 class="fn" translate="no" id="setHorizontalScrollBar"><span class="type">void</span> QAbstractScrollArea::<span class="name">setHorizontalScrollBar</span>(<span class="type"><a href="qscrollbar.html" translate="no">QScrollBar</a></span> *<i>scrollBar</i>)</h3>
<p>Replaces the existing horizontal scroll bar with <i translate="no">scrollBar</i>, and sets all the former scroll bar's slider properties on the new scroll bar. The former scroll bar is then deleted.</p>
<p><a href="qabstractscrollarea.html" translate="no">QAbstractScrollArea</a> already provides horizontal and vertical scroll bars by default. You can call this function to replace the default horizontal scroll bar with your own custom scroll bar.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#horizontalScrollBar" translate="no">horizontalScrollBar</a>() and <a href="qabstractscrollarea.html#setVerticalScrollBar" translate="no">setVerticalScrollBar</a>().</p>
<!-- @@@setHorizontalScrollBar -->
<!-- $$$setVerticalScrollBar[overload1]$$$setVerticalScrollBarQScrollBar* -->
<h3 class="fn" translate="no" id="setVerticalScrollBar"><span class="type">void</span> QAbstractScrollArea::<span class="name">setVerticalScrollBar</span>(<span class="type"><a href="qscrollbar.html" translate="no">QScrollBar</a></span> *<i>scrollBar</i>)</h3>
<p>Replaces the existing vertical scroll bar with <i translate="no">scrollBar</i>, and sets all the former scroll bar's slider properties on the new scroll bar. The former scroll bar is then deleted.</p>
<p><a href="qabstractscrollarea.html" translate="no">QAbstractScrollArea</a> already provides vertical and horizontal scroll bars by default. You can call this function to replace the default vertical scroll bar with your own custom scroll bar.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#verticalScrollBar" translate="no">verticalScrollBar</a>() and <a href="qabstractscrollarea.html#setHorizontalScrollBar" translate="no">setHorizontalScrollBar</a>().</p>
<!-- @@@setVerticalScrollBar -->
<!-- $$$setViewport[overload1]$$$setViewportQWidget* -->
<h3 class="fn" translate="no" id="setViewport"><span class="type">void</span> QAbstractScrollArea::<span class="name">setViewport</span>(<span class="type"><a href="qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>widget</i>)</h3>
<p>Sets the viewport to be the given <i translate="no">widget</i>. The <a href="qabstractscrollarea.html" translate="no">QAbstractScrollArea</a> will take ownership of the given <i translate="no">widget</i>.</p>
<p>If <i translate="no">widget</i> is <code translate="no">nullptr</code>, <a href="qabstractscrollarea.html" translate="no">QAbstractScrollArea</a> will assign a new <a href="qwidget.html" translate="no">QWidget</a> instance for the viewport.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>().</p>
<!-- @@@setViewport -->
<!-- $$$setViewportMargins[overload1]$$$setViewportMarginsintintintint -->
<h3 class="fn" translate="no" id="setViewportMargins"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">setViewportMargins</span>(<span class="type">int</span> <i>left</i>, <span class="type">int</span> <i>top</i>, <span class="type">int</span> <i>right</i>, <span class="type">int</span> <i>bottom</i>)</h3>
<p>Sets the margins around the scrolling area to <i translate="no">left</i>, <i translate="no">top</i>, <i translate="no">right</i> and <i translate="no">bottom</i>. This is useful for applications such as spreadsheets with &quot;locked&quot; rows and columns. The marginal space is left blank; put widgets in the unused area.</p>
<p>Note that this function is frequently called by <a href="qtreeview.html" translate="no">QTreeView</a> and <a href="qtableview.html" translate="no">QTableView</a>, so margins must be implemented by <a href="qabstractscrollarea.html" translate="no">QAbstractScrollArea</a> subclasses. Also, if the subclasses are to be used in item views, they should not call this function.</p>
<p>By default all margins are zero.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#viewportMargins" translate="no">viewportMargins</a>().</p>
<!-- @@@setViewportMargins -->
<!-- $$$setViewportMargins$$$setViewportMarginsconstQMargins& -->
<h3 class="fn" translate="no" id="setViewportMargins-1"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">setViewportMargins</span>(const <span class="type"><a href="../qtcore/qmargins.html" translate="no">QMargins</a></span> &amp;<i>margins</i>)</h3>
<p>Sets <i translate="no">margins</i> around the scrolling area. This is useful for applications such as spreadsheets with &quot;locked&quot; rows and columns. The marginal space is is left blank; put widgets in the unused area.</p>
<p>By default all margins are zero.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#viewportMargins" translate="no">viewportMargins</a>().</p>
<!-- @@@setViewportMargins -->
<!-- $$$setupViewport[overload1]$$$setupViewportQWidget* -->
<h3 class="fn" translate="no" id="setupViewport"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">setupViewport</span>(<span class="type"><a href="qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>viewport</i>)</h3>
<p>This slot is called by <a href="qabstractscrollarea.html" translate="no">QAbstractScrollArea</a> after <a href="qabstractscrollarea.html#setViewport" translate="no">setViewport</a>(<i translate="no">viewport</i>) has been called. Reimplement this function in a subclass of <a href="qabstractscrollarea.html" translate="no">QAbstractScrollArea</a> to initialize the new <i translate="no">viewport</i> before it is used.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#setViewport" translate="no">setViewport</a>().</p>
<!-- @@@setupViewport -->
<!-- $$$sizeHint[overload1]$$$sizeHint -->
<h3 class="fn" translate="no" id="sizeHint"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QAbstractScrollArea::<span class="name">sizeHint</span>() const</h3>
<p>Reimplements: <a href="qframe.html#sizeHint" translate="no">QFrame::sizeHint() const</a>.</p>
<p>Returns the sizeHint property of the scroll area. The size is determined by using <a href="qabstractscrollarea.html#viewportSizeHint" translate="no">viewportSizeHint</a>() plus some extra space for scroll bars, if needed.</p>
<!-- @@@sizeHint -->
<!-- $$$verticalScrollBar[overload1]$$$verticalScrollBar -->
<h3 class="fn" translate="no" id="verticalScrollBar"><span class="type"><a href="qscrollbar.html" translate="no">QScrollBar</a></span> *QAbstractScrollArea::<span class="name">verticalScrollBar</span>() const</h3>
<p>Returns the vertical scroll bar.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#setVerticalScrollBar" translate="no">setVerticalScrollBar</a>(), <a href="qabstractscrollarea.html#verticalScrollBarPolicy-prop" translate="no">verticalScrollBarPolicy</a>, and <a href="qabstractscrollarea.html#horizontalScrollBar" translate="no">horizontalScrollBar</a>().</p>
<!-- @@@verticalScrollBar -->
<!-- $$$viewport[overload1]$$$viewport -->
<h3 class="fn" translate="no" id="viewport"><span class="type"><a href="qwidget.html#QWidget" translate="no">QWidget</a></span> *QAbstractScrollArea::<span class="name">viewport</span>() const</h3>
<p>Returns the viewport widget.</p>
<p>Use the <a href="qscrollarea.html#widget" translate="no">QScrollArea::widget</a>() function to retrieve the contents of the viewport widget.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#setViewport" translate="no">setViewport</a>() and <a href="qscrollarea.html#widget" translate="no">QScrollArea::widget</a>().</p>
<!-- @@@viewport -->
<!-- $$$viewportEvent[overload1]$$$viewportEventQEvent* -->
<h3 class="fn" translate="no" id="viewportEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">bool</span> QAbstractScrollArea::<span class="name">viewportEvent</span>(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> *<i>event</i>)</h3>
<p>The main event handler for the scrolling area (the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget). It handles the <i translate="no">event</i> specified, and can be called by subclasses to provide reasonable default behavior.</p>
<p>Returns <code translate="no">true</code> to indicate to the event system that the event has been handled, and needs no further processing; otherwise returns <code translate="no">false</code> to indicate that the event should be propagated further.</p>
<p>You can reimplement this function in a subclass, but we recommend using one of the specialized event handlers instead.</p>
<p>Specialized handlers for viewport events are: <a href="qabstractscrollarea.html#paintEvent" translate="no">paintEvent</a>(), <a href="qabstractscrollarea.html#mousePressEvent" translate="no">mousePressEvent</a>(), <a href="qabstractscrollarea.html#mouseReleaseEvent" translate="no">mouseReleaseEvent</a>(), <a href="qabstractscrollarea.html#mouseDoubleClickEvent" translate="no">mouseDoubleClickEvent</a>(), <a href="qabstractscrollarea.html#mouseMoveEvent" translate="no">mouseMoveEvent</a>(), <a href="qabstractscrollarea.html#wheelEvent" translate="no">wheelEvent</a>(), <a href="qabstractscrollarea.html#dragEnterEvent" translate="no">dragEnterEvent</a>(), <a href="qabstractscrollarea.html#dragMoveEvent" translate="no">dragMoveEvent</a>(), <a href="qabstractscrollarea.html#dragLeaveEvent" translate="no">dragLeaveEvent</a>(), <a href="qabstractscrollarea.html#dropEvent" translate="no">dropEvent</a>(), <a href="qabstractscrollarea.html#contextMenuEvent" translate="no">contextMenuEvent</a>(), and <a href="qabstractscrollarea.html#resizeEvent" translate="no">resizeEvent</a>().</p>
<!-- @@@viewportEvent -->
<!-- $$$viewportMargins[overload1]$$$viewportMargins -->
<h3 class="fn" translate="no" id="viewportMargins"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtcore/qmargins.html" translate="no">QMargins</a></span> QAbstractScrollArea::<span class="name">viewportMargins</span>() const</h3>
<p>Returns the margins around the scrolling area. By default all the margins are zero.</p>
<p><b>See also </b><a href="qabstractscrollarea.html#setViewportMargins" translate="no">setViewportMargins</a>().</p>
<!-- @@@viewportMargins -->
<!-- $$$viewportSizeHint[overload1]$$$viewportSizeHint -->
<h3 class="fn" translate="no" id="viewportSizeHint"><code class="details extra" translate="no">[virtual protected]</code> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QAbstractScrollArea::<span class="name">viewportSizeHint</span>() const</h3>
<p>Returns the recommended size for the viewport. The default implementation returns <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>()-&gt;<a href="qabstractscrollarea.html#sizeHint" translate="no">sizeHint</a>(). Note that the size is just the viewport's size, without any scroll bars visible.</p>
<!-- @@@viewportSizeHint -->
<!-- $$$wheelEvent[overload1]$$$wheelEventQWheelEvent* -->
<h3 class="fn" translate="no" id="wheelEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QAbstractScrollArea::<span class="name">wheelEvent</span>(<span class="type"><a href="../qtgui/qwheelevent.html" translate="no">QWheelEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#wheelEvent" translate="no">QWidget::wheelEvent</a>(QWheelEvent *event).</p>
<p>This event handler can be reimplemented in a subclass to receive wheel events for the <a href="qabstractscrollarea.html#viewport" translate="no">viewport</a>() widget. The event is passed in <i translate="no">e</i>.</p>
<p><b>See also </b><a href="qwidget.html#wheelEvent" translate="no">QWidget::wheelEvent</a>().</p>
<!-- @@@wheelEvent -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
