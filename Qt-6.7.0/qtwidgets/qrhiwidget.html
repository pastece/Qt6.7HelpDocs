<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhiwidget.cpp -->
  <meta name="description" content="The QRhiWidget class is a widget for rendering 3D graphics via an accelerated grapics API, such as Vulkan, Metal, or Direct 3D.">
  <title>QRhiWidget Class | Qt Widgets 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtwidgets-index.html" translate="no">Qt Widgets</a></li>
<li><a href="qtwidgets-module.html" translate="no">C++ Classes</a></li>
<li>QRhiWidget</li>
<li id="buildversion"><a href="qtwidgets-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiWidget Class</h1>
<!-- $$$QRhiWidget-brief -->
<p>The QRhiWidget class is a widget for rendering 3D graphics via an accelerated grapics API, such as Vulkan, Metal, or Direct 3D. <a href="#details">More...</a></p>
<!-- @@@QRhiWidget -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRhiWidget&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Widgets) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Widgets)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += widgets</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.7</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qwidget.html" translate="no">QWidget</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Status:</td><td class="memItemRight bottomAlign"> Preliminary<span class="status preliminary"></span></td></tr>
</table></div>
<p><b>This class is under development and is subject to change.</b></p>
<ul>
<li><a href="qrhiwidget-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#Api-enum" translate="no">Api</a></b> { Null, OpenGL, Metal, Vulkan, Direct3D11, Direct3D12 }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#TextureFormat-enum" translate="no">TextureFormat</a></b> { RGBA8, RGBA16F, RGBA32F, RGB10A2 }</td></tr>
</table></div>
<h2 id="properties">Properties</h2>
<div class="table"><table class="propsummary" translate="no">
<tr><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qrhiwidget.html#autoRenderTarget-prop" translate="no">autoRenderTarget</a></b> : const bool</li>
<li class="fn" translate="no"><b><a href="qrhiwidget.html#colorBufferFormat-prop" translate="no">colorBufferFormat</a></b> : TextureFormat</li>
<li class="fn" translate="no"><b><a href="qrhiwidget.html#fixedColorBufferSize-prop" translate="no">fixedColorBufferSize</a></b> : QSize</li>
</ul></td><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qrhiwidget.html#mirrorVertically-prop" translate="no">mirrorVertically</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qrhiwidget.html#sampleCount-prop" translate="no">sampleCount</a></b> : int</li>
</ul>
</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#QRhiWidget" translate="no">QRhiWidget</a></b>(QWidget *<i>parent</i> = nullptr, Qt::WindowFlags <i>f</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#dtor.QRhiWidget" translate="no">~QRhiWidget</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiWidget::Api </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#api" translate="no">api</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiWidget::TextureFormat </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#colorBufferFormat-prop" translate="no">colorBufferFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#fixedColorBufferSize-prop" translate="no">fixedColorBufferSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#grabFramebuffer" translate="no">grabFramebuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#isDebugLayerEnabled" translate="no">isDebugLayerEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#mirrorVertically-prop" translate="no">isMirrorVerticallyEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#sampleCount-prop" translate="no">sampleCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#setApi" translate="no">setApi</a></b>(QRhiWidget::Api <i>api</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#colorBufferFormat-prop" translate="no">setColorBufferFormat</a></b>(QRhiWidget::TextureFormat <i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#setDebugLayerEnabled" translate="no">setDebugLayerEnabled</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#fixedColorBufferSize-prop" translate="no">setFixedColorBufferSize</a></b>(QSize <i>pixelSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#fixedColorBufferSize-prop" translate="no">setFixedColorBufferSize</a></b>(int <i>w</i>, int <i>h</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#mirrorVertically-prop" translate="no">setMirrorVertically</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#sampleCount-prop" translate="no">setSampleCount</a></b>(int <i>samples</i>)</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#colorBufferFormat-prop" translate="no">colorBufferFormatChanged</a></b>(QRhiWidget::TextureFormat <i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#fixedColorBufferSize-prop" translate="no">fixedColorBufferSizeChanged</a></b>(const QSize &amp;<i>pixelSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#frameSubmitted" translate="no">frameSubmitted</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#mirrorVertically-prop" translate="no">mirrorVerticallyChanged</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#renderFailed" translate="no">renderFailed</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#sampleCount-prop" translate="no">sampleCountChanged</a></b>(int <i>samples</i>)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#depthStencilBuffer" translate="no">depthStencilBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#initialize" translate="no">initialize</a></b>(QRhiCommandBuffer *<i>cb</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#msaaColorBuffer" translate="no">msaaColorBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#releaseResources" translate="no">releaseResources</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#render" translate="no">render</a></b>(QRhiCommandBuffer *<i>cb</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderTarget *</td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#resolveTexture" translate="no">resolveTexture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhi *</td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#rhi" translate="no">rhi</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#setAutoRenderTarget" translate="no">setAutoRenderTarget</a></b>(bool <i>enabled</i>)</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#event" translate="no">event</a></b>(QEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#paintEvent" translate="no">paintEvent</a></b>(QPaintEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qrhiwidget.html#resizeEvent" translate="no">resizeEvent</a></b>(QResizeEvent *<i>e</i>) override</td></tr>
</table></div>
<!-- $$$QRhiWidget-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<div class="admonition note">
<p><b>Note: </b>QRhiWidget is in tech preview in Qt 6.7. <b>The API is under development and subject to change.</b></p>
</div>
<p>QRhiWidget provides functionality for displaying 3D content rendered through the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> APIs within a <a href="qwidget.html" translate="no">QWidget</a>-based application. In many ways it is the portable equivalent of <a href="../qtopengl/qopenglwidget.html" translate="no">QOpenGLWidget</a> that is not tied to a single 3D graphics API, but rather can function with all the APIs <a href="../qtgui/qrhi.html" translate="no">QRhi</a> supports (such as, Direct 3D 11/12, Vulkan, Metal, and OpenGL).</p>
<p>QRhiWidget is expected to be subclassed. To render into the 2D texture that is implicitly created and managed by the QRhiWidget, subclasses should reimplement the virtual functions <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() and <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<p>The size of the texture will by default adapt to the size of the widget. If a fixed size is preferred, set a fixed size specified in pixels by calling <a href="qrhiwidget.html#fixedColorBufferSize-prop" translate="no">setFixedColorBufferSize</a>().</p>
<p>In addition to the texture serving as the color buffer, a depth/stencil buffer and a render target binding these together is maintained implicitly as well.</p>
<p>The <a href="../qtgui/qrhi.html" translate="no">QRhi</a> for the widget's top-level window is configured to use a platform-specific backend and graphics API by default: Metal on macOS and iOS, Direct 3D 11 on Windows, OpenGL otherwise. Call <a href="qrhiwidget.html#setApi" translate="no">setApi</a>() to override this.</p>
<div class="admonition note">
<p><b>Note: </b>A single widget window can only use one <a href="../qtgui/qrhi.html" translate="no">QRhi</a> backend, and so one single 3D graphics API. If two QRhiWidget or <a href="../qtquick/qquickwidget.html" translate="no">QQuickWidget</a> widgets in the window's widget hierarchy request different APIs, only one of them will function correctly.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>While QRhiWidget is a public Qt API, the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> family of classes in the Qt Gui module, including <a href="../qtgui/qrhi.html" translate="no">QRhi</a>, <a href="../qtgui/qshader.html" translate="no">QShader</a> and <a href="../qtgui/qshaderdescription.html" translate="no">QShaderDescription</a>, offer limited compatibility guarantees. There are no source or binary compatibility guarantees for these classes, meaning the API is only guaranteed to work with the Qt version the application was developed against. Source incompatible changes are however aimed to be kept at a minimum and will only be made in minor releases (6.7, 6.8, and so on). <code translate="no">qrhiwidget.h</code> does not directly include any <a href="../qtgui/qrhi.html" translate="no">QRhi</a>-related headers. To use those classes when implementing a QRhiWidget subclass, link to <code translate="no">Qt::GuiPrivate</code> (if using CMake), and include the appropriate headers with the <code translate="no">rhi</code> prefix, for example <code translate="no">#include &lt;rhi/qrhi.h&gt;</code>.</p>
</div>
<p>An example of a simple QRhiWidget subclass rendering a triangle is the following:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> ExampleRhiWidget : <span class="keyword">public</span> <span class="type"><a href="qrhiwidget.html#QRhiWidget" translate="no">QRhiWidget</a></span>
 {
 <span class="keyword">public</span>:
     ExampleRhiWidget(<span class="type"><a href="qwidget.html#QWidget" translate="no">QWidget</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr) : <span class="type"><a href="qrhiwidget.html#QRhiWidget" translate="no">QRhiWidget</a></span>(parent) { }
     <span class="type">void</span> initialize(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb) override;
     <span class="type">void</span> render(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb) override;
 <span class="keyword">private</span>:
     <span class="type"><a href="../qtgui/qrhi.html" translate="no">QRhi</a></span> <span class="operator">*</span>m_rhi <span class="operator">=</span> nullptr;
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">&gt;</span> m_vbuf;
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">&gt;</span> m_ubuf;
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="../qtgui/qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a></span><span class="operator">&gt;</span> m_srb;
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a></span><span class="operator">&gt;</span> m_pipeline;
     QMatrix4x4 m_viewProjection;
     <span class="type">float</span> m_rotation <span class="operator">=</span> <span class="number">0.0f</span>;
 };

 <span class="type">float</span> vertexData<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
      <span class="number">0.0f</span><span class="operator">,</span>   <span class="number">0.5f</span><span class="operator">,</span>     <span class="number">1.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span>
     <span class="operator">-</span><span class="number">0.5f</span><span class="operator">,</span>  <span class="operator">-</span><span class="number">0.5f</span><span class="operator">,</span>     <span class="number">0.0f</span><span class="operator">,</span> <span class="number">1.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span>
      <span class="number">0.5f</span><span class="operator">,</span>  <span class="operator">-</span><span class="number">0.5f</span><span class="operator">,</span>     <span class="number">0.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span> <span class="number">1.0f</span><span class="operator">,</span>
 };

 <span class="type"><a href="../qtgui/qshader.html" translate="no">QShader</a></span> getShader(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>name)
 {
     <span class="type"><a href="../qtcore/qfile.html" translate="no">QFile</a></span> f(name);
     <span class="keyword">return</span> f<span class="operator">.</span>open(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span><span class="operator">::</span>ReadOnly) <span class="operator">?</span> <span class="type"><a href="../qtgui/qshader.html" translate="no">QShader</a></span><span class="operator">::</span>fromSerialized(f<span class="operator">.</span>readAll()) : <span class="type"><a href="../qtgui/qshader.html" translate="no">QShader</a></span>();
 }

 <span class="type">void</span> ExampleRhiWidget<span class="operator">::</span>initialize(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb)
 {
     <span class="keyword">if</span> (m_rhi <span class="operator">!</span><span class="operator">=</span> rhi()) {
         m_pipeline<span class="operator">.</span>reset();
         m_rhi <span class="operator">=</span> rhi();
     }

     <span class="keyword">if</span> (<span class="operator">!</span>m_pipeline) {
         m_vbuf<span class="operator">.</span>reset(m_rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>Immutable<span class="operator">,</span> <span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>VertexBuffer<span class="operator">,</span> <span class="keyword">sizeof</span>(vertexData)));
         m_vbuf<span class="operator">-</span><span class="operator">&gt;</span>create();

         m_ubuf<span class="operator">.</span>reset(m_rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>Dynamic<span class="operator">,</span> <span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>UniformBuffer<span class="operator">,</span> <span class="number">64</span>));
         m_ubuf<span class="operator">-</span><span class="operator">&gt;</span>create();

         m_srb<span class="operator">.</span>reset(m_rhi<span class="operator">-</span><span class="operator">&gt;</span>newShaderResourceBindings());
         m_srb<span class="operator">-</span><span class="operator">&gt;</span>setBindings({
             <span class="type"><a href="../qtgui/qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>uniformBuffer(<span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtgui/qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>VertexStage<span class="operator">,</span> m_ubuf<span class="operator">.</span>get())<span class="operator">,</span>
         });
         m_srb<span class="operator">-</span><span class="operator">&gt;</span>create();

         m_pipeline<span class="operator">.</span>reset(m_rhi<span class="operator">-</span><span class="operator">&gt;</span>newGraphicsPipeline());
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>setShaderStages({
             { <span class="type"><a href="../qtgui/qrhishaderstage.html" translate="no">QRhiShaderStage</a></span><span class="operator">::</span>Vertex<span class="operator">,</span> getShader(QLatin1String(<span class="string">&quot;:/shader_assets/color.vert.qsb&quot;</span>)) }<span class="operator">,</span>
             { <span class="type"><a href="../qtgui/qrhishaderstage.html" translate="no">QRhiShaderStage</a></span><span class="operator">::</span>Fragment<span class="operator">,</span> getShader(QLatin1String(<span class="string">&quot;:/shader_assets/color.frag.qsb&quot;</span>)) }
         });
         <span class="type"><a href="../qtgui/qrhivertexinputlayout.html" translate="no">QRhiVertexInputLayout</a></span> inputLayout;
         inputLayout<span class="operator">.</span>setBindings({
             { <span class="number">5</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) }
         });
         inputLayout<span class="operator">.</span>setAttributes({
             { <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtgui/qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a></span><span class="operator">::</span>Float2<span class="operator">,</span> <span class="number">0</span> }<span class="operator">,</span>
             { <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="../qtgui/qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a></span><span class="operator">::</span>Float3<span class="operator">,</span> <span class="number">2</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) }
         });
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>setVertexInputLayout(inputLayout);
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>setShaderResourceBindings(m_srb<span class="operator">.</span>get());
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>setRenderPassDescriptor(renderTarget()<span class="operator">-</span><span class="operator">&gt;</span>renderPassDescriptor());
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>create();

         <span class="type"><a href="../qtgui/qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>resourceUpdates <span class="operator">=</span> m_rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
         resourceUpdates<span class="operator">-</span><span class="operator">&gt;</span>uploadStaticBuffer(m_vbuf<span class="operator">.</span>get()<span class="operator">,</span> vertexData);
         cb<span class="operator">-</span><span class="operator">&gt;</span>resourceUpdate(resourceUpdates);
     }

     <span class="keyword">const</span> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> outputSize <span class="operator">=</span> colorTexture()<span class="operator">-</span><span class="operator">&gt;</span>pixelSize();
     m_viewProjection <span class="operator">=</span> m_rhi<span class="operator">-</span><span class="operator">&gt;</span>clipSpaceCorrMatrix();
     m_viewProjection<span class="operator">.</span>perspective(<span class="number">45.0f</span><span class="operator">,</span> outputSize<span class="operator">.</span>width() <span class="operator">/</span> (<span class="type">float</span>) outputSize<span class="operator">.</span>height()<span class="operator">,</span> <span class="number">0.01f</span><span class="operator">,</span> <span class="number">1000.0f</span>);
     m_viewProjection<span class="operator">.</span>translate(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">4</span>);
 }

 <span class="type">void</span> ExampleRhiWidget<span class="operator">::</span>render(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb)
 {
     <span class="type"><a href="../qtgui/qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>resourceUpdates <span class="operator">=</span> m_rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
     m_rotation <span class="operator">+</span><span class="operator">=</span> <span class="number">1.0f</span>;
     QMatrix4x4 modelViewProjection <span class="operator">=</span> m_viewProjection;
     modelViewProjection<span class="operator">.</span>rotate(m_rotation<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span>);
     resourceUpdates<span class="operator">-</span><span class="operator">&gt;</span>updateDynamicBuffer(m_ubuf<span class="operator">.</span>get()<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">64</span><span class="operator">,</span> modelViewProjection<span class="operator">.</span>constData());

     <span class="keyword">const</span> <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> clearColor <span class="operator">=</span> <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span><span class="operator">::</span>fromRgbF(<span class="number">0.4f</span><span class="operator">,</span> <span class="number">0.7f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span> <span class="number">1.0f</span>);
     cb<span class="operator">-</span><span class="operator">&gt;</span>beginPass(renderTarget()<span class="operator">,</span> clearColor<span class="operator">,</span> { <span class="number">1.0f</span><span class="operator">,</span> <span class="number">0</span> }<span class="operator">,</span> resourceUpdates);

     cb<span class="operator">-</span><span class="operator">&gt;</span>setGraphicsPipeline(m_pipeline<span class="operator">.</span>get());
     <span class="keyword">const</span> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> outputSize <span class="operator">=</span> colorTexture()<span class="operator">-</span><span class="operator">&gt;</span>pixelSize();
     cb<span class="operator">-</span><span class="operator">&gt;</span>setViewport(<span class="type"><a href="../qtgui/qrhiviewport.html" translate="no">QRhiViewport</a></span>(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> outputSize<span class="operator">.</span>width()<span class="operator">,</span> outputSize<span class="operator">.</span>height()));
     cb<span class="operator">-</span><span class="operator">&gt;</span>setShaderResources();
     <span class="keyword">const</span> <span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span><span class="operator">::</span>VertexInput vbufBinding(m_vbuf<span class="operator">.</span>get()<span class="operator">,</span> <span class="number">0</span>);
     cb<span class="operator">-</span><span class="operator">&gt;</span>setVertexInput(<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="operator">&amp;</span>vbufBinding);
     cb<span class="operator">-</span><span class="operator">&gt;</span>draw(<span class="number">3</span>);

     cb<span class="operator">-</span><span class="operator">&gt;</span>endPass();

     update();
 }
</pre>
<p>This is a widget that continuously requests updates, throttled by the presentation rate (vsync, depending on the screen refresh rate). If rendering continuously is not desired, the <a href="qwidget.html#update" translate="no">update</a>() call in <a href="qrhiwidget.html#render" translate="no">render</a>() should be removed, and rather issued only when updating the rendered content is necessary. For example, if the rotation of the cube should be tied to the value of a <a href="qslider.html" translate="no">QSlider</a>, then connecting the slider's value change signal to a slot or lambda that forwards the new value and calls <a href="qwidget.html#update" translate="no">update</a>() is sufficient.</p>
<p>The vertex and fragment shaders are provided as Vulkan-style GLSL and must be processed first by the Qt shader infrastructure first. This is achieved either by running the <code translate="no">qsb</code> command-line tool manually, or by using the <a href="../qtshadertools/qtshadertools-build.html" translate="no">qt_add_shaders()</a> function in CMake. The QRhiWidget implementation loads these pre-processed <code translate="no">.qsb</code> files that are shipped with the application. See <a href="../qtshadertools/qtshadertools-index.html" translate="no">Qt Shader Tools</a> for more information about Qt's shader translation infrastructure.</p>
<p>The source code for these shaders could be the following:</p>
<p><code translate="no">color.vert</code></p>
<pre class="cpp" translate="no">
 #version 440
 layout(location = 0) in vec4 position;
 layout(location = 1) in vec3 color;
 layout(location = 0) out vec3 v_color;
 layout(std140, binding = 0) uniform buf {
     mat4 mvp;
 };

 void main()
 {
     v_color = color;
     gl_Position = mvp * position;
 }
</pre>
<p><code translate="no">color.frag</code></p>
<pre class="cpp" translate="no">
 #version 440
 layout(location = 0) in vec3 v_color;
 layout(location = 0) out vec4 fragColor;

 void main()
 {
     fragColor = vec4(v_color, 1.0);
 }
</pre>
<p>The result is a widget that shows the following:</p>
<p class="centerAlign"><img src="images/qrhiwidget-intro.jpg" alt="" /></p><p>For a complete, minimal, introductory example check out the <a href="qtwidgets-rhi-simplerhiwidget-example.html" translate="no">Simple RHI Widget Example</a>.</p>
<p>For an example with more functionality and demonstration of further concepts, see the <a href="qtwidgets-rhi-cuberhiwidget-example.html" translate="no">Cube RHI Widget Example</a>.</p>
<p>QRhiWidget always involves rendering into a backing texture, not directly to the window (the surface or layer provided by the windowing system for the native window). This allows properly compositing the content with the rest of the widget-based UI, and offering a simple and compact API, making it easy to get started. All this comes at the expense of additional resources and a potential effect on performance. This is often perfectly acceptable in practice, but advanced users should keep in mind the pros and cons of the different approaches. Refer to the <a href="../qtgui/qtgui-rhiwindow-example.html" translate="no">RHI Window Example</a> and compare it with the <a href="qtwidgets-rhi-simplerhiwidget-example.html" translate="no">Simple RHI Widget Example</a> for details about the two approaches.</p>
<p>Reparenting a QRhiWidget into a widget hierarchy that belongs to a different window (top-level widget), or making the QRhiWidget itself a top-level (by setting the parent to <code translate="no">nullptr</code>), involves changing the associated <a href="../qtgui/qrhi.html" translate="no">QRhi</a> (and potentially destroying the old one) while the QRhiWidget continues to stay alive and well. To support this, robust QRhiWidget implementations are expected to reimplement the <a href="qrhiwidget.html#releaseResources" translate="no">releaseResources</a>() virtual function as well, and drop their <a href="../qtgui/qrhi.html" translate="no">QRhi</a> resources just as they do in the destructor. The <a href="qtwidgets-rhi-cuberhiwidget-example.html" translate="no">Cube RHI Widget Example</a> demonstrates this in practice.</p>
<p>While not a primary use case, QRhiWidget also allows incorporating rendering code that directly uses a 3D graphics API such as Vulkan, Metal, Direct 3D, or OpenGL. See <a href="../qtgui/qrhicommandbuffer.html#beginExternal" translate="no">QRhiCommandBuffer::beginExternal</a>() for details on recording native commands within a <a href="../qtgui/qrhi.html" translate="no">QRhi</a> render pass, as well as <a href="../qtgui/qrhitexture.html#createFrom" translate="no">QRhiTexture::createFrom</a>() for a way to wrap an existing native texture and then use it with <a href="../qtgui/qrhi.html" translate="no">QRhi</a> in a subsequent render pass. Note however that the configurability of the underlying graphics API (its device or context features, layers, extensions, etc.) is going to be limited since QRhiWidget's primary goal is to provide an environment suitable for <a href="../qtgui/qrhi.html" translate="no">QRhi</a>-based rendering code, not to enable arbitrary, potentially complex, foreign rendering engines.</p>
</div>
<p><b>See also </b><a href="../qtgui/qrhi.html" translate="no">QRhi</a>, <a href="../qtgui/qshader.html" translate="no">QShader</a>, <a href="../qtopengl/qopenglwidget.html" translate="no">QOpenGLWidget</a>, <a href="qtwidgets-rhi-simplerhiwidget-example.html" translate="no">Simple RHI Widget Example</a>, and <a href="qtwidgets-rhi-cuberhiwidget-example.html" translate="no">Cube RHI Widget Example</a>.</p>
<!-- @@@QRhiWidget -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Api$$$Null$$$OpenGL$$$Metal$$$Vulkan$$$Direct3D11$$$Direct3D12 -->
<h3 class="fn" translate="no" id="Api-enum">enum class QRhiWidget::<span class="name">Api</span></h3>
<p>Specifies the 3D API and <a href="../qtgui/qrhi.html" translate="no">QRhi</a> backend to use</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::Api::Null</code></td><td class="topAlign tblval"><code translate="no">0</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::Api::OpenGL</code></td><td class="topAlign tblval"><code translate="no">1</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::Api::Metal</code></td><td class="topAlign tblval"><code translate="no">2</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::Api::Vulkan</code></td><td class="topAlign tblval"><code translate="no">3</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::Api::Direct3D11</code></td><td class="topAlign tblval"><code translate="no">4</code></td></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::Api::Direct3D12</code></td><td class="topAlign tblval"><code translate="no">5</code></td></tr>
</table></div>
<p><b>See also </b><a href="../qtgui/qrhi.html" translate="no">QRhi</a>.</p>
<!-- @@@Api -->
<!-- $$$TextureFormat$$$RGBA8$$$RGBA16F$$$RGBA32F$$$RGB10A2 -->
<h3 class="fn" translate="no" id="TextureFormat-enum">enum class QRhiWidget::<span class="name">TextureFormat</span></h3>
<p>Specifies the format of the texture to which the <a href="qrhiwidget.html" translate="no">QRhiWidget</a> renders.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::TextureFormat::RGBA8</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">See <a href="../qtgui/qrhitexture.html#Format-enum" translate="no">QRhiTexture::RGBA8</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::TextureFormat::RGBA16F</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">See <a href="../qtgui/qrhitexture.html#Format-enum" translate="no">QRhiTexture::RGBA16F</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::TextureFormat::RGBA32F</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">See <a href="../qtgui/qrhitexture.html#Format-enum" translate="no">QRhiTexture::RGBA32F</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiWidget::TextureFormat::RGB10A2</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">See <a href="../qtgui/qrhitexture.html#Format-enum" translate="no">QRhiTexture::RGB10A2</a>.</td></tr>
</table></div>
<p><b>See also </b><a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>.</p>
<!-- @@@TextureFormat -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$autoRenderTarget-prop -->
<h3 class="fn" translate="no" id="autoRenderTarget-prop"><span class="name">autoRenderTarget</span> : const <span class="type">bool</span></h3>
<p>The current setting for automatic depth-stencil buffer and render target maintenance.</p>
<p>By default the value is <code translate="no">true</code>.</p>
<!-- @@@autoRenderTarget -->
<!-- $$$colorBufferFormat-prop$$$colorBufferFormat$$$setColorBufferFormatQRhiWidget::TextureFormat$$$colorBufferFormatChangedQRhiWidget::TextureFormat -->
<h3 class="fn" translate="no" id="colorBufferFormat-prop"><span class="name">colorBufferFormat</span> : <span class="type"><a href="qrhiwidget.html#TextureFormat-enum" translate="no">TextureFormat</a></span></h3>
<p>This property controls the texture format of the texture (or renderbuffer) used as the color buffer. The default value is <a href="qrhiwidget.html#TextureFormat-enum" translate="no">TextureFormat::RGBA8</a>. <a href="qrhiwidget.html" translate="no">QRhiWidget</a> supports rendering to a subset of the formats supported by <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>. Only formats that are reported as supported from <a href="../qtgui/qrhi.html#isTextureFormatSupported" translate="no">QRhi::isTextureFormatSupported</a>() should be specified, rendering will not be functional otherwise.</p>
<div class="admonition note">
<p><b>Note: </b>Setting a new format when the widget is already initialized and has rendered implies that all <a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> objects created by the renderer may become unusable, if the associated <a href="../qtgui/qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> is now incompatible due to the different texture format. Similarly to changing <a href="qrhiwidget.html#sampleCount-prop" translate="no">sampleCount</a> dynamically, this means that <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() or <a href="qrhiwidget.html#render" translate="no">render</a>() implementations must then take care of releasing the existing pipelines and creating new ones.</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QRhiWidget::TextureFormat </td><td class="memItemRight bottomAlign"><span class="name"><b>colorBufferFormat</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setColorBufferFormat</b></span>(QRhiWidget::TextureFormat <i>format</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>colorBufferFormatChanged</b></span>(QRhiWidget::TextureFormat <i>format</i>)</td></tr>
</table></div>
<!-- @@@colorBufferFormat -->
<!-- $$$fixedColorBufferSize-prop$$$fixedColorBufferSize$$$setFixedColorBufferSizeQSize$$$setFixedColorBufferSizeintint$$$fixedColorBufferSizeChangedconstQSize& -->
<h3 class="fn" translate="no" id="fixedColorBufferSize-prop"><span class="name">fixedColorBufferSize</span> : <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span></h3>
<p>The fixed size, in pixels, of the <a href="qrhiwidget.html" translate="no">QRhiWidget</a>'s associated texture. Relevant when a fixed texture size is desired that does not depend on the widget's size. This size has no effect on the geometry of the widget (its size and placement within the top-level window), which means the texture's content will appear stretched (scaled up) or scaled down onto the widget's area.</p>
<p>For example, setting a size that is exactly twice the widget's (pixel) size effectively performs 2x supersampling (rendering at twice the resolution and then implicitly scaling down when texturing the quad corresponding to the widget in the window).</p>
<p>By default the value is a null <a href="../qtcore/qsize.html" translate="no">QSize</a>. A null or empty <a href="../qtcore/qsize.html" translate="no">QSize</a> means that the texture's size follows the <a href="qrhiwidget.html" translate="no">QRhiWidget</a>'s size. (<code translate="no">texture size</code> = <code translate="no">widget size</code> * <code translate="no">device pixel ratio</code>).</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>fixedColorBufferSize</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFixedColorBufferSize</b></span>(QSize <i>pixelSize</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFixedColorBufferSize</b></span>(int <i>w</i>, int <i>h</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>fixedColorBufferSizeChanged</b></span>(const QSize &amp;<i>pixelSize</i>)</td></tr>
</table></div>
<!-- @@@fixedColorBufferSize -->
<!-- $$$mirrorVertically-prop$$$isMirrorVerticallyEnabled$$$setMirrorVerticallybool$$$mirrorVerticallyChangedbool -->
<h3 class="fn" translate="no" id="mirrorVertically-prop"><span class="name">mirrorVertically</span> : <span class="type">bool</span></h3>
<p>When enabled, flips the image around the X axis when compositing the <a href="qrhiwidget.html" translate="no">QRhiWidget</a>'s backing texture with the rest of the widget content in the top-level window.</p>
<p>The default value is <code translate="no">false</code>.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isMirrorVerticallyEnabled</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMirrorVertically</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>mirrorVerticallyChanged</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<!-- @@@mirrorVertically -->
<!-- $$$sampleCount-prop$$$sampleCount$$$setSampleCountint$$$sampleCountChangedint -->
<h3 class="fn" translate="no" id="sampleCount-prop"><span class="name">sampleCount</span> : <span class="type">int</span></h3>
<p>This property controls for sample count for multisample antialiasing. By default the value is <code translate="no">1</code> which means MSAA is disabled.</p>
<p>Valid values are 1, 4, 8, and sometimes 16 and 32. <a href="../qtgui/qrhi.html#supportedSampleCounts" translate="no">QRhi::supportedSampleCounts</a>() can be used to query the supported sample counts at run time, but typically applications should request 1 (no MSAA), 4x (normal MSAA) or 8x (high MSAA).</p>
<div class="admonition note">
<p><b>Note: </b>Setting a new value implies that all <a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> objects created by the renderer must use the same sample count from then on. Existing <a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> objects created with a different sample count must not be used anymore. When the value changes, all color and depth-stencil buffers are destroyed and recreated automatically, and <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() is invoked again. However, when <a href="qrhiwidget.html#autoRenderTarget-prop" translate="no">autoRenderTarget</a> is <code translate="no">false</code>, it will be up to the application to manage this with regards to the depth-stencil buffer or additional color buffers.</p>
</div>
<p>Changing the sample count from the default 1 to a higher value implies that <a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>() becomes <code translate="no">nullptr</code> and <a href="qrhiwidget.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>() starts returning a valid object. Switching back to 1 (or 0), implies the opposite: in the next call to <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() <a href="qrhiwidget.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>() is going to return <code translate="no">nullptr</code>, whereas <a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>() becomes once again valid. In addition, <a href="qrhiwidget.html#resolveTexture" translate="no">resolveTexture</a>() returns a valid (non-multisample) <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a> whenever the sample count is greater than 1 (i.e., MSAA is in use).</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>sampleCount</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSampleCount</b></span>(int <i>samples</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sampleCountChanged</b></span>(int <i>samples</i>)</td></tr>
</table></div>
<p><b>See also </b><a href="qrhiwidget.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>() and <a href="qrhiwidget.html#resolveTexture" translate="no">resolveTexture</a>().</p>
<!-- @@@sampleCount -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QRhiWidget[overload1]$$$QRhiWidgetQWidget*Qt::WindowFlags -->
<h3 class="fn" translate="no" id="QRhiWidget"><code class="details extra" translate="no">[explicit]</code> QRhiWidget::<span class="name">QRhiWidget</span>(<span class="type"><a href="qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>parent</i> = nullptr, <span class="type"><a href="../qtcore/qt.html#WindowType-enum" translate="no">Qt::WindowFlags</a></span> <i>f</i> = {})</h3>
<p>Constructs a widget which is a child of <i translate="no">parent</i>, with widget flags set to <i translate="no">f</i>.</p>
<!-- @@@QRhiWidget -->
<!-- $$$~QRhiWidget[overload1]$$$~QRhiWidget -->
<h3 class="fn" translate="no" id="dtor.QRhiWidget"><code class="details extra" translate="no">[override virtual noexcept]</code> QRhiWidget::<span class="name">~QRhiWidget</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QRhiWidget -->
<!-- $$$api[overload1]$$$api -->
<h3 class="fn" translate="no" id="api"><span class="type"><a href="qrhiwidget.html#Api-enum" translate="no">QRhiWidget::Api</a></span> QRhiWidget::<span class="name">api</span>() const</h3>
<p>Returns the currently set graphics API (<a href="../qtgui/qrhi.html" translate="no">QRhi</a> backend).</p>
<p><b>See also </b><a href="qrhiwidget.html#setApi" translate="no">setApi</a>().</p>
<!-- @@@api -->
<!-- $$$colorTexture[overload1]$$$colorTexture -->
<h3 class="fn" translate="no" id="colorTexture"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a></span> *QRhiWidget::<span class="name">colorTexture</span>() const</h3>
<p>Returns the texture serving as the color buffer for the widget.</p>
<p>Must only be called from <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() and <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<p>Unlike the depth-stencil buffer and the <a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a>, this texture is always available and is managed by the <a href="qrhiwidget.html" translate="no">QRhiWidget</a>, independent of the value of <a href="qrhiwidget.html#autoRenderTarget-prop" translate="no">autoRenderTarget</a>.</p>
<div class="admonition note">
<p><b>Note: </b>When <a href="qrhiwidget.html#sampleCount-prop" translate="no">sampleCount</a> is larger than 1, and so multisample antialiasing is enabled, the return value is <code translate="no">nullptr</code>. Instead, query the <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> by calling <a href="qrhiwidget.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The backing texture size and sample count can also be queried via the <a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a> returned from <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>(). This can be more convenient and compact than querying from the <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a> or <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>, because it works regardless of multisampling is in use or not.</p>
</div>
<p><b>See also </b><a href="qrhiwidget.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>(), <a href="qrhiwidget.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>(), <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>(), and <a href="qrhiwidget.html#resolveTexture" translate="no">resolveTexture</a>().</p>
<!-- @@@colorTexture -->
<!-- $$$depthStencilBuffer[overload1]$$$depthStencilBuffer -->
<h3 class="fn" translate="no" id="depthStencilBuffer"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *QRhiWidget::<span class="name">depthStencilBuffer</span>() const</h3>
<p>Returns the depth-stencil buffer used by the widget's rendering.</p>
<p>Must only be called from <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() and <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<p>Available only when <a href="qrhiwidget.html#autoRenderTarget-prop" translate="no">autoRenderTarget</a> is <code translate="no">true</code>. Otherwise the returned value is <code translate="no">nullptr</code> and it is up the reimplementation of <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() to create and manage a depth-stencil buffer and a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>.</p>
<p><b>See also </b><a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>() and <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>().</p>
<!-- @@@depthStencilBuffer -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" translate="no" id="event"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">bool</span> QRhiWidget::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#event" translate="no">QWidget::event</a>(QEvent *event).</p>
<!-- @@@event -->
<!-- $$$frameSubmitted[overload1]$$$frameSubmitted -->
<h3 class="fn" translate="no" id="frameSubmitted"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QRhiWidget::<span class="name">frameSubmitted</span>()</h3>
<p>This signal is emitted after the widget's top-level window has finished composition and has <a href="../qtgui/qrhi.html#endFrame" translate="no">submitted a frame</a>.</p>
<!-- @@@frameSubmitted -->
<!-- $$$grabFramebuffer[overload1]$$$grabFramebuffer -->
<h3 class="fn" translate="no" id="grabFramebuffer"><span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span> QRhiWidget::<span class="name">grabFramebuffer</span>() const</h3>
<p>Renders a new frame, reads the contents of the texture back, and returns it as a <a href="../qtgui/qimage.html" translate="no">QImage</a>.</p>
<p>When an error occurs, a null <a href="../qtgui/qimage.html" translate="no">QImage</a> is returned.</p>
<p>The returned <a href="../qtgui/qimage.html" translate="no">QImage</a> will have a format of <a href="../qtgui/qimage.html#Format-enum" translate="no">QImage::Format_RGBA8888</a>, <a href="../qtgui/qimage.html#Format-enum" translate="no">QImage::Format_RGBA16FPx4</a>, <a href="../qtgui/qimage.html#Format-enum" translate="no">QImage::Format_RGBA32FPx4</a>, or <a href="../qtgui/qimage.html#Format-enum" translate="no">QImage::Format_BGR30</a>, depending on <a href="qrhiwidget.html#colorBufferFormat-prop" translate="no">colorBufferFormat</a>().</p>
<p><a href="qrhiwidget.html" translate="no">QRhiWidget</a> does not know the renderer's approach to blending and composition, and therefore cannot know if the output has alpha premultiplied in the RGB color values. Thus <code translate="no">_Premultiplied</code> <a href="../qtgui/qimage.html" translate="no">QImage</a> formats are never used for the returned <a href="../qtgui/qimage.html" translate="no">QImage</a>, even when it would be appropriate. It is up to the caller to reinterpret the resulting data as it sees fit.</p>
<div class="admonition note">
<p><b>Note: </b>This function can also be called when the <a href="qrhiwidget.html" translate="no">QRhiWidget</a> is not added to a widget hierarchy belonging to an on-screen top-level window. This allows generating an image from a 3D rendering off-screen.</p>
</div>
<p>The function is named grabFramebuffer() for consistency with <a href="../qtopengl/qopenglwidget.html" translate="no">QOpenGLWidget</a> and <a href="../qtquick/qquickwidget.html" translate="no">QQuickWidget</a>. It is not the only way to get CPU-side image data out of the <a href="qrhiwidget.html" translate="no">QRhiWidget</a>'s content: calling <a href="qwidget.html#grab" translate="no">QWidget::grab</a>() on a <a href="qrhiwidget.html" translate="no">QRhiWidget</a>, or an ancestor of it, is functional as well (returning a <a href="../qtgui/qpixmap.html" translate="no">QPixmap</a>). Besides working directly with <a href="../qtgui/qimage.html" translate="no">QImage</a>, another advantage of grabFramebuffer() is that it may be slightly more performant, simply because it does not have to go through the rest of <a href="qwidget.html" translate="no">QWidget</a> infrastructure but can right away trigger rendering a new frame and then do the readback.</p>
<p><b>See also </b><a href="qrhiwidget.html#colorBufferFormat-prop" translate="no">setColorBufferFormat</a>().</p>
<!-- @@@grabFramebuffer -->
<!-- $$$initialize[overload1]$$$initializeQRhiCommandBuffer* -->
<h3 class="fn" translate="no" id="initialize"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QRhiWidget::<span class="name">initialize</span>(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> *<i>cb</i>)</h3>
<p>Called when the widget is initialized for the first time, when the associated texture's size, format, or sample count changes, or when the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> and texture change for any reason. The function is expected to maintain (create if not yet created, adjust and rebuild if the size has changed) the graphics resources used by the rendering code in <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<p>To query the <a href="../qtgui/qrhi.html" translate="no">QRhi</a>, <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>, and other related objects, call <a href="qrhiwidget.html#rhi" translate="no">rhi</a>(), <a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>(), <a href="qrhiwidget.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>(), and <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>().</p>
<p>When the widget size changes, the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> object, the color buffer texture, and the depth stencil buffer objects are all the same instances (so the getters return the same pointers) as before, but the color and depth/stencil buffers will likely have been rebuilt, meaning the <a href="../qtgui/qrhitexture.html#pixelSize" translate="no">size</a> and the underlying native texture resource may be different than in the last invocation.</p>
<p>Reimplementations should also be prepared that the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> object and the color buffer texture may change between invocations of this function. One special case where the objects will be different is when performing a <a href="qrhiwidget.html#grabFramebuffer" translate="no">grabFramebuffer</a>() with a widget that is not yet shown, and then making the widget visible on-screen within a top-level widget. There the grab will happen with a dedicated <a href="../qtgui/qrhi.html" translate="no">QRhi</a> that is then replaced with the top-level window's associated <a href="../qtgui/qrhi.html" translate="no">QRhi</a> in subsequent initialize() and <a href="qrhiwidget.html#render" translate="no">render</a>() invocations. Another, more common case is when the widget is reparented so that it belongs to a new top-level window. In this case the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> and all related resources managed by the <a href="qrhiwidget.html" translate="no">QRhiWidget</a> will be different instances than before in the subsequent call to this function. Is is then important that all existing <a href="../qtgui/qrhi.html" translate="no">QRhi</a> resources previously created by the subclass are destroyed because they belong to the previous <a href="../qtgui/qrhi.html" translate="no">QRhi</a> that should not be used by the widget anymore.</p>
<p>When <a href="qrhiwidget.html#autoRenderTarget-prop" translate="no">autoRenderTarget</a> is <code translate="no">true</code>, which is the default, a depth-stencil <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> and a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> associated with <a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>() (or <a href="qrhiwidget.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>()) and the depth-stencil buffer are created and managed automatically. Reimplementations of initialize() and <a href="qrhiwidget.html#render" translate="no">render</a>() can query those objects via <a href="qrhiwidget.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>() and <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>(). When <a href="qrhiwidget.html#autoRenderTarget-prop" translate="no">autoRenderTarget</a> is set to <code translate="no">false</code>, these objects are no longer created and managed automatically. Rather, it will be up the the initialize() implementation to create buffers and set up the render target as it sees fit. When manually managing additional color or depth-stencil attachments for the render target, their size and sample count must always follow the size and sample count of <a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>() / <a href="qrhiwidget.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>(), otherwise rendering or 3D API validation errors may occur.</p>
<p>The subclass-created graphics resources are expected to be released in the destructor implementation of the subclass.</p>
<p><i translate="no">cb</i> is the <a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> for the current frame of the widget. The function is called with a frame being recorded, but without an active render pass. The command buffer is provided primarily to allow enqueuing <a href="../qtgui/qrhicommandbuffer.html#resourceUpdate" translate="no">resource updates</a> without deferring to <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<p><b>See also </b><a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<!-- @@@initialize -->
<!-- $$$isDebugLayerEnabled[overload1]$$$isDebugLayerEnabled -->
<h3 class="fn" translate="no" id="isDebugLayerEnabled"><span class="type">bool</span> QRhiWidget::<span class="name">isDebugLayerEnabled</span>() const</h3>
<p>Returns true if a debug or validation layer will be requested if applicable to the graphics API in use.</p>
<p><b>See also </b><a href="qrhiwidget.html#setDebugLayerEnabled" translate="no">setDebugLayerEnabled</a>().</p>
<!-- @@@isDebugLayerEnabled -->
<!-- $$$msaaColorBuffer[overload1]$$$msaaColorBuffer -->
<h3 class="fn" translate="no" id="msaaColorBuffer"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *QRhiWidget::<span class="name">msaaColorBuffer</span>() const</h3>
<p>Returns the renderbuffer serving as the multisample color buffer for the widget.</p>
<p>Must only be called from <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() and <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<p>When <a href="qrhiwidget.html#sampleCount-prop" translate="no">sampleCount</a> is larger than 1, and so multisample antialising is enabled, the returned <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> has a matching sample count and serves as the color buffer. Graphics pipelines used to render into this buffer must be created with the same sample count, and the depth-stencil buffer's sample count must match as well. The multisample content is expected to be resolved into the texture returned from <a href="qrhiwidget.html#resolveTexture" translate="no">resolveTexture</a>(). When <a href="qrhiwidget.html#autoRenderTarget-prop" translate="no">autoRenderTarget</a> is <code translate="no">true</code>, <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>() is set up automatically to do this, by setting up msaaColorBuffer() as the <a href="../qtgui/qrhicolorattachment.html#renderBuffer" translate="no">renderbuffer</a> of color attachment 0 and <a href="qrhiwidget.html#resolveTexture" translate="no">resolveTexture</a>() as its <a href="../qtgui/qrhicolorattachment.html#resolveTexture" translate="no">resolveTexture</a>.</p>
<p>When MSAA is not in use, the return value is <code translate="no">nullptr</code>. Use <a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>() instead then.</p>
<p>Depending on the underlying 3D graphics API, there may be no practical difference between multisample textures and color renderbuffers with a sample count larger than 1 (<a href="../qtgui/qrhi.html" translate="no">QRhi</a> may just map both to the same native resource type). Some older APIs however may differentiate between textures and renderbuffers. In order to support OpenGL ES 3.0, where multisample renderbuffers are available, but multisample textures are not, <a href="qrhiwidget.html" translate="no">QRhiWidget</a> always performs MSAA by using a multisample <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> as the color attachment (and never a multisample <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>).</p>
<div class="admonition note">
<p><b>Note: </b>The backing texture size and sample count can also be queried via the <a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a> returned from <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>(). This can be more convenient and compact than querying from the <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a> or <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>, because it works regardless of multisampling is in use or not.</p>
</div>
<p><b>See also </b><a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>(), <a href="qrhiwidget.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>(), <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>(), and <a href="qrhiwidget.html#resolveTexture" translate="no">resolveTexture</a>().</p>
<!-- @@@msaaColorBuffer -->
<!-- $$$paintEvent[overload1]$$$paintEventQPaintEvent* -->
<h3 class="fn" translate="no" id="paintEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QRhiWidget::<span class="name">paintEvent</span>(<span class="type"><a href="../qtgui/qpaintevent.html" translate="no">QPaintEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#paintEvent" translate="no">QWidget::paintEvent</a>(QPaintEvent *event).</p>
<p>Handles paint events.</p>
<p>Calling <a href="qwidget.html#update" translate="no">QWidget::update</a>() will lead to sending a paint event <i translate="no">e</i>, and thus invoking this function. The sending of the event is asynchronous and will happen at some point after returning from <a href="qwidget.html#update" translate="no">update</a>(). This function will then, after some preparation, call the virtual <a href="qrhiwidget.html#render" translate="no">render</a>() to update the contents of the <a href="qrhiwidget.html" translate="no">QRhiWidget</a>'s associated texture. The widget's top-level window will then composite the texture with the rest of the window.</p>
<!-- @@@paintEvent -->
<!-- $$$releaseResources[overload1]$$$releaseResources -->
<h3 class="fn" translate="no" id="releaseResources"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QRhiWidget::<span class="name">releaseResources</span>()</h3>
<p>Called when the need to early-release the graphics resources arises.</p>
<p>This normally does not happen for a <a href="qrhiwidget.html" translate="no">QRhiWidget</a> that is added to a top-level widget's child hierarchy and it then stays there for the rest of its and the top-level's lifetime. Thus in many cases there is no need to reimplement this function, e.g. because the application only ever has a single top-level widget (native window). However, when reparenting of the widget (or an ancestor of it) is involved, reimplementing this function will become necessary in robust, well-written <a href="qrhiwidget.html" translate="no">QRhiWidget</a> subclasses.</p>
<p>When this function is called, the implementation is expected to destroy all <a href="../qtgui/qrhi.html" translate="no">QRhi</a> resources (<a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a>, <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>, etc. objects), similarly to how it is expected to do this in the destructor. Nulling out, using a smart pointer, or setting a <code translate="no">resources-invalid</code> flag is going to be required as well, because <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() will eventually get called afterwards. Note however that deferring the releasing of resources to the subsequent <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() is wrong. If this function is called, the resource must be dropped before returning. Also note that implementing this function does not replace the class destructor (or smart pointers): the graphics resources must still be released in both.</p>
<p>See the <a href="qtwidgets-rhi-cuberhiwidget-example.html" translate="no">Cube RHI Widget Example</a> for an example of this in action. There the button that toggles the <a href="qrhiwidget.html" translate="no">QRhiWidget</a> between being a child widget (due to having a parent widget) and being a top-level widget (due to having no parent widget), will trigger invoking this function since the associated top-level widget, native window, and <a href="../qtgui/qrhi.html" translate="no">QRhi</a> all change during the lifetime of the <a href="qrhiwidget.html" translate="no">QRhiWidget</a>, with the previously used <a href="../qtgui/qrhi.html" translate="no">QRhi</a> getting destroyed which implies an early-release of the associated resources managed by the still-alive <a href="qrhiwidget.html" translate="no">QRhiWidget</a>.</p>
<p>Another case when this function is called is when <a href="qrhiwidget.html#grabFramebuffer" translate="no">grabFramebuffer</a>() is used with a <a href="qrhiwidget.html" translate="no">QRhiWidget</a> that is not added to a visible window, i.e. the rendering is performed offscreen. If later on this <a href="qrhiwidget.html" translate="no">QRhiWidget</a> is made visible, or added to a visible widget hierarchy, the associated <a href="../qtgui/qrhi.html" translate="no">QRhi</a> will change from the temporary one used for offscreen rendering to the window's dedicated one, thus triggering this function as well.</p>
<p><b>See also </b><a href="qrhiwidget.html#initialize" translate="no">initialize</a>().</p>
<!-- @@@releaseResources -->
<!-- $$$render[overload1]$$$renderQRhiCommandBuffer* -->
<h3 class="fn" translate="no" id="render"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QRhiWidget::<span class="name">render</span>(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> *<i>cb</i>)</h3>
<p>Called when the widget contents (i.e. the contents of the texture) need updating.</p>
<p>There is always at least one call to <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() before this function is called.</p>
<p>To request updates, call <a href="qwidget.html#update" translate="no">QWidget::update</a>(). Calling <a href="qwidget.html#update" translate="no">update</a>() from within render() will lead to updating continuously, throttled by vsync.</p>
<p><i translate="no">cb</i> is the <a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> for the current frame of the widget. The function is called with a frame being recorded, but without an active render pass.</p>
<p><b>See also </b><a href="qrhiwidget.html#initialize" translate="no">initialize</a>().</p>
<!-- @@@render -->
<!-- $$$renderFailed[overload1]$$$renderFailed -->
<h3 class="fn" translate="no" id="renderFailed"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QRhiWidget::<span class="name">renderFailed</span>()</h3>
<p>This signal is emitted whenever the widget is supposed to render to its backing texture (either due to a <a href="qwidget.html#update" translate="no">widget update</a> or due to a call to <a href="qrhiwidget.html#grabFramebuffer" translate="no">grabFramebuffer</a>()), but there is no <a href="../qtgui/qrhi.html" translate="no">QRhi</a> for the widget to use, likely due to issues related to graphics configuration.</p>
<p>This signal may be emitted multiple times when a problem arises. Do not assume it is emitted only once. Connect with <a href="../qtcore/qt.html#ConnectionType-enum" translate="no">Qt::SingleShotConnection</a> if the error handling code is to be notified only once.</p>
<!-- @@@renderFailed -->
<!-- $$$renderTarget[overload1]$$$renderTarget -->
<h3 class="fn" translate="no" id="renderTarget"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a></span> *QRhiWidget::<span class="name">renderTarget</span>() const</h3>
<p>Returns the render target object that must be used with <a href="../qtgui/qrhicommandbuffer.html#beginPass" translate="no">QRhiCommandBuffer::beginPass</a>() in reimplementations of <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<p>Must only be called from <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() and <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<p>Available only when <a href="qrhiwidget.html#autoRenderTarget-prop" translate="no">autoRenderTarget</a> is <code translate="no">true</code>. Otherwise the returned value is <code translate="no">nullptr</code> and it is up the reimplementation of <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() to create and manage a depth-stencil buffer and a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>.</p>
<p>When creating <a href="../qtgui/qrhigraphicspipeline.html" translate="no">graphics pipelines</a>, a <a href="../qtgui/qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> is needed. This can be queried from the returned <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> by calling <a href="../qtgui/qrhirendertarget.html#renderPassDescriptor" translate="no">renderPassDescriptor</a>().</p>
<p><b>See also </b><a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>() and <a href="qrhiwidget.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>().</p>
<!-- @@@renderTarget -->
<!-- $$$resizeEvent[overload1]$$$resizeEventQResizeEvent* -->
<h3 class="fn" translate="no" id="resizeEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QRhiWidget::<span class="name">resizeEvent</span>(<span class="type"><a href="../qtgui/qresizeevent.html" translate="no">QResizeEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qwidget.html#resizeEvent" translate="no">QWidget::resizeEvent</a>(QResizeEvent *event).</p>
<p>Handles resize events that are passed in the <i translate="no">e</i> event parameter. Calls the virtual function <a href="qrhiwidget.html#initialize" translate="no">initialize</a>().</p>
<div class="admonition note">
<p><b>Note: </b>Avoid overriding this function in derived classes. If that is not feasible, make sure that <a href="qrhiwidget.html" translate="no">QRhiWidget</a>'s implementation is invoked too. Otherwise the underlying texture object and related resources will not get resized properly and will lead to incorrect rendering.</p>
</div>
<!-- @@@resizeEvent -->
<!-- $$$resolveTexture[overload1]$$$resolveTexture -->
<h3 class="fn" translate="no" id="resolveTexture"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a></span> *QRhiWidget::<span class="name">resolveTexture</span>() const</h3>
<p>Returns the non-multisample texture to which the multisample content is resolved.</p>
<p>The result is <code translate="no">nullptr</code> when multisample antialiasing is not enabled.</p>
<p>Must only be called from <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() and <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<p>With MSAA enabled, this is the texture that gets composited with the rest of the <a href="qwidget.html" translate="no">QWidget</a> content on-screen. However, the <a href="qrhiwidget.html" translate="no">QRhiWidget</a>'s rendering must target the (multisample) <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> returned from <a href="qrhiwidget.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>(). When <a href="qrhiwidget.html#autoRenderTarget-prop" translate="no">autoRenderTarget</a> is <code translate="no">true</code>, this is taken care of by the <a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a> returned from <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>(). Otherwise, it is up to the subclass code to correctly configure a render target object with both the color buffer and resolve textures.</p>
<p><b>See also </b><a href="qrhiwidget.html#colorTexture" translate="no">colorTexture</a>().</p>
<!-- @@@resolveTexture -->
<!-- $$$rhi[overload1]$$$rhi -->
<h3 class="fn" translate="no" id="rhi"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhi.html" translate="no">QRhi</a></span> *QRhiWidget::<span class="name">rhi</span>() const</h3>
<p>Returns the current <a href="../qtgui/qrhi.html" translate="no">QRhi</a> object.</p>
<p>Must only be called from <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() and <a href="qrhiwidget.html#render" translate="no">render</a>().</p>
<!-- @@@rhi -->
<!-- $$$setApi[overload1]$$$setApiQRhiWidget::Api -->
<h3 class="fn" translate="no" id="setApi"><span class="type">void</span> QRhiWidget::<span class="name">setApi</span>(<span class="type"><a href="qrhiwidget.html#Api-enum" translate="no">QRhiWidget::Api</a></span> <i>api</i>)</h3>
<p>Sets the graphics API and <a href="../qtgui/qrhi.html" translate="no">QRhi</a> backend to use to <i translate="no">api</i>.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function must be called early enough, before the widget is added to a widget hierarchy and displayed on screen. For example, aim to call the function for the subclass constructor. If called too late, the function will have no effect.</p>
</div>
<p>The default value depends on the platform: Metal on macOS and iOS, Direct 3D 11 on Windows, OpenGL otherwise.</p>
<p>The <i translate="no">api</i> can only be set once for the widget and its top-level window, once it is done and takes effect, the window can only use that API and <a href="../qtgui/qrhi.html" translate="no">QRhi</a> backend to render. Attempting to set another value, or to add another <a href="qrhiwidget.html" translate="no">QRhiWidget</a> with a different <i translate="no">api</i> will not function as expected.</p>
<p><b>See also </b><a href="qrhiwidget.html#colorBufferFormat-prop" translate="no">setColorBufferFormat</a>(), <a href="qrhiwidget.html#setDebugLayerEnabled" translate="no">setDebugLayerEnabled</a>(), and <a href="qrhiwidget.html#api" translate="no">api</a>().</p>
<!-- @@@setApi -->
<!-- $$$setAutoRenderTarget[overload1]$$$setAutoRenderTargetbool -->
<h3 class="fn" translate="no" id="setAutoRenderTarget"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QRhiWidget::<span class="name">setAutoRenderTarget</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>Controls if a depth-stencil <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> and a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> is created and maintained automatically by the widget. The default value is <code translate="no">true</code>.</p>
<p>In automatic mode, the size and sample count of the depth-stencil buffer follows the color buffer texture's settings. In non-automatic mode, <a href="qrhiwidget.html#renderTarget" translate="no">renderTarget</a>() and <a href="qrhiwidget.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>() always return <code translate="no">nullptr</code> and it is then up to the application's implementation of <a href="qrhiwidget.html#initialize" translate="no">initialize</a>() to take care of setting up and managing these objects.</p>
<p>Call this function with <i translate="no">enabled</i> set to <code translate="no">false</code> early on, for example in the derived class' constructor, to disable the automatic mode.</p>
<!-- @@@setAutoRenderTarget -->
<!-- $$$setDebugLayerEnabled[overload1]$$$setDebugLayerEnabledbool -->
<h3 class="fn" translate="no" id="setDebugLayerEnabled"><span class="type">void</span> QRhiWidget::<span class="name">setDebugLayerEnabled</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Requests the debug or validation layer of the underlying graphics API when <i translate="no">enable</i> is true.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function must be called early enough, before the widget is added to a widget hierarchy and displayed on screen. For example, aim to call the function for the subclass constructor. If called too late, the function will have no effect.</p>
</div>
<p>Applicable for Vulkan and Direct 3D.</p>
<p>By default this is disabled.</p>
<p><b>See also </b><a href="qrhiwidget.html#setApi" translate="no">setApi</a>() and <a href="qrhiwidget.html#isDebugLayerEnabled" translate="no">isDebugLayerEnabled</a>().</p>
<!-- @@@setDebugLayerEnabled -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
