<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qjsengine.cpp -->
  <meta name="description" content="The QJSEngine class provides an environment for evaluating JavaScript code.">
  <title>QJSEngine Class | Qt QML 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtqml-index.html" translate="no">Qt QML</a></li>
<li><a href="qtqml-module.html" translate="no">C++ Classes</a></li>
<li>QJSEngine</li>
<li id="buildversion"><a href="qtqml-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#evaluating-scripts">Evaluating Scripts</a></li>
<li class="level2"><a href="#engine-configuration">Engine Configuration</a></li>
<li class="level2"><a href="#script-exceptions">Script Exceptions</a></li>
<li class="level2"><a href="#script-object-creation">Script Object Creation</a></li>
<li class="level2"><a href="#qobject-integration">QObject Integration</a></li>
<li class="level2"><a href="#extensions">Extensions</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QJSEngine Class</h1>
<!-- $$$QJSEngine-brief -->
<p>The QJSEngine class provides an environment for evaluating JavaScript code. <a href="#details">More...</a></p>
<!-- @@@QJSEngine -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QJSEngine&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Qml) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Qml)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += qml</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html" translate="no">QObject</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qqmlengine.html" translate="no">QQmlEngine</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qjsengine-members.html">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#Extension-enum" translate="no">Extension</a></b> { TranslationExtension, ConsoleExtension, GarbageCollectionExtension, AllExtensions }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#Extension-enum" translate="no">Extensions</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#ObjectOwnership-enum" translate="no">ObjectOwnership</a></b> { CppOwnership, JavaScriptOwnership }</td></tr>
</table></div>
<h2 id="properties">Properties</h2>
<ul>
<li class="fn" translate="no"><b><a href="qjsengine.html#uiLanguage-prop" translate="no">uiLanguage</a></b> : QString</li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#QJSEngine" translate="no">QJSEngine</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#QJSEngine-1" translate="no">QJSEngine</a></b>(QObject *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#dtor.QJSEngine" translate="no">~QJSEngine</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since Qt 6.1)</code> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#catchError" translate="no">catchError</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> To </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#coerceValue" translate="no">coerceValue</a></b>(const From &amp;<i>from</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#collectGarbage" translate="no">collectGarbage</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#evaluate" translate="no">evaluate</a></b>(const QString &amp;<i>program</i>, const QString &amp;<i>fileName</i> = QString(), int <i>lineNumber</i> = 1, QStringList *<i>exceptionStackTrace</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#fromManagedValue" translate="no">fromManagedValue</a></b>(const QJSManagedValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#fromPrimitiveValue" translate="no">fromPrimitiveValue</a></b>(const QJSPrimitiveValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#fromScriptValue" translate="no">fromScriptValue</a></b>(const QJSValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#fromVariant" translate="no">fromVariant</a></b>(const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#globalObject" translate="no">globalObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since Qt 6.1)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#hasError" translate="no">hasError</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#importModule" translate="no">importModule</a></b>(const QString &amp;<i>fileName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#installExtensions" translate="no">installExtensions</a></b>(QJSEngine::Extensions <i>extensions</i>, const QJSValue &amp;<i>object</i> = QJSValue())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#isInterrupted" translate="no">isInterrupted</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#newArray" translate="no">newArray</a></b>(uint <i>length</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#newErrorObject" translate="no">newErrorObject</a></b>(QJSValue::ErrorType <i>errorType</i>, const QString &amp;<i>message</i> = QString())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#newObject" translate="no">newObject</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#newQMetaObject" translate="no">newQMetaObject</a></b>(const QMetaObject *<i>metaObject</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#newQMetaObject-1" translate="no">newQMetaObject</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#newQObject" translate="no">newQObject</a></b>(QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#newSymbol" translate="no">newSymbol</a></b>(const QString &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#registerModule" translate="no">registerModule</a></b>(const QString &amp;<i>moduleName</i>, const QJSValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#setInterrupted" translate="no">setInterrupted</a></b>(bool <i>interrupted</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#uiLanguage-prop" translate="no">setUiLanguage</a></b>(const QString &amp;<i>language</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since Qt 5.12)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#throwError" translate="no">throwError</a></b>(const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since Qt 5.12)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#throwError-1" translate="no">throwError</a></b>(QJSValue::ErrorType <i>errorType</i>, const QString &amp;<i>message</i> = QString())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#throwError-2" translate="no">throwError</a></b>(const QJSValue &amp;<i>error</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSManagedValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#toManagedValue" translate="no">toManagedValue</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSPrimitiveValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#toPrimitiveValue" translate="no">toPrimitiveValue</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJSValue </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#toScriptValue" translate="no">toScriptValue</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#uiLanguage-prop" translate="no">uiLanguage</a></b>() const</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#uiLanguage-prop" translate="no">uiLanguageChanged</a></b>()</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QJSEngine::ObjectOwnership </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#objectOwnership" translate="no">objectOwnership</a></b>(QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#setObjectOwnership" translate="no">setObjectOwnership</a></b>(QObject *<i>object</i>, QJSEngine::ObjectOwnership <i>ownership</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QJSEngine *</td><td class="memItemRight bottomAlign"><b><a href="qjsengine.html#qjsEnginex" translate="no">qjsEngine</a></b>(const QObject *<i>object</i>)</td></tr>
</table></div>
<!-- $$$QJSEngine-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<h3 id="evaluating-scripts">Evaluating Scripts</h3>
<p>Use <a href="qjsengine.html#evaluate" translate="no">evaluate</a>() to evaluate script code.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjsengine.html#QJSEngine" translate="no">QJSEngine</a></span> myEngine;
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> three <span class="operator">=</span> myEngine<span class="operator">.</span>evaluate(<span class="string">&quot;1 + 2&quot;</span>);
</pre>
<p><a href="qjsengine.html#evaluate" translate="no">evaluate</a>() returns a <a href="qjsvalue.html" translate="no">QJSValue</a> that holds the result of the evaluation. The <a href="qjsvalue.html" translate="no">QJSValue</a> class provides functions for converting the result to various C++ types (e.g. <a href="qjsvalue.html#toString" translate="no">QJSValue::toString</a>() and <a href="qjsvalue.html#toNumber" translate="no">QJSValue::toNumber</a>()).</p>
<p>The following code snippet shows how a script function can be defined and then invoked from C++ using <a href="qjsvalue.html#call" translate="no">QJSValue::call</a>():</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> fun <span class="operator">=</span> myEngine<span class="operator">.</span>evaluate(<span class="string">&quot;(function(a, b) { return a + b; })&quot;</span>);
 <span class="type"><a href="qjsvalue.html#QJSValueList-typedef" translate="no">QJSValueList</a></span> args;
 args <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">2</span>;
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> threeAgain <span class="operator">=</span> fun<span class="operator">.</span>call(args);
</pre>
<p>As can be seen from the above snippets, a script is provided to the engine in the form of a string. One common way of loading scripts is by reading the contents of a file and passing it to <a href="qjsengine.html#evaluate" translate="no">evaluate</a>():</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> fileName <span class="operator">=</span> <span class="string">&quot;helloworld.qs&quot;</span>;
 <span class="type"><a href="../qtcore/qfile.html" translate="no">QFile</a></span> scriptFile(fileName);
 <span class="keyword">if</span> (<span class="operator">!</span>scriptFile<span class="operator">.</span>open(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span><span class="operator">::</span>ReadOnly))
     <span class="comment">// handle error</span>
 <span class="type"><a href="../qtcore/qtextstream.html" translate="no">QTextStream</a></span> stream(<span class="operator">&amp;</span>scriptFile);
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> contents <span class="operator">=</span> stream<span class="operator">.</span>readAll();
 scriptFile<span class="operator">.</span>close();
 myEngine<span class="operator">.</span>evaluate(contents<span class="operator">,</span> fileName);
</pre>
<p>Here we pass the name of the file as the second argument to <a href="qjsengine.html#evaluate" translate="no">evaluate</a>(). This does not affect evaluation in any way; the second argument is a general-purpose string that is stored in the <code translate="no">Error</code> object for debugging purposes.</p>
<p>For larger pieces of functionality, you may want to encapsulate your code and data into modules. A module is a file that contains script code, variables, etc., and uses export statements to describe its interface towards the rest of the application. With the help of import statements, a module can refer to functionality from other modules. This allows building a scripted application from smaller connected building blocks in a safe way. In contrast, the approach of using <a href="qjsengine.html#evaluate" translate="no">evaluate</a>() carries the risk that internal variables or functions from one <a href="qjsengine.html#evaluate" translate="no">evaluate</a>() call accidentally pollute the global object and affect subsequent evaluations.</p>
<p>The following example provides a module that can add numbers:</p>
<pre class="cpp" translate="no">
 <span class="keyword">export</span> function sum(left<span class="operator">,</span> right)
 {
     <span class="keyword">return</span> left <span class="operator">+</span> right
 }
</pre>
<p>This module can be loaded with QJSEngine::import() if it is saved under the name <code translate="no">math.mjs</code>:</p>
<pre class="cpp" translate="no">
 <span class="type">QJSvalue</span> module <span class="operator">=</span> myEngine<span class="operator">.</span>importModule(<span class="string">&quot;./math.mjs&quot;</span>);
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> sumFunction <span class="operator">=</span> module<span class="operator">.</span>property(<span class="string">&quot;sum&quot;</span>);
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> result <span class="operator">=</span> sumFunction<span class="operator">.</span>call(args);
</pre>
<p>Modules can also use functionality from other modules using import statements:</p>
<pre class="cpp" translate="no">
 import { sum } from <span class="string">&quot;./math.mjs&quot;</span>;
 <span class="keyword">export</span> function addTwice(left<span class="operator">,</span> right)
 {
     <span class="keyword">return</span> sum(left<span class="operator">,</span> right) <span class="operator">*</span> <span class="number">2</span>;
 }
</pre>
<p>Modules don't have to be files. They can be values registered with <a href="qjsengine.html#registerModule" translate="no">QJSEngine::registerModule</a>():</p>
<pre class="cpp" translate="no">
 import version from <span class="string">&quot;version&quot;</span>;

 <span class="keyword">export</span> function getVersion()
 {
     <span class="keyword">return</span> version;
 }
</pre>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> version(<span class="number">610</span>);
 myEngine<span class="operator">.</span>registerModule(<span class="string">&quot;version&quot;</span><span class="operator">,</span> version);
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> module <span class="operator">=</span> myEngine<span class="operator">.</span>importModule(<span class="string">&quot;./myprint.mjs&quot;</span>);
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> getVersion <span class="operator">=</span> module<span class="operator">.</span>property(<span class="string">&quot;getVersion&quot;</span>);
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> result <span class="operator">=</span> getVersion<span class="operator">.</span>call();
</pre>
<p>Named exports are supported, but because they are treated as members of an object, the default export must be an ECMAScript object. Most of the newXYZ functions in <a href="qjsvalue.html" translate="no">QJSValue</a> will return an object.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> name(<span class="string">&quot;Qt6&quot;</span>);
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> obj <span class="operator">=</span> myEngine<span class="operator">.</span>newObject();
 obj<span class="operator">.</span>setProperty(<span class="string">&quot;name&quot;</span><span class="operator">,</span> name);
 myEngine<span class="operator">.</span>registerModule(<span class="string">&quot;info&quot;</span><span class="operator">,</span> obj);
</pre>
<pre class="cpp" translate="no">
 import { name } from <span class="string">&quot;info&quot;</span>;

 <span class="keyword">export</span> function getName()
 {
     <span class="keyword">return</span> name;
 }
</pre>
<h3 id="engine-configuration">Engine Configuration</h3>
<p>The <a href="qjsengine.html#globalObject" translate="no">globalObject</a>() function returns the <b>Global Object</b> associated with the script engine. Properties of the Global Object are accessible from any script code (i.e. they are global variables). Typically, before evaluating &quot;user&quot; scripts, you will want to configure a script engine by adding one or more properties to the Global Object:</p>
<pre class="cpp" translate="no">
 myEngine<span class="operator">.</span>globalObject()<span class="operator">.</span>setProperty(<span class="string">&quot;myNumber&quot;</span><span class="operator">,</span> <span class="number">123</span>);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> myNumberPlusOne <span class="operator">=</span> myEngine<span class="operator">.</span>evaluate(<span class="string">&quot;myNumber + 1&quot;</span>);
</pre>
<p>Adding custom properties to the scripting environment is one of the standard means of providing a scripting API that is specific to your application. Usually these custom properties are objects created by the <a href="qjsengine.html#newQObject" translate="no">newQObject</a>() or <a href="qjsengine.html#newObject" translate="no">newObject</a>() functions.</p>
<h3 id="script-exceptions">Script Exceptions</h3>
<p><a href="qjsengine.html#evaluate" translate="no">evaluate</a>() can throw a script exception (e.g. due to a syntax error). If it does, then <a href="qjsengine.html#evaluate" translate="no">evaluate</a>() returns the value that was thrown (typically an <code translate="no">Error</code> object). Use <a href="qjsvalue.html#isError" translate="no">QJSValue::isError</a>() to check for exceptions.</p>
<p>For detailed information about the error, use <a href="qjsvalue.html#toString" translate="no">QJSValue::toString</a>() to obtain an error message, and use <a href="qjsvalue.html#property" translate="no">QJSValue::property</a>() to query the properties of the <code translate="no">Error</code> object. The following properties are available:</p>
<ul>
<li><code translate="no">name</code></li>
<li><code translate="no">message</code></li>
<li><code translate="no">fileName</code></li>
<li><code translate="no">lineNumber</code></li>
<li><code translate="no">stack</code></li>
</ul>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> result <span class="operator">=</span> myEngine<span class="operator">.</span>evaluate(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
 <span class="keyword">if</span> (result<span class="operator">.</span>isError())
     <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>()
             <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Uncaught exception at line&quot;</span>
             <span class="operator">&lt;</span><span class="operator">&lt;</span> result<span class="operator">.</span>property(<span class="string">&quot;lineNumber&quot;</span>)<span class="operator">.</span>toInt()
             <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;:&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> result<span class="operator">.</span>toString();
</pre>
<h3 id="script-object-creation">Script Object Creation</h3>
<p>Use <a href="qjsengine.html#newObject" translate="no">newObject</a>() to create a JavaScript object; this is the C++ equivalent of the script statement <code translate="no">new Object()</code>. You can use the object-specific functionality in <a href="qjsvalue.html" translate="no">QJSValue</a> to manipulate the script object (e.g. <a href="qjsvalue.html#setProperty" translate="no">QJSValue::setProperty</a>()). Similarly, use <a href="qjsengine.html#newArray" translate="no">newArray</a>() to create a JavaScript array object.</p>
<h3 id="qobject-integration">QObject Integration</h3>
<p>Use <a href="qjsengine.html#newQObject" translate="no">newQObject</a>() to wrap a <a href="../qtcore/qobject.html" translate="no">QObject</a> (or subclass) pointer. <a href="qjsengine.html#newQObject" translate="no">newQObject</a>() returns a proxy script object; properties, children, and signals and slots of the <a href="../qtcore/qobject.html" translate="no">QObject</a> are available as properties of the proxy object. No binding code is needed because it is done dynamically using the Qt meta object system.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span>button <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span>;
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> scriptButton <span class="operator">=</span> myEngine<span class="operator">.</span>newQObject(button);
 myEngine<span class="operator">.</span>globalObject()<span class="operator">.</span>setProperty(<span class="string">&quot;button&quot;</span><span class="operator">,</span> scriptButton);

 myEngine<span class="operator">.</span>evaluate(<span class="string">&quot;button.checkable = true&quot;</span>);

 <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> scriptButton<span class="operator">.</span>property(<span class="string">&quot;checkable&quot;</span>)<span class="operator">.</span>toBool();
 scriptButton<span class="operator">.</span>property(<span class="string">&quot;show&quot;</span>)<span class="operator">.</span>call(); <span class="comment">// call the show() slot</span>
</pre>
<p>Use <a href="qjsengine.html#newQMetaObject-1" translate="no">newQMetaObject</a>() to wrap a <a href="../qtcore/qmetaobject.html" translate="no">QMetaObject</a>; this gives you a &quot;script representation&quot; of a <a href="../qtcore/qobject.html" translate="no">QObject</a>-based class. <a href="qjsengine.html#newQMetaObject-1" translate="no">newQMetaObject</a>() returns a proxy script object; enum values of the class are available as properties of the proxy object.</p>
<p>Constructors exposed to the meta-object system (using <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>) can be called from the script to create a new <a href="../qtcore/qobject.html" translate="no">QObject</a> instance with <a href="qjsengine.html#ObjectOwnership-enum" translate="no">JavaScriptOwnership</a>. For example, given the following class definition:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyObject : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     Q_INVOKABLE MyObject() {}
 };
</pre>
<p>The <code translate="no">staticMetaObject</code> for the class can be exposed to JavaScript like so:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> jsMetaObject <span class="operator">=</span> engine<span class="operator">.</span>newQMetaObject(<span class="operator">&amp;</span>MyObject<span class="operator">::</span>staticMetaObject);
 engine<span class="operator">.</span>globalObject()<span class="operator">.</span>setProperty(<span class="string">&quot;MyObject&quot;</span><span class="operator">,</span> jsMetaObject);
</pre>
<p>Instances of the class can then be created in JavaScript:</p>
<pre class="cpp" translate="no">
 engine<span class="operator">.</span>evaluate(<span class="string">&quot;var myObject = new MyObject()&quot;</span>);
</pre>
<div class="admonition note">
<p><b>Note: </b>Currently only classes using the <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro are supported; it is not possible to expose the <code translate="no">staticMetaObject</code> of a <a href="../qtcore/qobject.html#Q_GADGET" translate="no">Q_GADGET</a> class to JavaScript.</p>
</div>
<h4 id="dynamic-qobject-properties">Dynamic QObject Properties</h4>
<p>Dynamic <a href="../qtcore/qobject.html" translate="no">QObject</a> properties are not supported. For example, the following code will not work:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjsengine.html#QJSEngine" translate="no">QJSEngine</a></span> engine;

 <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>myQObject <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span>();
 myQObject<span class="operator">-</span><span class="operator">&gt;</span>setProperty(<span class="string">&quot;dynamicProperty&quot;</span><span class="operator">,</span> <span class="number">3</span>);

 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> myScriptQObject <span class="operator">=</span> engine<span class="operator">.</span>newQObject(myQObject);
 engine<span class="operator">.</span>globalObject()<span class="operator">.</span>setProperty(<span class="string">&quot;myObject&quot;</span><span class="operator">,</span> myScriptQObject);

 <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> engine<span class="operator">.</span>evaluate(<span class="string">&quot;myObject.dynamicProperty&quot;</span>)<span class="operator">.</span>toInt();
</pre>
<h3 id="extensions">Extensions</h3>
<p>QJSEngine provides a compliant ECMAScript implementation. By default, familiar utilities like logging are not available, but they can be installed via the <a href="qjsengine.html#installExtensions" translate="no">installExtensions</a>() function.</p>
</div>
<p><b>See also </b><a href="qjsvalue.html" translate="no">QJSValue</a>, <a href="qtjavascript.html" translate="no">Making Applications Scriptable</a>, and <a href="qtqml-javascript-functionlist.html" translate="no">List of JavaScript Objects and Functions</a>.</p>
<!-- @@@QJSEngine -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Extension$$$TranslationExtension$$$ConsoleExtension$$$GarbageCollectionExtension$$$AllExtensions -->
<h3 class="flags" id="Extension-enum">enum QJSEngine::<span class="name">Extension</span><br/>flags QJSEngine::<span class="name">Extensions</span></h3>
<p>This enum is used to specify extensions to be installed via <a href="qjsengine.html#installExtensions" translate="no">installExtensions</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QJSEngine::TranslationExtension</code></td><td class="topAlign tblval"><code translate="no">0x1</code></td><td class="topAlign">Indicates that translation functions (<code translate="no">qsTr()</code>, for example) should be installed. This also installs the Qt.<a href="qjsengine.html#uiLanguage-prop" translate="no">uiLanguage</a> property.</td></tr>
<tr><td class="topAlign"><code translate="no">QJSEngine::ConsoleExtension</code></td><td class="topAlign tblval"><code translate="no">0x2</code></td><td class="topAlign">Indicates that console functions (<code translate="no">console.log()</code>, for example) should be installed.</td></tr>
<tr><td class="topAlign"><code translate="no">QJSEngine::GarbageCollectionExtension</code></td><td class="topAlign tblval"><code translate="no">0x4</code></td><td class="topAlign">Indicates that garbage collection functions (<code translate="no">gc()</code>, for example) should be installed.</td></tr>
<tr><td class="topAlign"><code translate="no">QJSEngine::AllExtensions</code></td><td class="topAlign tblval"><code translate="no">0xffffffff</code></td><td class="topAlign">Indicates that all extension should be installed.</td></tr>
</table></div>
<p><b>TranslationExtension</b></p>
<p>The relation between script translation functions and C++ translation functions is described in the following table:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Script Function</th><th >Corresponding C++ Function</th></tr></thead>
<tr valign="top" class="odd"><td >qsTr()</td><td ><a href="../qtcore/qobject.html#tr" translate="no">QObject::tr</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qttranslation-qtcore-proxy.html#QT_TR_NOOP" translate="no">QT_TR_NOOP</a>()</td><td ><a href="../qtcore/qttranslation-qtcore-proxy.html#QT_TR_NOOP" translate="no">QT_TR_NOOP</a>()</td></tr>
<tr valign="top" class="odd"><td >qsTranslate()</td><td ><a href="../qtcore/qcoreapplication.html#translate" translate="no">QCoreApplication::translate</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qttranslation-qtcore-proxy.html#QT_TRANSLATE_NOOP" translate="no">QT_TRANSLATE_NOOP</a>()</td><td ><a href="../qtcore/qttranslation-qtcore-proxy.html#QT_TRANSLATE_NOOP" translate="no">QT_TRANSLATE_NOOP</a>()</td></tr>
<tr valign="top" class="odd"><td >qsTrId()</td><td ><a href="../qtcore/qttranslation-qtcore-proxy.html#qtTrId" translate="no">qtTrId</a>()</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qttranslation-qtcore-proxy.html#QT_TRID_NOOP" translate="no">QT_TRID_NOOP</a>()</td><td ><a href="../qtcore/qttranslation-qtcore-proxy.html#QT_TRID_NOOP" translate="no">QT_TRID_NOOP</a>()</td></tr>
</table></div>
<p>This flag also adds an <code translate="no">arg()</code> function to the string prototype.</p>
<p>For more information, see the <a href="../qtdoc/internationalization.html" translate="no">Internationalization with Qt</a> documentation.</p>
<p><b>ConsoleExtension</b></p>
<p>The <a href="../qtdoc/qtquick-debugging.html#console-api" translate="no">console</a> object implements a subset of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console" translate="no">Console API</a>, which provides familiar logging functions, such as <code translate="no">console.log()</code>.</p>
<p>The list of functions added is as follows:</p>
<ul>
<li><code translate="no">console.assert()</code></li>
<li><code translate="no">console.debug()</code></li>
<li><code translate="no">console.exception()</code></li>
<li><code translate="no">console.info()</code></li>
<li><code translate="no">console.log()</code> (equivalent to <code translate="no">console.debug()</code>)</li>
<li><code translate="no">console.error()</code></li>
<li><code translate="no">console.time()</code></li>
<li><code translate="no">console.timeEnd()</code></li>
<li><code translate="no">console.trace()</code></li>
<li><code translate="no">console.count()</code></li>
<li><code translate="no">console.warn()</code></li>
<li><code translate="no">print()</code> (equivalent to <code translate="no">console.debug()</code>)</li>
</ul>
<p>For more information, see the <a href="../qtdoc/qtquick-debugging.html#console-api" translate="no">Console API</a> documentation.</p>
<p><b>GarbageCollectionExtension</b></p>
<p>The <code translate="no">gc()</code> function is equivalent to calling <a href="qjsengine.html#collectGarbage" translate="no">collectGarbage</a>().</p>
<p>The Extensions type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Extension&gt;. It stores an OR combination of Extension values.</p>
<!-- @@@Extension -->
<!-- $$$ObjectOwnership$$$CppOwnership$$$JavaScriptOwnership -->
<h3 class="fn" translate="no" id="ObjectOwnership-enum">enum QJSEngine::<span class="name">ObjectOwnership</span></h3>
<p>ObjectOwnership controls whether or not the JavaScript memory manager automatically destroys the <a href="../qtcore/qobject.html" translate="no">QObject</a> when the corresponding JavaScript object is garbage collected by the engine. The two ownership options are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QJSEngine::CppOwnership</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The object is owned by C++ code and the JavaScript memory manager will never delete it. The JavaScript destroy() method cannot be used on these objects. This option is similar to QScriptEngine::QtOwnership.</td></tr>
<tr><td class="topAlign"><code translate="no">QJSEngine::JavaScriptOwnership</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The object is owned by JavaScript. When the object is returned to the JavaScript memory manager as the return value of a method call, the JavaScript memory manager will track it and delete it if there are no remaining JavaScript references to it and it has no <a href="../qtcore/qobject.html#parent" translate="no">QObject::parent</a>(). An object tracked by one <a href="qjsengine.html" translate="no">QJSEngine</a> will be deleted during that <a href="qjsengine.html" translate="no">QJSEngine</a>'s destructor. Thus, JavaScript references between objects with JavaScriptOwnership from two different engines will not be valid if one of these engines is deleted. This option is similar to QScriptEngine::ScriptOwnership.</td></tr>
</table></div>
<p>Generally an application doesn't need to set an object's ownership explicitly. The JavaScript memory manager uses a heuristic to set the default ownership. By default, an object that is created by the JavaScript memory manager has JavaScriptOwnership. The exception to this are the root objects created by calling <a href="qqmlcomponent.html#create" translate="no">QQmlComponent::create</a>() or <a href="qqmlcomponent.html#beginCreate" translate="no">QQmlComponent::beginCreate</a>(), which have CppOwnership by default. The ownership of these root-level objects is considered to have been transferred to the C++ caller.</p>
<p>Objects not-created by the JavaScript memory manager have CppOwnership by default. The exception to this are objects returned from C++ method calls; their ownership will be set to JavaScriptOwnership. This applies only to explicit invocations of <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> methods or slots, but not to property getter invocations.</p>
<p>Calling <a href="qjsengine.html#setObjectOwnership" translate="no">setObjectOwnership</a>() overrides the default ownership.</p>
<p><b>See also </b><a href="qtqml-cppintegration-data.html#data-ownership" translate="no">Data Ownership</a>.</p>
<!-- @@@ObjectOwnership -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$uiLanguage-prop$$$uiLanguage$$$setUiLanguageconstQString&$$$uiLanguageChanged -->
<h3 class="fn" translate="no" id="uiLanguage-prop"><span class="name">uiLanguage</span> : <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span></h3>
<p>This property holds the language to be used for translating user interface strings</p>
<p>This property holds the name of the language to be used for user interface string translations. It is exposed for reading and writing as <code translate="no">Qt.uiLanguage</code> when the <a href="qjsengine.html#Extension-enum" translate="no">QJSEngine::TranslationExtension</a> is installed on the engine. It is always exposed in instances of <a href="qqmlengine.html" translate="no">QQmlEngine</a>.</p>
<p>You can set the value freely and use it in bindings. It is recommended to set it after installing translators in your application. By convention, an empty string means no translation from the language used in the source code is intended to occur.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>uiLanguage</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setUiLanguage</b></span>(const QString &amp;<i>language</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>uiLanguageChanged</b></span>()</td></tr>
</table></div>
<!-- @@@uiLanguage -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QJSEngine[overload1]$$$QJSEngine -->
<h3 class="fn" translate="no" id="QJSEngine">QJSEngine::<span class="name">QJSEngine</span>()</h3>
<p>Constructs a QJSEngine object.</p>
<p>The <a href="qjsengine.html#globalObject" translate="no">globalObject</a>() is initialized to have properties as described in <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/" translate="no">ECMA-262</a>, Section 15.1.</p>
<!-- @@@QJSEngine -->
<!-- $$$QJSEngine$$$QJSEngineQObject* -->
<h3 class="fn" translate="no" id="QJSEngine-1"><code class="details extra" translate="no">[explicit]</code> QJSEngine::<span class="name">QJSEngine</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i>)</h3>
<p>Constructs a QJSEngine object with the given <i translate="no">parent</i>.</p>
<p>The <a href="qjsengine.html#globalObject" translate="no">globalObject</a>() is initialized to have properties as described in <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/" translate="no">ECMA-262</a>, Section 15.1.</p>
<!-- @@@QJSEngine -->
<!-- $$$~QJSEngine[overload1]$$$~QJSEngine -->
<h3 class="fn" translate="no" id="dtor.QJSEngine"><code class="details extra" translate="no">[override virtual noexcept]</code> QJSEngine::<span class="name">~QJSEngine</span>()</h3>
<p>Destroys this <a href="qjsengine.html" translate="no">QJSEngine</a>.</p>
<p>Garbage is not collected from the persistent JS heap during <a href="qjsengine.html" translate="no">QJSEngine</a> destruction. If you need all memory freed, call <a href="qjsengine.html#collectGarbage" translate="no">collectGarbage</a>() manually right before destroying the <a href="qjsengine.html" translate="no">QJSEngine</a>.</p>
<!-- @@@~QJSEngine -->
<!-- $$$catchError[overload1]$$$catchError -->
<h3 class="fn" translate="no" id="catchError"><code class="details extra" translate="no">[since Qt 6.1]</code> <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">catchError</span>()</h3>
<p>If an exception is currently pending, catches it and returns it as a <a href="qjsvalue.html" translate="no">QJSValue</a>. Otherwise returns undefined as <a href="qjsvalue.html" translate="no">QJSValue</a>. After calling this method <a href="qjsengine.html#hasError" translate="no">hasError</a>() returns <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@catchError -->
<!-- $$$coerceValue[overload1]$$$coerceValueconstFrom& -->
<h3 class="fn" translate="no" id="coerceValue">template &lt;typename From, typename To&gt; <span class="type">To</span> QJSEngine::<span class="name">coerceValue</span>(const <span class="type">From</span> &amp;<i>from</i>)</h3>
<p>Returns the given <i translate="no">from</i> converted to the template type <code translate="no">To</code>. The conversion is done in JavaScript semantics. Those differ from <a href="../qtcore/qvariant.html#qvariant_cast-1" translate="no">qvariant_cast</a>'s semantics. There are a number of implicit conversions between JavaScript-equivalent types that are not performed by <a href="../qtcore/qvariant.html#qvariant_cast-1" translate="no">qvariant_cast</a> by default. This method is a generalization of all the other conversion methods in this class.</p>
<p><b>See also </b><a href="qjsengine.html#fromVariant" translate="no">fromVariant</a>(), <a href="../qtcore/qvariant.html#qvariant_cast" translate="no">qvariant_cast</a>(), <a href="qjsengine.html#fromScriptValue" translate="no">fromScriptValue</a>(), and <a href="qjsengine.html#toScriptValue" translate="no">toScriptValue</a>().</p>
<!-- @@@coerceValue -->
<!-- $$$collectGarbage[overload1]$$$collectGarbage -->
<h3 class="fn" translate="no" id="collectGarbage"><span class="type">void</span> QJSEngine::<span class="name">collectGarbage</span>()</h3>
<p>Runs the garbage collector.</p>
<p>The garbage collector will attempt to reclaim memory by locating and disposing of objects that are no longer reachable in the script environment.</p>
<p>Normally you don't need to call this function; the garbage collector will automatically be invoked when the <a href="qjsengine.html" translate="no">QJSEngine</a> decides that it's wise to do so (i.e. when a certain number of new objects have been created). However, you can call this function to explicitly request that garbage collection should be performed as soon as possible.</p>
<!-- @@@collectGarbage -->
<!-- $$$evaluate[overload1]$$$evaluateconstQString&constQString&intQStringList* -->
<h3 class="fn" translate="no" id="evaluate"><span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">evaluate</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>program</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>fileName</i> = QString(), <span class="type">int</span> <i>lineNumber</i> = 1, <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> *<i>exceptionStackTrace</i> = nullptr)</h3>
<p>Evaluates <i translate="no">program</i>, using <i translate="no">lineNumber</i> as the base line number, and returns the result of the evaluation.</p>
<p>The script code will be evaluated in the context of the global object.</p>
<div class="admonition note">
<p><b>Note: </b>If you need to evaluate inside a QML context, use <a href="qqmlexpression.html" translate="no">QQmlExpression</a> instead.</p>
</div>
<p>The evaluation of <i translate="no">program</i> can cause an <a href="qjsengine.html#script-exceptions" translate="no">exception</a> in the engine; in this case the return value will be the exception that was thrown (typically an <code translate="no">Error</code> object; see <a href="qjsvalue.html#isError" translate="no">QJSValue::isError</a>()).</p>
<p><i translate="no">lineNumber</i> is used to specify a starting line number for <i translate="no">program</i>; line number information reported by the engine that pertains to this evaluation will be based on this argument. For example, if <i translate="no">program</i> consists of two lines of code, and the statement on the second line causes a script exception, the exception line number would be <i translate="no">lineNumber</i> plus one. When no starting line number is specified, line numbers will be 1-based.</p>
<p><i translate="no">fileName</i> is used for error reporting. For example, in error objects the file name is accessible through the &quot;fileName&quot; property if it is provided with this function.</p>
<p><i translate="no">exceptionStackTrace</i> is used to report whether an uncaught exception was thrown. If you pass a non-null pointer to a <a href="../qtcore/qstringlist.html" translate="no">QStringList</a> to it, it will set it to list of &quot;stackframe messages&quot; if the script threw an unhandled exception, or an empty list otherwise. A stackframe message has the format function name:line number:column:file name</p>
<div class="admonition note">
<p><b>Note: </b>In some cases, e.g. for native functions, function name and file name can be empty and line number and column can be -1.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If an exception was thrown and the exception value is not an Error instance (i.e., <a href="qjsvalue.html#isError" translate="no">QJSValue::isError</a>() returns <code translate="no">false</code>), the exception value will still be returned. Use <code translate="no">exceptionStackTrace-&gt;isEmpty()</code> to distinguish whether the value was a normal or an exceptional return value.</p>
</div>
<p><b>See also </b><a href="qqmlexpression.html#evaluate" translate="no">QQmlExpression::evaluate</a>.</p>
<!-- @@@evaluate -->
<!-- $$$fromManagedValue[overload1]$$$fromManagedValueconstQJSManagedValue& -->
<h3 class="fn" translate="no" id="fromManagedValue">template &lt;typename T&gt; <span class="type">T</span> QJSEngine::<span class="name">fromManagedValue</span>(const <span class="type"><a href="qjsmanagedvalue.html" translate="no">QJSManagedValue</a></span> &amp;<i>value</i>)</h3>
<p>Returns the given <i translate="no">value</i> converted to the template type <code translate="no">T</code>.</p>
<p><b>See also </b><a href="qjsengine.html#toManagedValue" translate="no">toManagedValue</a>() and <a href="qjsengine.html#coerceValue" translate="no">coerceValue</a>().</p>
<!-- @@@fromManagedValue -->
<!-- $$$fromPrimitiveValue[overload1]$$$fromPrimitiveValueconstQJSPrimitiveValue& -->
<h3 class="fn" translate="no" id="fromPrimitiveValue">template &lt;typename T&gt; <span class="type">T</span> QJSEngine::<span class="name">fromPrimitiveValue</span>(const <span class="type"><a href="qjsprimitivevalue.html" translate="no">QJSPrimitiveValue</a></span> &amp;<i>value</i>)</h3>
<p>Returns the given <i translate="no">value</i> converted to the template type <code translate="no">T</code>.</p>
<p>Since <a href="qjsprimitivevalue.html" translate="no">QJSPrimitiveValue</a> can only hold int, bool, double, <a href="../qtcore/qstring.html" translate="no">QString</a>, and the equivalents of JavaScript <code translate="no">null</code> and <code translate="no">undefined</code>, the value will be coerced aggressively if you request any other type.</p>
<p><b>See also </b><a href="qjsengine.html#toPrimitiveValue" translate="no">toPrimitiveValue</a>() and <a href="qjsengine.html#coerceValue" translate="no">coerceValue</a>().</p>
<!-- @@@fromPrimitiveValue -->
<!-- $$$fromScriptValue[overload1]$$$fromScriptValueconstQJSValue& -->
<h3 class="fn" translate="no" id="fromScriptValue">template &lt;typename T&gt; <span class="type">T</span> QJSEngine::<span class="name">fromScriptValue</span>(const <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> &amp;<i>value</i>)</h3>
<p>Returns the given <i translate="no">value</i> converted to the template type <code translate="no">T</code>.</p>
<p><b>See also </b><a href="qjsengine.html#toScriptValue" translate="no">toScriptValue</a>() and <a href="qjsengine.html#coerceValue" translate="no">coerceValue</a>().</p>
<!-- @@@fromScriptValue -->
<!-- $$$fromVariant[overload1]$$$fromVariantconstQVariant& -->
<h3 class="fn" translate="no" id="fromVariant">template &lt;typename T&gt; <span class="type">T</span> QJSEngine::<span class="name">fromVariant</span>(const <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Returns the given <i translate="no">value</i> converted to the template type <code translate="no">T</code>. The conversion is done in JavaScript semantics. Those differ from <a href="../qtcore/qvariant.html#qvariant_cast-1" translate="no">qvariant_cast</a>'s semantics. There are a number of implicit conversions between JavaScript-equivalent types that are not performed by <a href="../qtcore/qvariant.html#qvariant_cast-1" translate="no">qvariant_cast</a> by default.</p>
<p><b>See also </b><a href="qjsengine.html#coerceValue" translate="no">coerceValue</a>(), <a href="qjsengine.html#fromScriptValue" translate="no">fromScriptValue</a>(), and <a href="../qtcore/qvariant.html#qvariant_cast" translate="no">qvariant_cast</a>().</p>
<!-- @@@fromVariant -->
<!-- $$$globalObject[overload1]$$$globalObject -->
<h3 class="fn" translate="no" id="globalObject"><span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">globalObject</span>() const</h3>
<p>Returns this engine's Global Object.</p>
<p>By default, the Global Object contains the built-in objects that are part of <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/" translate="no">ECMA-262</a>, such as Math, Date and String. Additionally, you can set properties of the Global Object to make your own extensions available to all script code. Non-local variables in script code will be created as properties of the Global Object, as well as local variables in global code.</p>
<!-- @@@globalObject -->
<!-- $$$hasError[overload1]$$$hasError -->
<h3 class="fn" translate="no" id="hasError"><code class="details extra" translate="no">[since Qt 6.1]</code> <span class="type">bool</span> QJSEngine::<span class="name">hasError</span>() const</h3>
<p>Returns <code translate="no">true</code> if the last JavaScript execution resulted in an exception or if <a href="qjsengine.html#throwError" translate="no">throwError</a>() was called. Otherwise returns <code translate="no">false</code>. Mind that <a href="qjsengine.html#evaluate" translate="no">evaluate</a>() catches any exceptions thrown in the evaluated code.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@hasError -->
<!-- $$$importModule[overload1]$$$importModuleconstQString& -->
<h3 class="fn" translate="no" id="importModule"><span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">importModule</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>fileName</i>)</h3>
<p>Imports the module located at <i translate="no">fileName</i> and returns a module namespace object that contains all exported variables, constants and functions as properties.</p>
<p>If this is the first time the module is imported in the engine, the file is loaded from the specified location in either the local file system or the Qt resource system and evaluated as an ECMAScript module. The file is expected to be encoded in UTF-8 text.</p>
<p>Subsequent imports of the same module will return the previously imported instance. Modules are singletons and remain around until the engine is destroyed.</p>
<p>The specified <i translate="no">fileName</i> will internally be normalized using <a href="../qtcore/qfileinfo.html#canonicalFilePath" translate="no">QFileInfo::canonicalFilePath</a>(). That means that multiple imports of the same file on disk using different relative paths will load the file only once.</p>
<div class="admonition note">
<p><b>Note: </b>If an exception is thrown during the loading of the module, the return value will be the exception (typically an <code translate="no">Error</code> object; see <a href="qjsvalue.html#isError" translate="no">QJSValue::isError</a>()).</p>
</div>
<p><b>See also </b><a href="qjsengine.html#registerModule" translate="no">registerModule</a>().</p>
<!-- @@@importModule -->
<!-- $$$installExtensions[overload1]$$$installExtensionsQJSEngine::ExtensionsconstQJSValue& -->
<h3 class="fn" translate="no" id="installExtensions"><span class="type">void</span> QJSEngine::<span class="name">installExtensions</span>(<span class="type"><a href="qjsengine.html#Extension-enum" translate="no">QJSEngine::Extensions</a></span> <i>extensions</i>, const <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> &amp;<i>object</i> = QJSValue())</h3>
<p>Installs JavaScript <i translate="no">extensions</i> to add functionality that is not available in a standard ECMAScript implementation.</p>
<p>The extensions are installed on the given <i translate="no">object</i>, or on the <a href="qjsengine.html#globalObject" translate="no">Global Object</a> if no object is specified.</p>
<p>Several extensions can be installed at once by <code translate="no">OR</code>-ing the enum values:</p>
<pre class="cpp" translate="no">
 installExtensions(<span class="type"><a href="qjsengine.html#QJSEngine" translate="no">QJSEngine</a></span><span class="operator">::</span>TranslationExtension <span class="operator">|</span> <span class="type"><a href="qjsengine.html#QJSEngine" translate="no">QJSEngine</a></span><span class="operator">::</span>ConsoleExtension);
</pre>
<p><b>See also </b><a href="qjsengine.html#Extension-enum" translate="no">Extension</a>.</p>
<!-- @@@installExtensions -->
<!-- $$$isInterrupted[overload1]$$$isInterrupted -->
<h3 class="fn" translate="no" id="isInterrupted"><span class="type">bool</span> QJSEngine::<span class="name">isInterrupted</span>() const</h3>
<p>Returns whether JavaScript execution is currently interrupted.</p>
<p><b>See also </b><a href="qjsengine.html#setInterrupted" translate="no">setInterrupted</a>().</p>
<!-- @@@isInterrupted -->
<!-- $$$newArray[overload1]$$$newArrayuint -->
<h3 class="fn" translate="no" id="newArray"><span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">newArray</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>length</i> = 0)</h3>
<p>Creates a JavaScript object of class Array with the given <i translate="no">length</i>.</p>
<p><b>See also </b><a href="qjsengine.html#newObject" translate="no">newObject</a>().</p>
<!-- @@@newArray -->
<!-- $$$newErrorObject[overload1]$$$newErrorObjectQJSValue::ErrorTypeconstQString& -->
<h3 class="fn" translate="no" id="newErrorObject"><span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">newErrorObject</span>(<span class="type"><a href="qjsvalue.html#ErrorType-enum" translate="no">QJSValue::ErrorType</a></span> <i>errorType</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>message</i> = QString())</h3>
<p>Creates a JavaScript object of class Error, with <i translate="no">message</i> as the error message.</p>
<p>The prototype of the created object will be <i translate="no">errorType</i>.</p>
<p><b>See also </b><a href="qjsengine.html#newObject" translate="no">newObject</a>(), <a href="qjsengine.html#throwError" translate="no">throwError</a>(), and <a href="qjsvalue.html#isError" translate="no">QJSValue::isError</a>().</p>
<!-- @@@newErrorObject -->
<!-- $$$newObject[overload1]$$$newObject -->
<h3 class="fn" translate="no" id="newObject"><span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">newObject</span>()</h3>
<p>Creates a JavaScript object of class Object.</p>
<p>The prototype of the created object will be the Object prototype object.</p>
<p><b>See also </b><a href="qjsengine.html#newArray" translate="no">newArray</a>() and <a href="qjsvalue.html#setProperty" translate="no">QJSValue::setProperty</a>().</p>
<!-- @@@newObject -->
<!-- $$$newQMetaObject[overload1]$$$newQMetaObjectconstQMetaObject* -->
<h3 class="fn" translate="no" id="newQMetaObject"><span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">newQMetaObject</span>(const <span class="type"><a href="../qtcore/qmetaobject.html" translate="no">QMetaObject</a></span> *<i>metaObject</i>)</h3>
<p>Creates a JavaScript object that wraps the given <a href="../qtcore/qmetaobject.html" translate="no">QMetaObject</a> The <i translate="no">metaObject</i> must outlive the script engine. It is recommended to only use this method with static metaobjects.</p>
<p>When called as a constructor, a new instance of the class will be created. Only constructors exposed by <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> will be visible from the script engine.</p>
<p><b>See also </b><a href="qjsengine.html#newQObject" translate="no">newQObject</a>() and <a href="qjsengine.html#qobject-integration" translate="no">QObject Integration</a>.</p>
<!-- @@@newQMetaObject -->
<!-- $$$newQMetaObject$$$newQMetaObject -->
<h3 class="fn" translate="no" id="newQMetaObject-1">template &lt;typename T&gt; <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">newQMetaObject</span>()</h3>
<p>Creates a JavaScript object that wraps the static <a href="../qtcore/qmetaobject.html" translate="no">QMetaObject</a> associated with class <code translate="no">T</code>.</p>
<p><b>See also </b><a href="qjsengine.html#newQObject" translate="no">newQObject</a>() and <a href="qjsengine.html#qobject-integration" translate="no">QObject Integration</a>.</p>
<!-- @@@newQMetaObject -->
<!-- $$$newQObject[overload1]$$$newQObjectQObject* -->
<h3 class="fn" translate="no" id="newQObject"><span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">newQObject</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>)</h3>
<p>Creates a JavaScript object that wraps the given <a href="../qtcore/qobject.html" translate="no">QObject</a> <i translate="no">object</i>, using <a href="qjsengine.html#ObjectOwnership-enum" translate="no">JavaScriptOwnership</a>.</p>
<p>Signals and slots, properties and children of <i translate="no">object</i> are available as properties of the created <a href="qjsvalue.html" translate="no">QJSValue</a>.</p>
<p>If <i translate="no">object</i> is a null pointer, this function returns a null value.</p>
<p>If a default prototype has been registered for the <i translate="no">object</i>'s class (or its superclass, recursively), the prototype of the new script object will be set to be that default prototype.</p>
<p>If the given <i translate="no">object</i> is deleted outside of the engine's control, any attempt to access the deleted <a href="../qtcore/qobject.html" translate="no">QObject</a>'s members through the JavaScript wrapper object (either by script code or C++) will result in a <a href="qjsengine.html#script-exceptions" translate="no">script exception</a>.</p>
<p><b>See also </b><a href="qjsvalue.html#toQObject" translate="no">QJSValue::toQObject</a>().</p>
<!-- @@@newQObject -->
<!-- $$$newSymbol[overload1]$$$newSymbolconstQString& -->
<h3 class="fn" translate="no" id="newSymbol"><code class="details extra" translate="no">[since 6.2]</code> <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">newSymbol</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>name</i>)</h3>
<p>Creates a JavaScript object of class Symbol, with value <i translate="no">name</i>.</p>
<p>The prototype of the created object will be the Symbol prototype object.</p>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qjsengine.html#newObject" translate="no">newObject</a>().</p>
<!-- @@@newSymbol -->
<!-- $$$objectOwnership[overload1]$$$objectOwnershipQObject* -->
<h3 class="fn" translate="no" id="objectOwnership"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qjsengine.html#ObjectOwnership-enum" translate="no">QJSEngine::ObjectOwnership</a></span> QJSEngine::<span class="name">objectOwnership</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>)</h3>
<p>Returns the ownership of <i translate="no">object</i>.</p>
<p><b>See also </b><a href="qjsengine.html#setObjectOwnership" translate="no">setObjectOwnership</a>() and <a href="qjsengine.html#ObjectOwnership-enum" translate="no">QJSEngine::ObjectOwnership</a>.</p>
<!-- @@@objectOwnership -->
<!-- $$$registerModule[overload1]$$$registerModuleconstQString&constQJSValue& -->
<h3 class="fn" translate="no" id="registerModule"><span class="type">bool</span> QJSEngine::<span class="name">registerModule</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>moduleName</i>, const <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> &amp;<i>value</i>)</h3>
<p>Registers a <a href="qjsvalue.html" translate="no">QJSValue</a> to serve as a module. After this function is called, all modules that import <i translate="no">moduleName</i> will import the value of <i translate="no">value</i> instead of loading <i translate="no">moduleName</i> from the filesystem.</p>
<p>Any valid <a href="qjsvalue.html" translate="no">QJSValue</a> can be registered, but named exports (i.e. <code translate="no">import { name } from &quot;info&quot;</code> are treated as members of an object, so the default export must be created with one of the newXYZ methods of <a href="qjsengine.html" translate="no">QJSEngine</a>.</p>
<p>Because this allows modules that do not exist on the filesystem to be imported, scripting applications can use this to provide built-in modules, similar to Node.js.</p>
<p>Returns <code translate="no">true</code> on success, <code translate="no">false</code> otherwise.</p>
<div class="admonition note">
<p><b>Note: </b>The <a href="qjsvalue.html" translate="no">QJSValue</a> <i translate="no">value</i> is not called or read until it is used by another module. This means that there is no code to evaluate, so no errors will be seen until another module throws an exception while trying to load this module.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>Attempting to access a named export from a <a href="qjsvalue.html" translate="no">QJSValue</a> that is not an object will trigger a <a href="qjsengine.html#script-exceptions" translate="no">exception</a>.</p>
</div>
<p><b>See also </b><a href="qjsengine.html#importModule" translate="no">importModule</a>().</p>
<!-- @@@registerModule -->
<!-- $$$setInterrupted[overload1]$$$setInterruptedbool -->
<h3 class="fn" translate="no" id="setInterrupted"><span class="type">void</span> QJSEngine::<span class="name">setInterrupted</span>(<span class="type">bool</span> <i>interrupted</i>)</h3>
<p>Interrupts or re-enables JavaScript execution.</p>
<p>If <i translate="no">interrupted</i> is <code translate="no">true</code>, any JavaScript executed by this engine immediately aborts and returns an error object until this function is called again with a value of <code translate="no">false</code> for <i translate="no">interrupted</i>.</p>
<p>This function is thread safe. You may call it from a different thread in order to interrupt, for example, an infinite loop in JavaScript.</p>
<p><b>See also </b><a href="qjsengine.html#isInterrupted" translate="no">isInterrupted</a>().</p>
<!-- @@@setInterrupted -->
<!-- $$$setObjectOwnership[overload1]$$$setObjectOwnershipQObject*QJSEngine::ObjectOwnership -->
<h3 class="fn" translate="no" id="setObjectOwnership"><code class="details extra" translate="no">[static]</code> <span class="type">void</span> QJSEngine::<span class="name">setObjectOwnership</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>, <span class="type"><a href="qjsengine.html#ObjectOwnership-enum" translate="no">QJSEngine::ObjectOwnership</a></span> <i>ownership</i>)</h3>
<p>Sets the <i translate="no">ownership</i> of <i translate="no">object</i>.</p>
<p>An object with <code translate="no">JavaScriptOwnership</code> is not garbage collected as long as it still has a parent, even if there are no references to it.</p>
<p><b>See also </b><a href="qjsengine.html#objectOwnership" translate="no">objectOwnership</a>() and <a href="qjsengine.html#ObjectOwnership-enum" translate="no">QJSEngine::ObjectOwnership</a>.</p>
<!-- @@@setObjectOwnership -->
<!-- $$$throwError[overload1]$$$throwErrorconstQString& -->
<h3 class="fn" translate="no" id="throwError"><code class="details extra" translate="no">[since Qt 5.12]</code> <span class="type">void</span> QJSEngine::<span class="name">throwError</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>message</i>)</h3>
<p>Throws a run-time error (exception) with the given <i translate="no">message</i>.</p>
<p>This method is the C++ counterpart of a <code translate="no">throw()</code> expression in JavaScript. It enables C++ code to report run-time errors to <a href="qjsengine.html" translate="no">QJSEngine</a>. Therefore it should only be called from C++ code that was invoked by a JavaScript function through <a href="qjsengine.html" translate="no">QJSEngine</a>.</p>
<p>When returning from C++, the engine will interrupt the normal flow of execution and call the next pre-registered exception handler with an error object that contains the given <i translate="no">message</i>. The error object will point to the location of the top-most context on the JavaScript caller stack; specifically, it will have properties <code translate="no">lineNumber</code>, <code translate="no">fileName</code> and <code translate="no">stack</code>. These properties are described in <a href="qjsengine.html#script-exceptions" translate="no">Script Exceptions</a>.</p>
<p>In the following example a C++ method in <i>FileAccess.cpp</i> throws an error in <i>qmlFile.qml</i> at the position where <code translate="no">readFileAsText()</code> is called:</p>
<pre class="cpp" translate="no">
 <span class="comment">// qmlFile.qml</span>
 function someFunction() {
   <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
   var text <span class="operator">=</span> FileAccess<span class="operator">.</span>readFileAsText(<span class="string">&quot;/path/to/file.txt&quot;</span>);
 }
</pre>
<pre class="cpp" translate="no">
 <span class="comment">// FileAccess.cpp</span>
 <span class="comment">// Assuming that FileAccess is a QObject-derived class that has been</span>
 <span class="comment">// registered as a singleton type and provides an invokable method</span>
 <span class="comment">// readFileAsText()</span>

 <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> FileAccess<span class="operator">::</span>readFileAsText(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span> filePath) {
   <span class="type"><a href="../qtcore/qfile.html" translate="no">QFile</a></span> file(filePath);

   <span class="keyword">if</span> (<span class="operator">!</span>file<span class="operator">.</span>open(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span><span class="operator">::</span>ReadOnly)) {
     jsEngine<span class="operator">-</span><span class="operator">&gt;</span>throwError(file<span class="operator">.</span>errorString());
     <span class="keyword">return</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>();
   }

   <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
   <span class="keyword">return</span> content;
 }
</pre>
<p>It is also possible to catch the thrown error in JavaScript:</p>
<pre class="cpp" translate="no">
 <span class="comment">// qmlFile.qml</span>
 function someFunction() {
   <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
   var text;
   <span class="keyword">try</span> {
     text <span class="operator">=</span> FileAccess<span class="operator">.</span>readFileAsText(<span class="string">&quot;/path/to/file.txt&quot;</span>);
   } <span class="keyword">catch</span> (error) {
     console<span class="operator">.</span>warn(<span class="string">&quot;In &quot;</span> <span class="operator">+</span> error<span class="operator">.</span>fileName <span class="operator">+</span> <span class="string">&quot;:&quot;</span> <span class="operator">+</span> <span class="string">&quot;error.lineNumber&quot;</span> <span class="operator">+</span>
                  <span class="string">&quot;: &quot;</span> <span class="operator">+</span> error<span class="operator">.</span>message);
   }
 }
</pre>
<p>If you need a more specific run-time error to describe an exception, you can use the <a href="qjsengine.html#throwError-1" translate="no">throwError</a>(QJSValue::ErrorType errorType, const QString &amp;message) overload.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="qjsengine.html#script-exceptions" translate="no">Script Exceptions</a>.</p>
<!-- @@@throwError -->
<!-- $$$throwError$$$throwErrorQJSValue::ErrorTypeconstQString& -->
<h3 class="fn" translate="no" id="throwError-1"><code class="details extra" translate="no">[since Qt 5.12]</code> <span class="type">void</span> QJSEngine::<span class="name">throwError</span>(<span class="type"><a href="qjsvalue.html#ErrorType-enum" translate="no">QJSValue::ErrorType</a></span> <i>errorType</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>message</i> = QString())</h3>
<p>This function overloads throwError().</p>
<p>Throws a run-time error (exception) with the given <i translate="no">errorType</i> and <i translate="no">message</i>.</p>
<pre class="cpp" translate="no">
 <span class="comment">// Assuming that DataEntry is a QObject-derived class that has been</span>
 <span class="comment">// registered as a singleton type and provides an invokable method</span>
 <span class="comment">// setAge().</span>

 <span class="type">void</span> DataEntry<span class="operator">::</span>setAge(<span class="type">int</span> age) {
   <span class="keyword">if</span> (age <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> age <span class="operator">&gt;</span> <span class="number">200</span>) {
     jsEngine<span class="operator">-</span><span class="operator">&gt;</span>throwError(<span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span><span class="operator">::</span>RangeError<span class="operator">,</span>
                          <span class="string">&quot;Age must be between 0 and 200&quot;</span>);
   }
   <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 }
</pre>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="qjsengine.html#script-exceptions" translate="no">Script Exceptions</a> and <a href="qjsengine.html#newErrorObject" translate="no">newErrorObject</a>().</p>
<!-- @@@throwError -->
<!-- $$$throwError$$$throwErrorconstQJSValue& -->
<h3 class="fn" translate="no" id="throwError-2"><code class="details extra" translate="no">[since 6.1]</code> <span class="type">void</span> QJSEngine::<span class="name">throwError</span>(const <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> &amp;<i>error</i>)</h3>
<p>This function overloads throwError().</p>
<p>Throws a pre-constructed run-time <i translate="no">error</i> (exception). This way you can use <a href="qjsengine.html#newErrorObject" translate="no">newErrorObject</a>() to create the error and customize it as necessary.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qjsengine.html#script-exceptions" translate="no">Script Exceptions</a> and <a href="qjsengine.html#newErrorObject" translate="no">newErrorObject</a>().</p>
<!-- @@@throwError -->
<!-- $$$toManagedValue[overload1]$$$toManagedValueconstT& -->
<h3 class="fn" translate="no" id="toManagedValue">template &lt;typename T&gt; <span class="type"><a href="qjsmanagedvalue.html" translate="no">QJSManagedValue</a></span> QJSEngine::<span class="name">toManagedValue</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Creates a <a href="qjsmanagedvalue.html" translate="no">QJSManagedValue</a> with the given <i translate="no">value</i>.</p>
<p><b>See also </b><a href="qjsengine.html#fromManagedValue" translate="no">fromManagedValue</a>() and <a href="qjsengine.html#coerceValue" translate="no">coerceValue</a>().</p>
<!-- @@@toManagedValue -->
<!-- $$$toPrimitiveValue[overload1]$$$toPrimitiveValueconstT& -->
<h3 class="fn" translate="no" id="toPrimitiveValue">template &lt;typename T&gt; <span class="type"><a href="qjsprimitivevalue.html" translate="no">QJSPrimitiveValue</a></span> QJSEngine::<span class="name">toPrimitiveValue</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Creates a <a href="qjsprimitivevalue.html" translate="no">QJSPrimitiveValue</a> with the given <i translate="no">value</i>.</p>
<p>Since <a href="qjsprimitivevalue.html" translate="no">QJSPrimitiveValue</a> can only hold int, bool, double, <a href="../qtcore/qstring.html" translate="no">QString</a>, and the equivalents of JavaScript <code translate="no">null</code> and <code translate="no">undefined</code>, the value will be coerced aggressively if you pass any other type.</p>
<p><b>See also </b><a href="qjsengine.html#fromPrimitiveValue" translate="no">fromPrimitiveValue</a>() and <a href="qjsengine.html#coerceValue" translate="no">coerceValue</a>().</p>
<!-- @@@toPrimitiveValue -->
<!-- $$$toScriptValue[overload1]$$$toScriptValueconstT& -->
<h3 class="fn" translate="no" id="toScriptValue">template &lt;typename T&gt; <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> QJSEngine::<span class="name">toScriptValue</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Creates a <a href="qjsvalue.html" translate="no">QJSValue</a> with the given <i translate="no">value</i>.</p>
<p><b>See also </b><a href="qjsengine.html#fromScriptValue" translate="no">fromScriptValue</a>() and <a href="qjsengine.html#coerceValue" translate="no">coerceValue</a>().</p>
<!-- @@@toScriptValue -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qjsEngine[overload1]$$$qjsEngineconstQObject* -->
<h3 class="fn" translate="no" id="qjsEnginex"><span class="type"><a href="qjsengine.html#QJSEngine" translate="no">QJSEngine</a></span> *<span class="name">qjsEngine</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>)</h3>
<p>Returns the <a href="qjsengine.html" translate="no">QJSEngine</a> associated with <i translate="no">object</i>, if any.</p>
<p>This function is useful if you have exposed a <a href="../qtcore/qobject.html" translate="no">QObject</a> to the JavaScript environment and later in your program would like to regain access. It does not require you to keep the wrapper around that was returned from <a href="qjsengine.html#newQObject" translate="no">QJSEngine::newQObject</a>().</p>
<!-- @@@qjsEngine -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
