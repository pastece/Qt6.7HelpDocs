<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- definetypes.qdoc -->
  <meta name="description" content="Description of ways to define QML object types from C++ code">
  <title>Defining QML Types from C++ | Qt QML 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtqml-index.html" translate="no">Qt QML</a></li>
<li>Defining QML Types from C++</li>
<li id="buildversion"><a href="qtqml-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#registering-c-types-with-the-qml-type-system">Registering C++ Types with the QML Type System</a></li>
<li class="level2"><a href="#preconditions">Preconditions</a></li>
<li class="level2"><a href="#registering-an-instantiable-object-type">Registering an Instantiable Object Type</a></li>
<li class="level2"><a href="#registering-value-types">Registering Value Types</a></li>
<li class="level2"><a href="#value-types-with-enumerations">Value Types with Enumerations</a></li>
<li class="level2"><a href="#registering-non-instantiable-types">Registering Non-Instantiable Types</a></li>
<li class="level2"><a href="#final-properties">Final properties</a></li>
<li class="level2"><a href="#type-revisions-and-versions">Type Revisions and Versions</a></li>
<li class="level2"><a href="#registering-extension-objects">Registering Extension Objects</a></li>
<li class="level2"><a href="#registering-foreign-types">Registering Foreign Types</a></li>
<li class="level1"><a href="#defining-qml-specific-types-and-attributes">Defining QML-Specific Types and Attributes</a></li>
<li class="level2"><a href="#providing-attached-properties">Providing Attached Properties</a></li>
<li class="level2"><a href="#property-modifier-types">Property Modifier Types</a></li>
<li class="level2"><a href="#specifying-default-and-parent-properties-for-qml-object-types">Specifying Default and Parent Properties for QML Object Types</a></li>
<li class="level2"><a href="#defining-visual-items-with-the-qt-quick-module">Defining Visual Items with the Qt Quick Module</a></li>
<li class="level1"><a href="#receiving-notifications-for-object-initialization">Receiving Notifications for Object Initialization</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Defining QML Types from C++</h1>
<!-- $$$qtqml-cppintegration-definetypes.html-description -->
<div class="descr" id="details">
<p>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived class are accessible from QML, as discussed in <a href="qtqml-cppintegration-exposecppattributes.html" translate="no">Exposing Attributes of C++ Types to QML</a>, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable <a href="qtqml-typesystem-objecttypes.html" translate="no">QML object type</a> from QML, or enabling a singleton instance of the class to be imported and used from QML.</p>
<p>Additionally, the <a href="qtqml-index.html" translate="no">Qt Qml</a> module provides mechanisms for implementing QML-specific features such as <i>attached properties</i> and <i>default properties</i> in C++.</p>
<p>(Note that a number of the important concepts covered in this document are demonstrated in the <a href="qtqml-tutorials-extending-qml-example.html" translate="no">Writing QML Extensions with C++</a> tutorial.)</p>
<p><b>NOTE:</b> All headers that declare QML types need to be accessible without any prefix from the project's include path.</p>
<p>For more information about C++ and the different QML integration methods, see the <a href="qtqml-cppintegration-overview.html" translate="no">C++ and QML integration overview</a> page.</p>
<h2 id="registering-c-types-with-the-qml-type-system">Registering C++ Types with the QML Type System</h2>
<p>A <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived class can be registered with the QML type system to enable the type to be used as a data type from within QML code.</p>
<p>The engine allows the registration of both instantiable and non-instantiable types. Registering an instantiable type enables a C++ class to be used as the definition of a QML object type, allowing it to be used in object declarations from QML code to create objects of this type. Registration also provides the engine with additional type metadata, enabling the type (and any enums declared by the class) to be used as a data type for property values, method parameters and return values, and signal parameters that are exchanged between QML and C++.</p>
<p>Registering a non-instantiable type also registers the class as a data type in this manner, but the type cannot be used instantiated as a QML object type from QML. This is useful, for example, if a type has enums that should be exposed to QML but the type itself should not be instantiable.</p>
<p>For a quick guide to choosing the correct approach to expose C++ types to QML, see <a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml" translate="no">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<h3 id="preconditions">Preconditions</h3>
<p>All the macros mentioned below are available from the <code translate="no">qqmlregistration.h</code> header. You need to add the following code to the files using them in order to make the macros available:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;QtQml/qqmlregistration.h&gt;</span>
</pre>
<p>Furthermore, your class declarations have to live in headers reachable via your project's include path. The declarations are used to generate registration code at compile time, and the registration code needs to include the headers that contain the declarations.</p>
<h3 id="registering-an-instantiable-object-type">Registering an Instantiable Object Type</h3>
<p><b>Any <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived C++ class can be registered as the definition of a <a href="qtqml-typesystem-objecttypes.html" translate="no">QML object type</a></b>. Once a class is registered with the QML type system, the class can be declared and instantiated like any other object type from QML code. Once created, a class instance can be manipulated from QML; as <a href="qtqml-cppintegration-exposecppattributes.html" translate="no">Exposing Attributes of C++ Types to QML</a> explains, the properties, methods and signals of any <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived class are accessible from QML code.</p>
<p>To register a <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived class as an instantiable QML object type, add <code translate="no">QML_ELEMENT</code> or <code translate="no">QML_NAMED_ELEMENT(&lt;name&gt;)</code> to the class declaration. You also need to make adjustments in the build system. For qmake, add <code translate="no">CONFIG += qmltypes</code>, a <code translate="no">QML_IMPORT_NAME</code>, and a <code translate="no">QML_IMPORT_MAJOR_VERSION</code> to your project file. For CMake, the file containing the class should be part of a target set-up with <a href="qt-add-qml-module.html" translate="no">qt_add_qml_module()</a>. This will register the class into the type namespace under the given major version, using either the class name or an explicitly given name as QML type name. The minor version(s) will be derived from any revisions attached to properties, methods, or signals. The default minor version is <code translate="no">0</code>. You can explicitly restrict the type to be available only from specific minor versions by adding the <code translate="no">QML_ADDED_IN_VERSION()</code> macro to the class declaration. Clients can import suitable versions of the namespace in order to use the type.</p>
<p>For example, suppose there is a <code translate="no">Message</code> class with <code translate="no">author</code> and <code translate="no">creationDate</code> properties:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Message : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> author READ author WRITE setAuthor NOTIFY authorChanged)
     Q_PROPERTY(<span class="type"><a href="../qtcore/qdatetime.html" translate="no">QDateTime</a></span> creationDate READ creationDate WRITE setCreationDate NOTIFY creationDateChanged)
     QML_ELEMENT
 <span class="keyword">public</span>:
     <span class="comment">// ...</span>
 };
</pre>
<p>This type can be registered by adding an appropriate type namespace and version number to the project file. For example, to make the type available in the <code translate="no">com.mycompany.messaging</code> namespace with version 1.0:</p>
<h4 id="using-cmake">Using CMake</h4>
<pre class="cpp plain" translate="no">
 qt_add_qml_module(messaging
     URI com.mycompany.messaging
     VERSION 1.0
     SOURCES
         message.cpp message.h
 )
</pre>
<h4 id="using-qmake">Using QMake</h4>
<pre class="cpp" translate="no">
 CONFIG <span class="operator">+</span><span class="operator">=</span> qmltypes
 QML_IMPORT_NAME <span class="operator">=</span> com<span class="operator">.</span>mycompany<span class="operator">.</span>messaging
 QML_IMPORT_MAJOR_VERSION <span class="operator">=</span> <span class="number">1</span>
</pre>
<p>If the header the class is declared in is not accessible from your project's include path, you may have to amend the include path so that the generated registration code can be compiled.</p>
<pre class="cpp" translate="no">
 INCLUDEPATH <span class="operator">+</span><span class="operator">=</span> com<span class="operator">/</span>mycompany<span class="operator">/</span>messaging
</pre>
<p>The type can be used in an <a href="qtqml-syntax-basics.html#object-declarations" translate="no">object declaration</a> from QML, and its properties can be read and written to, as per the example below:</p>
<pre class="qml" translate="no">
 import com.mycompany.messaging

 <span class="type">Message</span> {
     <span class="name">author</span>: <span class="string">&quot;Amelie&quot;</span>
     <span class="name">creationDate</span>: new <span class="name">Date</span>()
 }
</pre>
<h3 id="registering-value-types">Registering Value Types</h3>
<p>Any type with a <a href="../qtcore/qobject.html#Q_GADGET" translate="no">Q_GADGET</a> macro can the registered as a <a href="qtqml-typesystem-valuetypes.html" translate="no">QML value type</a>. Once such a type is registered with the QML type system it can be used as property type in QML code. Such an instance can be manipulated from QML; as <a href="qtqml-cppintegration-exposecppattributes.html" translate="no">Exposing Attributes of C++ Types to QML</a> explains, the properties and methods of any value type are accessible from QML code.</p>
<p>In contrast to object types, value types require <b>lower case</b> names. The preferred way to register them is using the <a href="qqmlengine.html#QML_VALUE_TYPE" translate="no">QML_VALUE_TYPE</a> or <a href="qqmlengine.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a> macros. There is no equivalent to <a href="qqmlengine.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> as your C++ classes are typically going to have upper case names. Otherwise the registration is very similar to the registration of object types.</p>
<p>For example, suppose you want to register a value type <code translate="no">person</code> that consists of two strings for first and last name:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Person
 {
     Q_GADGET
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> firstName READ firstName WRITE setFirstName)
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> lastName READ lastName WRITE setLastName)
     QML_VALUE_TYPE(person)
 <span class="keyword">public</span>:
     <span class="comment">// ...</span>
 };
</pre>
<p>There are some further limitations on what you can do with value types:</p>
<ul>
<li>Value types cannot be singletons.</li>
<li>Value types need to be default-constructible and copy-constructible.</li>
<li>Using <a href="../qtcore/qproperty.html" translate="no">QProperty</a> as a member of a value type is problematic. Value types get copied, and you would need to decide what to do with any bindings on the <a href="../qtcore/qproperty.html" translate="no">QProperty</a> at that point. You should not use <a href="../qtcore/qproperty.html" translate="no">QProperty</a> in value types.</li>
<li>Value types cannot provide attached properties.</li>
<li>The API to define extensions to value types (<a href="qqmlengine.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>) is not public and subject to future changes.</li>
</ul>
<h3 id="value-types-with-enumerations">Value Types with Enumerations</h3>
<p>Exposing enumerations from a value type to QML requires some extra steps.</p>
<p>Value types have lower case names in QML and types with lower case names are generally not addressable in JavaScript code (unless you specify <a href="qtqml-documents-structure.html#valuetypebehavior" translate="no">pragma ValueTypeBehavior: Addressable</a>). If you have a value type in C++ with an enumeration you want to expose to QML, you need to expose the enumeration separately.</p>
<p>This can be solved by using <a href="qqmlengine.html#QML_FOREIGN_NAMESPACE" translate="no">QML_FOREIGN_NAMESPACE</a>. First, derive from your value type to create a separate C++ type:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Person
 {
     Q_GADGET
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> firstName READ firstName WRITE setFirstName)
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> lastName READ lastName WRITE setLastName)
     QML_VALUE_TYPE(person)
 <span class="keyword">public</span>:
     <span class="keyword">enum</span> TheEnum { A<span class="operator">,</span> B<span class="operator">,</span> C };
     Q_ENUM(TheEnum)
     <span class="comment">//...</span>
 };

 <span class="keyword">class</span> PersonDerived: <span class="keyword">public</span> Person
 {
     Q_GADGET
 };
</pre>
<p>Then expose the derived type as a foreign namespace:</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> PersonDerivedForeign
 {
     Q_NAMESPACE
     QML_NAMED_ELEMENT(Person)
     QML_FOREIGN_NAMESPACE(PersonDerived)
 }
</pre>
<p>This produces a <a href="qtqml-typesystem-namespaces.html" translate="no">QML Namespace</a> called <code translate="no">Person</code> (upper case) with an enumeration called <code translate="no">TheEnum</code> and values <code translate="no">A</code>, <code translate="no">B</code>, and <code translate="no">C</code>. Then you can write the following in QML:</p>
<pre class="qml" translate="no">
 someProperty: Person.A
</pre>
<p>At the same time you can still use your value type called <code translate="no">person</code> (lower case) exactly as before.</p>
<h3 id="registering-non-instantiable-types">Registering Non-Instantiable Types</h3>
<p>Sometimes a <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived class may need to be registered with the QML type system but not as an instantiable type. For example, this is the case if a C++ class:</p>
<ul>
<li>is an interface type that should not be instantiable</li>
<li>is a base class type that does not need to be exposed to QML</li>
<li>declares some enum that should be accessible from QML, but otherwise should not be instantiable</li>
<li>is a type that should be provided to QML through a singleton instance, and should not be instantiable from QML</li>
</ul>
<p>The <a href="qtqml-index.html" translate="no">Qt Qml</a> module provides several macros for registering non-instantiable types:</p>
<ul>
<li><a href="qqmlengine.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a> registers a C++ type that is not instantiable and cannot be referred to from QML. This enables the engine to coerce any inherited types that are instantiable from QML.</li>
<li><a href="qqmlengine.html#QML_INTERFACE" translate="no">QML_INTERFACE</a> registers an existing Qt interface type. The type is not instantiable from QML, and you cannot declare QML properties with it. Using C++ properties of this type from QML will do the expected interface casts, though.</li>
<li><a href="qqmlengine.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(reason) combined with with <a href="qqmlengine.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlengine.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a> registers a named C++ type that is not instantiable but should be identifiable as a type to the QML type system. This is useful if a type's enums or attached properties should be accessible from QML but the type itself should not be instantiable. The parameter should be an error message to be emitted if an attempt at creating an instance of the type is detected.</li>
<li><a href="qqmlengine.html#QML_SINGLETON" translate="no">QML_SINGLETON</a> combined with <a href="qqmlengine.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlengine.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a> registers a singleton type that can be imported from QML, as discussed below.</li>
</ul>
<p>Note that all C++ types registered with the QML type system must be <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived, even if they are non-instantiable.</p>
<h4 id="registering-singleton-objects-with-a-singleton-type">Registering Singleton Objects with a Singleton Type</h4>
<p>A singleton type enables properties, signals and methods to be exposed in a namespace without requiring the client to manually instantiate an object instance. <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton types in particular are an efficient and convenient way to provide functionality or global property values.</p>
<p>Note that singleton types do not have an associated <a href="qqmlcontext.html" translate="no">QQmlContext</a> as they are shared across all contexts in an engine. <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton type instances are constructed and owned by the <a href="qqmlengine.html" translate="no">QQmlEngine</a>, and will be destroyed when the engine is destroyed.</p>
<p>A <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton type can be interacted with in a manner similar to any other <a href="../qtcore/qobject.html" translate="no">QObject</a> or instantiated type, except that only one (engine constructed and owned) instance will exist, and it must be referenced by type name rather than id. Q_PROPERTYs of <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton types may be bound to, and <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> functions of <a href="../qtcore/qobject.html" translate="no">QObject</a> module APIs may be used in signal handler expressions. This makes singleton types an ideal way to implement styling or theming, and they can also be used instead of &quot;.pragma library&quot; script imports to store global state or to provide global functionality.</p>
<p>Once registered, a <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton type may be imported and used like any other <a href="../qtcore/qobject.html" translate="no">QObject</a> instance exposed to QML. The following example assumes that a <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton type was registered into the &quot;MyThemeModule&quot; namespace with version 1.0, where that <a href="../qtcore/qobject.html" translate="no">QObject</a> has a <a href="../qtgui/qcolor.html" translate="no">QColor</a> &quot;color&quot; <a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a>:</p>
<pre class="qml" translate="no">
 import MyThemeModule 1.0 as Theme

 <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     <span class="name">color</span>: <span class="name">Theme</span>.<span class="name">color</span> <span class="comment">// binding.</span>
 }
</pre>
<p>A <a href="qjsvalue.html" translate="no">QJSValue</a> may also be exposed as a singleton type, however clients should be aware that properties of such a singleton type cannot be bound to.</p>
<p>See <a href="qqmlengine.html#QML_SINGLETON" translate="no">QML_SINGLETON</a> for more information on how implement and register a new singleton type, and how to use an existing singleton type. See <a href="qml-singleton.html" translate="no">Singletons in QML</a> for more in-depth information about singletons.</p>
<div class="admonition note">
<p><b>Note: </b>Enum values for registered types in QML should start with a capital.</p>
</div>
<h3 id="final-properties">Final properties</h3>
<p>Properties declared final using the <code translate="no">FINAL</code> modifier to <a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a> cannot be overridden. This means that any properties or functions of the same name, declared either in QML or in C++ on derived types, are ignored by the QML engine. You should declare properties <code translate="no">FINAL</code> when possible, in order to avoid accidental overrides. An override of a property is visible not only in derived classes, but also to QML code executing the context of the base class. Such QML code, typically expects the original property, though. This is a frequent source of mistakes.</p>
<p>Properties declared <code translate="no">FINAL</code> can also not be overridden by functions in QML, or by <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> methods in C++.</p>
<h3 id="type-revisions-and-versions">Type Revisions and Versions</h3>
<p>Many of the type registration functions require versions to be specified for the registered type. Type revisions and versions allow new properties or methods to exist in the new version while remaining compatible with previous versions.</p>
<p>Consider these two QML files:</p>
<pre class="cpp" translate="no">
 <span class="comment">// main.qml</span>
 import <span class="type"><a href="../qtquick/qtquick-module.html" translate="no">QtQuick</a></span> <span class="number">1.0</span>

 Item {
     id: root
     MyType {}
 }
</pre>
<pre class="cpp" translate="no">
 <span class="comment">// MyType.qml</span>
 import MyTypes <span class="number">1.0</span>

 CppType {
     value: root<span class="operator">.</span>x
 }
</pre>
<p>where <code translate="no">CppType</code> maps to the C++ class <code translate="no">CppType</code>.</p>
<p>If the author of CppType adds a <code translate="no">root</code> property to CppType in a new version of their type definition, <code translate="no">root.x</code> now resolves to a different value because <code translate="no">root</code> is also the <code translate="no">id</code> of the top level component. The author could specify that the new <code translate="no">root</code> property is available from a specific minor version. This permits new properties and features to be added to existing types without breaking existing programs.</p>
<p>The REVISION tag is used to mark the <code translate="no">root</code> property as added in revision 1 of the type. Methods such as <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>'s, signals and slots can also be tagged for a revision using the <code translate="no">Q_REVISION(x)</code> macro:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> CppType : <span class="keyword">public</span> BaseType
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type">int</span> root READ root WRITE setRoot NOTIFY rootChanged REVISION <span class="number">1</span>)
     QML_ELEMENT

 <span class="keyword">signals</span>:
     Q_REVISION(<span class="number">1</span>) <span class="type">void</span> rootChanged();
 };
</pre>
<p>The revisions given this way are automatically interpreted as minor versions to the major version given in the project file. In this case, <code translate="no">root</code> is only available when <code translate="no">MyTypes</code> version 1.1 or higher is imported. Imports of <code translate="no">MyTypes</code> version 1.0 remain unaffected.</p>
<p>For the same reason, new types introduced in later versions should be tagged with the <a href="qqmlengine.html#QML_ADDED_IN_VERSION" translate="no">QML_ADDED_IN_VERSION</a> macro.</p>
<p>This feature of the language allows for behavioural changes to be made without breaking existing applications. Consequently QML module authors should always remember to document what changed between minor versions, and QML module users should check that their application still runs correctly before deploying an updated import statement.</p>
<p>Revisions of a base class that your type depends upon are automatically registered when registering the type itself. This is useful when deriving from base classes provided by other authors, e.g. when extending classes from the Qt Quick module.</p>
<div class="admonition note">
<p><b>Note: </b>The QML engine does not support revisions for properties or signals of grouped and attached property objects.</p>
</div>
<h3 id="registering-extension-objects">Registering Extension Objects</h3>
<p>When integrating existing classes and technology into QML, APIs will often need tweaking to fit better into the declarative environment. Although the best results are usually obtained by modifying the original classes directly, if this is either not possible or is complicated by some other concerns, extension objects allow limited extension possibilities without direct modifications.</p>
<p><i>Extension objects</i> add additional properties to an existing type. An extended type definition allows the programmer to supply an additional type, known as the <i>extension type</i>, when registering the class. Its members are transparently merged with the original target class when used from within QML. For example:</p>
<pre class="qml" translate="no">
 <span class="type">QLineEdit</span> {
     <span class="name">leftMargin</span>: <span class="number">20</span>
 }
</pre>
<p>The <code translate="no">leftMargin</code> property is a new property added to an existing C++ type, <a href="../qtwidgets/qlineedit.html" translate="no">QLineEdit</a>, without modifying its source code.</p>
<p>The <a href="qqmlengine.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>(extension) macro is for registering extended types. The argument is the name of another class to be used as extension.</p>
<p>You can also use <a href="qqmlengine.html#QML_EXTENDED_NAMESPACE" translate="no">QML_EXTENDED_NAMESPACE</a>(namespace) to register a namespace, and especially the enumerations declared within, as an extension to a type. If the type you are extending is itself a namespace, you need to use QML_NAMESPACE_EXTENDED(namespace) instead.</p>
<p>An extension class is a regular <a href="../qtcore/qobject.html" translate="no">QObject</a>, with a constructor that takes a <a href="../qtcore/qobject.html" translate="no">QObject</a> pointer. However, the extension class creation is delayed until the first extended property is accessed. The extension class is created and the target object is passed in as the parent. When the property on the original is accessed, the corresponding property on the extension object is used instead.</p>
<h3 id="registering-foreign-types">Registering Foreign Types</h3>
<p>There may be C++ types that cannot be modified to hold the above mentioned macros. Those may be types from 3rdparty libraries, or types that need to fulfill some contract that contradicts the presence of those macros. You can still expose those types to QML, though, using the <a href="qqmlengine.html#QML_FOREIGN" translate="no">QML_FOREIGN</a> macro. In order to do this, create a separate struct that consists entirely of the registration macros, like this:</p>
<pre class="cpp" translate="no">
 <span class="comment">// Contains class Immutable3rdParty</span>
 <span class="preprocessor">#include &lt;3rdpartyheader.h&gt;</span>

 <span class="keyword">struct</span> Foreign
 {
     Q_GADGET
     QML_FOREIGN(Immutable3rdParty)
     QML_NAMED_ELEMENT(Accessible3rdParty)
     QML_ADDED_IN_VERSION(<span class="number">2</span><span class="operator">,</span> <span class="number">4</span>)
     <span class="comment">// QML_EXTENDED, QML_SINGLETON ...</span>
 };
</pre>
<p>From this code, you get a QML type with the methods and properties of Immutable3rdParty, and the QML traits (e.g.: singleton, extended) specified in Foreign.</p>
<h2 id="defining-qml-specific-types-and-attributes">Defining QML-Specific Types and Attributes</h2>
<h3 id="providing-attached-properties">Providing Attached Properties</h3>
<p>In the QML language syntax, there is a notion of <a href="qtqml-syntax-objectattributes.html#attached-properties-and-attached-signal-handlers" translate="no"><i>attached properties</i> and <i>attached signal handlers</i></a>, which are additional attributes that are attached to an object. Essentially, such attributes are implemented and provided by an <i>attaching type</i>, and these attributes may be <i>attached</i> to an object of another type. This contrasts with ordinary object properties which are provided by the object type itself (or the object's inherited type).</p>
<p>For example, the <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> below uses attached properties and attached handlers:</p>
<pre class="qml" translate="no">
 import QtQuick 2.0

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

     <span class="name">focus</span>: <span class="number">true</span>
     <span class="name">Keys</span>.enabled: <span class="number">false</span>
     <span class="name">Keys</span>.onReturnPressed: <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Return key was pressed&quot;</span>)
 }
</pre>
<p>Here, the <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> object is able to access and set the values of <code translate="no">Keys.enabled</code> and <code translate="no">Keys.onReturnPressed</code>. This allows the <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> object to access these extra attributes as an extension to its own existing attributes.</p>
<h4 id="steps-for-implementing-attached-objects">Steps for Implementing Attached Objects</h4>
<p>When considering the above example, there are several parties involved:</p>
<ul>
<li>There is an instance of an anonymous <i>attached object type</i>, with an <code translate="no">enabled</code> and a <code translate="no">returnPressed</code> signal, that has been attached to the <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> object to enable it to access and set these attributes.</li>
<li>The <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> object is the <i>attachee</i>, to which the instance of the <i>attached object type</i> has been attached.</li>
<li><a href="../qtquick/qml-qtquick-keys.html" translate="no">Keys</a> is the <i>attaching type</i>, which provides the <i>attachee</i> with a named qualifier, &quot;Keys&quot;, through which it may access the attributes of the <i>attached object type</i>.</li>
</ul>
<p>When the QML engine processes this code, it creates a single instance of the <i>attached object type</i> and attaches this instance to the <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> object, thereby providing it with access to the <code translate="no">enabled</code> and <code translate="no">returnPressed</code> attributes of the instance.</p>
<p>The mechanisms for providing attached objects can be implemented from C++ by providing classes for the <i>attached object type</i> and <i>attaching type</i>. For the <i>attached object type</i>, provide a <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived class that defines the attributes to be made accessible to <i>attachee</i> objects. For the <i>attaching type</i>, provide a <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived class that:</p>
<ul>
<li>implements a static qmlAttachedProperties() with the following signature:<pre class="cpp" translate="no">
 <span class="keyword">static</span> <span class="operator">&lt;</span>AttachedPropertiesType<span class="operator">&gt;</span> <span class="operator">*</span>qmlAttachedProperties(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>object);
</pre>
<p>This method should return an instance of the <i>attached object type</i>.</p>
<p>The QML engine invokes this method in order to attach an instance of the attached object type to the <i>attachee</i> specified by the <code translate="no">object</code> parameter. It is customary, though not strictly required, for this method implementation to parent the returned instance to <code translate="no">object</code> in order to prevent memory leaks.</p>
<p>This method is called at most once by the engine for each attachee object instance, as the engine caches the returned instance pointer for subsequent attached property accesses. Consequently the attachment object may not be deleted until the attachee <code translate="no">object</code> is destroyed.</p>
</li>
<li>is declared as an attaching type, by adding the <a href="qqmlengine.html#QML_ATTACHED" translate="no">QML_ATTACHED</a>(attached) macro to the class declaration. The argument is the name of the <i>attached object type</i></li>
</ul>
<h4 id="implementing-attached-objects-an-example">Implementing Attached Objects: An Example</h4>
<p>For example, take the <code translate="no">Message</code> type described in an <a href="qtqml-cppintegration-definetypes.html#registering-an-instantiable-object-type" translate="no">earlier example</a>:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Message : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> author READ author WRITE setAuthor NOTIFY authorChanged)
     Q_PROPERTY(<span class="type"><a href="../qtcore/qdatetime.html" translate="no">QDateTime</a></span> creationDate READ creationDate WRITE setCreationDate NOTIFY creationDateChanged)
     QML_ELEMENT
 <span class="keyword">public</span>:
     <span class="comment">// ...</span>
 };
</pre>
<p>Suppose it is necessary to trigger a signal on a <code translate="no">Message</code> when it is published to a message board, and also track when the message has expired on the message board. Since it doesn't make sense to add these attributes directly to a <code translate="no">Message</code>, as the attributes are more relevant to the message board context, they could be implemented as <i>attached</i> attributes on a <code translate="no">Message</code> object that are provided through a &quot;MessageBoard&quot; qualifier. In terms of the concepts described earlier, the parties involved here are:</p>
<ul>
<li>An instance of an anonymous <i>attached object type</i>, which provides a <code translate="no">published</code> signal and an expired property. This type is implemented by <code translate="no">MessageBoardAttachedType</code> below</li>
<li>A <code translate="no">Message</code> object, which will be the <i>attachee</i></li>
<li>The <code translate="no">MessageBoard</code> type, which will be the <i>attaching type</i> that is used by <code translate="no">Message</code> objects to access the attached attributes</li>
</ul>
<p>Following is an example implementation. First, there needs to be an <i>attached object type</i> with the necessary properties and signals that will be accessible to the <i>attachee</i>:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MessageBoardAttachedType : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type">bool</span> expired READ expired WRITE setExpired NOTIFY expiredChanged)
     QML_ANONYMOUS
 <span class="keyword">public</span>:
     MessageBoardAttachedType(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>parent);
     <span class="type">bool</span> expired() <span class="keyword">const</span>;
     <span class="type">void</span> setExpired(<span class="type">bool</span> expired);
 <span class="keyword">signals</span>:
     <span class="type">void</span> published();
     <span class="type">void</span> expiredChanged();
 };
</pre>
<p>Then the <i>attaching type</i>, <code translate="no">MessageBoard</code>, must declare a <code translate="no">qmlAttachedProperties()</code> method that returns an instance of the <i>attached object type</i> as implemented by MessageBoardAttachedType. Additionally, <code translate="no">MessageBoard</code> must be declared as an attaching type via the <a href="qqmlengine.html#QML_ATTACHED" translate="no">QML_ATTACHED</a>() macro:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MessageBoard : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_ATTACHED(MessageBoardAttachedType)
     QML_ELEMENT
 <span class="keyword">public</span>:
     <span class="keyword">static</span> MessageBoardAttachedType <span class="operator">*</span>qmlAttachedProperties(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>object)
     {
         <span class="keyword">return</span> <span class="keyword">new</span> MessageBoardAttachedType(object);
     }
 };
</pre>
<p>Now, a <code translate="no">Message</code> type can access the properties and signals of the attached object type:</p>
<pre class="qml" translate="no">
 <span class="type">Message</span> {
     <span class="name">author</span>: <span class="string">&quot;Amelie&quot;</span>
     <span class="name">creationDate</span>: new <span class="name">Date</span>()

     <span class="name">MessageBoard</span>.expired: <span class="name">creationDate</span> <span class="operator">&lt;</span> new <span class="name">Date</span>(<span class="string">&quot;January 01, 2015 10:45:00&quot;</span>)
     <span class="name">MessageBoard</span>.onPublished: <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Message by&quot;</span>, <span class="name">author</span>, <span class="string">&quot;has been
 published!&quot;</span>)
 }
</pre>
<p>Additionally, the C++ implementation may access the attached object instance that has been attached to any object by calling the <a href="qqmlengine.html#qmlAttachedPropertiesObject" translate="no">qmlAttachedPropertiesObject</a>() function.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 Message <span class="operator">*</span>msg <span class="operator">=</span> someMessageInstance();
 MessageBoardAttachedType <span class="operator">*</span>attached <span class="operator">=</span>
         qobject_cast<span class="operator">&lt;</span>MessageBoardAttachedType<span class="operator">*</span><span class="operator">&gt;</span>(qmlAttachedPropertiesObject<span class="operator">&lt;</span>MessageBoard<span class="operator">&gt;</span>(msg));

 <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Value of MessageBoard.expired:&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> attached<span class="operator">-</span><span class="operator">&gt;</span>expired();
</pre>
<h4 id="propagating-attached-properties">Propagating Attached Properties</h4>
<p><a href="../qtquickcontrols/qquickattachedpropertypropagator.html" translate="no">QQuickAttachedPropertyPropagator</a> can be subclassed to propagate attached properties from a parent object to its children, similar to <a href="../qtquickcontrols/qml-qtquick-controls-control.html#font-prop" translate="no">font</a> and <a href="../qtquick/qml-qtquick-item.html#palette-prop" translate="no">palette</a> propagation. It supports propagation through <a href="../qtquick/qml-qtquick-item.html" translate="no">items</a>, <a href="../qtquickcontrols/qml-qtquick-controls-popup.html" translate="no">popups</a>, and <a href="../qtquick/qml-qtquick-window.html" translate="no">windows</a>.</p>
<h3 id="property-modifier-types">Property Modifier Types</h3>
<p>A property modifier type is a special kind of QML object type. A property modifier type instance affects a property (of a QML object instance) which it is applied to. There are two different kinds of property modifier types:</p>
<ul>
<li>property value write interceptors</li>
<li>property value sources</li>
</ul>
<p>A property value write interceptor can be used to filter or modify values as they are written to properties. Currently, the only supported property value write interceptor is the <a href="../qtquick/qml-qtquick-behavior.html" translate="no">Behavior</a> type provided by the <code translate="no">QtQuick</code> import.</p>
<p>A property value source can be used to automatically update the value of a property over time. Clients can define their own property value source types. The various <a href="../qtquick/qtquick-statesanimations-animations.html" translate="no">property animation</a> types provided by the <code translate="no">QtQuick</code> import are examples of property value sources.</p>
<p>Property modifier type instances can be created and applied to a property of a QML object through the &quot;&lt;ModifierType&gt; on &lt;propertyName&gt;&quot; syntax, as the following example shows:</p>
<pre class="qml" translate="no">
 import QtQuick 2.0

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">width</span>: <span class="number">400</span>
     <span class="name">height</span>: <span class="number">50</span>

     <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">width</span>: <span class="number">50</span>
         <span class="name">height</span>: <span class="number">50</span>
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>

         NumberAnimation on <span class="name">x</span> {
             <span class="name">from</span>: <span class="number">0</span>
             <span class="name">to</span>: <span class="number">350</span>
             <span class="name">loops</span>: <span class="name">Animation</span>.<span class="name">Infinite</span>
             <span class="name">duration</span>: <span class="number">2000</span>
         }
     }
 }
</pre>
<p>This is commonly referred to as &quot;on&quot; syntax.</p>
<p>Clients can register their own property value source types, but currently not property value write interceptors.</p>
<h4 id="property-value-sources">Property Value Sources</h4>
<p><i>Property value sources</i> are QML types that can automatically update the value of a property over time, using the <code translate="no">&lt;PropertyValueSource&gt; on &lt;property&gt;</code> syntax. For example, the various <a href="../qtquick/qtquick-statesanimations-animations.html" translate="no">property animation</a> types provided by the <code translate="no">QtQuick</code> module are examples of property value sources.</p>
<p>A property value source can be implemented in C++ by subclassing <a href="qqmlpropertyvaluesource.html" translate="no">QQmlPropertyValueSource</a> and providing an implementation that writes different values to a property over time. When the property value source is applied to a property using the <code translate="no">&lt;PropertyValueSource&gt; on &lt;property&gt;</code> syntax in QML, it is given a reference to this property by the engine so that the property value can be updated.</p>
<p>For example, suppose there is a <code translate="no">RandomNumberGenerator</code> class to be made available as a property value source, so that when applied to a QML property, it will update the property value to a different random number every 500 milliseconds. Additionally, a maxValue can be provided to this random number generator. This class can be implemented as follows:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> RandomNumberGenerator : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">,</span> <span class="keyword">public</span> <span class="type"><a href="qqmlpropertyvaluesource.html" translate="no">QQmlPropertyValueSource</a></span>
 {
     Q_OBJECT
     Q_INTERFACES(<span class="type"><a href="qqmlpropertyvaluesource.html" translate="no">QQmlPropertyValueSource</a></span>)
     Q_PROPERTY(<span class="type">int</span> maxValue READ maxValue WRITE setMaxValue NOTIFY maxValueChanged);
     QML_ELEMENT
 <span class="keyword">public</span>:
     RandomNumberGenerator(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>parent)
         : <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>(parent)<span class="operator">,</span> m_maxValue(<span class="number">100</span>)
     {
         <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(<span class="operator">&amp;</span>m_timer<span class="operator">,</span> SIGNAL(timeout())<span class="operator">,</span> SLOT(updateProperty()));
         m_timer<span class="operator">.</span>start(<span class="number">500</span>);
     }

     <span class="type">int</span> maxValue() <span class="keyword">const</span>;
     <span class="type">void</span> setMaxValue(<span class="type">int</span> maxValue);

     <span class="keyword">virtual</span> <span class="type">void</span> setTarget(<span class="keyword">const</span> <span class="type"><a href="qqmlproperty.html" translate="no">QQmlProperty</a></span> <span class="operator">&amp;</span>prop) { m_targetProperty <span class="operator">=</span> prop; }

 <span class="keyword">signals</span>:
     <span class="type">void</span> maxValueChanged();

 <span class="keyword">private</span> <span class="keyword">slots</span>:
     <span class="type">void</span> updateProperty() {
         m_targetProperty<span class="operator">.</span>write(<span class="type"><a href="../qtcore/qrandomgenerator.html" translate="no">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(m_maxValue));
     }

 <span class="keyword">private</span>:
     <span class="type"><a href="qqmlproperty.html" translate="no">QQmlProperty</a></span> m_targetProperty;
     <span class="type"><a href="../qtcore/qtimer.html" translate="no">QTimer</a></span> m_timer;
     <span class="type">int</span> m_maxValue;
 };
</pre>
<p>When the QML engine encounters a use of <code translate="no">RandomNumberGenerator</code> as a property value source, it invokes <code translate="no">RandomNumberGenerator::setTarget()</code> to provide the type with the property to which the value source has been applied. When the internal timer in <code translate="no">RandomNumberGenerator</code> triggers every 500 milliseconds, it will write a new number value to that specified property.</p>
<p>Once the <code translate="no">RandomNumberGenerator</code> class has been registered with the QML type system, it can be used from QML as a property value source. Below, it is used to change the width of a <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a> every 500 milliseconds:</p>
<pre class="qml" translate="no">
 import QtQuick 2.0

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">width</span>: <span class="number">300</span>; <span class="name">height</span>: <span class="number">300</span>

     <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         RandomNumberGenerator on <span class="name">width</span> { <span class="name">maxValue</span>: <span class="number">300</span> }

         <span class="name">height</span>: <span class="number">100</span>
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
     }
 }
</pre>
<p>In all other respects, property value sources are regular QML types that can have properties, signals methods and so on, but with the added capability that they can be used to change property values using the <code translate="no">&lt;PropertyValueSource&gt; on &lt;property&gt;</code> syntax.</p>
<p>When a property value source object is assigned to a property, QML first tries to assign it normally, as though it were a regular QML type. Only if this assignment fails does the engine call the <a href="qqmlpropertyvaluesource.html#setTarget" translate="no">setTarget</a>() method. This allows the type to also be used in contexts other than just as a value source.</p>
<h3 id="specifying-default-and-parent-properties-for-qml-object-types">Specifying Default and Parent Properties for QML Object Types</h3>
<p>Any <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived type that is registered as an instantiable QML object type can optionally specify a <i>default property</i> for the type. A default property is the property to which an object's children are automatically assigned if they are not assigned to any specific property.</p>
<p>The default property can be set by calling the <a href="../qtcore/qobject.html#Q_CLASSINFO" translate="no">Q_CLASSINFO</a>() macro for a class with a specific &quot;DefaultProperty&quot; value. For example, the <code translate="no">MessageBoard</code> class below specifies its <code translate="no">messages</code> property as the default property for the class:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MessageBoard : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="qqmllistproperty.html" translate="no">QQmlListProperty</a></span><span class="operator">&lt;</span>Message<span class="operator">&gt;</span> messages READ messages)
     Q_CLASSINFO(<span class="string">&quot;DefaultProperty&quot;</span><span class="operator">,</span> <span class="string">&quot;messages&quot;</span>)
     QML_ELEMENT
 <span class="keyword">public</span>:
     <span class="type"><a href="qqmllistproperty.html" translate="no">QQmlListProperty</a></span><span class="operator">&lt;</span>Message<span class="operator">&gt;</span> messages();

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span>Message <span class="operator">*</span><span class="operator">&gt;</span> m_messages;
 };
</pre>
<p>This enables children of a <code translate="no">MessageBoard</code> object to be automatically assigned to its <code translate="no">messages</code> property if they are not assigned to a specific property. For example:</p>
<pre class="qml" translate="no">
 <span class="type">MessageBoard</span> {
     <span class="type">Message</span> { <span class="name">author</span>: <span class="string">&quot;Naomi&quot;</span> }
     <span class="type">Message</span> { <span class="name">author</span>: <span class="string">&quot;Clancy&quot;</span> }
 }
</pre>
<p>If <code translate="no">messages</code> was not set as the default property, then any <code translate="no">Message</code> objects would have to be explicitly assigned to the <code translate="no">messages</code> property instead, as follows:</p>
<pre class="qml" translate="no">
 <span class="type">MessageBoard</span> {
     <span class="name">messages</span>: [
         <span class="type">Message</span> { <span class="name">author</span>: <span class="string">&quot;Naomi&quot;</span> },
         <span class="type">Message</span> { <span class="name">author</span>: <span class="string">&quot;Clancy&quot;</span> }
     ]
 }
</pre>
<p>(Incidentally, the <a href="../qtquick/qml-qtquick-item.html#data-prop" translate="no">Item::data</a> property is its default property. Any <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> objects added to this <code translate="no">data</code> property are also added to the list of <a href="../qtquick/qml-qtquick-item.html#children-prop" translate="no">Item::children</a>, so the use of the default property enables visual children to be declared for an item without explicitly assigning them to the <a href="../qtquick/qml-qtquick-item.html#children-prop" translate="no">children</a> property.)</p>
<p>Additionally, you can declare a &quot;ParentProperty&quot; <a href="../qtcore/qobject.html#Q_CLASSINFO" translate="no">Q_CLASSINFO</a>() to inform the QML engine which property should denote the parent object in the QML hierarchy. For example, the Message type might be declared as follows:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Message : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">*</span> board READ board BINDABLE boardBindable)
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> author READ author BINDABLE authorBindable)
     Q_CLASSINFO(<span class="string">&quot;ParentProperty&quot;</span><span class="operator">,</span> <span class="string">&quot;board&quot;</span>)
     QML_ELEMENT

 <span class="keyword">public</span>:
     Message(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr) : <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>(parent) { m_board <span class="operator">=</span> parent; }

     <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>board() <span class="keyword">const</span> { <span class="keyword">return</span> m_board<span class="operator">.</span>value(); }
     <span class="type"><a href="../qtcore/qbindable.html" translate="no">QBindable</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span><span class="operator">&gt;</span> boardBindable() { <span class="keyword">return</span> <span class="type"><a href="../qtcore/qbindable.html" translate="no">QBindable</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(<span class="operator">&amp;</span>m_board); }

     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> author() <span class="keyword">const</span> { <span class="keyword">return</span> m_author<span class="operator">.</span>value(); }
     <span class="type"><a href="../qtcore/qbindable.html" translate="no">QBindable</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> authorBindable() { <span class="keyword">return</span> <span class="type"><a href="../qtcore/qbindable.html" translate="no">QBindable</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span>(<span class="operator">&amp;</span>m_author); }

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtcore/qproperty.html" translate="no">QProperty</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span><span class="operator">&gt;</span> m_board;
     <span class="type"><a href="../qtcore/qproperty.html" translate="no">QProperty</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> m_author;
 };
</pre>
<p>Defining the parent property affords <a href="../qtquick/qtquick-tools-and-utilities.html#qmllint" translate="no">qmllint</a> and other tools better insight into the intention of your code and avoids false positive warnings on some property accesses.</p>
<h3 id="defining-visual-items-with-the-qt-quick-module">Defining Visual Items with the Qt Quick Module</h3>
<p>When building user interfaces with the <a href="../qtquick/qtquick-index.html" translate="no">Qt Quick</a> module, all QML objects that are to be visually rendered must derive from the <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> type, as it is the base type for all visual objects in <a href="../qtquick/qtquick-index.html" translate="no">Qt Quick</a>. This <a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a> type is implemented by the <a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a> C++ class, which is provided by the <a href="../qtquick/qtquick-index.html" translate="no">Qt Quick</a> module. Therefore, this class should be subclassed when it is necessary to implement a visual type in C++ that can be integrated into a QML-based user interface.</p>
<p>See the <a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a> documentation for more information. Additionally, the <a href="qtqml-tutorials-extending-qml-example.html" translate="no">Writing QML Extensions with C++</a> tutorial demonstrates how a <a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a>-based visual item can be implemented in C++ and integrated into a Qt Quick-based user interface.</p>
<h2 id="receiving-notifications-for-object-initialization">Receiving Notifications for Object Initialization</h2>
<p>For some custom QML object types, it may be beneficial to delay the initialization of particular data until the object has been created and all of its properties have been set. For example, this may be the case if the initialization is costly, or if the initialization should not be performed until all property values have been initialized.</p>
<p>The <a href="qtqml-index.html" translate="no">Qt Qml</a> module provides the <a href="qqmlparserstatus.html" translate="no">QQmlParserStatus</a> to be subclassed for these purposes. It defines a number of virtual methods that are invoked at various stages during component instantiation. To receive these notifications, a C++ class should inherit <a href="qqmlparserstatus.html" translate="no">QQmlParserStatus</a> and also notify the Qt meta system using the <a href="../qtcore/qobject.html#Q_INTERFACES" translate="no">Q_INTERFACES</a>() macro.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyQmlType : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">,</span> <span class="keyword">public</span> <span class="type"><a href="qqmlparserstatus.html" translate="no">QQmlParserStatus</a></span>
 {
     Q_OBJECT
     Q_INTERFACES(<span class="type"><a href="qqmlparserstatus.html" translate="no">QQmlParserStatus</a></span>)
     QML_ELEMENT
 <span class="keyword">public</span>:
     <span class="keyword">virtual</span> <span class="type">void</span> componentComplete()
     {
         <span class="comment">// Perform some initialization here now that the object is fully created</span>
     }
 };
</pre>
</div>
<!-- @@@qtqml-cppintegration-definetypes.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
