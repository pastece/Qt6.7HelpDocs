<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- data.qdoc -->
  <meta name="description" content="Description of how data types are exchanged between QML and C++">
  <title>Data Type Conversion Between QML and C++ | Qt QML 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtqml-index.html" translate="no">Qt QML</a></li>
<li>Data Type Conversion Between QML and C++</li>
<li id="buildversion"><a href="qtqml-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#data-ownership">Data Ownership</a></li>
<li class="level1"><a href="#basic-qt-data-types">Basic Qt Data Types</a></li>
<li class="level1"><a href="#qobject-derived-types">QObject-derived Types</a></li>
<li class="level1"><a href="#conversion-between-qt-and-javascript-types">Conversion Between Qt and JavaScript Types</a></li>
<li class="level2"><a href="#qvariantlist-and-qvariantmap-to-javascript-array-and-object">QVariantList and QVariantMap to JavaScript Array and Object</a></li>
<li class="level2"><a href="#qdatetime-to-javascript-date">QDateTime to JavaScript Date</a></li>
<li class="level2"><a href="#qdate-and-javascript-date">QDate and JavaScript Date</a></li>
<li class="level2"><a href="#qtime-and-javascript-date">QTime and JavaScript Date</a></li>
<li class="level2"><a href="#sequence-type-to-javascript-array">Sequence Type to JavaScript Array</a></li>
<li class="level2"><a href="#qbytearray-to-javascript-arraybuffer">QByteArray to JavaScript ArrayBuffer</a></li>
<li class="level2"><a href="#value-types">Value Types</a></li>
<li class="level1"><a href="#enumeration-types">Enumeration Types</a></li>
<li class="level2"><a href="#enumeration-types-as-signal-and-method-parameters">Enumeration Types as Signal and Method Parameters</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Data Type Conversion Between QML and C++</h1>
<!-- $$$qtqml-cppintegration-data.html-description -->
<div class="descr" id="details">
<p>When data values are exchanged between QML and C++, they are converted by the QML engine to have the correct data types as appropriate for use in QML or C++. This requires the exchanged data to be of a type that is recognizable by the engine.</p>
<p>The QML engine provides built-in support for a large number of Qt C++ data types. Additionally, custom C++ types may be registered with the QML type system to make them available to the engine.</p>
<p>For more information about C++ and the different QML integration methods, see the <a href="qtqml-cppintegration-overview.html" translate="no">C++ and QML integration overview</a> page.</p>
<p>This page discusses the data types supported by the QML engine and how they are converted between QML and C++.</p>
<h2 id="data-ownership">Data Ownership</h2>
<p>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a <a href="../qtcore/qobject.html" translate="no">QObject</a> is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking <a href="qjsengine.html#setObjectOwnership" translate="no">QQmlEngine::setObjectOwnership</a>() with QQmlEngine::CppOwnership specified.</p>
<p>Additionally, the QML engine respects the normal <a href="../qtcore/qobject.html" translate="no">QObject</a> parent ownership semantics of Qt C++ objects, and will never delete a <a href="../qtcore/qobject.html" translate="no">QObject</a> instance which has a parent.</p>
<h2 id="basic-qt-data-types">Basic Qt Data Types</h2>
<p>By default, QML recognizes the following Qt data types, which are automatically converted to a corresponding <a href="qtqml-typesystem-valuetypes.html" translate="no">QML value type</a> when passed from C++ to QML and vice-versa:</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td >Qt Type</td><td >QML Value Type</td></tr>
<tr valign="top" class="even"><td >bool</td><td ><a href="qml-bool.html" translate="no">bool</a></td></tr>
<tr valign="top" class="odd"><td >unsigned int, int</td><td ><a href="qml-int.html" translate="no">int</a></td></tr>
<tr valign="top" class="even"><td >double</td><td ><a href="qml-double.html" translate="no">double</a></td></tr>
<tr valign="top" class="odd"><td >float, qreal</td><td ><a href="qml-real.html" translate="no">real</a></td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qstring.html" translate="no">QString</a></td><td ><a href="qml-string.html" translate="no">string</a></td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qurl.html" translate="no">QUrl</a></td><td ><a href="qml-url.html" translate="no">url</a></td></tr>
<tr valign="top" class="even"><td ><a href="../qtgui/qcolor.html" translate="no">QColor</a></td><td ><a href="../qtquick/qml-color.html" translate="no">color</a></td></tr>
<tr valign="top" class="odd"><td ><a href="../qtgui/qfont.html" translate="no">QFont</a></td><td ><a href="../qtquick/qml-font.html" translate="no">font</a></td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qdatetime.html" translate="no">QDateTime</a></td><td ><a href="qml-date.html" translate="no">date</a></td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qpoint.html" translate="no">QPoint</a>, <a href="../qtcore/qpointf.html" translate="no">QPointF</a></td><td ><a href="qml-point.html" translate="no">point</a></td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qsize.html" translate="no">QSize</a>, <a href="../qtcore/qsizef.html" translate="no">QSizeF</a></td><td ><a href="qml-size.html" translate="no">size</a></td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qrect.html" translate="no">QRect</a>, <a href="../qtcore/qrectf.html" translate="no">QRectF</a></td><td ><a href="qml-rect.html" translate="no">rect</a></td></tr>
<tr valign="top" class="even"><td ><a href="../qtgui/qmatrix4x4.html" translate="no">QMatrix4x4</a></td><td ><a href="../qtquick/qml-matrix4x4.html" translate="no">matrix4x4</a></td></tr>
<tr valign="top" class="odd"><td ><a href="../qtgui/qquaternion.html" translate="no">QQuaternion</a></td><td ><a href="../qtquick/qml-quaternion.html" translate="no">quaternion</a></td></tr>
<tr valign="top" class="even"><td ><a href="../qtgui/qvector2d.html" translate="no">QVector2D</a>, <a href="../qtgui/qvector3d.html" translate="no">QVector3D</a>, <a href="../qtgui/qvector4d.html" translate="no">QVector4D</a></td><td ><a href="../qtquick/qml-vector2d.html" translate="no">vector2d</a>, <a href="../qtquick/qml-vector3d.html" translate="no">vector3d</a>, <a href="../qtquick/qml-vector4d.html" translate="no">vector4d</a></td></tr>
<tr valign="top" class="odd"><td >Enums declared with <a href="../qtcore/qobject.html#Q_ENUM" translate="no">Q_ENUM</a>()</td><td ><a href="qml-enumeration.html" translate="no">enumeration</a></td></tr>
</table></div>
<div class="admonition note">
<p><b>Note: </b>Classes provided by the <a href="../qtgui/qtgui-index.html" translate="no">Qt GUI</a> module, such as <a href="../qtgui/qcolor.html" translate="no">QColor</a>, <a href="../qtgui/qfont.html" translate="no">QFont</a>, <a href="../qtgui/qquaternion.html" translate="no">QQuaternion</a> and <a href="../qtgui/qmatrix4x4.html" translate="no">QMatrix4x4</a>, are only available from QML when the <a href="../qtquick/qtquick-index.html" translate="no">Qt Quick</a> module is included.</p>
</div>
<p>As a convenience, many of these types can be specified in QML by string values, or by a related method provided by the <a href="qml-qtqml-qt.html" translate="no">QtQml::Qt</a> object. For example, the <a href="../qtquick/qml-qtquick-image.html#sourceSize-prop" translate="no">Image::sourceSize</a> property is of type <a href="qml-size.html" translate="no">size</a> (which automatically translates to the <a href="../qtcore/qsize.html" translate="no">QSize</a> type) and can be specified by a string value formatted as &quot;width<code translate="no">x</code>height&quot;, or by the Qt.<a href="../qtquickcontrols/qml-qtquick-controls-stackview.html#size" translate="no">size()</a> function:</p>
<pre class="qml" translate="no">
 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="type"><a href="../qtquick/qml-qtquick-image.html" translate="no">Image</a></span> { <span class="name">sourceSize</span>: <span class="string">&quot;100x200&quot;</span> }
     <span class="type"><a href="../qtquick/qml-qtquick-image.html" translate="no">Image</a></span> { <span class="name">sourceSize</span>: <span class="name">Qt</span>.<span class="name">size</span>(<span class="number">100</span>, <span class="number">200</span>) }
 }
</pre>
<p>See documentation for each individual type under <a href="qtqml-typesystem-valuetypes.html" translate="no">QML Value Types</a> for more information.</p>
<h2 id="qobject-derived-types">QObject-derived Types</h2>
<p>Any <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived class may be used as a type for the exchange of data between QML and C++, providing the class has been registered with the QML type system.</p>
<p>The engine allows the registration of both instantiable and non-instantiable types. Once a class is registered as a QML type, it can be used as a data type for exchanging data between QML and C++. See <a href="qtqml-cppintegration-definetypes.html#registering-c-types-with-the-qml-type-system" translate="no">Registering C++ types with the QML type system</a> for further details on type registration.</p>
<h2 id="conversion-between-qt-and-javascript-types">Conversion Between Qt and JavaScript Types</h2>
<p>The QML engine has built-in support for converting a number of Qt types to related JavaScript types, and vice-versa, when transferring data between QML and C++. This makes it possible to use these types and receive them in C++ or JavaScript without needing to implement custom types that provide access to the data values and their attributes.</p>
<p>(Note that the JavaScript environment in QML modifies native JavaScript object prototypes, including those of <code translate="no">String</code>, <code translate="no">Date</code> and <code translate="no">Number</code>, to provide additional features. See the <a href="qtqml-javascript-hostenvironment.html" translate="no">JavaScript Host Environment</a> for further details.)</p>
<h3 id="qvariantlist-and-qvariantmap-to-javascript-array-and-object">QVariantList and QVariantMap to JavaScript Array and Object</h3>
<p>The QML engine provides automatic type conversion between <a href="../qtcore/qvariant.html#QVariantList-typedef" translate="no">QVariantList</a> and JavaScript arrays, and between <a href="../qtcore/qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> and JavaScript objects.</p>
<p>For example, the function defined in QML below expects two arguments, an array and an object, and prints their contents using the standard JavaScript syntax for array and object item access. The C++ code below calls this function, passing a <a href="../qtcore/qvariant.html#QVariantList-typedef" translate="no">QVariantList</a> and a <a href="../qtcore/qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a>, which are automatically converted to JavaScript array and object values, repectively:</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td >QML</td><td ><pre class="qml" translate="no">
 <span class="comment">// MyItem.qml</span>
 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="keyword">function </span><span class="name">readValues</span>(anArray, anObject) {
         <span class="keyword">for</span> (var i=0; <span class="name">i</span><span class="operator">&lt;</span><span class="name">anArray</span>.<span class="name">length</span>; i++)
             <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Array item:&quot;</span>, <span class="name">anArray</span>[<span class="name">i</span>])

         <span class="keyword">for</span> (var prop in <span class="name">anObject</span>) {
             <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Object item:&quot;</span>, <span class="name">prop</span>, <span class="string">&quot;=&quot;</span>, <span class="name">anObject</span>[<span class="name">prop</span>])
         }
     }
 }
</pre>
</td></tr>
<tr valign="top" class="even"><td >C++</td><td ><pre class="cpp" translate="no">
 <span class="comment">// C++</span>
 <span class="type"><a href="../qtquick/qquickview.html" translate="no">QQuickView</a></span> view(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span><span class="operator">::</span>fromLocalFile(<span class="string">&quot;MyItem.qml&quot;</span>));

 <span class="type"><a href="../qtcore/qvariant.html#QVariantList-typedef" translate="no">QVariantList</a></span> list;
 list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">10</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span>(<span class="type"><a href="qml-qtqml-qt.html" translate="no">Qt</a></span><span class="operator">::</span>green) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;bottles&quot;</span>;

 <span class="type"><a href="../qtcore/qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a></span> map;
 map<span class="operator">.</span>insert(<span class="string">&quot;language&quot;</span><span class="operator">,</span> <span class="string">&quot;QML&quot;</span>);
 map<span class="operator">.</span>insert(<span class="string">&quot;released&quot;</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qdate.html" translate="no">QDate</a></span>(<span class="number">2010</span><span class="operator">,</span> <span class="number">9</span><span class="operator">,</span> <span class="number">21</span>));

 <span class="type"><a href="../qtcore/qmetaobject.html" translate="no">QMetaObject</a></span><span class="operator">::</span>invokeMethod(view<span class="operator">.</span>rootObject()<span class="operator">,</span> <span class="string">&quot;readValues&quot;</span><span class="operator">,</span>
         Q_ARG(<span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span><span class="operator">,</span> <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span><span class="operator">::</span>fromValue(list))<span class="operator">,</span>
         Q_ARG(<span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span><span class="operator">,</span> <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span><span class="operator">::</span>fromValue(map)));
</pre>
</td></tr>
</table></div>
<p>This produces output like:</p>
<pre class="cpp" translate="no">
 Array item: <span class="number">10</span>
 Array item: <span class="preprocessor">#00ff00</span>
 Array item: bottles
 Object item: language <span class="operator">=</span> QML
 Object item: released <span class="operator">=</span> Tue Sep <span class="number">21</span> <span class="number">2010</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> GMT<span class="operator">+</span><span class="number">1000</span> (EST)
</pre>
<p>Similarly, if a C++ type uses a <a href="../qtcore/qvariant.html#QVariantList-typedef" translate="no">QVariantList</a> or <a href="../qtcore/qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> type for a property type or method parameter, the value can be created as a JavaScript array or object in QML, and is automatically converted to a <a href="../qtcore/qvariant.html#QVariantList-typedef" translate="no">QVariantList</a> or <a href="../qtcore/qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> when it is passed to C++.</p>
<p>Mind that <a href="../qtcore/qvariant.html#QVariantList-typedef" translate="no">QVariantList</a> and <a href="../qtcore/qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> properties of C++ types are stored as values and cannot be changed in place by QML code. You can only replace the whole map or list, but not manipulate its contents. The following code does not work if the property <code translate="no">l</code> is a <a href="../qtcore/qvariant.html#QVariantList-typedef" translate="no">QVariantList</a>:</p>
<pre class="cpp" translate="no">
 MyListExposingItem {
    l: <span class="operator">[</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">]</span>
    Component<span class="operator">.</span>onCompleted: l<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">10</span>
 }
</pre>
<p>The following code does work:</p>
<pre class="cpp" translate="no">
 MyListExposingItem {
    l: <span class="operator">[</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">]</span>
    Component<span class="operator">.</span>onCompleted: l <span class="operator">=</span> <span class="operator">[</span><span class="number">10</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">]</span>
 }
</pre>
<h3 id="qdatetime-to-javascript-date">QDateTime to JavaScript Date</h3>
<p>The QML engine provides automatic type conversion between <a href="../qtcore/qdatetime.html" translate="no">QDateTime</a> values and JavaScript <code translate="no">Date</code> objects.</p>
<p>For example, the function defined in QML below expects a JavaScript <code translate="no">Date</code> object, and also returns a new <code translate="no">Date</code> object with the current date and time. The C++ code below calls this function, passing a <a href="../qtcore/qdatetime.html" translate="no">QDateTime</a> value that is automatically converted by the engine into a <code translate="no">Date</code> object when it is passed to the <code translate="no">readDate()</code> function. In turn, the readDate() function returns a <code translate="no">Date</code> object that is automatically converted into a <a href="../qtcore/qdatetime.html" translate="no">QDateTime</a> value when it is received in C++:</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td >QML</td><td ><pre class="qml" translate="no">
 <span class="comment">// MyItem.qml</span>
 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="keyword">function </span><span class="name">readDate</span>(dt) {
         <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;The given date is:&quot;</span>, <span class="name">dt</span>.<span class="name">toUTCString</span>());
         <span class="keyword">return</span> new <span class="name">Date</span>();
     }
 }
</pre>
</td></tr>
<tr valign="top" class="even"><td >C++</td><td ><pre class="cpp" translate="no">
 <span class="comment">// C++</span>
 <span class="type"><a href="../qtquick/qquickview.html" translate="no">QQuickView</a></span> view(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span><span class="operator">::</span>fromLocalFile(<span class="string">&quot;MyItem.qml&quot;</span>));

 <span class="type"><a href="../qtcore/qdatetime.html" translate="no">QDateTime</a></span> dateTime <span class="operator">=</span> <span class="type"><a href="../qtcore/qdatetime.html" translate="no">QDateTime</a></span><span class="operator">::</span>currentDateTime();
 <span class="type"><a href="../qtcore/qdatetime.html" translate="no">QDateTime</a></span> retValue;

 <span class="type"><a href="../qtcore/qmetaobject.html" translate="no">QMetaObject</a></span><span class="operator">::</span>invokeMethod(view<span class="operator">.</span>rootObject()<span class="operator">,</span> <span class="string">&quot;readDate&quot;</span><span class="operator">,</span>
         Q_RETURN_ARG(<span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span><span class="operator">,</span> retValue)<span class="operator">,</span>
         Q_ARG(<span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span><span class="operator">,</span> <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span><span class="operator">::</span>fromValue(dateTime)));

 <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Value returned from readDate():&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> retValue;
</pre>
</td></tr>
</table></div>
<p>Similarly, if a C++ type uses a <a href="../qtcore/qdatetime.html" translate="no">QDateTime</a> for a property type or method parameter, the value can be created as a JavaScript <code translate="no">Date</code> object in QML, and is automatically converted to a <a href="../qtcore/qdatetime.html" translate="no">QDateTime</a> value when it is passed to C++.</p>
<div class="admonition note">
<p><b>Note: </b>Watch out for the difference in month numbering: JavaScript numbers January as 0 through 11 for December, off by one from Qt's numbering of January as 1 through 12 for December.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When using a string in JavaScript as the value of a <code translate="no">Date</code> object, note that a string with no time fields (so a simple date) is interpreted as the UTC start of the relevant day, in contrast to <code translate="no">new Date(y, m, d)</code> which uses the local time start of the day. Most other ways of constructing a <code translate="no">Date</code> object in JavaScript produce a local time, unless methods with UTC in their names are used. If your program is run in a zone behind UTC (nominally west of The Prime Meridian), use of a date-only string will lead to a <code translate="no">Date</code> object whose <code translate="no">getDate()</code> is one less than the day-number in your string; it will typically have a large value for <code translate="no">getHours()</code>. The UTC variants of these methods, <code translate="no">getUTCDate()</code> and <code translate="no">getUTCHours()</code>, will give the results you expect for such a <code translate="no">Date</code> objects. See also the next section.</p>
</div>
<h3 id="qdate-and-javascript-date">QDate and JavaScript Date</h3>
<p>The QML engine converts automatically between <a href="../qtcore/qdate.html" translate="no">QDate</a> and the JavaScript <code translate="no">Date</code> type by representing the date by the UTC start of its day. A date is mapped back to <a href="../qtcore/qdate.html" translate="no">QDate</a> via <a href="../qtcore/qdatetime.html" translate="no">QDateTime</a>, selecting its <a href="../qtcore/qdatetime.html#date" translate="no">date</a>() method, using the local time form of the date unless the UTC form of it coincides with the start of the next day, in which case the UTC form is used.</p>
<p>This slighly eccentric arrangement is a work-around for the fact that JavaScript's construction of a <code translate="no">Date</code> object from a date-only string uses the UTC start of the day, but <code translate="no">new Date(y, m, d)</code> uses the local time start of the indicated date, as discussed in a note at the end of the previous section.</p>
<p>As a result, where a <a href="../qtcore/qdate.html" translate="no">QDate</a> property or parameter is exposed to QML, care should be taken in reading its value: the <code translate="no">Date.getUTCFullYear()</code>, <code translate="no">Date.getUTCMonth()</code> and <code translate="no">Date.getUTCDate()</code> methods are more likely to deliver the results users expect than the corresponding methods without UTC in their names.</p>
<p>It is thus commonly more robust to use a <a href="../qtcore/qdatetime.html" translate="no">QDateTime</a> property. This makes it possible to take control, on the <a href="../qtcore/qdatetime.html" translate="no">QDateTime</a> side, of whether the date (and time) is specified in terms of UTC or local time; as long as the JavaScript code is written to work with the same standard, it should be possible to avoid trouble.</p>
<span id="qtime-to-javascript-date"></span><h3 id="qtime-and-javascript-date">QTime and JavaScript Date</h3>
<p>The QML engine provides automatic type conversion from <a href="../qtcore/qtime.html" translate="no">QTime</a> values to JavaScript <code translate="no">Date</code> objects. As <a href="../qtcore/qtime.html" translate="no">QTime</a> values do not contain a date component, one is created for the conversion only. Thus, you should not rely on the date component of the resulting Date object.</p>
<p>Under the hood, conversion from a JavaScript <code translate="no">Date</code> object to <a href="../qtcore/qtime.html" translate="no">QTime</a> is done by converting to a <a href="../qtcore/qdatetime.html" translate="no">QDateTime</a> object (using local time) and calling its <a href="../qtcore/qdatetime.html#time" translate="no">time</a>() method.</p>
<h3 id="sequence-type-to-javascript-array">Sequence Type to JavaScript Array</h3>
<p>See <a href="qtqml-typesystem-sequencetypes.html" translate="no">QML Sequence Types</a> for a general description of sequence types. The <a href="qtqml-qmlmodule.html" translate="no">QtQml module</a> contains a few sequence types you may want to use.</p>
<p>You can also create a list-like data structure by constructing a <a href="qjsvalue.html" translate="no">QJSValue</a> using <a href="qjsengine.html#newArray" translate="no">QJSEngine::newArray</a>(). Such a JavaScript array does not need any conversion when passing it between QML and C++. See <a href="qjsvalue.html#working-with-arrays" translate="no">QJSValue#Working With Arrays</a> for details on how to manipulate JavaScript arrays from C++.</p>
<h3 id="qbytearray-to-javascript-arraybuffer">QByteArray to JavaScript ArrayBuffer</h3>
<p>The QML engine provides automatic type conversion between <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a> values and JavaScript <code translate="no">ArrayBuffer</code> objects.</p>
<h3 id="value-types">Value Types</h3>
<p>Some value types in Qt such as <a href="../qtcore/qpoint.html" translate="no">QPoint</a> are represented in JavaScript as objects that have the same properties and functions like in the C++ API. The same representation is possible with custom C++ value types. To enable a custom value type with the QML engine, the class declaration needs to be annotated with <code translate="no">Q_GADGET</code>. Properties that are intended to be visible in the JavaScript representation need to be declared with <code translate="no">Q_PROPERTY</code>. Similarly functions need to be marked with <code translate="no">Q_INVOKABLE</code>. This is the same with <a href="../qtcore/qobject.html" translate="no">QObject</a> based C++ APIs. For example, the <code translate="no">Actor</code> class below is annotated as gadget and has properties:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Actor
 {
     Q_GADGET
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> name READ name WRITE setName)
 <span class="keyword">public</span>:
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> name() <span class="keyword">const</span> { <span class="keyword">return</span> m_name; }
     <span class="type">void</span> setName(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>name) { m_name <span class="operator">=</span> name; }

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> m_name;
 };

 Q_DECLARE_METATYPE(Actor)
</pre>
<p>The usual pattern is to use a gadget class as the type of a property, or to emit a gadget as a signal argument. In such cases, the gadget instance is passed by value between C++ and QML (because it's a value type). If QML code changes a property of a gadget property, the entire gadget is re-created and passed back to the C++ property setter. In Qt 5, gadget types cannot be instantiated by direct declaration in QML. In contrast, a <a href="../qtcore/qobject.html" translate="no">QObject</a> instance can be declared; and <a href="../qtcore/qobject.html" translate="no">QObject</a> instances are always passed by pointer from C++ to QML.</p>
<h2 id="enumeration-types">Enumeration Types</h2>
<p>To use a custom enumeration as a data type, its class must be registered and the enumeration must also be declared with <a href="../qtcore/qobject.html#Q_ENUM" translate="no">Q_ENUM</a>() to register it with Qt's meta object system. For example, the <code translate="no">Message</code> class below has a <code translate="no">Status</code> enum:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Message : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(Status status READ status NOTIFY statusChanged)
 <span class="keyword">public</span>:
     <span class="keyword">enum</span> Status {
         Ready<span class="operator">,</span>
         Loading<span class="operator">,</span>
         Error
     };
     Q_ENUM(Status)
     Status status() <span class="keyword">const</span>;
 <span class="keyword">signals</span>:
     <span class="type">void</span> statusChanged();
 };
</pre>
<p>Providing the <code translate="no">Message</code> class has been <a href="qtqml-cppintegration-definetypes.html#registering-c-types-with-the-qml-type-system" translate="no">registered</a> with the QML type system, its <code translate="no">Status</code> enum can be used from QML:</p>
<pre class="qml" translate="no">
 <span class="type">Message</span> {
      <span class="name">onStatusChanged</span>: {
          <span class="keyword">if</span> (<span class="name">status</span> <span class="operator">==</span> <span class="name">Message</span>.<span class="name">Ready</span>)
              <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Message is loaded!&quot;</span>)
      }
  }
</pre>
<p>To use an enum as a <a href="../qtcore/qflags.html" translate="no">flags</a> type in QML, see <a href="../qtcore/qobject.html#Q_FLAG" translate="no">Q_FLAG</a>().</p>
<div class="admonition note">
<p><b>Note: </b>The names of enum values must begin with a capital letter in order to be accessible from QML.</p>
</div>
<pre class="cpp" translate="no">
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">enum</span> <span class="keyword">class</span> Status {
           Ready<span class="operator">,</span>
           Loading<span class="operator">,</span>
           Error
 }
 Q_ENUM(Status)
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>Enum classes are registered in QML as scoped and unscoped properties. The <code translate="no">Ready</code> value will be registered at <code translate="no">Message.Status.Ready</code> and <code translate="no">Message.Ready</code> .</p>
<p>When using enum classes, there can be multiple enums using the same identifiers. The unscoped registration will be overwriten by the last registered enum. For classes that contain such name conficts it is possible to disable the unscoped registration by annotating your class with a special <a href="../qtcore/qobject.html#Q_CLASSINFO" translate="no">Q_CLASSINFO</a> macro. Use the name <code translate="no">RegisterEnumClassesUnscoped</code> with the value <code translate="no">false</code> to prevent scoped enums from being merged into the same name space.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Message : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
     {
         Q_OBJECT
         Q_CLASSINFO(<span class="string">&quot;RegisterEnumClassesUnscoped&quot;</span><span class="operator">,</span> <span class="string">&quot;false&quot;</span>)
         Q_ENUM(ScopedEnum)
         Q_ENUM(OtherValue)

     <span class="keyword">public</span>:
         <span class="keyword">enum</span> <span class="keyword">class</span> ScopedEnum {
               Value1<span class="operator">,</span>
               Value2<span class="operator">,</span>
               OtherValue
         };
         <span class="keyword">enum</span> <span class="keyword">class</span> OtherValue {
               Value1<span class="operator">,</span>
               Value2
         };
     };
</pre>
<p>Enums from related types are usually registered in the scope of the relating type. For example any enum from a different type used in a <a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a> declaration causes all enums from that type to be made available in QML. This is usually more of a liability than a feature. In order to prevent it from happening, annotate your class with a special <a href="../qtcore/qobject.html#Q_CLASSINFO" translate="no">Q_CLASSINFO</a> macro. Use the name <code translate="no">RegisterEnumsFromRelatedTypes</code> with the value <code translate="no">false</code> to prevent enums from related types from being registered in this type.</p>
<p>You should explicitly register the enclosing types of any enums you want to use in QML, using <a href="qqmlengine.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlengine.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>, rather than rely on their enums to be injected into other types.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> OtherType : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_ELEMENT

 <span class="keyword">public</span>:
     <span class="keyword">enum</span> SomeEnum { A<span class="operator">,</span> B<span class="operator">,</span> C };
     Q_ENUM(SomeEnum)

     <span class="keyword">enum</span> AnotherEnum { D<span class="operator">,</span> E<span class="operator">,</span> F };
     Q_ENUM(AnotherEnum)
 };

 <span class="keyword">class</span> Message : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_ELEMENT

     <span class="comment">// This would usually cause all enums from OtherType to be registered</span>
     <span class="comment">// as members of Message ...</span>
     Q_PROPERTY(OtherType<span class="operator">::</span>SomeEnum someEnum READ someEnum CONSTANT)

     <span class="comment">// ... but this way it doesn't.</span>
     Q_CLASSINFO(<span class="string">&quot;RegisterEnumsFromRelatedTypes&quot;</span><span class="operator">,</span> <span class="string">&quot;false&quot;</span>)

 <span class="keyword">public</span>:
     OtherType<span class="operator">::</span>SomeEnum someEnum() <span class="keyword">const</span> { <span class="keyword">return</span> OtherType<span class="operator">::</span>B; }
 };
</pre>
<p>The important difference is the scope for the enums in QML. If an enum from a related class is automatically registered, the scope is the type it is imported into. In the above case, without the extra <a href="../qtcore/qobject.html#Q_CLASSINFO" translate="no">Q_CLASSINFO</a>, you would use <code translate="no">Message.A</code>, for example. If C++ type holding the enums is explicitly registered, and the registration of enums from related types is suppressed, the QML type for the C++ type holding the enums is the scope for all of its enums. You would use <code translate="no">OtherType.A</code> instead of <code translate="no">Message.A</code> in QML.</p>
<p>Mind that you can use <a href="qqmlengine.html#QML_FOREIGN" translate="no">QML_FOREIGN</a> to register a type you cannot modify. You can also use <a href="qqmlengine.html#QML_FOREIGN_NAMESPACE" translate="no">QML_FOREIGN_NAMESPACE</a> to register the enumerators of a C++ type into a QML namespace of any upper-case name, even if the same C++ type is also registered as a QML value type.</p>
<h3 id="enumeration-types-as-signal-and-method-parameters">Enumeration Types as Signal and Method Parameters</h3>
<p>C++ signals and methods with enumeration-type parameters can be used from QML provided that the enumeration and the signal or method are both declared within the same class, or that the enumeration value is one of those declared in the <a href="qml-qtqml-qt.html" translate="no">Qt Namespace</a>.</p>
<p>Additionally, if a C++ signal with an enum parameter should be connectable to a QML function using the <a href="qtqml-syntax-signals.html#connecting-signals-to-methods-and-signals" translate="no">connect()</a> function, the enum type must be registered using <a href="../qtcore/qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>().</p>
<p>For QML signals, enum values may be passed as signal parameters using the <code translate="no">int</code> type:</p>
<pre class="qml" translate="no">
 <span class="type">Message</span> {
     signal <span class="type">someOtherSignal</span>(int statusValue)

     <span class="name">Component</span>.onCompleted: {
         <span class="name">someOtherSignal</span>(<span class="name">Message</span>.<span class="name">Loading</span>)
     }
 }
</pre>
</div>
<!-- @@@qtqml-cppintegration-data.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
