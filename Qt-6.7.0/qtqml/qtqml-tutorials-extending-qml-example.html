<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- extending-tutorial.qdoc -->
  <meta name="description" content="Tutorial about extending QML with Qt C++.">
  <title>Writing QML Extensions with C++ | Qt QML 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtqml-index.html" translate="no">Qt QML</a></li>
<li>Writing QML Extensions with C++</li>
<li id="buildversion"><a href="qtqml-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#opening-the-tutorial-sources">Opening the Tutorial Sources</a></li>
<li class="level1"><a href="#creating-project-from-scratch">Creating Project from Scratch</a></li>
<li class="level1"><a href="#chapter-1-creating-a-new-type">Chapter 1: Creating a New Type</a></li>
<li class="level2"><a href="#class-declaration">Class Declaration</a></li>
<li class="level2"><a href="#qmake-setup">qmake Setup</a></li>
<li class="level2"><a href="#cmake-setup">CMake Setup</a></li>
<li class="level2"><a href="#class-implementation">Class Implementation</a></li>
<li class="level2"><a href="#qml-usage">QML Usage</a></li>
<li class="level2"><a href="#project-build">Project Build</a></li>
<li class="level1"><a href="#chapter-2-connecting-to-c-methods-and-signals">Chapter 2: Connecting to C++ Methods and Signals</a></li>
<li class="level1"><a href="#chapter-3-adding-property-bindings">Chapter 3: Adding Property Bindings</a></li>
<li class="level1"><a href="#chapter-4-using-custom-property-types">Chapter 4: Using Custom Property Types</a></li>
<li class="level1"><a href="#chapter-5-using-list-property-types">Chapter 5: Using List Property Types</a></li>
<li class="level1"><a href="#chapter-6-writing-an-extension-plugin">Chapter 6: Writing an Extension Plugin</a></li>
<li class="level1"><a href="#chapter-7-summary">Chapter 7: Summary</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Writing QML Extensions with C++</h1>
<!-- $$$qtqml-tutorials-extending-qml-example.html-description -->
<div class="descr" id="details">
<p>The <a href="qtqml-index.html" translate="no">Qt Qml</a> module provides a set of APIs for extending QML through C++ extensions. You can write extensions to add your own QML types, extend existing Qt types, or call C/C++ functions that are not accessible from ordinary QML code.</p>
<p>This tutorial shows how to write a QML extension using C++ that includes core QML features, including properties, signals and bindings. It also shows how extensions can be deployed through plugins.</p>
<p>Many of the topics covered in this tutorial are documented in further detail in <a href="qtqml-cppintegration-overview.html" translate="no">Overview - QML and C++ Integration</a> and its documentation sub-topics. In particular, you may be interested in the sub-topics <a href="qtqml-cppintegration-exposecppattributes.html" translate="no">Exposing Attributes of C++ Classes to QML</a> and <a href="qtqml-cppintegration-definetypes.html" translate="no">Defining QML Types from C++</a>.</p>
<h2 id="opening-the-tutorial-sources">Opening the Tutorial Sources</h2>
<p>The code in this tutorial is available as part of the Qt sources. If you installed Qt with the Qt Online Installer, you can find the sources in the Qt installation directory under Examples/Qt-6.7.0/qml/tutorials/extending-qml/.</p>
<h2 id="creating-project-from-scratch">Creating Project from Scratch</h2>
<p>Alternatively, you can follow the tutorial by creating the sources from scratch: For each chapter, create a new project using the <i>Qt Quick Application</i> template in Qt Creator, as instructed in <a href="https://doc.qt.io/qtcreator/quick-projects.html" translate="no">Qt Creator: Creating Qt Quick Projects</a>. Then follow along by adapting and extending the generated skeleton code.</p>
<h2 id="chapter-1-creating-a-new-type">Chapter 1: Creating a New Type</h2>
<p><code translate="no">extending-qml/chapter1-basics</code></p>
<p>A common task when extending QML is to provide a new QML type that supports some custom functionality beyond what is provided by the built-in <a href="../qtquick/qtquick-qmlmodule.html" translate="no">Qt Quick types</a>. For example, this could be done to implement particular data models, or provide types with custom painting and drawing capabilities, or access system features like network programming that are not accessible through built-in QML features.</p>
<p>In this tutorial, we will show how to use the C++ classes in the Qt Quick module to extend QML. The end result will be a simple Pie Chart display implemented by several custom QML types connected together through QML features like bindings and signals, and made available to the QML runtime through a plugin.</p>
<p>To begin with, let's create a new QML type called &quot;PieChart&quot; that has two properties: a name and a color. We will make it available in an importable type namespace called &quot;Charts&quot;, with a version of 1.0.</p>
<p>We want this <code translate="no">PieChart</code> type to be usable from QML like this:</p>
<pre class="qml" translate="no">
 import Charts

 <span class="type">PieChart</span> {
     <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
     <span class="name">name</span>: <span class="string">&quot;A simple pie chart&quot;</span>
     <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
 }
</pre>
<p>To do this, we need a C++ class that encapsulates this <code translate="no">PieChart</code> type and its two properties. Since QML makes extensive use of Qt's <a href="../qtcore/metaobjects.html" translate="no">meta object system</a>, this new class must:</p>
<ul>
<li>Inherit from <a href="../qtcore/qobject.html" translate="no">QObject</a></li>
<li>Declare its properties using the <a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a> macro</li>
</ul>
<h3 id="class-declaration">Class Declaration</h3>
<p>Here is our <code translate="no">PieChart</code> class, defined in <code translate="no">piechart.h</code>:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;QtQuick/QQuickPaintedItem&gt;</span>
 <span class="preprocessor">#include &lt;QColor&gt;</span>

 <span class="keyword">class</span> PieChart : <span class="keyword">public</span> <span class="type"><a href="../qtquick/qquickpainteditem.html" translate="no">QQuickPaintedItem</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> name READ name WRITE setName FINAL)
     Q_PROPERTY(<span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> color READ color WRITE setColor FINAL)
     QML_ELEMENT

 <span class="keyword">public</span>:
     PieChart(<span class="type"><a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);

     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> name() <span class="keyword">const</span>;
     <span class="type">void</span> setName(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>name);

     <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> color() <span class="keyword">const</span>;
     <span class="type">void</span> setColor(<span class="keyword">const</span> <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> <span class="operator">&amp;</span>color);

     <span class="type">void</span> paint(<span class="type"><a href="../qtgui/qpainter.html" translate="no">QPainter</a></span> <span class="operator">*</span>painter) override;

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> m_name;
     <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> m_color;
 };
</pre>
<p>The class inherits from <a href="../qtquick/qquickpainteditem.html" translate="no">QQuickPaintedItem</a> because we want to override <a href="../qtquick/qquickpainteditem.html#paint" translate="no">QQuickPaintedItem::paint</a>() to perform drawing operations with the <a href="../qtgui/qpainter.html" translate="no">QPainter</a> API. If the class just represented some data type and was not an item that actually needed to be displayed, it could simply inherit from <a href="../qtcore/qobject.html" translate="no">QObject</a>. Or, if we want to extend the functionality of an existing <a href="../qtcore/qobject.html" translate="no">QObject</a>-based class, it could inherit from that class instead. Alternatively, if we want to create a visual item that doesn't need to perform drawing operations with the <a href="../qtgui/qpainter.html" translate="no">QPainter</a> API, we can just subclass <a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a>.</p>
<p>The <code translate="no">PieChart</code> class defines the two properties, <code translate="no">name</code> and <code translate="no">color</code>, with the <a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a> macro, and overrides <a href="../qtquick/qquickpainteditem.html#paint" translate="no">QQuickPaintedItem::paint</a>(). The <code translate="no">PieChart</code> class is registered using the <a href="qqmlengine.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> macro, to allow it to be used from QML. If you don't register the class, <code translate="no">app.qml</code> won't be able to create a <code translate="no">PieChart</code>.</p>
<h3 id="qmake-setup">qmake Setup</h3>
<p>For the registration to take effect, the <code translate="no">qmltypes</code> option is added to <code translate="no">CONFIG</code> in the project file and a <code translate="no">QML_IMPORT_NAME</code> and <code translate="no">QML_IMPORT_MAJOR_VERSION</code> are given:</p>
<pre class="cpp" translate="no">
 CONFIG += qmltypes
 QML_IMPORT_NAME = Charts
 QML_IMPORT_MAJOR_VERSION = 1
</pre>
<h3 id="cmake-setup">CMake Setup</h3>
<p>Similarly, for the registration to take effect when using CMake, use the <a href="qt-add-qml-module.html#qt6-add-qml-module" translate="no">qt_add_qml_module</a> command:</p>
<pre class="cpp" translate="no">
 qt_add_qml_module(chapter1-basics
     URI Charts
     QML_FILES app.qml
     NO_RESOURCE_TARGET_PATH
     DEPENDENCIES QtQuick
 )
</pre>
<h3 id="class-implementation">Class Implementation</h3>
<p>The class implementation in <code translate="no">piechart.cpp</code> simply sets and returns the <code translate="no">m_name</code> and <code translate="no">m_color</code> values as appropriate, and implements <code translate="no">paint()</code> to draw a simple pie chart:</p>
<pre class="cpp" translate="no">
 PieChart<span class="operator">::</span>PieChart(<span class="type"><a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a></span> <span class="operator">*</span>parent)
     : <span class="type"><a href="../qtquick/qquickpainteditem.html" translate="no">QQuickPaintedItem</a></span>(parent)
 {
 }
 ...
 <span class="type">void</span> PieChart<span class="operator">::</span>paint(<span class="type"><a href="../qtgui/qpainter.html" translate="no">QPainter</a></span> <span class="operator">*</span>painter)
 {
     <span class="type"><a href="../qtgui/qpen.html" translate="no">QPen</a></span> pen(m_color<span class="operator">,</span> <span class="number">2</span>);
     painter<span class="operator">-</span><span class="operator">&gt;</span>setPen(pen);
     painter<span class="operator">-</span><span class="operator">&gt;</span>setRenderHints(<span class="type"><a href="../qtgui/qpainter.html" translate="no">QPainter</a></span><span class="operator">::</span>Antialiasing<span class="operator">,</span> <span class="keyword">true</span>);
     painter<span class="operator">-</span><span class="operator">&gt;</span>drawPie(boundingRect()<span class="operator">.</span>adjusted(<span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span>)<span class="operator">,</span> <span class="number">90</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">,</span> <span class="number">290</span> <span class="operator">*</span> <span class="number">16</span>);
 }
</pre>
<h3 id="qml-usage">QML Usage</h3>
<p>Now that we have defined the <code translate="no">PieChart</code> type, we will use it from QML. The <code translate="no">app.qml</code> file creates a <code translate="no">PieChart</code> item and displays the pie chart's details using a standard QML <a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a> item:</p>
<pre class="qml" translate="no">
 import Charts
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">width</span>: <span class="number">300</span>; <span class="name">height</span>: <span class="number">200</span>

     <span class="type">PieChart</span> {
         <span class="name">id</span>: <span class="name">aPieChart</span>
         <span class="name">anchors</span>.centerIn: <span class="name">parent</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         <span class="name">name</span>: <span class="string">&quot;A simple pie chart&quot;</span>
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
     }

     <span class="type"><a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a></span> {
         <span class="type">anchors</span> { <span class="name">bottom</span>: <span class="name">parent</span>.<span class="name">bottom</span>; <span class="name">horizontalCenter</span>: <span class="name">parent</span>.<span class="name">horizontalCenter</span>; <span class="name">bottomMargin</span>: <span class="number">20</span> }
         <span class="name">text</span>: <span class="name">aPieChart</span>.<span class="name">name</span>
     }
 }
</pre>
<p>Notice that although the color is specified as a string in QML, it is automatically converted to a <a href="../qtgui/qcolor.html" translate="no">QColor</a> object for the PieChart <code translate="no">color</code> property. Automatic conversions are provided for various other <a href="qtqml-typesystem-valuetypes.html" translate="no">value types</a>. For example, a string like &quot;640x480&quot; can be automatically converted to a <a href="../qtcore/qsize.html" translate="no">QSize</a> value.</p>
<p>We'll also create a C++ application that uses a <a href="../qtquick/qquickview.html" translate="no">QQuickView</a> to run and display <code translate="no">app.qml</code>.</p>
<p>Here is the application <code translate="no">main.cpp</code>:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &quot;piechart.h&quot;</span>
 <span class="preprocessor">#include &lt;QtQuick/QQuickView&gt;</span>
 <span class="preprocessor">#include &lt;QGuiApplication&gt;</span>

 <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>argv<span class="operator">[</span><span class="operator">]</span>)
 {
     <span class="type"><a href="../qtgui/qguiapplication.html" translate="no">QGuiApplication</a></span> app(argc<span class="operator">,</span> argv);

     <span class="type"><a href="../qtquick/qquickview.html" translate="no">QQuickView</a></span> view;
     view<span class="operator">.</span>setResizeMode(<span class="type"><a href="../qtquick/qquickview.html" translate="no">QQuickView</a></span><span class="operator">::</span>SizeRootObjectToView);
     view<span class="operator">.</span>setSource(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>(<span class="string">&quot;qrc:///app.qml&quot;</span>));
     view<span class="operator">.</span>show();
     <span class="keyword">return</span> <span class="type"><a href="../qtgui/qguiapplication.html" translate="no">QGuiApplication</a></span><span class="operator">::</span>exec();
 }
</pre>
<h3 id="project-build">Project Build</h3>
<p>To build the project we include the files, link against the libraries, and define a type namespace called &quot;Charts&quot; with version 1.0 for any types exposed to QML.</p>
<p>Using qmake:</p>
<pre class="cpp" translate="no">
 QT += qml quick

 CONFIG += qmltypes
 QML_IMPORT_NAME = Charts
 QML_IMPORT_MAJOR_VERSION = 1

 HEADERS += piechart.h
 SOURCES += piechart.cpp \
            main.cpp

 RESOURCES += chapter1-basics.qrc

 DESTPATH = $$[QT_INSTALL_EXAMPLES]/qml/tutorials/extending-qml/chapter1-basics
 target.path = $$DESTPATH
 INSTALLS += target
</pre>
<p>Using CMake:</p>
<pre class="cpp" translate="no">
 # Copyright (C) 2022 The Qt Company Ltd.
 # SPDX-License-Identifier: BSD-3-Clause

 cmake_minimum_required(VERSION 3.16)
 project(chapter1-basics LANGUAGES CXX)

 set(CMAKE_AUTOMOC ON)

 if(NOT DEFINED INSTALL_EXAMPLESDIR)
     set(INSTALL_EXAMPLESDIR &quot;examples&quot;)
 endif()

 set(INSTALL_EXAMPLEDIR &quot;${INSTALL_EXAMPLESDIR}/qml/tutorials/extending-qml/chapter1-basics&quot;)

 find_package(Qt6 REQUIRED COMPONENTS Core Gui Qml Quick)

 qt_add_executable(chapter1-basics
     main.cpp
     piechart.cpp piechart.h
 )

 set_target_properties(chapter1-basics PROPERTIES
     WIN32_EXECUTABLE TRUE
     MACOSX_BUNDLE TRUE
 )

 target_link_libraries(chapter1-basics PUBLIC
     Qt6::Core
     Qt6::Gui
     Qt6::Qml
     Qt6::Quick
 )
 qt_add_qml_module(chapter1-basics
     URI Charts
     QML_FILES app.qml
     NO_RESOURCE_TARGET_PATH
     DEPENDENCIES QtQuick
 )
 install(TARGETS chapter1-basics
     RUNTIME DESTINATION &quot;${INSTALL_EXAMPLEDIR}&quot;
     BUNDLE DESTINATION &quot;${INSTALL_EXAMPLEDIR}&quot;
     LIBRARY DESTINATION &quot;${INSTALL_EXAMPLEDIR}&quot;
 )
</pre>
<p>Now we can build and run the application:</p>
<p class="centerAlign"><img src="images/extending-tutorial-chapter1.png" alt="" /></p><div class="admonition note">
<p><b>Note: </b>You may see a warning <i>Expression ... depends on non-NOTIFYable properties: PieChart::name</i>. This happens because we add a binding to the writable <code translate="no">name</code> property, but haven't yet defined a notify signal for it. The QML engine therefore cannot update the binding if the <code translate="no">name</code> value changes. This is addressed in the following chapters.</p>
</div>
<h2 id="chapter-2-connecting-to-c-methods-and-signals">Chapter 2: Connecting to C++ Methods and Signals</h2>
<p><code translate="no">extending-qml/chapter2-methods</code></p>
<p>Suppose we want <code translate="no">PieChart</code> to have a &quot;clearChart()&quot; method that erases the chart and then emits a &quot;chartCleared&quot; signal. Our <code translate="no">app.qml</code> would be able to call <code translate="no">clearChart()</code> and receive <code translate="no">chartCleared()</code> signals like this:</p>
<pre class="qml" translate="no">
 import Charts
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">width</span>: <span class="number">300</span>; <span class="name">height</span>: <span class="number">200</span>

     <span class="type">PieChart</span> {
         <span class="name">id</span>: <span class="name">aPieChart</span>
         <span class="name">anchors</span>.centerIn: <span class="name">parent</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>

         <span class="name">onChartCleared</span>: <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;The chart has been cleared&quot;</span>)
     }

     <span class="type"><a href="../qtquick/qml-qtquick-mousearea.html" translate="no">MouseArea</a></span> {
         <span class="name">anchors</span>.fill: <span class="name">parent</span>
         <span class="name">onClicked</span>: <span class="name">aPieChart</span>.<span class="name">clearChart</span>()
     }

     <span class="type"><a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a></span> {
         <span class="type">anchors</span> { <span class="name">bottom</span>: <span class="name">parent</span>.<span class="name">bottom</span>; <span class="name">horizontalCenter</span>: <span class="name">parent</span>.<span class="name">horizontalCenter</span>; <span class="name">bottomMargin</span>: <span class="number">20</span> }
         <span class="name">text</span>: <span class="string">&quot;Click anywhere to clear the chart&quot;</span>
     }
 }
</pre>
<p class="centerAlign"><img src="images/extending-tutorial-chapter2.png" alt="" /></p><p>To do this, we add a <code translate="no">clearChart()</code> method and a <code translate="no">chartCleared()</code> signal to our C++ class:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> PieChart : <span class="keyword">public</span> <span class="type"><a href="../qtquick/qquickpainteditem.html" translate="no">QQuickPaintedItem</a></span>
 {
     ...
 <span class="keyword">public</span>:
     ...
     Q_INVOKABLE <span class="type">void</span> clearChart();

 <span class="keyword">signals</span>:
     <span class="type">void</span> chartCleared();
     ...
 };
</pre>
<p>The use of <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> makes the <code translate="no">clearChart()</code> method available to the Qt Meta-Object system, and in turn, to QML. Note that it could have been declared as a Qt slot instead of using <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>, as slots are also callable from QML. Both of these approaches are valid.</p>
<p>The <code translate="no">clearChart()</code> method simply changes the color to <a href="../qtcore/qt.html#GlobalColor-enum" translate="no">Qt::transparent</a>, repaints the chart, then emits the <code translate="no">chartCleared()</code> signal:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> PieChart<span class="operator">::</span>clearChart()
 {
     setColor(<span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span>(<span class="type"><a href="qml-qtqml-qt.html" translate="no">Qt</a></span><span class="operator">::</span>transparent));
     update();

     <span class="keyword">emit</span> chartCleared();
 }
</pre>
<p>Now when we run the application and click the window, the pie chart disappears, and the application outputs:</p>
<pre class="cpp plain" translate="no">
 qml: The chart has been cleared
</pre>
<h2 id="chapter-3-adding-property-bindings">Chapter 3: Adding Property Bindings</h2>
<p><code translate="no">extending-qml/chapter3-bindings</code></p>
<p>Property binding is a powerful feature of QML that allows values of different types to be synchronized automatically. It uses signals to notify and update other types' values when property values are changed.</p>
<p>Let's enable property bindings for the <code translate="no">color</code> property. That means if we have code like this:</p>
<pre class="qml" translate="no">
 import Charts
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">width</span>: <span class="number">300</span>; <span class="name">height</span>: <span class="number">200</span>

     <span class="type"><a href="../qtquick/qml-qtquick-row.html" translate="no">Row</a></span> {
         <span class="name">anchors</span>.centerIn: <span class="name">parent</span>
         <span class="name">spacing</span>: <span class="number">20</span>

         <span class="type">PieChart</span> {
             <span class="name">id</span>: <span class="name">chartA</span>
             <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
             <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         }

         <span class="type">PieChart</span> {
             <span class="name">id</span>: <span class="name">chartB</span>
             <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
             <span class="name">color</span>: <span class="name">chartA</span>.<span class="name">color</span>
         }
     }

     <span class="type"><a href="../qtquick/qml-qtquick-mousearea.html" translate="no">MouseArea</a></span> {
         <span class="name">anchors</span>.fill: <span class="name">parent</span>
         <span class="name">onClicked</span>: { <span class="name">chartA</span>.<span class="name">color</span> <span class="operator">=</span> <span class="string">&quot;blue&quot;</span> }
     }

     <span class="type"><a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a></span> {
         <span class="type">anchors</span> { <span class="name">bottom</span>: <span class="name">parent</span>.<span class="name">bottom</span>; <span class="name">horizontalCenter</span>: <span class="name">parent</span>.<span class="name">horizontalCenter</span>; <span class="name">bottomMargin</span>: <span class="number">20</span> }
         <span class="name">text</span>: <span class="string">&quot;Click anywhere to change the chart color&quot;</span>
     }
 }
</pre>
<p class="centerAlign"><img src="images/extending-tutorial-chapter3.png" alt="" /></p><p>The &quot;color: chartA.color&quot; statement binds the <code translate="no">color</code> value of <code translate="no">chartB</code> to the <code translate="no">color</code> of <code translate="no">chartA</code>. Whenever <code translate="no">chartA</code>'s <code translate="no">color</code> value changes, <code translate="no">chartB</code>'s <code translate="no">color</code> value updates to the same value. When the window is clicked, the <code translate="no">onClicked</code> handler in the <a href="../qtquick/qml-qtquick-mousearea.html" translate="no">MouseArea</a> changes the color of <code translate="no">chartA</code>, thereby changing both charts to the color blue.</p>
<p>It's easy to enable property binding for the <code translate="no">color</code> property. We add a <a href="../qtcore/properties.html" translate="no">NOTIFY</a> feature to its <a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a>() declaration to indicate that a &quot;colorChanged&quot; signal is emitted whenever the value changes.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> PieChart : <span class="keyword">public</span> <span class="type"><a href="../qtquick/qquickpainteditem.html" translate="no">QQuickPaintedItem</a></span>
 {
     ...
     Q_PROPERTY(<span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> color READ color WRITE setColor NOTIFY colorChanged FINAL)
 <span class="keyword">public</span>:
     ...
 <span class="keyword">signals</span>:
     <span class="type">void</span> colorChanged();
     ...
 };
</pre>
<p>Then, we emit this signal in <code translate="no">setColor()</code>:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> PieChart<span class="operator">::</span>setColor(<span class="keyword">const</span> <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> <span class="operator">&amp;</span>color)
 {
     <span class="keyword">if</span> (color <span class="operator">!</span><span class="operator">=</span> m_color) {
         m_color <span class="operator">=</span> color;
         update();   <span class="comment">// repaint with the new color</span>
         <span class="keyword">emit</span> colorChanged();
     }
 }
</pre>
<p>It's important for <code translate="no">setColor()</code> to check that the color value has actually changed before emitting <code translate="no">colorChanged()</code>. This ensures the signal is not emitted unnecessarily and also prevents loops when other types respond to the value change.</p>
<p>The use of bindings is essential to QML. You should always add NOTIFY signals for properties if they are able to be implemented, so that your properties can be used in bindings. Properties that cannot be bound cannot be automatically updated and cannot be used as flexibly in QML. Also, since bindings are invoked so often and relied upon in QML usage, users of your custom QML types may see unexpected behavior if bindings are not implemented.</p>
<h2 id="chapter-4-using-custom-property-types">Chapter 4: Using Custom Property Types</h2>
<p><code translate="no">extending-qml/chapter4-customPropertyTypes</code></p>
<p>The <code translate="no">PieChart</code> type currently has a string-type property and a color-type property. It could have many other types of properties. For example, it could have an int-type property to store an identifier for each chart:</p>
<pre class="cpp" translate="no">
 <span class="comment">// C++</span>
 <span class="keyword">class</span> PieChart : <span class="keyword">public</span> <span class="type"><a href="../qtquick/qquickpainteditem.html" translate="no">QQuickPaintedItem</a></span>
 {
     Q_PROPERTY(<span class="type">int</span> chartId READ chartId WRITE setChartId NOTIFY chartIdChanged)
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

 <span class="keyword">public</span>:
     <span class="type">void</span> setChartId(<span class="type">int</span> chartId);
     <span class="type">int</span> chartId() <span class="keyword">const</span>;
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

 <span class="keyword">signals</span>:
     <span class="type">void</span> chartIdChanged();
 };

 <span class="comment">// QML</span>
 PieChart {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     chartId: <span class="number">100</span>
 }
</pre>
<p>Aside from <code translate="no">int</code>, we could use various other property types. Many of the Qt data types such as <a href="../qtgui/qcolor.html" translate="no">QColor</a>, <a href="../qtcore/qsize.html" translate="no">QSize</a> and <a href="../qtcore/qrect.html" translate="no">QRect</a> are automatically supported from QML. (See <a href="qtqml-cppintegration-data.html" translate="no">Data Type Conversion Between QML and C++</a> documentation for a full list.)</p>
<p>If we want to create a property whose type is not supported by QML by default, we need to register the type with the QML engine.</p>
<p>For example, let's replace the use of the <code translate="no">property</code> with a type called &quot;PieSlice&quot; that has a <code translate="no">color</code> property. Instead of assigning a color, we assign an <code translate="no">PieSlice</code> value which itself contains a <code translate="no">color</code>:</p>
<pre class="qml" translate="no">
 import Charts
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">width</span>: <span class="number">300</span>; <span class="name">height</span>: <span class="number">200</span>

     <span class="type">PieChart</span> {
         <span class="name">id</span>: <span class="name">chart</span>
         <span class="name">anchors</span>.centerIn: <span class="name">parent</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

         <span class="name">pieSlice</span>: <span class="name">PieSlice</span> {
             <span class="name">anchors</span>.fill: <span class="name">parent</span>
             <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         }
     }

     <span class="name">Component</span>.onCompleted: <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;The pie is colored &quot;</span> <span class="operator">+</span> <span class="name">chart</span>.<span class="name">pieSlice</span>.<span class="name">color</span>)
 }
</pre>
<p>Like <code translate="no">PieChart</code>, this new <code translate="no">PieSlice</code> type inherits from <a href="../qtquick/qquickpainteditem.html" translate="no">QQuickPaintedItem</a> and declares its properties with <a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a>():</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> PieSlice : <span class="keyword">public</span> <span class="type"><a href="../qtquick/qquickpainteditem.html" translate="no">QQuickPaintedItem</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> color READ color WRITE setColor FINAL)
     QML_ELEMENT

 <span class="keyword">public</span>:
     PieSlice(<span class="type"><a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);

     <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> color() <span class="keyword">const</span>;
     <span class="type">void</span> setColor(<span class="keyword">const</span> <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> <span class="operator">&amp;</span>color);

     <span class="type">void</span> paint(<span class="type"><a href="../qtgui/qpainter.html" translate="no">QPainter</a></span> <span class="operator">*</span>painter) override;

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> m_color;
 };
</pre>
<p>To use it in <code translate="no">PieChart</code>, we modify the <code translate="no">color</code> property declaration and associated method signatures:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> PieChart : <span class="keyword">public</span> <span class="type"><a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(PieSlice<span class="operator">*</span> pieSlice READ pieSlice WRITE setPieSlice FINAL)
     ...
 <span class="keyword">public</span>:
     ...
     PieSlice <span class="operator">*</span>pieSlice() <span class="keyword">const</span>;
     <span class="type">void</span> setPieSlice(PieSlice <span class="operator">*</span>pieSlice);
     ...
 };
</pre>
<p>There is one thing to be aware of when implementing <code translate="no">setPieSlice()</code>. The <code translate="no">PieSlice</code> is a visual item, so it must be set as a child of the <code translate="no">PieChart</code> using <a href="../qtquick/qquickitem.html#parent-prop" translate="no">QQuickItem::setParentItem</a>() so that the <code translate="no">PieChart</code> knows to paint this child item when its contents are drawn:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> PieChart<span class="operator">::</span>setPieSlice(PieSlice <span class="operator">*</span>pieSlice)
 {
     m_pieSlice <span class="operator">=</span> pieSlice;
     pieSlice<span class="operator">-</span><span class="operator">&gt;</span>setParentItem(<span class="keyword">this</span>);
 }
</pre>
<p>Like the <code translate="no">PieChart</code> type, the <code translate="no">PieSlice</code> type has to be exposted to QML using <a href="qqmlengine.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> PieSlice : <span class="keyword">public</span> <span class="type"><a href="../qtquick/qquickpainteditem.html" translate="no">QQuickPaintedItem</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> color READ color WRITE setColor FINAL)
     QML_ELEMENT

 <span class="keyword">public</span>:
     PieSlice(<span class="type"><a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);

     <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> color() <span class="keyword">const</span>;
     <span class="type">void</span> setColor(<span class="keyword">const</span> <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> <span class="operator">&amp;</span>color);

     <span class="type">void</span> paint(<span class="type"><a href="../qtgui/qpainter.html" translate="no">QPainter</a></span> <span class="operator">*</span>painter) override;

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> m_color;
 };
     ...
</pre>
<p>As with <code translate="no">PieChart</code>, we add the &quot;Charts&quot; type namespace, version 1.0, to our build file:</p>
<p>Using qmake:</p>
<pre class="cpp" translate="no">
 QT += qml quick

 CONFIG += qmltypes
 QML_IMPORT_NAME = Charts
 QML_IMPORT_MAJOR_VERSION = 1

 HEADERS += piechart.h \
            pieslice.h
 SOURCES += piechart.cpp \
            pieslice.cpp \
            main.cpp

 RESOURCES += chapter4-customPropertyTypes.qrc

 DESTPATH = $$[QT_INSTALL_EXAMPLES]/qml/tutorials/extending-qml/chapter4-customPropertyTypes
 target.path = $$DESTPATH
 INSTALLS += target
</pre>
<p>Using CMake:</p>
<pre class="cpp" translate="no">
     ...
 qt_add_executable(chapter4-customPropertyTypes
     main.cpp
     piechart.cpp piechart.h
     pieslice.cpp pieslice.h
 )
 qt_add_qml_module(chapter4-customPropertyTypes
     URI Charts
     QML_FILES app.qml
     NO_RESOURCE_TARGET_PATH
     DEPENDENCIES QtQuick
 )
     ...
</pre>
<h2 id="chapter-5-using-list-property-types">Chapter 5: Using List Property Types</h2>
<p><code translate="no">extending-qml/chapter5-listproperties</code></p>
<p>Right now, a <code translate="no">PieChart</code> can only have one <code translate="no">PieSlice</code>. Ideally a chart would have multiple slices, with different colors and sizes. To do this, we could have a <code translate="no">slices</code> property that accepts a list of <code translate="no">PieSlice</code> items:</p>
<pre class="qml" translate="no">
 import Charts
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">width</span>: <span class="number">300</span>; <span class="name">height</span>: <span class="number">200</span>

     <span class="type">PieChart</span> {
         <span class="name">anchors</span>.centerIn: <span class="name">parent</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

         <span class="name">slices</span>: [
             <span class="type">PieSlice</span> {
                 <span class="name">anchors</span>.fill: <span class="name">parent</span>
                 <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
                 <span class="name">fromAngle</span>: <span class="number">0</span>; <span class="name">angleSpan</span>: <span class="number">110</span>
             },
             <span class="type">PieSlice</span> {
                 <span class="name">anchors</span>.fill: <span class="name">parent</span>
                 <span class="name">color</span>: <span class="string">&quot;black&quot;</span>
                 <span class="name">fromAngle</span>: <span class="number">110</span>; <span class="name">angleSpan</span>: <span class="number">50</span>
             },
             <span class="type">PieSlice</span> {
                 <span class="name">anchors</span>.fill: <span class="name">parent</span>
                 <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
                 <span class="name">fromAngle</span>: <span class="number">160</span>; <span class="name">angleSpan</span>: <span class="number">100</span>
             }
         ]
     }
 }
</pre>
<p class="centerAlign"><img src="images/extending-tutorial-chapter5.png" alt="" /></p><p>To do this, we replace the <code translate="no">pieSlice</code> property in <code translate="no">PieChart</code> with a <code translate="no">slices</code> property, declared as a <a href="qqmllistproperty.html" translate="no">QQmlListProperty</a> type. The <a href="qqmllistproperty.html" translate="no">QQmlListProperty</a> class enables the creation of list properties in QML extensions. We replace the <code translate="no">pieSlice()</code> function with a <code translate="no">slices()</code> function that returns a list of slices, and add an internal <code translate="no">append_slice()</code> function (discussed below). We also use a <a href="../qtcore/qlist.html" translate="no">QList</a> to store the internal list of slices as <code translate="no">m_slices</code>:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> PieChart : <span class="keyword">public</span> <span class="type"><a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="qqmllistproperty.html" translate="no">QQmlListProperty</a></span><span class="operator">&lt;</span>PieSlice<span class="operator">&gt;</span> slices READ slices FINAL)
     ...
 <span class="keyword">public</span>:
     ...
     <span class="type"><a href="qqmllistproperty.html" translate="no">QQmlListProperty</a></span><span class="operator">&lt;</span>PieSlice<span class="operator">&gt;</span> slices();

 <span class="keyword">private</span>:
     <span class="keyword">static</span> <span class="type">void</span> append_slice(<span class="type"><a href="qqmllistproperty.html" translate="no">QQmlListProperty</a></span><span class="operator">&lt;</span>PieSlice<span class="operator">&gt;</span> <span class="operator">*</span>list<span class="operator">,</span> PieSlice <span class="operator">*</span>slice);

     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> m_name;
     <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span>PieSlice <span class="operator">*</span><span class="operator">&gt;</span> m_slices;
 };
</pre>
<p>Although the <code translate="no">slices</code> property does not have an associated <code translate="no">WRITE</code> function, it is still modifiable because of the way <a href="qqmllistproperty.html" translate="no">QQmlListProperty</a> works. In the <code translate="no">PieChart</code> implementation, we implement <code translate="no">PieChart::slices()</code> to return a <a href="qqmllistproperty.html" translate="no">QQmlListProperty</a> value and indicate that the internal <code translate="no">PieChart::append_slice()</code> function is to be called whenever a request is made from QML to add items to the list:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qqmllistproperty.html" translate="no">QQmlListProperty</a></span><span class="operator">&lt;</span>PieSlice<span class="operator">&gt;</span> PieChart<span class="operator">::</span>slices()
 {
     <span class="keyword">return</span> <span class="type"><a href="qqmllistproperty.html" translate="no">QQmlListProperty</a></span><span class="operator">&lt;</span>PieSlice<span class="operator">&gt;</span>(<span class="keyword">this</span><span class="operator">,</span> nullptr<span class="operator">,</span> <span class="operator">&amp;</span>PieChart<span class="operator">::</span>append_slice<span class="operator">,</span> nullptr<span class="operator">,</span>
                                       nullptr<span class="operator">,</span> nullptr<span class="operator">,</span> nullptr<span class="operator">,</span> nullptr);
 }

 <span class="type">void</span> PieChart<span class="operator">::</span>append_slice(<span class="type"><a href="qqmllistproperty.html" translate="no">QQmlListProperty</a></span><span class="operator">&lt;</span>PieSlice<span class="operator">&gt;</span> <span class="operator">*</span>list<span class="operator">,</span> PieSlice <span class="operator">*</span>slice)
 {
     PieChart <span class="operator">*</span>chart <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>PieChart <span class="operator">*</span><span class="operator">&gt;</span>(list<span class="operator">-</span><span class="operator">&gt;</span>object);
     <span class="keyword">if</span> (chart) {
         slice<span class="operator">-</span><span class="operator">&gt;</span>setParentItem(chart);
         chart<span class="operator">-</span><span class="operator">&gt;</span>m_slices<span class="operator">.</span>append(slice);
     }
 }
</pre>
<p>The <code translate="no">append_slice()</code> function simply sets the parent item as before, and adds the new item to the <code translate="no">m_slices</code> list. As you can see, the append function for a <a href="qqmllistproperty.html" translate="no">QQmlListProperty</a> is called with two arguments: the list property, and the item that is to be appended.</p>
<p>The <code translate="no">PieSlice</code> class has also been modified to include <code translate="no">fromAngle</code> and <code translate="no">angleSpan</code> properties and to draw the slice according to these values. This is a straightforward modification if you have read the previous pages in this tutorial, so the code is not shown here.</p>
<h2 id="chapter-6-writing-an-extension-plugin">Chapter 6: Writing an Extension Plugin</h2>
<p><code translate="no">extending-qml/chapter6-plugins</code></p>
<p>Currently the <code translate="no">PieChart</code> and <code translate="no">PieSlice</code> types are used by <code translate="no">app.qml</code>, which is displayed using a <a href="../qtquick/qquickview.html" translate="no">QQuickView</a> in a C++ application. An alternative way to use our QML extension is to create a plugin library to make it available to the QML engine as a new QML import module. This allows the <code translate="no">PieChart</code> and <code translate="no">PieSlice</code> types to be registered into a type namespace which can be imported by any QML application, instead of restricting these types to be only used by the one application.</p>
<p>The steps for creating a plugin are described in <a href="qtqml-modules-cppplugins.html" translate="no">Creating C++ Plugins for QML</a>. To start with, we create a plugin class named <code translate="no">ChartsPlugin</code>. It subclasses <a href="qqmlengineextensionplugin.html" translate="no">QQmlEngineExtensionPlugin</a> and uses the <a href="../qtcore/qtplugin.html#Q_PLUGIN_METADATA" translate="no">Q_PLUGIN_METADATA</a>() macro to register the plugin with the Qt meta object system.</p>
<p>Here is the <code translate="no">ChartsPlugin</code> definition in <code translate="no">chartsplugin.h</code>:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;QQmlEngineExtensionPlugin&gt;</span>

 <span class="keyword">class</span> ChartsPlugin : <span class="keyword">public</span> <span class="type"><a href="qqmlengineextensionplugin.html" translate="no">QQmlEngineExtensionPlugin</a></span>
 {
     Q_OBJECT
     Q_PLUGIN_METADATA(IID QQmlEngineExtensionInterface_iid)
 };
</pre>
<p>Then, we configure the build file to define the project as a plugin library.</p>
<p>Using qmake:</p>
<pre class="cpp" translate="no">
 TEMPLATE = lib
 CONFIG += plugin qmltypes
 QT += qml quick

 QML_IMPORT_NAME = Charts
 QML_IMPORT_MAJOR_VERSION = 1

 TARGET = $$qtLibraryTarget(chartsplugin)

 HEADERS += piechart.h \
            pieslice.h \
            chartsplugin.h

 SOURCES += piechart.cpp \
            pieslice.cpp

 DESTPATH=$$[QT_INSTALL_EXAMPLES]/qml/tutorials/extending-qml/chapter6-plugins/$$QML_IMPORT_NAME

 target.path=$$DESTPATH
 qmldir.files=$$PWD/qmldir
 qmldir.path=$$DESTPATH
 INSTALLS += target qmldir

 CONFIG += install_ok  # Do not cargo-cult this!

 OTHER_FILES += qmldir

 # Copy the qmldir file to the same folder as the plugin binary
 cpqmldir.files = qmldir
 cpqmldir.path = .
 COPIES += cpqmldir
</pre>
<p>Using CMake:</p>
<pre class="cpp" translate="no">
 # Copyright (C) 2022 The Qt Company Ltd.
 # SPDX-License-Identifier: BSD-3-Clause

 qt6_policy(SET QTP0001 NEW)
 qt6_add_qml_module(chartsplugin
     URI &quot;Charts&quot;
     PLUGIN_TARGET chartsplugin
     DEPENDENCIES QtQuick
 )

 target_sources(chartsplugin PRIVATE
     piechart.cpp piechart.h
     pieslice.cpp pieslice.h
 )

 target_link_libraries(chartsplugin PRIVATE
     Qt6::Core
     Qt6::Gui
     Qt6::Qml
     Qt6::Quick
 )

 if(QT6_IS_SHARED_LIBS_BUILD AND APPLE)
     get_target_property(is_bundle chapter6-plugins MACOSX_BUNDLE)
     if(is_bundle)
         # The application's main.cpp adds an explicit QML import path to look for qml modules under
         # a PlugIns subdirectory in a macOS bundle.
         # Copy the qmldir and shared library qml plugin.

         set(charts_dir &quot;$&lt;TARGET_FILE_DIR:chartsplugin&gt;&quot;)
         set(chars_qmldir_file &quot;${charts_dir}/qmldir&quot;)
         set(app_dir &quot;$&lt;TARGET_FILE_DIR:chapter6-plugins&gt;&quot;)
         set(bundle_charts_dir &quot;${app_dir}/../PlugIns/Charts&quot;)

         add_custom_command(TARGET chartsplugin POST_BUILD
             COMMAND ${CMAKE_COMMAND} -E make_directory ${bundle_charts_dir}
             COMMAND ${CMAKE_COMMAND} -E copy_if_different
                     $&lt;TARGET_FILE:chartsplugin&gt; ${bundle_charts_dir}
             COMMAND ${CMAKE_COMMAND} -E copy_if_different
                     ${chars_qmldir_file} ${bundle_charts_dir}
             VERBATIM
         )
     endif()
 endif()

 set(INSTALL_EXAMPLEDIR &quot;${INSTALL_EXAMPLEDIR}/Charts&quot;)
 install(TARGETS chartsplugin
     RUNTIME DESTINATION &quot;${INSTALL_EXAMPLEDIR}&quot;
     BUNDLE DESTINATION &quot;${INSTALL_EXAMPLEDIR}&quot;
     LIBRARY DESTINATION &quot;${INSTALL_EXAMPLEDIR}&quot;
 )
 install(FILES ${CMAKE_CURRENT_BINARY_DIR}/qmldir
     DESTINATION &quot;${INSTALL_EXAMPLEDIR}&quot;)
</pre>
<p>When building this example on Windows or Linux, the <code translate="no">Charts</code> directory will be located at the same level as the application that uses our new import module. This way, the QML engine will find our module as the default search path for QML imports includes the directory of the application executable. On macOS, the plugin binary is copied to <code translate="no">Contents/PlugIns</code> in the the application bundle. With qmake, this path is set in <code translate="no">chapter6-plugins/app.pro</code>:</p>
<pre class="cpp" translate="no">
 macos:!qtConfig(static) {
     charts.files = $$OUT_PWD/Charts
     charts.path = Contents/PlugIns
     QMAKE_BUNDLE_DATA += charts
 }
</pre>
<p>To account for this, we also need to add this location as a <a href="qtqml-syntax-imports.html#qml-import-path" translate="no">QML import path</a> in <code translate="no">main.cpp</code>:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="../qtquick/qquickview.html" translate="no">QQuickView</a></span> view;
 <span class="preprocessor">#ifdef Q_OS_MACOS</span>
     view<span class="operator">.</span>engine()<span class="operator">-</span><span class="operator">&gt;</span>addImportPath(app<span class="operator">.</span>applicationDirPath() <span class="operator">+</span> <span class="string">&quot;/../PlugIns&quot;</span>);
 <span class="preprocessor">#endif</span>
     ...
</pre>
<p>Defining custom import paths is useful also when there are multiple applications using the same QML imports.</p>
<p>The <code translate="no">.pro</code> file also contains additional magic to ensure that the <a href="qtqml-modules-qmldir.html" translate="no">module definition qmldir file</a> is always copied to the same location as the plugin binary.</p>
<p>The <code translate="no">qmldir</code> file declares the module name and the plugin that is made available by the module:</p>
<pre class="cpp" translate="no">
 module Charts
 linktarget chartsplugin
 optional plugin chartsplugin
 classname ChartsPlugin
 typeinfo chartsplugin<span class="operator">.</span>qmltypes
 depends <span class="type"><a href="../qtquick/qtquick-module.html" translate="no">QtQuick</a></span>
 prefer :<span class="operator">/</span>qt<span class="operator">/</span>qml<span class="operator">/</span>Charts<span class="operator">/</span>
</pre>
<p>Now we have a QML module that can be imported to any application, provided that the QML engine knows where to find it. The example contains an executable that loads <code translate="no">app.qml</code>, which uses the <code translate="no">import Charts 1.0</code> statement. Alternatively, you can load the QML file using the <a href="../qtdoc/qtquick-qml-runtime.html" translate="no">qml tool</a>, setting the import path to the current directory so that it finds the <code translate="no">qmldir</code> file:</p>
<pre class="cpp" translate="no">
 qml <span class="operator">-</span>I <span class="operator">.</span> app<span class="operator">.</span>qml
</pre>
<p>The module &quot;Charts&quot; will be loaded by the QML engine, and the types provided by that module will be available for use in any QML document which imports it.</p>
<h2 id="chapter-7-summary">Chapter 7: Summary</h2>
<p>In this tutorial, we've shown the basic steps for creating a QML extension:</p>
<ul>
<li>Define new QML types by subclassing <a href="../qtcore/qobject.html" translate="no">QObject</a> and registering them with <a href="qqmlengine.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlengine.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>()</li>
<li>Add callable methods using <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> or Qt slots, and connect to Qt signals with an <code translate="no">onSignal</code> syntax</li>
<li>Add property bindings by defining <a href="../qtcore/properties.html" translate="no">NOTIFY</a> signals</li>
<li>Define custom property types if the built-in types are not sufficient</li>
<li>Define list property types using <a href="qqmllistproperty.html" translate="no">QQmlListProperty</a></li>
<li>Create a plugin library by defining a Qt plugin and writing a <a href="qtqml-modules-qmldir.html" translate="no">qmldir</a> file</li>
</ul>
<p>The <a href="qtqml-cppintegration-overview.html" translate="no">QML and C++ Integration overview</a> documentation shows other useful features that can be added to QML extensions. For example, we could use <a href="qtqml-syntax-objectattributes.html#default-properties" translate="no">default properties</a> to allow slices to be added without using the <code translate="no">slices</code> property:</p>
<pre class="cpp plain" translate="no">
 PieChart {
     PieSlice { ... }
     PieSlice { ... }
     PieSlice { ... }
 }
</pre>
<p>Or randomly add and remove slices from time to time using <a href="qtqml-cppintegration-definetypes.html#property-value-sources" translate="no">property value sources</a>:</p>
<pre class="cpp plain" translate="no">
 PieChart {
     PieSliceRandomizer on slices {}
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>To continue learning about QML extensions and features follow the <a href="qtqml-tutorials-extending-qml-advanced-example.html" translate="no">Writing advanced QML Extensions with C++</a> tutorial.</p>
</div>
</div>
<!-- @@@qtqml-tutorials-extending-qml-example.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
