<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qtestcase.qdoc -->
  <meta name="description" content="The QTest namespace contains all the functions and declarations that are related to Qt Test.">
  <title>QTest Namespace | Qt Test 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qttest-index.html" translate="no">Qt Test</a></li>
<li>QTest Namespace</li>
<li id="buildversion"><a href="qttest-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#classes">Classes</a></li>
<li class="level1"><a href="#types">Types</a></li>
<li class="level1"><a href="#functions">Functions</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QTest Namespace</h1>
<!-- $$$QTest-brief -->
<p>The QTest namespace contains all the functions and declarations that are related to Qt Test. <a href="#details">More...</a></p>
<!-- @@@QTest -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QTest&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Test) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Test)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += testlib</td></tr>
</table></div>
<ul>
<li><a href="qtest-obsolete.html">Deprecated members</a></li>
</ul>
<h2 id="classes">Classes</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qtest-qtoucheventsequence.html" translate="no">QTouchEventSequence</a></b></td></tr>
</table></div>
<h2 id="types">Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#KeyAction-enum" translate="no">KeyAction</a></b> { Press, Release, Click, Shortcut }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#MouseAction-enum" translate="no">MouseAction</a></b> { MousePress, MouseRelease, MouseClick, MouseDClick, MouseMove }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QBenchmarkMetric-enum" translate="no">QBenchmarkMetric</a></b> { FramesPerSecond, BitsPerSecond, BytesPerSecond, WalltimeMilliseconds, WalltimeNanoseconds, &hellip;, EmulationFaults }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#TestFailMode-enum" translate="no">TestFailMode</a></b> { Abort, Continue }</td></tr>
</table></div>
<h2 id="functions">Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#addColumn" translate="no">addColumn</a></b>(const char *<i>name</i>, T *<i>dummy</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTestData &amp;</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#addRow" translate="no">addRow</a></b>(const char *<i>format</i>, ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#benchmarkMetricName" translate="no">benchmarkMetricName</a></b>(QTest::QBenchmarkMetric <i>metric</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#benchmarkMetricUnit" translate="no">benchmarkMetricUnit</a></b>(QTest::QBenchmarkMetric <i>metric</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointingDevice *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#createTouchDevice" translate="no">createTouchDevice</a></b>(QInputDevice::DeviceType <i>devType</i> = QInputDevice::DeviceType::TouchScreen, QInputDevice::Capabilities <i>caps</i> = QInputDevice::Capability::Position)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#currentAppName" translate="no">currentAppName</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#currentDataTag" translate="no">currentDataTag</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#currentTestFailed" translate="no">currentTestFailed</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#currentTestFunction" translate="no">currentTestFunction</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#currentTestResolved" translate="no">currentTestResolved</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#failOnWarning" translate="no">failOnWarning</a></b>(const QRegularExpression &amp;<i>messagePattern</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#failOnWarning-1" translate="no">failOnWarning</a></b>(const char *<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#ignoreMessage" translate="no">ignoreMessage</a></b>(QtMsgType <i>type</i>, const char *<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#ignoreMessage-1" translate="no">ignoreMessage</a></b>(QtMsgType <i>type</i>, const QRegularExpression &amp;<i>messagePattern</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyClick" translate="no">keyClick</a></b>(QWidget *<i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyClick-1" translate="no">keyClick</a></b>(QWindow *<i>window</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyClick-2" translate="no">keyClick</a></b>(QWindow *<i>window</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyClick-3" translate="no">keyClick</a></b>(QWidget *<i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyClicks" translate="no">keyClicks</a></b>(QWidget *<i>widget</i>, const QString &amp;<i>sequence</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyEvent" translate="no">keyEvent</a></b>(QTest::KeyAction <i>action</i>, QWidget *<i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyEvent-1" translate="no">keyEvent</a></b>(QTest::KeyAction <i>action</i>, QWindow *<i>window</i>, char <i>ascii</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyEvent-2" translate="no">keyEvent</a></b>(QTest::KeyAction <i>action</i>, QWindow *<i>window</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyEvent-3" translate="no">keyEvent</a></b>(QTest::KeyAction <i>action</i>, QWidget *<i>widget</i>, char <i>ascii</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyPress" translate="no">keyPress</a></b>(QWidget *<i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyPress-1" translate="no">keyPress</a></b>(QWindow *<i>window</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyPress-2" translate="no">keyPress</a></b>(QWindow *<i>window</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyPress-3" translate="no">keyPress</a></b>(QWidget *<i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyRelease" translate="no">keyRelease</a></b>(QWidget *<i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyRelease-1" translate="no">keyRelease</a></b>(QWindow *<i>window</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyRelease-2" translate="no">keyRelease</a></b>(QWindow *<i>window</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyRelease-3" translate="no">keyRelease</a></b>(QWidget *<i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keySequence" translate="no">keySequence</a></b>(QWindow *<i>window</i>, const QKeySequence &amp;<i>keySequence</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keySequence-1" translate="no">keySequence</a></b>(QWidget *<i>widget</i>, const QKeySequence &amp;<i>keySequence</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseClick" translate="no">mouseClick</a></b>(QWidget *<i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseClick-1" translate="no">mouseClick</a></b>(QWindow *<i>window</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>stateKey</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseDClick" translate="no">mouseDClick</a></b>(QWidget *<i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseDClick-1" translate="no">mouseDClick</a></b>(QWindow *<i>window</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>stateKey</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseMove" translate="no">mouseMove</a></b>(QWidget *<i>widget</i>, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseMove-1" translate="no">mouseMove</a></b>(QWindow *<i>window</i>, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mousePress" translate="no">mousePress</a></b>(QWidget *<i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mousePress-1" translate="no">mousePress</a></b>(QWindow *<i>window</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>stateKey</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseRelease" translate="no">mouseRelease</a></b>(QWidget *<i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseRelease-1" translate="no">mouseRelease</a></b>(QWindow *<i>window</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>stateKey</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTestData &amp;</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#newRow" translate="no">newRow</a></b>(const char *<i>dataTag</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qExec" translate="no">qExec</a></b>(QObject *<i>testObject</i>, int <i>argc</i> = 0, char **<i>argv</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qExec-1" translate="no">qExec</a></b>(QObject *<i>testObject</i>, const QStringList &amp;<i>arguments</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;QTemporaryDir&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qExtractTestData" translate="no">qExtractTestData</a></b>(const QString &amp;<i>dirName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qRegisterTestCase" translate="no">qRegisterTestCase</a></b>(const QString &amp;<i>name</i>, QTest::TestEntryFunction <i>entryFunction</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qSleep" translate="no">qSleep</a></b>(std::chrono::milliseconds <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qSleep-1" translate="no">qSleep</a></b>(int <i>ms</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWait" translate="no">qWait</a></b>(std::chrono::milliseconds <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWait-1" translate="no">qWait</a></b>(int <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWaitFor" translate="no">qWaitFor</a></b>(Functor <i>predicate</i>, QDeadlineTimer <i>deadline</i> = QDeadlineTimer(std::chrono::seconds{5}))</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWaitFor-1" translate="no">qWaitFor</a></b>(Functor <i>predicate</i>, int <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWaitForWindowActive" translate="no">qWaitForWindowActive</a></b>(QWindow *<i>window</i>, int <i>timeout</i> = 5000)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWaitForWindowActive-1" translate="no">qWaitForWindowActive</a></b>(QWidget *<i>widget</i>, int <i>timeout</i> = 5000)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWaitForWindowExposed" translate="no">qWaitForWindowExposed</a></b>(QWindow *<i>window</i>, int <i>timeout</i> = 5000)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWaitForWindowExposed-1" translate="no">qWaitForWindowExposed</a></b>(QWidget *<i>widget</i>, int <i>timeout</i> = 5000)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWaitForWindowFocused" translate="no">qWaitForWindowFocused</a></b>(QWindow *<i>window</i>, QDeadlineTimer <i>timeout</i> = std::chrono::seconds{5})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWaitForWindowFocused-1" translate="no">qWaitForWindowFocused</a></b>(QWidget *<i>widget</i>, QDeadlineTimer <i>timeout</i> = std::chrono::seconds{5})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#setBenchmarkResult" translate="no">setBenchmarkResult</a></b>(qreal <i>result</i>, QTest::QBenchmarkMetric <i>metric</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toHexRepresentation" translate="no">toHexRepresentation</a></b>(const char *<i>ba</i>, qsizetype <i>length</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString" translate="no">toString</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-1" translate="no">toString</a></b>(const std::pair&lt;T1, T2&gt; &amp;<i>pair</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-36" translate="no">toString</a></b>(const QKeySequence &amp;<i>ks</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-37" translate="no">toString</a></b>(QSizePolicy::Policy <i>p</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-38" translate="no">toString</a></b>(QSizePolicy::ControlTypes <i>cts</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-39" translate="no">toString</a></b>(QSizePolicy::ControlType <i>ct</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-40" translate="no">toString</a></b>(QSizePolicy <i>sp</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-2" translate="no">toString</a></b>(const std::tuple&lt;Types...&gt; &amp;<i>tuple</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-5" translate="no">toString</a></b>(const QStringView &amp;<i>string</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-6" translate="no">toString</a></b>(const QString &amp;<i>string</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-7" translate="no">toString</a></b>(const QLatin1StringView &amp;<i>string</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-8" translate="no">toString</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-10" translate="no">toString</a></b>(const QTime &amp;<i>time</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-11" translate="no">toString</a></b>(const QDate &amp;<i>date</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-12" translate="no">toString</a></b>(const QDateTime &amp;<i>dateTime</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-13" translate="no">toString</a></b>(const QCborError &amp;<i>c</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-14" translate="no">toString</a></b>(const QChar &amp;<i>character</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-16" translate="no">toString</a></b>(const QPoint &amp;<i>point</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-17" translate="no">toString</a></b>(const QSize &amp;<i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-18" translate="no">toString</a></b>(const QRect &amp;<i>rectangle</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-19" translate="no">toString</a></b>(const QPointF &amp;<i>point</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-20" translate="no">toString</a></b>(const QSizeF &amp;<i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-21" translate="no">toString</a></b>(const QRectF &amp;<i>rectangle</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-22" translate="no">toString</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-23" translate="no">toString</a></b>(const QUuid &amp;<i>uuid</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-24" translate="no">toString</a></b>(const QVariant &amp;<i>variant</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-30" translate="no">toString</a></b>(std::nullptr_t)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-33" translate="no">toString</a></b>(const QVector2D &amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-34" translate="no">toString</a></b>(const QVector3D &amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-35" translate="no">toString</a></b>(const QVector4D &amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTest::QTouchEventWidgetSequence </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#touchEvent" translate="no">touchEvent</a></b>(QWidget *<i>widget</i>, QPointingDevice *<i>device</i>, bool <i>autoCommit</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTest::QTouchEventSequence </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#touchEvent-1" translate="no">touchEvent</a></b>(QWindow *<i>window</i>, QPointingDevice *<i>device</i>, bool <i>autoCommit</i> = true)</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QBENCHMARK" translate="no">QBENCHMARK</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QBENCHMARK_ONCE" translate="no">QBENCHMARK_ONCE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a></b>(<i>actual</i>, <i>expected</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a></b>(<i>dataIndex</i>, <i>comment</i>, <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QFAIL" translate="no">QFAIL</a></b>(<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QFETCH" translate="no">QFETCH</a></b>(<i>type</i>, <i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QFETCH_GLOBAL" translate="no">QFETCH_GLOBAL</a></b>(<i>type</i>, <i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QFINDTESTDATA" translate="no">QFINDTESTDATA</a></b>(<i>filename</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QSKIP" translate="no">QSKIP</a></b>(<i>description</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTEST" translate="no">QTEST</a></b>(<i>actual</i>, <i>testElement</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTEST_APPLESS_MAIN" translate="no">QTEST_APPLESS_MAIN</a></b>(<i>TestClass</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTEST_GUILESS_MAIN" translate="no">QTEST_GUILESS_MAIN</a></b>(<i>TestClass</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTEST_MAIN" translate="no">QTEST_MAIN</a></b>(<i>TestClass</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE" translate="no">QTRY_COMPARE</a></b>(<i>actual</i>, <i>expected</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_EQ" translate="no">QTRY_COMPARE_EQ</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_EQ_WITH_TIMEOUT" translate="no">QTRY_COMPARE_EQ_WITH_TIMEOUT</a></b>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_GE" translate="no">QTRY_COMPARE_GE</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_GE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_GE_WITH_TIMEOUT</a></b>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_GT" translate="no">QTRY_COMPARE_GT</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_GT_WITH_TIMEOUT" translate="no">QTRY_COMPARE_GT_WITH_TIMEOUT</a></b>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_LE" translate="no">QTRY_COMPARE_LE</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_LE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_LE_WITH_TIMEOUT</a></b>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_LT" translate="no">QTRY_COMPARE_LT</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_LT_WITH_TIMEOUT" translate="no">QTRY_COMPARE_LT_WITH_TIMEOUT</a></b>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_NE" translate="no">QTRY_COMPARE_NE</a></b>(<i>computed</i>, <i>baseline</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_NE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_NE_WITH_TIMEOUT</a></b>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_COMPARE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_WITH_TIMEOUT</a></b>(<i>actual</i>, <i>expected</i>, <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_VERIFY2" translate="no">QTRY_VERIFY2</a></b>(<i>condition</i>, <i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_VERIFY" translate="no">QTRY_VERIFY</a></b>(<i>condition</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_VERIFY2_WITH_TIMEOUT" translate="no">QTRY_VERIFY2_WITH_TIMEOUT</a></b>(<i>condition</i>, <i>message</i>, <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT" translate="no">QTRY_VERIFY_WITH_TIMEOUT</a></b>(<i>condition</i>, <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QVERIFY2" translate="no">QVERIFY2</a></b>(<i>condition</i>, <i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QVERIFY" translate="no">QVERIFY</a></b>(<i>condition</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QVERIFY_THROWS_EXCEPTION" translate="no">QVERIFY_THROWS_EXCEPTION</a></b>(<i>exceptiontype</i>, ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QVERIFY_THROWS_NO_EXCEPTION" translate="no">QVERIFY_THROWS_NO_EXCEPTION</a></b>(...)</td></tr>
</table></div>
<!-- $$$QTest-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>See the <a href="qtest-overview.html" translate="no">Qt Test Overview</a> for information about how to write unit tests.</p>
</div>
<!-- @@@QTest -->
<div class="classes">
<h2>Classes</h2>
<h3> class <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a></h3><!-- $$$QTouchEventSequence-brief -->
<p>The QTouchEventSequence class is used to simulate a sequence of touch events. <a href="qtest-qtoucheventsequence.html#details">More...</a></p>
<!-- @@@QTouchEventSequence -->
</div>
<div class="types">
<h2>Type Documentation</h2>
<!-- $$$KeyAction$$$Press$$$Release$$$Click$$$Shortcut -->
<h3 class="fn" translate="no" id="KeyAction-enum">enum QTest::<span class="name">KeyAction</span></h3>
<p>This enum describes possible actions for key handling.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QTest::Press</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The key is pressed.</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::Release</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The key is released.</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::Click</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The key is clicked (pressed and released).</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::Shortcut</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">A shortcut is activated. This value has been added in Qt 5.6.</td></tr>
</table></div>
<!-- @@@KeyAction -->
<!-- $$$MouseAction$$$MousePress$$$MouseRelease$$$MouseClick$$$MouseDClick$$$MouseMove -->
<h3 class="fn" translate="no" id="MouseAction-enum">enum QTest::<span class="name">MouseAction</span></h3>
<p>This enum describes possible actions for mouse handling.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QTest::MousePress</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">A mouse button is pressed.</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::MouseRelease</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">A mouse button is released.</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::MouseClick</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">A mouse button is clicked (pressed and released).</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::MouseDClick</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">A mouse button is double clicked (pressed and released twice).</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::MouseMove</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The mouse pointer has moved.</td></tr>
</table></div>
<!-- @@@MouseAction -->
<!-- $$$QBenchmarkMetric$$$FramesPerSecond$$$BitsPerSecond$$$BytesPerSecond$$$WalltimeMilliseconds$$$CPUTicks$$$InstructionReads$$$Events$$$WalltimeNanoseconds$$$BytesAllocated$$$CPUMigrations$$$CPUCycles$$$BusCycles$$$StalledCycles$$$Instructions$$$BranchInstructions$$$BranchMisses$$$CacheReferences$$$CacheReads$$$CacheWrites$$$CachePrefetches$$$CacheMisses$$$CacheReadMisses$$$CacheWriteMisses$$$CachePrefetchMisses$$$ContextSwitches$$$PageFaults$$$MinorPageFaults$$$MajorPageFaults$$$AlignmentFaults$$$EmulationFaults$$$RefCPUCycles -->
<h3 class="fn" translate="no" id="QBenchmarkMetric-enum">enum QTest::<span class="name">QBenchmarkMetric</span></h3>
<p>This enum lists all the things that can be benchmarked.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QTest::FramesPerSecond</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Frames per second</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::BitsPerSecond</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Bits per second</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::BytesPerSecond</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Bytes per second</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::WalltimeMilliseconds</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Clock time in milliseconds</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::WalltimeNanoseconds</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">Clock time in nanoseconds</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::BytesAllocated</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">Memory usage in bytes</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::Events</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">Event count</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CPUTicks</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">CPU time</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CPUMigrations</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">Process migrations between CPUs</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CPUCycles</code></td><td class="topAlign tblval"><code translate="no">10</code></td><td class="topAlign">CPU cycles</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::RefCPUCycles</code></td><td class="topAlign tblval"><code translate="no">30</code></td><td class="topAlign">Reference CPU cycles</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::BusCycles</code></td><td class="topAlign tblval"><code translate="no">11</code></td><td class="topAlign">Bus cycles</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::StalledCycles</code></td><td class="topAlign tblval"><code translate="no">12</code></td><td class="topAlign">Cycles stalled</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::InstructionReads</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Instruction reads</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::Instructions</code></td><td class="topAlign tblval"><code translate="no">13</code></td><td class="topAlign">Instructions executed</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::BranchInstructions</code></td><td class="topAlign tblval"><code translate="no">14</code></td><td class="topAlign">Branch-type instructions</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::BranchMisses</code></td><td class="topAlign tblval"><code translate="no">15</code></td><td class="topAlign">Branch instructions that were mispredicted</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CacheReferences</code></td><td class="topAlign tblval"><code translate="no">16</code></td><td class="topAlign">Cache accesses of any type</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CacheMisses</code></td><td class="topAlign tblval"><code translate="no">20</code></td><td class="topAlign">Cache misses of any type</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CacheReads</code></td><td class="topAlign tblval"><code translate="no">17</code></td><td class="topAlign">Cache reads / loads</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CacheReadMisses</code></td><td class="topAlign tblval"><code translate="no">21</code></td><td class="topAlign">Cache read / load misses</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CacheWrites</code></td><td class="topAlign tblval"><code translate="no">18</code></td><td class="topAlign">Cache writes / stores</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CacheWriteMisses</code></td><td class="topAlign tblval"><code translate="no">22</code></td><td class="topAlign">Cache write / store misses</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CachePrefetches</code></td><td class="topAlign tblval"><code translate="no">19</code></td><td class="topAlign">Cache prefetches</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::CachePrefetchMisses</code></td><td class="topAlign tblval"><code translate="no">23</code></td><td class="topAlign">Cache prefetch misses</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::ContextSwitches</code></td><td class="topAlign tblval"><code translate="no">24</code></td><td class="topAlign">Context switches</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::PageFaults</code></td><td class="topAlign tblval"><code translate="no">25</code></td><td class="topAlign">Page faults of any type</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::MinorPageFaults</code></td><td class="topAlign tblval"><code translate="no">26</code></td><td class="topAlign">Minor page faults</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::MajorPageFaults</code></td><td class="topAlign tblval"><code translate="no">27</code></td><td class="topAlign">Major page faults</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::AlignmentFaults</code></td><td class="topAlign tblval"><code translate="no">28</code></td><td class="topAlign">Faults caused due to misalignment</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::EmulationFaults</code></td><td class="topAlign tblval"><code translate="no">29</code></td><td class="topAlign">Faults that needed software emulation</td></tr>
</table></div>
<p>Note that <code translate="no">WalltimeNanoseconds</code> and <code translate="no">BytesAllocated</code> are only provided for use via <a href="qtest.html#setBenchmarkResult" translate="no">setBenchmarkResult</a>(), and results in those metrics are not able to be provided automatically by the <a href="qtest.html" translate="no">QTest</a> framework.</p>
<p><b>See also </b><a href="qtest.html#benchmarkMetricName" translate="no">QTest::benchmarkMetricName</a>() and <a href="qtest.html#benchmarkMetricUnit" translate="no">QTest::benchmarkMetricUnit</a>().</p>
<!-- @@@QBenchmarkMetric -->
<!-- $$$TestFailMode$$$Abort$$$Continue -->
<h3 class="fn" translate="no" id="TestFailMode-enum">enum QTest::<span class="name">TestFailMode</span></h3>
<p>This enum describes the modes for handling a check, such as by <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>() or <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>() macros, that is known to fail. The mode applies regardless of whether the check fails or succeeds.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QTest::Abort</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Aborts the execution of the test. Use this mode when it doesn't make sense to execute the test any further after the problematic check.</td></tr>
<tr><td class="topAlign"><code translate="no">QTest::Continue</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Continues execution of the test after the problematic check.</td></tr>
</table></div>
<p><b>See also </b><a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>().</p>
<!-- @@@TestFailMode -->
</div>
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$addColumn[overload1]$$$addColumnconstchar*T* -->
<h3 class="fn" translate="no" id="addColumn">template &lt;typename T&gt; <span class="type">void</span> QTest::<span class="name">addColumn</span>(const <span class="type">char</span> *<i>name</i>, <span class="type">T</span> *<i>dummy</i> = 0)</h3>
<p>Adds a column with type <code translate="no">T</code> to the current test data. <i translate="no">name</i> is the name of the column. <i translate="no">dummy</i> is a workaround for buggy compilers and can be ignored.</p>
<p>To populate the column with values, <a href="qtest.html#newRow" translate="no">newRow</a>() can be used. Use <a href="qtest.html#QFETCH" translate="no">QFETCH</a>() to fetch the data in the actual test.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(<span class="string">&quot;intval&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span>(<span class="string">&quot;str&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span>(<span class="string">&quot;dbl&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;row1&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;hello&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1.5</span>;
</pre>
<p>To add custom types to the testdata, the type must be registered with <a href="../qtcore/qmetatype.html" translate="no">QMetaType</a> via <a href="../qtcore/qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This function can only be used called as part of a test's data function that is invoked by the test framework.</p>
</div>
<p>See <a href="qttestlib-tutorial2-example.html" translate="no">Data Driven Testing</a> for a more extensive example.</p>
<p><b>See also </b><a href="qtest.html#newRow" translate="no">QTest::newRow</a>(), <a href="qtest.html#QFETCH" translate="no">QFETCH</a>(), and <a href="../qtcore/qmetatype.html" translate="no">QMetaType</a>.</p>
<!-- @@@addColumn -->
<!-- $$$addRow[overload1]$$$addRowconstchar*... -->
<h3 class="fn" translate="no" id="addRow"><span class="type">QTestData</span> &amp;QTest::<span class="name">addRow</span>(const <span class="type">char</span> *<i>format</i>, ...)</h3>
<p>Appends a new row to the current test data.</p>
<p>The function's arguments are passed to <a href="../qtcore/qbytearray.html#qsnprintf" translate="no">qsnprintf</a>() for formatting according to <i translate="no">format</i>. See the <a href="../qtcore/qbytearray.html#qvsnprintf" translate="no">qvsnprintf</a>() documentation for caveats and limitations.</p>
<p>The test output will identify the test run with this test data using the name that results from this formatting.</p>
<p>Returns a QTestData reference that can be used to stream in data, one value for each column in the table.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(<span class="string">&quot;input&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span>(<span class="string">&quot;output&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>addRow(<span class="string">&quot;%d&quot;</span><span class="operator">,</span> <span class="number">0</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>(<span class="string">&quot;0&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>addRow(<span class="string">&quot;%d&quot;</span><span class="operator">,</span> <span class="number">1</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>(<span class="string">&quot;1&quot;</span>);
</pre>
<div class="admonition note">
<p><b>Note: </b>This function can only be called as part of a test's data function that is invoked by the test framework.</p>
</div>
<p>See <a href="qttestlib-tutorial2-example.html" translate="no">Data Driven Testing</a> for a more extensive example.</p>
<p><b>See also </b><a href="qtest.html#newRow" translate="no">newRow</a>(), <a href="qtest.html#addColumn" translate="no">addColumn</a>(), and <a href="qtest.html#QFETCH" translate="no">QFETCH</a>().</p>
<!-- @@@addRow -->
<!-- $$$benchmarkMetricName[overload1]$$$benchmarkMetricNameQTest::QBenchmarkMetric -->
<h3 class="fn" translate="no" id="benchmarkMetricName">const <span class="type">char</span> *QTest::<span class="name">benchmarkMetricName</span>(<span class="type"><a href="qtest.html#QBenchmarkMetric-enum" translate="no">QTest::QBenchmarkMetric</a></span> <i>metric</i>)</h3>
<p>Returns the enum value <i translate="no">metric</i> as a character string.</p>
<!-- @@@benchmarkMetricName -->
<!-- $$$benchmarkMetricUnit[overload1]$$$benchmarkMetricUnitQTest::QBenchmarkMetric -->
<h3 class="fn" translate="no" id="benchmarkMetricUnit">const <span class="type">char</span> *QTest::<span class="name">benchmarkMetricUnit</span>(<span class="type"><a href="qtest.html#QBenchmarkMetric-enum" translate="no">QTest::QBenchmarkMetric</a></span> <i>metric</i>)</h3>
<p>Returns the units of measure for the specified <i translate="no">metric</i>.</p>
<!-- @@@benchmarkMetricUnit -->
<!-- $$$createTouchDevice[overload1]$$$createTouchDeviceQInputDevice::DeviceTypeQInputDevice::Capabilities -->
<h3 class="fn" translate="no" id="createTouchDevice"><span class="type"><a href="../qtgui/qpointingdevice.html" translate="no">QPointingDevice</a></span> *QTest::<span class="name">createTouchDevice</span>(<span class="type"><a href="../qtgui/qinputdevice.html#DeviceType-enum" translate="no">QInputDevice::DeviceType</a></span> <i>devType</i> = QInputDevice::DeviceType::TouchScreen, <span class="type"><a href="../qtgui/qinputdevice.html#Capability-enum" translate="no">QInputDevice::Capabilities</a></span> <i>caps</i> = QInputDevice::Capability::Position)</h3>
<p>Creates a dummy touch device of type <i translate="no">devType</i> with capabilities <i translate="no">caps</i> for simulation of touch events.</p>
<p>The touch device will be registered with the Qt window system interface. You should typically use createTouchDevice() to initialize a <a href="../qtgui/qpointingdevice.html" translate="no">QPointingDevice</a> member variable in your test case class, use the same instance for all tests and delete it when no longer needed.</p>
<p><b>See also </b><a href="qtest-qtoucheventsequence.html" translate="no">QTest::QTouchEventSequence</a> and <a href="qtest.html#touchEvent" translate="no">touchEvent</a>().</p>
<!-- @@@createTouchDevice -->
<!-- $$$currentAppName[overload1]$$$currentAppName -->
<h3 class="fn" translate="no" id="currentAppName">const <span class="type">char</span> *QTest::<span class="name">currentAppName</span>()</h3>
<p>Returns the name of the binary that is currently executed.</p>
<!-- @@@currentAppName -->
<!-- $$$currentDataTag[overload1]$$$currentDataTag -->
<h3 class="fn" translate="no" id="currentDataTag">const <span class="type">char</span> *QTest::<span class="name">currentDataTag</span>()</h3>
<p>Returns the name of the current test data. If the test doesn't have any assigned testdata, the function returns <code translate="no">nullptr</code>.</p>
<!-- @@@currentDataTag -->
<!-- $$$currentTestFailed[overload1]$$$currentTestFailed -->
<h3 class="fn" translate="no" id="currentTestFailed"><span class="type">bool</span> QTest::<span class="name">currentTestFailed</span>()</h3>
<p>Returns <code translate="no">true</code> if the current test function has failed, otherwise false.</p>
<p><b>See also </b><a href="qtest.html#currentTestResolved" translate="no">QTest::currentTestResolved</a>().</p>
<!-- @@@currentTestFailed -->
<!-- $$$currentTestFunction[overload1]$$$currentTestFunction -->
<h3 class="fn" translate="no" id="currentTestFunction">const <span class="type">char</span> *QTest::<span class="name">currentTestFunction</span>()</h3>
<p>Returns the name of the test function that is currently executed.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> MyTestClass<span class="operator">::</span>cleanup()
 {
     <span class="keyword">if</span> (qstrcmp(<span class="type">QTest</span><span class="operator">::</span>currentTestFunction()<span class="operator">,</span> <span class="string">&quot;myDatabaseTest&quot;</span>) <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="comment">// clean up all database connections</span>
         closeAllDatabases();
     }
 }
</pre>
<!-- @@@currentTestFunction -->
<!-- $$$currentTestResolved[overload1]$$$currentTestResolved -->
<h3 class="fn" translate="no" id="currentTestResolved"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">bool</span> QTest::<span class="name">currentTestResolved</span>()</h3>
<p>Returns <code translate="no">true</code> if the current test function has failed or skipped.</p>
<p>This applies if the test has failed or exercised a skip. When it is true, the test function should return early. In particular, the <code translate="no">QTRY_*</code> macros and the test event loop terminate their loops early if executed during the test function (but not its cleanup()). After a test has called a helper function that uses this module's macros, it can use this function to test whether to return early.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qtest.html#currentTestFailed" translate="no">QTest::currentTestFailed</a>().</p>
<!-- @@@currentTestResolved -->
<!-- $$$failOnWarning[overload1]$$$failOnWarningconstQRegularExpression& -->
<h3 class="fn" translate="no" id="failOnWarning"><code class="details extra" translate="no">[since 6.3]</code> <span class="type">void</span> QTest::<span class="name">failOnWarning</span>(const <span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>messagePattern</i>)</h3>
<p>Appends a test failure to the test log for each warning that matches <i translate="no">messagePattern</i>.</p>
<p>The test function will continue execution when a failure is added. To abort the test instead, you can check <a href="qtest.html#currentTestFailed" translate="no">currentTestFailed</a>() and return early if it's <code translate="no">true</code>.</p>
<p>For each warning, the first pattern that matches will cause a failure, and the remaining patterns will be ignored.</p>
<p>All patterns are cleared at the end of each test function.</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> FileTest<span class="operator">::</span>loadFiles()
 {
     <span class="type">QTest</span><span class="operator">::</span>failOnWarning(<span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;^Failed to load&quot;</span>));

     <span class="comment">// Each of these will cause a test failure:</span>
     <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Failed to load image&quot;</span>;
     <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Failed to load video&quot;</span>;
 }
</pre>
<p>To fail every test that triggers a given warning, pass a suitable regular expression to this function in <a href="qtest-overview.html#creating-a-test" translate="no">init()</a>:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> FileTest<span class="operator">::</span>init()
 {
     <span class="type">QTest</span><span class="operator">::</span>failOnWarning(<span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;.?&quot;</span>));
 }
</pre>
<div class="admonition note">
<p><b>Note: </b><a href="qtest.html#ignoreMessage" translate="no">ignoreMessage</a>() takes precedence over this function, so any warnings that match a pattern given to both <code translate="no">ignoreMessage()</code> and <code translate="no">failOnWarning()</code> will be ignored.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qtest-overview.html#qt-test-environment-variables" translate="no">QTEST_FATAL_FAIL</a>.</p>
<!-- @@@failOnWarning -->
<!-- $$$failOnWarning$$$failOnWarningconstchar* -->
<h3 class="fn" translate="no" id="failOnWarning-1"><code class="details extra" translate="no">[since 6.3]</code> <span class="type">void</span> QTest::<span class="name">failOnWarning</span>(const <span class="type">char</span> *<i>message</i>)</h3>
<p>This function overloads failOnWarning().</p>
<p>Appends a test failure to the test log if the <i translate="no">message</i> is output.</p>
<p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qtest.html#failOnWarning" translate="no">failOnWarning</a>().</p>
<!-- @@@failOnWarning -->
<!-- $$$ignoreMessage[overload1]$$$ignoreMessageQtMsgTypeconstchar* -->
<h3 class="fn" translate="no" id="ignoreMessage"><span class="type">void</span> QTest::<span class="name">ignoreMessage</span>(<span class="type"><a href="../qtcore/qtlogging.html#QtMsgType-enum" translate="no">QtMsgType</a></span> <i>type</i>, const <span class="type">char</span> *<i>message</i>)</h3>
<p>Ignores messages created by <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>(), <a href="../qtcore/qtlogging.html#qInfo" translate="no">qInfo</a>() or <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>(). If the <i translate="no">message</i> with the corresponding <i translate="no">type</i> is outputted, it will be removed from the test log. If the test finished and the <i translate="no">message</i> was not outputted, a test failure is appended to the test log.</p>
<div class="admonition note">
<p><b>Note: </b>Invoking this function will only ignore one message. If the message you want to ignore is output twice, you have to call ignoreMessage() twice, too.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qdir.html" translate="no">QDir</a></span> dir;
 <span class="type">QTest</span><span class="operator">::</span>ignoreMessage(<span class="type"><a href="../qtcore/qtlogging.html#QtMsgType-enum" translate="no">QtWarningMsg</a></span><span class="operator">,</span> <span class="string">&quot;QDir::mkdir: Empty or null file name(s)&quot;</span>);
 dir<span class="operator">.</span>mkdir(<span class="string">&quot;&quot;</span>);
</pre>
<p>The example above tests that <a href="../qtcore/qdir.html#mkdir" translate="no">QDir::mkdir</a>() outputs the right warning when invoked with an invalid file name.</p>
<!-- @@@ignoreMessage -->
<!-- $$$ignoreMessage$$$ignoreMessageQtMsgTypeconstQRegularExpression& -->
<h3 class="fn" translate="no" id="ignoreMessage-1"><span class="type">void</span> QTest::<span class="name">ignoreMessage</span>(<span class="type"><a href="../qtcore/qtlogging.html#QtMsgType-enum" translate="no">QtMsgType</a></span> <i>type</i>, const <span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>messagePattern</i>)</h3>
<p>This is an overloaded function.</p>
<p>Ignores messages created by <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>(), <a href="../qtcore/qtlogging.html#qInfo" translate="no">qInfo</a>() or <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>(). If the message matching <i translate="no">messagePattern</i> with the corresponding <i translate="no">type</i> is outputted, it will be removed from the test log. If the test finished and the message was not outputted, a test failure is appended to the test log.</p>
<div class="admonition note">
<p><b>Note: </b>Invoking this function will only ignore one message. If the message you want to ignore is output twice, you have to call ignoreMessage() twice, too.</p>
</div>
<!-- @@@ignoreMessage -->
<!-- $$$keyClick[overload1]$$$keyClickQWidget*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyClick"><span class="type">void</span> QTest::<span class="name">keyClick</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qt.html#Key-enum" translate="no">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Simulates clicking of <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before clicking the key.</p>
<p>Examples:</p>
<pre class="cpp" translate="no">
 <span class="type">QTest</span><span class="operator">::</span>keyClick(myWidget<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>Key_Escape);

 <span class="type">QTest</span><span class="operator">::</span>keyClick(myWidget<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>Key_Escape<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>ShiftModifier<span class="operator">,</span> <span class="number">200</span>);
</pre>
<p>The first example above simulates clicking the <code translate="no">escape</code> key on <code translate="no">myWidget</code> without any keyboard modifiers and without delay. The second example simulates clicking <code translate="no">shift-escape</code> on <code translate="no">myWidget</code> following a 200 ms delay of the test.</p>
<p><b>See also </b><a href="qtest.html#keyClicks" translate="no">QTest::keyClicks</a>().</p>
<!-- @@@keyClick -->
<!-- $$$keyClick$$$keyClickQWindow*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyClick-1"><span class="type">void</span> QTest::<span class="name">keyClick</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qt.html#Key-enum" translate="no">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates clicking of <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">window</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before clicking the key.</p>
<p>Examples:</p>
<pre class="cpp" translate="no">
 <span class="type">QTest</span><span class="operator">::</span>keyClick(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>Key_Escape);
 <span class="type">QTest</span><span class="operator">::</span>keyClick(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>Key_Escape<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>ShiftModifier<span class="operator">,</span> <span class="number">200</span>);
</pre>
<p>The first example above simulates clicking the <code translate="no">escape</code> key on <code translate="no">myWindow</code> without any keyboard modifiers and without delay. The second example simulates clicking <code translate="no">shift-escape</code> on <code translate="no">myWindow</code> following a 200 ms delay of the test.</p>
<p><b>See also </b><a href="qtest.html#keyClicks" translate="no">QTest::keyClicks</a>().</p>
<!-- @@@keyClick -->
<!-- $$$keyClick$$$keyClickQWindow*charQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyClick-2"><span class="type">void</span> QTest::<span class="name">keyClick</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates clicking of <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">window</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before clicking the key.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> myWindow;
 <span class="type">QTest</span><span class="operator">::</span>keyClick(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>Key_Tab);
</pre>
<p>The example above simulates clicking <code translate="no">a</code> on <code translate="no">myWindow</code> without any keyboard modifiers and without delay of the test.</p>
<p><b>See also </b><a href="qtest.html#keyClicks" translate="no">QTest::keyClicks</a>().</p>
<!-- @@@keyClick -->
<!-- $$$keyClick$$$keyClickQWidget*charQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyClick-3"><span class="type">void</span> QTest::<span class="name">keyClick</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates clicking of <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before clicking the key.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">QTest</span><span class="operator">::</span>keyClick(myWidget<span class="operator">,</span> <span class="char">'a'</span>);
</pre>
<p>The example above simulates clicking <code translate="no">a</code> on <code translate="no">myWidget</code> without any keyboard modifiers and without delay of the test.</p>
<p><b>See also </b><a href="qtest.html#keyClicks" translate="no">QTest::keyClicks</a>().</p>
<!-- @@@keyClick -->
<!-- $$$keyClicks[overload1]$$$keyClicksQWidget*constQString&Qt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyClicks"><span class="type">void</span> QTest::<span class="name">keyClicks</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>sequence</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Simulates clicking a <i translate="no">sequence</i> of keys on a <i translate="no">widget</i>. Optionally, a keyboard <i translate="no">modifier</i> can be specified as well as a <i translate="no">delay</i> (in milliseconds) of the test before each key click.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">QTest</span><span class="operator">::</span>keyClicks(myWidget<span class="operator">,</span> <span class="string">&quot;hello world&quot;</span>);
</pre>
<p>The example above simulates clicking the sequence of keys representing &quot;hello world&quot; on <code translate="no">myWidget</code> without any keyboard modifiers and without delay of the test.</p>
<p><b>See also </b><a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>().</p>
<!-- @@@keyClicks -->
<!-- $$$keyEvent[overload1]$$$keyEventQTest::KeyActionQWidget*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyEvent"><span class="type">void</span> QTest::<span class="name">keyEvent</span>(<span class="type"><a href="qtest.html#KeyAction-enum" translate="no">QTest::KeyAction</a></span> <i>action</i>, <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qt.html#Key-enum" translate="no">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Sends a Qt key event to <i translate="no">widget</i> with the given <i translate="no">key</i> and an associated <i translate="no">action</i>. Optionally, a keyboard <i translate="no">modifier</i> can be specified, as well as a <i translate="no">delay</i> (in milliseconds) of the test before sending the event.</p>
<!-- @@@keyEvent -->
<!-- $$$keyEvent$$$keyEventQTest::KeyActionQWindow*charQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyEvent-1"><span class="type">void</span> QTest::<span class="name">keyEvent</span>(<span class="type"><a href="qtest.html#KeyAction-enum" translate="no">QTest::KeyAction</a></span> <i>action</i>, <span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type">char</span> <i>ascii</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Sends a Qt key event to <i translate="no">window</i> with the given key <i translate="no">ascii</i> and an associated <i translate="no">action</i>. Optionally, a keyboard <i translate="no">modifier</i> can be specified, as well as a <i translate="no">delay</i> (in milliseconds) of the test before sending the event.</p>
<!-- @@@keyEvent -->
<!-- $$$keyEvent$$$keyEventQTest::KeyActionQWindow*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyEvent-2"><span class="type">void</span> QTest::<span class="name">keyEvent</span>(<span class="type"><a href="qtest.html#KeyAction-enum" translate="no">QTest::KeyAction</a></span> <i>action</i>, <span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qt.html#Key-enum" translate="no">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Sends a Qt key event to <i translate="no">window</i> with the given <i translate="no">key</i> and an associated <i translate="no">action</i>. Optionally, a keyboard <i translate="no">modifier</i> can be specified, as well as a <i translate="no">delay</i> (in milliseconds) of the test before sending the event.</p>
<!-- @@@keyEvent -->
<!-- $$$keyEvent$$$keyEventQTest::KeyActionQWidget*charQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyEvent-3"><span class="type">void</span> QTest::<span class="name">keyEvent</span>(<span class="type"><a href="qtest.html#KeyAction-enum" translate="no">QTest::KeyAction</a></span> <i>action</i>, <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type">char</span> <i>ascii</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Sends a Qt key event to <i translate="no">widget</i> with the given key <i translate="no">ascii</i> and an associated <i translate="no">action</i>. Optionally, a keyboard <i translate="no">modifier</i> can be specified, as well as a <i translate="no">delay</i> (in milliseconds) of the test before sending the event.</p>
<!-- @@@keyEvent -->
<!-- $$$keyPress[overload1]$$$keyPressQWidget*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyPress"><span class="type">void</span> QTest::<span class="name">keyPress</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qt.html#Key-enum" translate="no">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Simulates pressing a <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before pressing the key.</p>
<div class="admonition note">
<p><b>Note: </b>At some point you should release the key using <a href="qtest.html#keyRelease" translate="no">keyRelease</a>().</p>
</div>
<p><b>See also </b><a href="qtest.html#keyRelease" translate="no">QTest::keyRelease</a>() and <a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>().</p>
<!-- @@@keyPress -->
<!-- $$$keyPress$$$keyPressQWindow*charQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyPress-1"><span class="type">void</span> QTest::<span class="name">keyPress</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates pressing a <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">window</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before pressing the key.</p>
<div class="admonition note">
<p><b>Note: </b>At some point you should release the key using <a href="qtest.html#keyRelease" translate="no">keyRelease</a>().</p>
</div>
<p><b>See also </b><a href="qtest.html#keyRelease" translate="no">QTest::keyRelease</a>() and <a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>().</p>
<!-- @@@keyPress -->
<!-- $$$keyPress$$$keyPressQWindow*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyPress-2"><span class="type">void</span> QTest::<span class="name">keyPress</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qt.html#Key-enum" translate="no">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates pressing a <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">window</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before pressing the key.</p>
<div class="admonition note">
<p><b>Note: </b>At some point you should release the key using <a href="qtest.html#keyRelease" translate="no">keyRelease</a>().</p>
</div>
<p><b>See also </b><a href="qtest.html#keyRelease" translate="no">QTest::keyRelease</a>() and <a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>().</p>
<!-- @@@keyPress -->
<!-- $$$keyPress$$$keyPressQWidget*charQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyPress-3"><span class="type">void</span> QTest::<span class="name">keyPress</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates pressing a <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before pressing the key.</p>
<div class="admonition note">
<p><b>Note: </b>At some point you should release the key using <a href="qtest.html#keyRelease" translate="no">keyRelease</a>().</p>
</div>
<p><b>See also </b><a href="qtest.html#keyRelease" translate="no">QTest::keyRelease</a>() and <a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>().</p>
<!-- @@@keyPress -->
<!-- $$$keyRelease[overload1]$$$keyReleaseQWidget*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyRelease"><span class="type">void</span> QTest::<span class="name">keyRelease</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qt.html#Key-enum" translate="no">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Simulates releasing a <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before releasing the key.</p>
<p><b>See also </b><a href="qtest.html#keyPress" translate="no">QTest::keyPress</a>() and <a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>().</p>
<!-- @@@keyRelease -->
<!-- $$$keyRelease$$$keyReleaseQWindow*charQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyRelease-1"><span class="type">void</span> QTest::<span class="name">keyRelease</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates releasing a <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">window</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before releasing the key.</p>
<p><b>See also </b><a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>().</p>
<!-- @@@keyRelease -->
<!-- $$$keyRelease$$$keyReleaseQWindow*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyRelease-2"><span class="type">void</span> QTest::<span class="name">keyRelease</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qt.html#Key-enum" translate="no">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates releasing a <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">window</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before releasing the key.</p>
<p><b>See also </b><a href="qtest.html#keyPress" translate="no">QTest::keyPress</a>() and <a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>().</p>
<!-- @@@keyRelease -->
<!-- $$$keyRelease$$$keyReleaseQWidget*charQt::KeyboardModifiersint -->
<h3 class="fn" translate="no" id="keyRelease-3"><span class="type">void</span> QTest::<span class="name">keyRelease</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates releasing a <i translate="no">key</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. If <i translate="no">delay</i> is larger than 0, the test will wait for <i translate="no">delay</i> milliseconds before releasing the key.</p>
<p><b>See also </b><a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>().</p>
<!-- @@@keyRelease -->
<!-- $$$keySequence[overload1]$$$keySequenceQWindow*constQKeySequence& -->
<h3 class="fn" translate="no" id="keySequence"><span class="type">void</span> QTest::<span class="name">keySequence</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, const <span class="type"><a href="../qtgui/qkeysequence.html" translate="no">QKeySequence</a></span> &amp;<i>keySequence</i>)</h3>
<p>This is an overloaded function.</p>
<p>Simulates typing of <i translate="no">keySequence</i> into a <i translate="no">window</i>.</p>
<p><b>See also </b><a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>() and <a href="qtest.html#keyClicks" translate="no">QTest::keyClicks</a>().</p>
<!-- @@@keySequence -->
<!-- $$$keySequence$$$keySequenceQWidget*constQKeySequence& -->
<h3 class="fn" translate="no" id="keySequence-1"><span class="type">void</span> QTest::<span class="name">keySequence</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, const <span class="type"><a href="../qtgui/qkeysequence.html" translate="no">QKeySequence</a></span> &amp;<i>keySequence</i>)</h3>
<p>This is an overloaded function.</p>
<p>Simulates typing of <i translate="no">keySequence</i> into a <i translate="no">widget</i>.</p>
<p><b>See also </b><a href="qtest.html#keyClick" translate="no">QTest::keyClick</a>() and <a href="qtest.html#keyClicks" translate="no">QTest::keyClicks</a>().</p>
<!-- @@@keySequence -->
<!-- $$$mouseClick[overload1]$$$mouseClickQWidget*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn" translate="no" id="mouseClick"><span class="type">void</span> QTest::<span class="name">mouseClick</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::KeyboardModifiers(), <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Simulates clicking a mouse <i translate="no">button</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. The position of the click is defined by <i translate="no">pos</i>; the default position is the center of the widget. If <i translate="no">delay</i> is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.</p>
<p><b>See also </b><a href="qtest.html#mousePress" translate="no">QTest::mousePress</a>() and <a href="qtest.html#mouseRelease" translate="no">QTest::mouseRelease</a>().</p>
<!-- @@@mouseClick -->
<!-- $$$mouseClick$$$mouseClickQWindow*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn" translate="no" id="mouseClick-1"><span class="type">void</span> QTest::<span class="name">mouseClick</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>stateKey</i> = Qt::KeyboardModifiers(), <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates clicking a mouse <i translate="no">button</i> with an optional <i translate="no">stateKey</i> modifier on a <i translate="no">window</i>. The position of the click is defined by <i translate="no">pos</i>; the default position is the center of the window. If <i translate="no">delay</i> is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.</p>
<p><b>See also </b><a href="qtest.html#mousePress" translate="no">QTest::mousePress</a>() and <a href="qtest.html#mouseRelease" translate="no">QTest::mouseRelease</a>().</p>
<!-- @@@mouseClick -->
<!-- $$$mouseDClick[overload1]$$$mouseDClickQWidget*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn" translate="no" id="mouseDClick"><span class="type">void</span> QTest::<span class="name">mouseDClick</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::KeyboardModifiers(), <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Simulates double clicking a mouse <i translate="no">button</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. The position of the click is defined by <i translate="no">pos</i>; the default position is the center of the widget. If <i translate="no">delay</i> is specified, the test will wait for the specified amount of milliseconds before each press and release.</p>
<p><b>See also </b><a href="qtest.html#mouseClick" translate="no">QTest::mouseClick</a>().</p>
<!-- @@@mouseDClick -->
<!-- $$$mouseDClick$$$mouseDClickQWindow*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn" translate="no" id="mouseDClick-1"><span class="type">void</span> QTest::<span class="name">mouseDClick</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>stateKey</i> = Qt::KeyboardModifiers(), <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates double clicking a mouse <i translate="no">button</i> with an optional <i translate="no">stateKey</i> modifier on a <i translate="no">window</i>. The position of the click is defined by <i translate="no">pos</i>; the default position is the center of the window. If <i translate="no">delay</i> is specified, the test will wait for the specified amount of milliseconds before each press and release.</p>
<p><b>See also </b><a href="qtest.html#mouseClick" translate="no">QTest::mouseClick</a>().</p>
<!-- @@@mouseDClick -->
<!-- $$$mouseMove[overload1]$$$mouseMoveQWidget*QPointint -->
<h3 class="fn" translate="no" id="mouseMove"><span class="type">void</span> QTest::<span class="name">mouseMove</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Moves the mouse pointer to a <i translate="no">widget</i>. If <i translate="no">pos</i> is not specified, the mouse pointer moves to the center of the widget. If a <i translate="no">delay</i> (in milliseconds) is given, the test will wait before moving the mouse pointer.</p>
<!-- @@@mouseMove -->
<!-- $$$mouseMove$$$mouseMoveQWindow*QPointint -->
<h3 class="fn" translate="no" id="mouseMove-1"><span class="type">void</span> QTest::<span class="name">mouseMove</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Moves the mouse pointer to a <i translate="no">window</i>. If <i translate="no">pos</i> is not specified, the mouse pointer moves to the center of the window. If a <i translate="no">delay</i> (in milliseconds) is given, the test will wait before moving the mouse pointer.</p>
<!-- @@@mouseMove -->
<!-- $$$mousePress[overload1]$$$mousePressQWidget*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn" translate="no" id="mousePress"><span class="type">void</span> QTest::<span class="name">mousePress</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::KeyboardModifiers(), <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Simulates pressing a mouse <i translate="no">button</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. The position is defined by <i translate="no">pos</i>; the default position is the center of the widget. If <i translate="no">delay</i> is specified, the test will wait for the specified amount of milliseconds before the press.</p>
<p><b>See also </b><a href="qtest.html#mouseRelease" translate="no">QTest::mouseRelease</a>() and <a href="qtest.html#mouseClick" translate="no">QTest::mouseClick</a>().</p>
<!-- @@@mousePress -->
<!-- $$$mousePress$$$mousePressQWindow*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn" translate="no" id="mousePress-1"><span class="type">void</span> QTest::<span class="name">mousePress</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>stateKey</i> = Qt::KeyboardModifiers(), <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates pressing a mouse <i translate="no">button</i> with an optional <i translate="no">stateKey</i> modifier on a <i translate="no">window</i>. The position is defined by <i translate="no">pos</i>; the default position is the center of the window. If <i translate="no">delay</i> is specified, the test will wait for the specified amount of milliseconds before the press.</p>
<p><b>See also </b><a href="qtest.html#mouseRelease" translate="no">QTest::mouseRelease</a>() and <a href="qtest.html#mouseClick" translate="no">QTest::mouseClick</a>().</p>
<!-- @@@mousePress -->
<!-- $$$mouseRelease[overload1]$$$mouseReleaseQWidget*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn" translate="no" id="mouseRelease"><span class="type">void</span> QTest::<span class="name">mouseRelease</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::KeyboardModifiers(), <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>Simulates releasing a mouse <i translate="no">button</i> with an optional <i translate="no">modifier</i> on a <i translate="no">widget</i>. The position of the release is defined by <i translate="no">pos</i>; the default position is the center of the widget. If <i translate="no">delay</i> is specified, the test will wait for the specified amount of milliseconds before releasing the button; otherwise, it will wait for a default amount of time (1 ms), which can be overridden via <a href="qtest-overview.html#testing-options" translate="no">command-line arguments</a>.</p>
<div class="admonition note">
<p><b>Note: </b>If you wish to test a double-click by sending events individually, specify a short delay, greater than the default, on both mouse release events. The total of the delays for the press, release, press and release must be less than <a href="../qtgui/qstylehints.html#mouseDoubleClickInterval-prop" translate="no">QStyleHints::mouseDoubleClickInterval</a>(). But if you don't need to check state between events, it's better to use <a href="qtest.html#mouseDClick" translate="no">QTest::mouseDClick</a>().</p>
</div>
<pre class="cpp" translate="no">
 <span class="type"><a href="qsignalspy.html" translate="no">QSignalSpy</a></span> doubleClickSpy(target<span class="operator">,</span> <span class="operator">&amp;</span>TargetClass<span class="operator">::</span>doubleClicked);
 <span class="keyword">const</span> <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> p(<span class="number">1</span><span class="operator">,</span> <span class="number">2</span>);
 <span class="type">QTest</span><span class="operator">::</span>mousePress(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>LeftButton<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>NoModifier<span class="operator">,</span> p);
 QVERIFY(target<span class="operator">.</span>isPressed());
 <span class="type">QTest</span><span class="operator">::</span>mouseRelease(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>LeftButton<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>NoModifier<span class="operator">,</span> p<span class="operator">,</span> <span class="number">10</span>);
 QCOMPARE(target<span class="operator">.</span>isPressed()<span class="operator">,</span> <span class="keyword">false</span>);
 <span class="type">QTest</span><span class="operator">::</span>mousePress(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>LeftButton<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>NoModifier<span class="operator">,</span> p<span class="operator">,</span> <span class="number">10</span>);
 QCOMPARE(target<span class="operator">.</span>pressCount()<span class="operator">,</span> <span class="number">2</span>);
 <span class="type">QTest</span><span class="operator">::</span>mouseRelease(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>LeftButton<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>NoModifier<span class="operator">,</span> p<span class="operator">,</span> <span class="number">10</span>);
 QCOMPARE(doubleClickSpy<span class="operator">.</span>count()<span class="operator">,</span> <span class="number">1</span>);
</pre>
<p><b>See also </b><a href="qtest.html#mousePress" translate="no">QTest::mousePress</a>() and <a href="qtest.html#mouseClick" translate="no">QTest::mouseClick</a>().</p>
<!-- @@@mouseRelease -->
<!-- $$$mouseRelease$$$mouseReleaseQWindow*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn" translate="no" id="mouseRelease-1"><span class="type">void</span> QTest::<span class="name">mouseRelease</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="../qtcore/qt.html#KeyboardModifier-enum" translate="no">Qt::KeyboardModifiers</a></span> <i>stateKey</i> = Qt::KeyboardModifiers(), <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Simulates releasing a mouse <i translate="no">button</i> with an optional <i translate="no">stateKey</i> modifier on a <i translate="no">window</i>. The position of the release is defined by <i translate="no">pos</i>; the default position is the center of the window. If <i translate="no">delay</i> is specified, the test will wait for the specified amount of milliseconds before releasing the button; otherwise, it will wait for a default amount of time (1 ms), which can be overridden via <a href="qtest-overview.html#testing-options" translate="no">command-line arguments</a>.</p>
<div class="admonition note">
<p><b>Note: </b>If you wish to test a double-click by sending events individually, specify a short delay, greater than the default, on both mouse release events. The total of the delays for the press, release, press and release must be less than <a href="../qtgui/qstylehints.html#mouseDoubleClickInterval-prop" translate="no">QStyleHints::mouseDoubleClickInterval</a>(). But if you don't need to check state between events, it's better to use <a href="qtest.html#mouseDClick" translate="no">QTest::mouseDClick</a>().</p>
</div>
<pre class="cpp" translate="no">
 <span class="type"><a href="qsignalspy.html" translate="no">QSignalSpy</a></span> doubleClickSpy(target<span class="operator">,</span> <span class="operator">&amp;</span>TargetClass<span class="operator">::</span>doubleClicked);
 <span class="keyword">const</span> <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> p(<span class="number">1</span><span class="operator">,</span> <span class="number">2</span>);
 <span class="type">QTest</span><span class="operator">::</span>mousePress(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>LeftButton<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>NoModifier<span class="operator">,</span> p);
 QVERIFY(target<span class="operator">.</span>isPressed());
 <span class="type">QTest</span><span class="operator">::</span>mouseRelease(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>LeftButton<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>NoModifier<span class="operator">,</span> p<span class="operator">,</span> <span class="number">10</span>);
 QCOMPARE(target<span class="operator">.</span>isPressed()<span class="operator">,</span> <span class="keyword">false</span>);
 <span class="type">QTest</span><span class="operator">::</span>mousePress(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>LeftButton<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>NoModifier<span class="operator">,</span> p<span class="operator">,</span> <span class="number">10</span>);
 QCOMPARE(target<span class="operator">.</span>pressCount()<span class="operator">,</span> <span class="number">2</span>);
 <span class="type">QTest</span><span class="operator">::</span>mouseRelease(<span class="operator">&amp;</span>myWindow<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>LeftButton<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>NoModifier<span class="operator">,</span> p<span class="operator">,</span> <span class="number">10</span>);
 QCOMPARE(doubleClickSpy<span class="operator">.</span>count()<span class="operator">,</span> <span class="number">1</span>);
</pre>
<p><b>See also </b><a href="qtest.html#mousePress" translate="no">QTest::mousePress</a>() and <a href="qtest.html#mouseClick" translate="no">QTest::mouseClick</a>().</p>
<!-- @@@mouseRelease -->
<!-- $$$newRow[overload1]$$$newRowconstchar* -->
<h3 class="fn" translate="no" id="newRow"><span class="type">QTestData</span> &amp;QTest::<span class="name">newRow</span>(const <span class="type">char</span> *<i>dataTag</i>)</h3>
<p>Appends a new row to the current test data.</p>
<p>The test output will identify the test run with this test data using the name <i translate="no">dataTag</i>.</p>
<p>Returns a QTestData reference that can be used to stream in data, one value for each column in the table.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> MyTestClass<span class="operator">::</span>addSingleStringRows()
 {
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span>(<span class="string">&quot;aString&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;just.hello&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>(<span class="string">&quot;hello&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;a.null.string&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>();
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>This function can only be called as part of a test's data function that is invoked by the test framework.</p>
</div>
<p>See <a href="qttestlib-tutorial2-example.html" translate="no">Data Driven Testing</a> for a more extensive example.</p>
<p><b>See also </b><a href="qtest.html#addRow" translate="no">addRow</a>(), <a href="qtest.html#addColumn" translate="no">addColumn</a>(), and <a href="qtest.html#QFETCH" translate="no">QFETCH</a>().</p>
<!-- @@@newRow -->
<!-- $$$qExec[overload1]$$$qExecQObject*intchar** -->
<h3 class="fn" translate="no" id="qExec"><span class="type">int</span> QTest::<span class="name">qExec</span>(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<i>testObject</i>, <span class="type">int</span> <i>argc</i> = 0, <span class="type">char</span> **<i>argv</i> = nullptr)</h3>
<p>Executes tests declared in <i translate="no">testObject</i>. In addition, the private slots <code translate="no">initTestCase()</code>, <code translate="no">cleanupTestCase()</code>, <code translate="no">init()</code> and <code translate="no">cleanup()</code> are executed if they exist. See <a href="qtest-overview.html#creating-a-test" translate="no">Creating a Test</a> for more details.</p>
<p>Optionally, the command line arguments <i translate="no">argc</i> and <i translate="no">argv</i> can be provided. For a list of recognized arguments, read <a href="qtest-overview.html#qt-test-command-line-arguments" translate="no">Qt Test Command Line Arguments</a>.</p>
<p>The following example will run all tests in <code translate="no">MyTestObject</code>:</p>
<pre class="cpp" translate="no">
 MyTestObject test1;
 <span class="type">QTest</span><span class="operator">::</span>qExec(<span class="operator">&amp;</span>test1);
</pre>
<p>This function returns 0 if no tests failed, or a value other than 0 if one or more tests failed or in case of unhandled exceptions. (Skipped tests do not influence the return value.)</p>
<p>For stand-alone test applications, the convenience macro <a href="qtest.html#QTEST_MAIN" translate="no">QTEST_MAIN</a>() can be used to declare a main() function that parses the command line arguments and executes the tests, avoiding the need to call this function explicitly.</p>
<p>The return value from this function is also the exit code of the test application when the <a href="qtest.html#QTEST_MAIN" translate="no">QTEST_MAIN</a>() macro is used.</p>
<p>For stand-alone test applications, this function should not be called more than once, as command-line options for logging test output to files and executing individual test functions will not behave correctly.</p>
<div class="admonition note">
<p><b>Note: </b>This function is not reentrant, only one test can run at a time. A test that was executed with qExec() can't run another test via qExec() and threads are not allowed to call qExec() simultaneously.</p>
</div>
<p>If you have programmatically created the arguments, as opposed to getting them from the arguments in <code translate="no">main()</code>, it is likely of interest to use QTest::qExec(<a href="../qtcore/qobject.html" translate="no">QObject</a> *, const <a href="../qtcore/qstringlist.html" translate="no">QStringList</a> &amp;) since it is Unicode safe.</p>
<p><b>See also </b><a href="qtest.html#QTEST_MAIN" translate="no">QTEST_MAIN</a>(), <a href="qtest.html#QTEST_GUILESS_MAIN" translate="no">QTEST_GUILESS_MAIN</a>(), and <a href="qtest.html#QTEST_APPLESS_MAIN" translate="no">QTEST_APPLESS_MAIN</a>().</p>
<!-- @@@qExec -->
<!-- $$$qExec$$$qExecQObject*constQStringList& -->
<h3 class="fn" translate="no" id="qExec-1"><span class="type">int</span> QTest::<span class="name">qExec</span>(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<i>testObject</i>, const <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> &amp;<i>arguments</i>)</h3>
<p>This is an overloaded function.</p>
<p>Behaves identically to qExec(<a href="../qtcore/qobject.html" translate="no">QObject</a> *, int, char**) but takes a <a href="../qtcore/qstringlist.html" translate="no">QStringList</a> of <i translate="no">arguments</i> instead of a <code translate="no">char**</code> list.</p>
<!-- @@@qExec -->
<!-- $$$qExtractTestData[overload1]$$$qExtractTestDataconstQString& -->
<h3 class="fn" translate="no" id="qExtractTestData"><span class="type"><a href="../qtcore/qsharedpointer.html" translate="no">QSharedPointer</a></span>&lt;<span class="type"><a href="../qtcore/qtemporarydir.html" translate="no">QTemporaryDir</a></span>&gt; QTest::<span class="name">qExtractTestData</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>dirName</i>)</h3>
<p>Extracts a directory from resources to disk. The content is extracted recursively to a temporary folder. The extracted content is removed automatically once the last reference to the return value goes out of scope.</p>
<p><i translate="no">dirName</i> is the name of the directory to extract from resources.</p>
<p>Returns the temporary directory where the data was extracted or null in case of errors.</p>
<!-- @@@qExtractTestData -->
<!-- $$$qRegisterTestCase[overload1]$$$qRegisterTestCaseconstQString&QTest::TestEntryFunction -->
<h3 class="fn" translate="no" id="qRegisterTestCase"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> QTest::<span class="name">qRegisterTestCase</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>name</i>, <span class="type">QTest::TestEntryFunction</span> <i>entryFunction</i>)</h3>
<p>Registers the test <i translate="no">name</i>, with entry function <i translate="no">entryFunction</i>, in a central test case registry for the current binary.</p>
<p>The <i translate="no">name</i> will be listed when running the batch test binary with no parameters. Running the test binary with the argv[1] of <i translate="no">name</i> will result in <i translate="no">entryFunction</i> being called.</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@qRegisterTestCase -->
<!-- $$$qSleep[overload1]$$$qSleepstd::chrono::milliseconds -->
<h3 class="fn" translate="no" id="qSleep"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">void</span> QTest::<span class="name">qSleep</span>(<span class="type">std::chrono::milliseconds</span> <i>msecs</i>)</h3>
<p>Sleeps for <i translate="no">msecs</i>, blocking execution of the test.</p>
<p>This method will not do any event processing and will leave your test unresponsive. Network communication might time out while sleeping. Use <a href="qtest.html#qWait" translate="no">QTest::qWait</a>() to do non-blocking sleeping.</p>
<p><i translate="no">msecs</i> must be greater than 0ms.</p>
<div class="admonition note">
<p><b>Note: </b>Starting from Qt 6.7, this function is implemented using <code translate="no">std::this_thread::sleep_for</code>, so the accuracy of time spent depends on the Standard Library implementation. Before Qt 6.7 this function called either <code translate="no">nanosleep()</code> on Unix or <code translate="no">Sleep()</code> on Windows, so the accuracy of time spent in this function depended on the operating system.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">using</span> <span class="keyword">namespace</span> std<span class="operator">::</span>chrono_literals;
 <span class="type">QTest</span><span class="operator">::</span>qSleep(<span class="number">250ms</span>);
</pre>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qtest.html#qWait" translate="no">QTest::qWait</a>().</p>
<!-- @@@qSleep -->
<!-- $$$qSleep$$$qSleepint -->
<h3 class="fn" translate="no" id="qSleep-1"><span class="type">void</span> QTest::<span class="name">qSleep</span>(<span class="type">int</span> <i>ms</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sleeps for <i translate="no">ms</i> milliseconds, blocking execution of the test.</p>
<p>Equivalent to calling:</p>
<pre class="cpp" translate="no">
 <span class="type">QTest</span><span class="operator">::</span><a href="qtest.html#qSleep" translate="no">qSleep</a>(std<span class="operator">::</span>chrono<span class="operator">::</span>milliseconds{ms});
</pre>
<!-- @@@qSleep -->
<!-- $$$qWait[overload1]$$$qWaitstd::chrono::milliseconds -->
<h3 class="fn" translate="no" id="qWait"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">void</span> QTest::<span class="name">qWait</span>(<span class="type">std::chrono::milliseconds</span> <i>msecs</i>)</h3>
<p>Waits for <i translate="no">msecs</i>. While waiting, events will be processed and your test will stay responsive to user interface events or network communication.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
     <span class="keyword">using</span> <span class="keyword">namespace</span> std<span class="operator">::</span>chrono_literals;
     <span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">while</span> (myNetworkServerNotResponding() <span class="operator">&amp;</span><span class="operator">&amp;</span> i<span class="operator">+</span><span class="operator">+</span> <span class="operator">&lt;</span> <span class="number">50</span>)
         <span class="type">QTest</span><span class="operator">::</span>qWait(<span class="number">250ms</span>);
</pre>
<p>The code above will wait until the network server is responding for a maximum of about 12.5 seconds.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qtest.html#qSleep" translate="no">QTest::qSleep</a>() and <a href="qsignalspy.html#wait" translate="no">QSignalSpy::wait</a>().</p>
<!-- @@@qWait -->
<!-- $$$qWait$$$qWaitint -->
<h3 class="fn" translate="no" id="qWait-1"><span class="type">void</span> QTest::<span class="name">qWait</span>(<span class="type">int</span> <i>msecs</i>)</h3>
<p>This is an overloaded function.</p>
<p>Waits for <i translate="no">msecs</i>. Equivalent to calling:</p>
<pre class="cpp" translate="no">
 <span class="type">QTest</span><span class="operator">::</span><a href="qtest.html#qWait" translate="no">qWait</a>(std<span class="operator">::</span>chrono<span class="operator">::</span>milliseconds{msecs});
</pre>
<!-- @@@qWait -->
<!-- $$$qWaitFor[overload1]$$$qWaitForFunctorQDeadlineTimer -->
<h3 class="fn" translate="no" id="qWaitFor"><code class="details extra" translate="no">[since 6.7]</code> template &lt;typename Functor&gt; <span class="type">bool</span> QTest::<span class="name">qWaitFor</span>(<span class="type">Functor</span> <i>predicate</i>, <span class="type"><a href="../qtcore/qdeadlinetimer.html" translate="no">QDeadlineTimer</a></span> <i>deadline</i> = QDeadlineTimer(std::chrono::seconds{5}))</h3>
<p>Waits until <i translate="no">deadline</i> has expired, or until <i translate="no">predicate</i> returns true, whichever happens first.</p>
<p>Returns <code translate="no">true</code> if <i translate="no">predicate</i> returned true at any point, otherwise returns <code translate="no">false</code>.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
     MyObject obj;
     obj<span class="operator">.</span>startup();
     <span class="keyword">using</span> <span class="keyword">namespace</span> std<span class="operator">::</span>chrono_literals;
     <span class="keyword">const</span> <span class="type">bool</span> result <span class="operator">=</span> <span class="type">QTest</span><span class="operator">::</span>qWaitFor(<span class="operator">[</span><span class="operator">&amp;</span>obj<span class="operator">]</span>() { <span class="keyword">return</span> obj<span class="operator">.</span>isReady(); }<span class="operator">,</span>
                                         <span class="type"><a href="../qtcore/qdeadlinetimer.html" translate="no">QDeadlineTimer</a></span>(<span class="number">3s</span>));
</pre>
<p>The code above will wait for the object to become ready, for a maximum of three seconds.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@qWaitFor -->
<!-- $$$qWaitFor$$$qWaitForFunctorint -->
<h3 class="fn" translate="no" id="qWaitFor-1">template &lt;typename Functor&gt; <span class="type">bool</span> QTest::<span class="name">qWaitFor</span>(<span class="type">Functor</span> <i>predicate</i>, <span class="type">int</span> <i>timeout</i>)</h3>
<p>This is an overloaded function.</p>
<p>Waits for <i translate="no">timeout</i> milliseconds or until the <i translate="no">predicate</i> returns true.</p>
<p>This is equivalent to calling:</p>
<pre class="cpp" translate="no">
 <a href="qtest.html#qWaitFor" translate="no">qWaitFor</a>(predicate<span class="operator">,</span> <span class="type"><a href="../qtcore/qdeadlinetimer.html" translate="no">QDeadlineTimer</a></span>(timeout));
</pre>
<!-- @@@qWaitFor -->
<!-- $$$qWaitForWindowActive[overload1]$$$qWaitForWindowActiveQWindow*int -->
<h3 class="fn" translate="no" id="qWaitForWindowActive"><span class="type">bool</span> QTest::<span class="name">qWaitForWindowActive</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type">int</span> <i>timeout</i> = 5000)</h3>
<p>Returns <code translate="no">true</code>, if <i translate="no">window</i> is active within <i translate="no">timeout</i> milliseconds. Otherwise returns <code translate="no">false</code>.</p>
<p>The method is useful in tests that call <a href="../qtgui/qwindow.html#show" translate="no">QWindow::show</a>() and rely on the window actually being active (i.e. being visible and having focus) before proceeding.</p>
<div class="admonition note">
<p><b>Note: </b>The method will time out and return <code translate="no">false</code> if another window prevents <i translate="no">window</i> from becoming active.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Since focus is an exclusive property, <i translate="no">window</i> may loose its focus to another window at any time - even after the method has returned <code translate="no">true</code>.</p>
</div>
<p><b>See also </b><a href="qtest.html#qWaitForWindowExposed" translate="no">qWaitForWindowExposed</a>(), <a href="qtest.html#qWaitForWindowFocused" translate="no">qWaitForWindowFocused</a>(), and <a href="../qtgui/qwindow.html#isActive" translate="no">QWindow::isActive</a>().</p>
<!-- @@@qWaitForWindowActive -->
<!-- $$$qWaitForWindowActive$$$qWaitForWindowActiveQWidget*int -->
<h3 class="fn" translate="no" id="qWaitForWindowActive-1"><span class="type">bool</span> QTest::<span class="name">qWaitForWindowActive</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type">int</span> <i>timeout</i> = 5000)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">widget</i> is active within <i translate="no">timeout</i> milliseconds. Otherwise returns <code translate="no">false</code>.</p>
<p>The method is useful in tests that call <a href="../qtwidgets/qwidget.html#show" translate="no">QWidget::show</a>() and rely on the widget actually being active (i.e. being visible and having focus) before proceeding.</p>
<div class="admonition note">
<p><b>Note: </b>The method will time out and return <code translate="no">false</code> if another window prevents <i translate="no">widget</i> from becoming active.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Since focus is an exclusive property, <i translate="no">widget</i> may loose its focus to another window at any time - even after the method has returned <code translate="no">true</code>.</p>
</div>
<p><b>See also </b><a href="qtest.html#qWaitForWindowExposed" translate="no">qWaitForWindowExposed</a>() and <a href="../qtwidgets/qwidget.html#isActiveWindow-prop" translate="no">QWidget::isActiveWindow</a>().</p>
<!-- @@@qWaitForWindowActive -->
<!-- $$$qWaitForWindowExposed[overload1]$$$qWaitForWindowExposedQWindow*int -->
<h3 class="fn" translate="no" id="qWaitForWindowExposed"><span class="type">bool</span> QTest::<span class="name">qWaitForWindowExposed</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type">int</span> <i>timeout</i> = 5000)</h3>
<p>Returns <code translate="no">true</code>, if <i translate="no">window</i> is exposed within <i translate="no">timeout</i> milliseconds. Otherwise returns <code translate="no">false</code>.</p>
<p>The method is useful in tests that call <a href="../qtgui/qwindow.html#show" translate="no">QWindow::show</a>() and rely on the window actually being being visible before proceeding.</p>
<div class="admonition note">
<p><b>Note: </b>A window mapped to screen may still not be considered exposed, if the window client area is not visible, e.g. because it is completely covered by other windows. In such cases, the method will time out and return <code translate="no">false</code>.</p>
</div>
<p><b>See also </b><a href="qtest.html#qWaitForWindowActive" translate="no">qWaitForWindowActive</a>() and <a href="../qtgui/qwindow.html#isExposed" translate="no">QWindow::isExposed</a>().</p>
<!-- @@@qWaitForWindowExposed -->
<!-- $$$qWaitForWindowExposed$$$qWaitForWindowExposedQWidget*int -->
<h3 class="fn" translate="no" id="qWaitForWindowExposed-1"><span class="type">bool</span> QTest::<span class="name">qWaitForWindowExposed</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type">int</span> <i>timeout</i> = 5000)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">widget</i> is exposed within <i translate="no">timeout</i> milliseconds. Otherwise returns <code translate="no">false</code>.</p>
<p>The method is useful in tests that call <a href="../qtwidgets/qwidget.html#show" translate="no">QWidget::show</a>() and rely on the widget actually being being visible before proceeding.</p>
<div class="admonition note">
<p><b>Note: </b>A window mapped to screen may still not be considered exposed, if the window client area is not visible, e.g. because it is completely covered by other windows. In such cases, the method will time out and return <code translate="no">false</code>.</p>
</div>
<p><b>See also </b><a href="qtest.html#qWaitForWindowActive" translate="no">qWaitForWindowActive</a>(), <a href="../qtwidgets/qwidget.html#visible-prop" translate="no">QWidget::isVisible</a>(), and <a href="../qtgui/qwindow.html#isExposed" translate="no">QWindow::isExposed</a>().</p>
<!-- @@@qWaitForWindowExposed -->
<!-- $$$qWaitForWindowFocused[overload1]$$$qWaitForWindowFocusedQWindow*QDeadlineTimer -->
<h3 class="fn" translate="no" id="qWaitForWindowFocused"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">bool</span> QTest::<span class="name">qWaitForWindowFocused</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtcore/qdeadlinetimer.html" translate="no">QDeadlineTimer</a></span> <i>timeout</i> = std::chrono::seconds{5})</h3>
<p>Returns <code translate="no">true</code>, if <i translate="no">window</i> is the focus window within <i translate="no">timeout</i>. Otherwise returns <code translate="no">false</code>.</p>
<p>The method is useful in tests that call <a href="../qtgui/qwindow.html#show" translate="no">QWindow::show</a>() and rely on the window having focus (for receiving keyboard events e.g.) before proceeding.</p>
<div class="admonition note">
<p><b>Note: </b>The method will time out and return <code translate="no">false</code> if another window prevents <i translate="no">window</i> from becoming focused.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Since focus is an exclusive property, <i translate="no">window</i> may loose its focus to another window at any time - even after the method has returned <code translate="no">true</code>.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qtest.html#qWaitForWindowExposed" translate="no">qWaitForWindowExposed</a>(), <a href="qtest.html#qWaitForWindowActive" translate="no">qWaitForWindowActive</a>(), and <a href="../qtgui/qguiapplication.html#focusWindow" translate="no">QGuiApplication::focusWindow</a>().</p>
<!-- @@@qWaitForWindowFocused -->
<!-- $$$qWaitForWindowFocused$$$qWaitForWindowFocusedQWidget*QDeadlineTimer -->
<h3 class="fn" translate="no" id="qWaitForWindowFocused-1"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">bool</span> QTest::<span class="name">qWaitForWindowFocused</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtcore/qdeadlinetimer.html" translate="no">QDeadlineTimer</a></span> <i>timeout</i> = std::chrono::seconds{5})</h3>
<p>Returns <code translate="no">true</code>, if <i translate="no">widget</i> is the focus window within <i translate="no">timeout</i>. Otherwise returns <code translate="no">false</code>.</p>
<p>The method is useful in tests that call <a href="../qtwidgets/qwidget.html#show" translate="no">QWidget::show</a>() and rely on the widget having focus (for receiving keyboard events e.g.) before proceeding.</p>
<div class="admonition note">
<p><b>Note: </b>The method will time out and return <code translate="no">false</code> if another window prevents <i translate="no">widget</i> from becoming focused.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Since focus is an exclusive property, <i translate="no">widget</i> may loose its focus to another window at any time - even after the method has returned <code translate="no">true</code>.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qtest.html#qWaitForWindowExposed" translate="no">qWaitForWindowExposed</a>(), <a href="qtest.html#qWaitForWindowActive" translate="no">qWaitForWindowActive</a>(), and <a href="../qtgui/qguiapplication.html#focusWindow" translate="no">QGuiApplication::focusWindow</a>().</p>
<!-- @@@qWaitForWindowFocused -->
<!-- $$$setBenchmarkResult[overload1]$$$setBenchmarkResultqrealQTest::QBenchmarkMetric -->
<h3 class="fn" translate="no" id="setBenchmarkResult"><span class="type">void</span> QTest::<span class="name">setBenchmarkResult</span>(<span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> <i>result</i>, <span class="type"><a href="qtest.html#QBenchmarkMetric-enum" translate="no">QTest::QBenchmarkMetric</a></span> <i>metric</i>)</h3>
<p>Sets the benchmark result for this test function to <i translate="no">result</i>.</p>
<p>Use this function if you want to report benchmark results without using the QBENCHMARK macro. Use <i translate="no">metric</i> to specify how Qt Test should interpret the results.</p>
<p>The context for the result will be the test function name and any data tag from the _data function. This function can only be called once in each test function, subsequent calls will replace the earlier reported results.</p>
<p>Note that the -iterations command line argument has no effect on test functions without the QBENCHMARK macro.</p>
<!-- @@@setBenchmarkResult -->
<!-- $$$toHexRepresentation[overload1]$$$toHexRepresentationconstchar*qsizetype -->
<h3 class="fn" translate="no" id="toHexRepresentation"><span class="type">char</span> *QTest::<span class="name">toHexRepresentation</span>(const <span class="type">char</span> *<i>ba</i>, <span class="type"><a href="../qtcore/qttypes.html#qsizetype-typedef" translate="no">qsizetype</a></span> <i>length</i>)</h3>
<p>Returns a pointer to a string that is the string <i translate="no">ba</i> represented as a space-separated sequence of hex characters. If the input is considered too long, it is truncated. A trucation is indicated in the returned string as an ellipsis at the end. The caller has ownership of the returned pointer and must ensure it is later passed to operator delete[].</p>
<p><i translate="no">length</i> is the length of the string <i translate="no">ba</i>.</p>
<!-- @@@toHexRepresentation -->
<!-- $$$toString[overload1]$$$toStringconstT& -->
<h3 class="fn" translate="no" id="toString">template &lt;typename T&gt; <span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Returns a textual representation of <i translate="no">value</i>. This function is used by <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>() to output verbose information in case of a test failure.</p>
<p>You can add specializations or overloads of this function to your test to enable verbose output.</p>
<div class="admonition note">
<p><b>Note: </b>Starting with Qt 5.5, you should prefer to provide a toString() function in the type's namespace instead of specializing this template. If your code needs to continue to work with the QTestLib from Qt 5.4 or earlier, you need to continue to use specialization.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The caller of toString() must delete the returned data using <code translate="no">delete[]</code>. Your implementation should return a string created with <code translate="no">new[]</code> or <a href="../qtcore/qbytearray.html#qstrdup" translate="no">qstrdup</a>(). The easiest way to do so is to create a <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a> or <a href="../qtcore/qstring.html" translate="no">QString</a> and call QTest::toString() on it (see second example below).</p>
</div>
<p>Example for specializing (Qt ≤ 5.4):</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> <span class="type">QTest</span> {
     <span class="keyword">template</span><span class="operator">&lt;</span><span class="operator">&gt;</span>
     <span class="type">char</span> <span class="operator">*</span>toString(<span class="keyword">const</span> MyPoint <span class="operator">&amp;</span>point)
     {
         <span class="keyword">const</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> ba(<span class="string">&quot;MyPoint(&quot;</span>
                             <span class="operator">+</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>number(point<span class="operator">.</span>x()) <span class="operator">+</span> <span class="string">&quot;, &quot;</span>
                             <span class="operator">+</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>number(point<span class="operator">.</span>y()) <span class="operator">+</span> <span class="char">')'</span>);
         <span class="keyword">return</span> qstrdup(ba<span class="operator">.</span>data());
     }
 }
</pre>
<p>The example above defines a toString() specialization for a class called <code translate="no">MyPoint</code>. Whenever a comparison of two instances of <code translate="no">MyPoint</code> fails, <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>() will call this function to output the contents of <code translate="no">MyPoint</code> to the test log.</p>
<p>Same example, but with overloading (Qt ≥ 5.5):</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> {
     <span class="type">char</span> <span class="operator">*</span>toString(<span class="keyword">const</span> MyPoint <span class="operator">&amp;</span>point)
     {
         <span class="keyword">return</span> <span class="type">QTest</span><span class="operator">::</span>toString(<span class="string">&quot;MyPoint(&quot;</span> <span class="operator">+</span>
                                <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>number(point<span class="operator">.</span>x()) <span class="operator">+</span> <span class="string">&quot;, &quot;</span> <span class="operator">+</span>
                                <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>number(point<span class="operator">.</span>y()) <span class="operator">+</span> <span class="char">')'</span>);
     }
 }
</pre>
<p><b>See also </b><a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>().</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconststd::pair<T1,T2>& -->
<h3 class="fn" translate="no" id="toString-1">template &lt;typename T1, typename T2&gt; <span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type">std::pair</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt; &amp;<i>pair</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the <i translate="no">pair</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQKeySequence& -->
<h3 class="fn" translate="no" id="toString-36"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtgui/qkeysequence.html" translate="no">QKeySequence</a></span> &amp;<i>ks</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the key sequence <i translate="no">ks</i>.</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringQSizePolicy::Policy -->
<h3 class="fn" translate="no" id="toString-37"><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type"><a href="../qtwidgets/qsizepolicy.html#Policy-enum" translate="no">QSizePolicy::Policy</a></span> <i>p</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of policy <i translate="no">p</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringQSizePolicy::ControlTypes -->
<h3 class="fn" translate="no" id="toString-38"><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type"><a href="../qtwidgets/qsizepolicy.html#ControlType-enum" translate="no">QSizePolicy::ControlTypes</a></span> <i>cts</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of control types <i translate="no">cts</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringQSizePolicy::ControlType -->
<h3 class="fn" translate="no" id="toString-39"><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type"><a href="../qtwidgets/qsizepolicy.html#ControlType-enum" translate="no">QSizePolicy::ControlType</a></span> <i>ct</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of control type <i translate="no">ct</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringQSizePolicy -->
<h3 class="fn" translate="no" id="toString-40"><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type"><a href="../qtwidgets/qsizepolicy.html" translate="no">QSizePolicy</a></span> <i>sp</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of size policy <i translate="no">sp</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconststd::tuple<Types...>& -->
<h3 class="fn" translate="no" id="toString-2">template &lt;typename... Types&gt; <span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type">std::tuple</span>&lt;<span class="type">Types</span>...&gt; &amp;<i>tuple</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">tuple</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQStringView& -->
<h3 class="fn" translate="no" id="toString-5"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qstringview.html" translate="no">QStringView</a></span> &amp;<i>string</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">string</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQString& -->
<h3 class="fn" translate="no" id="toString-6"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>string</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">string</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQLatin1StringView& -->
<h3 class="fn" translate="no" id="toString-7"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qlatin1stringview.html" translate="no">QLatin1StringView</a></span> &amp;<i>string</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">string</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQByteArray& -->
<h3 class="fn" translate="no" id="toString-8"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the byte array <i translate="no">ba</i>.</p>
<p><b>See also </b><a href="qtest.html#toHexRepresentation" translate="no">QTest::toHexRepresentation</a>().</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQTime& -->
<h3 class="fn" translate="no" id="toString-10"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qtime.html" translate="no">QTime</a></span> &amp;<i>time</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">time</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQDate& -->
<h3 class="fn" translate="no" id="toString-11"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qdate.html" translate="no">QDate</a></span> &amp;<i>date</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">date</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQDateTime& -->
<h3 class="fn" translate="no" id="toString-12"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qdatetime.html" translate="no">QDateTime</a></span> &amp;<i>dateTime</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the date and time specified by <i translate="no">dateTime</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQCborError& -->
<h3 class="fn" translate="no" id="toString-13"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qcborerror.html" translate="no">QCborError</a></span> &amp;<i>c</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given CBOR error <i translate="no">c</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQChar& -->
<h3 class="fn" translate="no" id="toString-14"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qchar.html" translate="no">QChar</a></span> &amp;<i>character</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">character</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQPoint& -->
<h3 class="fn" translate="no" id="toString-16"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qpoint.html" translate="no">QPoint</a></span> &amp;<i>point</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">point</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQSize& -->
<h3 class="fn" translate="no" id="toString-17"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>size</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">size</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQRect& -->
<h3 class="fn" translate="no" id="toString-18"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qrect.html" translate="no">QRect</a></span> &amp;<i>rectangle</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">rectangle</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQPointF& -->
<h3 class="fn" translate="no" id="toString-19"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> &amp;<i>point</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">point</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQSizeF& -->
<h3 class="fn" translate="no" id="toString-20"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qsizef.html" translate="no">QSizeF</a></span> &amp;<i>size</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">size</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQRectF& -->
<h3 class="fn" translate="no" id="toString-21"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> &amp;<i>rectangle</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">rectangle</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQUrl& -->
<h3 class="fn" translate="no" id="toString-22"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> &amp;<i>url</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">url</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQUuid& -->
<h3 class="fn" translate="no" id="toString-23"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/quuid.html" translate="no">QUuid</a></span> &amp;<i>uuid</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">uuid</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQVariant& -->
<h3 class="fn" translate="no" id="toString-24"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> &amp;<i>variant</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i translate="no">variant</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringstd::nullptr_t -->
<h3 class="fn" translate="no" id="toString-30"><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type">std::nullptr_t</span>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a string containing <code translate="no">nullptr</code>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQVector2D& -->
<h3 class="fn" translate="no" id="toString-33"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtgui/qvector2d.html" translate="no">QVector2D</a></span> &amp;<i>v</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the 2D vector <i translate="no">v</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQVector3D& -->
<h3 class="fn" translate="no" id="toString-34"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a></span> &amp;<i>v</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the 3D vector <i translate="no">v</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQVector4D& -->
<h3 class="fn" translate="no" id="toString-35"><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="../qtgui/qvector4d.html" translate="no">QVector4D</a></span> &amp;<i>v</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the 4D vector <i translate="no">v</i>.</p>
<!-- @@@toString -->
<!-- $$$touchEvent[overload1]$$$touchEventQWidget*QPointingDevice*bool -->
<h3 class="fn" translate="no" id="touchEvent"><span class="type">QTest::QTouchEventWidgetSequence</span> QTest::<span class="name">touchEvent</span>(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="../qtgui/qpointingdevice.html" translate="no">QPointingDevice</a></span> *<i>device</i>, <span class="type">bool</span> <i>autoCommit</i> = true)</h3>
<p>Creates and returns a <a href="qtest-qtoucheventsequence.html" translate="no">QTouchEventSequence</a> for the <i translate="no">device</i> to simulate events for <i translate="no">widget</i>.</p>
<p>When adding touch events to the sequence, <i translate="no">widget</i> will also be used to translate the position provided to screen coordinates, unless another widget is provided in the respective calls to press(), move() etc.</p>
<p>The touch events are committed to the event system when the destructor of the <a href="qtest-qtoucheventsequence.html" translate="no">QTouchEventSequence</a> is called (ie when the object returned runs out of scope), unless <i translate="no">autoCommit</i> is set to false. When <i translate="no">autoCommit</i> is false, commit() has to be called manually.</p>
<p><a href="qtest.html#createTouchDevice" translate="no">createTouchDevice</a>() can be called to create a test touch device for use with this function.</p>
<!-- @@@touchEvent -->
<!-- $$$touchEvent$$$touchEventQWindow*QPointingDevice*bool -->
<h3 class="fn" translate="no" id="touchEvent-1"><span class="type"><a href="qtest-qtoucheventsequence.html" translate="no">QTest::QTouchEventSequence</a></span> QTest::<span class="name">touchEvent</span>(<span class="type"><a href="../qtgui/qwindow.html" translate="no">QWindow</a></span> *<i>window</i>, <span class="type"><a href="../qtgui/qpointingdevice.html" translate="no">QPointingDevice</a></span> *<i>device</i>, <span class="type">bool</span> <i>autoCommit</i> = true)</h3>
<p>Creates and returns a <a href="qtest-qtoucheventsequence.html" translate="no">QTouchEventSequence</a> for the <i translate="no">device</i> to simulate events for <i translate="no">window</i>.</p>
<p>When adding touch events to the sequence, <i translate="no">window</i> will also be used to translate the position provided to screen coordinates, unless another window is provided in the respective calls to press(), move() etc.</p>
<p>The touch events are committed to the event system when the destructor of the <a href="qtest-qtoucheventsequence.html" translate="no">QTouchEventSequence</a> is called (ie when the object returned runs out of scope), unless <i translate="no">autoCommit</i> is set to false. When <i translate="no">autoCommit</i> is false, commit() has to be called manually.</p>
<p><a href="qtest.html#createTouchDevice" translate="no">createTouchDevice</a>() can be called to create a test touch device for use with this function.</p>
<!-- @@@touchEvent -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QBENCHMARK[overload1]$$$QBENCHMARK -->
<h3 class="fn" translate="no" id="QBENCHMARK"><span class="name">QBENCHMARK</span></h3>
<p>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> TestBenchmark<span class="operator">::</span>simple()
 {
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> str1 <span class="operator">=</span> u<span class="string">&quot;This is a test string&quot;</span>_s;
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> str2 <span class="operator">=</span> u<span class="string">&quot;This is a test string&quot;</span>_s;
     QCOMPARE(str1<span class="operator">.</span>localeAwareCompare(str2)<span class="operator">,</span> <span class="number">0</span>);
     QBENCHMARK {
         str1<span class="operator">.</span>localeAwareCompare(str2);
     }
 }
</pre>
<p><b>See also </b><a href="qtest-overview.html#creating-a-benchmark" translate="no">Creating a Benchmark</a> and <a href="qttestlib-tutorial5-example.html" translate="no">Writing a Benchmark</a>.</p>
<!-- @@@QBENCHMARK -->
<!-- $$$QBENCHMARK_ONCE[overload1]$$$QBENCHMARK_ONCE -->
<h3 class="fn" translate="no" id="QBENCHMARK_ONCE"><span class="name">QBENCHMARK_ONCE</span></h3>
<p>The QBENCHMARK_ONCE macro is for measuring performance of a code block by running it once.</p>
<p>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</p>
<p>Unlike QBENCHMARK, the contents of the contained code block is only run once. The elapsed time will be reported as &quot;0&quot; if it's too short to be measured by the selected backend.</p>
<p><b>See also </b><a href="qtest-overview.html#creating-a-benchmark" translate="no">Creating a Benchmark</a> and <a href="qttestlib-tutorial5-example.html" translate="no">Writing a Benchmark</a>.</p>
<!-- @@@QBENCHMARK_ONCE -->
<!-- $$$QCOMPARE[overload1]$$$QCOMPARE -->
<h3 class="fn" translate="no" id="QCOMPARE"><span class="name">QCOMPARE</span>(<i>actual</i>, <i>expected</i>)</h3>
<p>The QCOMPARE() macro compares an <i translate="no">actual</i> value to an <i translate="no">expected</i> value using the equality operator. If <i translate="no">actual</i> and <i translate="no">expected</i> match, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</p>
<p>Always respect QCOMPARE() parameter semantics. The first parameter passed to it should always be the actual value produced by the code-under-test, while the second parameter should always be the expected value. When the values don't match, QCOMPARE() prints them with the labels <i>Actual</i> and <i>Expected</i>. If the parameter order is swapped, debugging a failing test can be confusing and tests expecting zero may fail due to rounding errors.</p>
<p>QCOMPARE() tries to output the contents of the values if the comparison fails, so it is visible from the test log why the comparison failed.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 QCOMPARE(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>(<span class="string">&quot;hello&quot;</span>)<span class="operator">.</span>toUpper()<span class="operator">,</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>(<span class="string">&quot;HELLO&quot;</span>));
</pre>
<p>When comparing floating-point types (<code translate="no">float</code>, <code translate="no">double</code>, and <code translate="no">qfloat16</code>), <a href="../qtcore/qtnumeric.html#qFuzzyCompare" translate="no">qFuzzyCompare</a>() is used for finite values. If <a href="../qtcore/qtnumeric.html#qFuzzyIsNull" translate="no">qFuzzyIsNull</a>() is true for both values, they are also considered equal. Infinities match if they have the same sign, and any NaN as actual value matches with any NaN as expected value (even though NaN != NaN, even when they're identical).</p>
<p>When comparing <a href="../qtcore/qlist.html" translate="no">QList</a>, arrays and initializer lists of the value type can be passed as expected value:</p>
<pre class="cpp" translate="no">
     <span class="keyword">const</span> <span class="type">int</span> expected<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">8</span><span class="operator">,</span> <span class="number">10</span><span class="operator">,</span> <span class="number">12</span><span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> <span class="number">20</span><span class="operator">,</span> <span class="number">24</span>};
     QCOMPARE(<span class="type"><a href="../qtgui/qfontdatabase.html" translate="no">QFontDatabase</a></span><span class="operator">::</span>standardSizes()<span class="operator">,</span> expected);
</pre>
<p>Note that using initializer lists requires defining a helper macro to prevent the preprocessor from interpreting the commas as macro argument delimiters:</p>
<pre class="cpp" translate="no">
  <span class="preprocessor">#define ARG(...) __VA_ARGS__</span>
      QCOMPARE(<span class="type"><a href="../qtgui/qfontdatabase.html" translate="no">QFontDatabase</a></span><span class="operator">::</span>standardSizes()<span class="operator">,</span> ARG({<span class="number">8</span><span class="operator">,</span> <span class="number">10</span><span class="operator">,</span> <span class="number">12</span><span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> <span class="number">20</span><span class="operator">,</span> <span class="number">24</span>}));
  <span class="preprocessor">#undef ARG</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>For your own classes, you can overload <a href="qtest.html#toString" translate="no">QTest::toString</a>() to format values for output into the test log.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">char</span> <span class="operator">*</span>toString(<span class="keyword">const</span> MyType <span class="operator">&amp;</span>t)
 {
     <span class="type">char</span> <span class="operator">*</span>repr <span class="operator">=</span> <span class="keyword">new</span> <span class="type">char</span><span class="operator">[</span>t<span class="operator">.</span>reprSize()<span class="operator">]</span>;
     t<span class="operator">.</span>writeRepr(repr);
     <span class="keyword">return</span> repr;
 }
</pre>
<p>The return from <code translate="no">toString()</code> must be a <code translate="no">new char []</code>. That is, it shall be released with <code translate="no">delete[]</code> (rather than <code translate="no">free()</code> or plain <code translate="no">delete</code>) once the calling code is done with it.</p>
<p><b>See also </b><a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), <a href="qtest.html#QTRY_COMPARE" translate="no">QTRY_COMPARE</a>(), <a href="qtest.html#toString" translate="no">QTest::toString</a>(), <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>(), <a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>(), <a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>(), <a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>(), <a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>(), <a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>(), and <a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>().</p>
<!-- @@@QCOMPARE -->
<!-- $$$QCOMPARE_EQ[overload1]$$$QCOMPARE_EQ -->
<h3 class="fn" translate="no" id="QCOMPARE_EQ"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QCOMPARE_EQ</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>The QCOMPARE_EQ() macro checks that <i translate="no">computed</i> is equal to <i translate="no">baseline</i> using the equality operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</p>
<p>It is generally similar to calling <code translate="no">QVERIFY(computed == baseline);</code> but prints a formatted error message reporting <i translate="no">computed</i> and <i translate="no">baseline</i> argument expressions and values in case of failure.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>For your own classes, you can overload <a href="qtest.html#toString" translate="no">QTest::toString</a>() to format values for output into the test log.</p>
<div class="admonition note">
<p><b>Note: </b>Unlike <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), this macro does not provide overloads for custom types and pointers. So passing e.g. two <code translate="no">const char *</code> values as parameters will compare <i>pointers</i>, while <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>() does a comparison of C-style strings.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), <a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>(), <a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>(), <a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>(), <a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>(), and <a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>().</p>
<!-- @@@QCOMPARE_EQ -->
<!-- $$$QCOMPARE_GE[overload1]$$$QCOMPARE_GE -->
<h3 class="fn" translate="no" id="QCOMPARE_GE"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QCOMPARE_GE</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>The QCOMPARE_GE() macro checks that <i translate="no">computed</i> is at least <i translate="no">baseline</i> using the greater-than-or-equal-to operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</p>
<p>It is generally similar to calling <code translate="no">QVERIFY(computed &gt;= baseline);</code> but prints a formatted error message reporting <i translate="no">computed</i> and <i translate="no">baseline</i> argument expressions and values in case of failure.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>For your own classes, you can overload <a href="qtest.html#toString" translate="no">QTest::toString</a>() to format values for output into the test log.</p>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>(), <a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>(), <a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>(), <a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>(), and <a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>().</p>
<!-- @@@QCOMPARE_GE -->
<!-- $$$QCOMPARE_GT[overload1]$$$QCOMPARE_GT -->
<h3 class="fn" translate="no" id="QCOMPARE_GT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QCOMPARE_GT</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>The QCOMPARE_GT() macro checks that <i translate="no">computed</i> is greater than <i translate="no">baseline</i> using the greater-than operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</p>
<p>It is generally similar to calling <code translate="no">QVERIFY(computed &gt; baseline);</code> but prints a formatted error message reporting <i translate="no">computed</i> and <i translate="no">baseline</i> argument expressions and values in case of failure.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>For your own classes, you can overload <a href="qtest.html#toString" translate="no">QTest::toString</a>() to format values for output into the test log.</p>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>(), <a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>(), <a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>(), <a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>(), and <a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>().</p>
<!-- @@@QCOMPARE_GT -->
<!-- $$$QCOMPARE_LE[overload1]$$$QCOMPARE_LE -->
<h3 class="fn" translate="no" id="QCOMPARE_LE"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QCOMPARE_LE</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>The QCOMPARE_LE() macro checks that <i translate="no">computed</i> is at most <i translate="no">baseline</i> using the less-than-or-equal-to operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</p>
<p>It is generally similar to calling <code translate="no">QVERIFY(computed &lt;= baseline);</code> but prints a formatted error message reporting <i translate="no">computed</i> and <i translate="no">baseline</i> argument expressions and values in case of failure.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>For your own classes, you can overload <a href="qtest.html#toString" translate="no">QTest::toString</a>() to format values for output into the test log.</p>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>(), <a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>(), <a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>(), <a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>(), and <a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>().</p>
<!-- @@@QCOMPARE_LE -->
<!-- $$$QCOMPARE_LT[overload1]$$$QCOMPARE_LT -->
<h3 class="fn" translate="no" id="QCOMPARE_LT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QCOMPARE_LT</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>The QCOMPARE_LT() macro checks that <i translate="no">computed</i> is less than <i translate="no">baseline</i> using the less-than operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</p>
<p>It is generally similar to calling <code translate="no">QVERIFY(computed &lt; baseline);</code> but prints a formatted error message reporting <i translate="no">computed</i> and <i translate="no">baseline</i> argument expressions and values in case of failure.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>For your own classes, you can overload <a href="qtest.html#toString" translate="no">QTest::toString</a>() to format values for output into the test log.</p>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>(), <a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>(), <a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>(), <a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>(), and <a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>().</p>
<!-- @@@QCOMPARE_LT -->
<!-- $$$QCOMPARE_NE[overload1]$$$QCOMPARE_NE -->
<h3 class="fn" translate="no" id="QCOMPARE_NE"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QCOMPARE_NE</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>The QCOMPARE_NE() macro checks that <i translate="no">computed</i> is not equal to <i translate="no">baseline</i> using the inequality operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</p>
<p>It is generally similar to calling <code translate="no">QVERIFY(computed != baseline);</code> but prints a formatted error message reporting <i translate="no">computed</i> and <i translate="no">baseline</i> argument expressions and values in case of failure.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>For your own classes, you can overload <a href="qtest.html#toString" translate="no">QTest::toString</a>() to format values for output into the test log.</p>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>(), <a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>(), <a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>(), <a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>(), and <a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>().</p>
<!-- @@@QCOMPARE_NE -->
<!-- $$$QEXPECT_FAIL[overload1]$$$QEXPECT_FAIL -->
<h3 class="fn" translate="no" id="QEXPECT_FAIL"><span class="name">QEXPECT_FAIL</span>(<i>dataIndex</i>, <i>comment</i>, <i>mode</i>)</h3>
<p>The QEXPECT_FAIL() macro marks the next <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>() or <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>() as an expected failure. Instead of adding a failure to the test log, an expected failure will be reported.</p>
<p>If a <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>() or <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>() is marked as an expected failure, but passes instead, an unexpected pass (XPASS) is written to the test log and will be counted as a test failure.</p>
<p>The parameter <i translate="no">dataIndex</i> describes for which entry in the test data the failure is expected. Pass an empty string (<code translate="no">&quot;&quot;</code>) if the failure is expected for all entries or if no test data exists.</p>
<p><i translate="no">comment</i> will be appended to the test log for the expected failure.</p>
<p><i translate="no">mode</i> is a <a href="qtest.html#TestFailMode-enum" translate="no">QTest::TestFailMode</a> and sets whether the test should continue to execute or not. The <i translate="no">mode</i> is applied regardless of whether the expected test failure occurs.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>Example 1:</p>
<pre class="cpp" translate="no">
 QEXPECT_FAIL(<span class="string">&quot;&quot;</span><span class="operator">,</span> <span class="string">&quot;Will fix in the next release&quot;</span><span class="operator">,</span> Continue);
 QCOMPARE(i<span class="operator">,</span> <span class="number">42</span>);
 QCOMPARE(j<span class="operator">,</span> <span class="number">43</span>);
</pre>
<p>In the example above, an expected fail will be written into the test output if the variable <code translate="no">i</code> is not 42. If the variable <code translate="no">i</code> is 42, an unexpected pass is written instead. The QEXPECT_FAIL() has no influence on the second <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>() statement in the example.</p>
<p>Example 2:</p>
<pre class="cpp" translate="no">
 QEXPECT_FAIL(<span class="string">&quot;data27&quot;</span><span class="operator">,</span> <span class="string">&quot;Oh my, this is soooo broken&quot;</span><span class="operator">,</span> Abort);
 QCOMPARE(i<span class="operator">,</span> <span class="number">42</span>);
</pre>
<p>The above testfunction will not continue executing for the test data entry <code translate="no">data27</code> (regardless of the value of <code translate="no">i</code>).</p>
<p><b>See also </b><a href="qtest.html#TestFailMode-enum" translate="no">QTest::TestFailMode</a>, <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), and <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>().</p>
<!-- @@@QEXPECT_FAIL -->
<!-- $$$QFAIL[overload1]$$$QFAIL -->
<h3 class="fn" translate="no" id="QFAIL"><span class="name">QFAIL</span>(<i>message</i>)</h3>
<p>This macro can be used to force a test failure. The test stops executing and the failure <i translate="no">message</i> is appended to the test log.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">int</span>) <span class="operator">!</span><span class="operator">=</span> <span class="number">4</span>)
     QFAIL(<span class="string">&quot;This test has not been ported to this platform yet.&quot;</span>);
</pre>
<!-- @@@QFAIL -->
<!-- $$$QFETCH[overload1]$$$QFETCH -->
<h3 class="fn" translate="no" id="QFETCH"><span class="name">QFETCH</span>(<i>type</i>, <i>name</i>)</h3>
<p>The fetch macro creates a local variable named <i translate="no">name</i> with the type <i translate="no">type</i> on the stack. The <i translate="no">name</i> and <i translate="no">type</i> must match a column from the test's data table. This is asserted and the test will abort if the assertion fails.</p>
<p>Assuming a test has the following data:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> TestQString<span class="operator">::</span>toInt_data()
 {
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span>(<span class="string">&quot;aString&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(<span class="string">&quot;expected&quot;</span>);

     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;positive+value&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;42&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">42</span>;
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;negative-value&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;-42&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="operator">-</span><span class="number">42</span>;
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;zero&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;0&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">0</span>;
 }
</pre>
<p>The test data has two elements, a <a href="../qtcore/qstring.html" translate="no">QString</a> called <code translate="no">aString</code> and an integer called <code translate="no">expected</code>. To fetch these values in the actual test:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> TestQString<span class="operator">::</span>toInt()
 {
      QFETCH(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">,</span> aString);
      QFETCH(<span class="type">int</span><span class="operator">,</span> expected);

      QCOMPARE(aString<span class="operator">.</span>toInt()<span class="operator">,</span> expected);
 }
</pre>
<p><code translate="no">aString</code> and <code translate="no">expected</code> are variables on the stack that are initialized with the current test data.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework. The test function must have a _data function.</p>
</div>
<!-- @@@QFETCH -->
<!-- $$$QFETCH_GLOBAL[overload1]$$$QFETCH_GLOBAL -->
<h3 class="fn" translate="no" id="QFETCH_GLOBAL"><span class="name">QFETCH_GLOBAL</span>(<i>type</i>, <i>name</i>)</h3>
<p>This macro fetches a variable named <i translate="no">name</i> with the type <i translate="no">type</i> from a row in the global data table. The <i translate="no">name</i> and <i translate="no">type</i> must match a column in the global data table. This is asserted and the test will abort if the assertion fails.</p>
<p>Assuming a test has the following data:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> TestQLocale<span class="operator">::</span>initTestCase_data()
 {
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type"><a href="../qtcore/qlocale.html" translate="no">QLocale</a></span><span class="operator">&gt;</span>(<span class="string">&quot;locale&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;C&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qlocale.html" translate="no">QLocale</a></span><span class="operator">::</span>c();
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;UKish&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qlocale.html" translate="no">QLocale</a></span>(<span class="string">&quot;en_GB&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;USAish&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qlocale.html" translate="no">QLocale</a></span>(<span class="type"><a href="../qtcore/qlocale.html" translate="no">QLocale</a></span><span class="operator">::</span>English<span class="operator">,</span> <span class="type"><a href="../qtcore/qlocale.html" translate="no">QLocale</a></span><span class="operator">::</span>UnitedStates);
 }

 <span class="type">void</span> TestQLocale<span class="operator">::</span>roundTripInt_data()
 {
     <span class="type">QTest</span><span class="operator">::</span>addColumn<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(<span class="string">&quot;number&quot;</span>);
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;zero&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">0</span>;
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;one&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1</span>;
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;two&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">2</span>;
     <span class="type">QTest</span><span class="operator">::</span>newRow(<span class="string">&quot;ten&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">10</span>;
 }
</pre>
<p>The test's own data is a single number per row. In this case, <code translate="no">initTestCase_data()</code> also supplies a locale per row. Therefore, this test will be run with every combination of locale from the latter and number from the former. Thus, with four rows in the global table and three in the local, the test function is run for 12 distinct test-cases (4 * 3 = 12).</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> TestQLocale<span class="operator">::</span>roundTripInt()
 {
     QFETCH_GLOBAL(<span class="type"><a href="../qtcore/qlocale.html" translate="no">QLocale</a></span><span class="operator">,</span> locale);
     QFETCH(<span class="type">int</span><span class="operator">,</span> number);
     <span class="type">bool</span> ok;
     QCOMPARE(locale<span class="operator">.</span>toInt(locale<span class="operator">.</span>toString(number)<span class="operator">,</span> <span class="operator">&amp;</span>ok)<span class="operator">,</span> number);
     QVERIFY(ok);
 }
</pre>
<p>The locale is read from the global data table using QFETCH_GLOBAL(), and the number is read from the local data table using <a href="qtest.html#QFETCH" translate="no">QFETCH</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in test methods of a class with an <code translate="no">initTestCase_data()</code> method.</p>
</div>
<!-- @@@QFETCH_GLOBAL -->
<!-- $$$QFINDTESTDATA[overload1]$$$QFINDTESTDATA -->
<h3 class="fn" translate="no" id="QFINDTESTDATA"><span class="name">QFINDTESTDATA</span>(<i>filename</i>)</h3>
<p>Returns a <a href="../qtcore/qstring.html" translate="no">QString</a> for the testdata file referred to by <i translate="no">filename</i>, or an empty <a href="../qtcore/qstring.html" translate="no">QString</a> if the testdata file could not be found.</p>
<p>This macro allows the test to load data from an external file without hardcoding an absolute filename into the test, or using relative paths which may be error prone.</p>
<p>The returned path will be the first path from the following list which resolves to an existing file or directory:</p>
<ul>
<li><i translate="no">filename</i> relative to <a href="../qtcore/qcoreapplication.html#applicationDirPath" translate="no">QCoreApplication::applicationDirPath</a>() (only if a <a href="../qtcore/qcoreapplication.html" translate="no">QCoreApplication</a> or <a href="../qtwidgets/qapplication.html" translate="no">QApplication</a> object has been created).</li>
<li><i translate="no">filename</i> relative to the test's standard install directory (<a href="../qtcore/qlibraryinfo.html#LibraryPath-enum" translate="no">QLibraryInfo::TestsPath</a> with the lowercased testcase name appended).</li>
<li><i translate="no">filename</i> relative to the directory containing the source file from which QFINDTESTDATA is invoked.</li>
</ul>
<p>If the named file/directory does not exist at any of these locations, a warning is printed to the test log.</p>
<p>For example, in this code:</p>
<pre class="cpp" translate="no">
 <span class="type">bool</span> tst_MyXmlParser<span class="operator">::</span>parse()
 {
     MyXmlParser parser;
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> input <span class="operator">=</span> QFINDTESTDATA(<span class="string">&quot;testxml/simple1.xml&quot;</span>);
     QVERIFY(parser<span class="operator">.</span>parse(input));
 }
</pre>
<p>The testdata file will be resolved as the first existing file from:</p>
<ul>
<li><code translate="no">/home/user/build/myxmlparser/tests/tst_myxmlparser/testxml/simple1.xml</code></li>
<li><code translate="no">/usr/local/Qt-5.0.0/tests/tst_myxmlparser/testxml/simple1.xml</code></li>
<li><code translate="no">/home/user/sources/myxmlparser/tests/tst_myxmlparser/testxml/simple1.xml</code></li>
</ul>
<p>This allows the test to find its testdata regardless of whether the test has been installed, and regardless of whether the test's build tree is equal to the test's source tree.</p>
<div class="admonition note">
<p><b>Note: </b>reliable detection of testdata from the source directory requires either that qmake is used, or the <code translate="no">QT_TESTCASE_BUILDDIR</code> macro is defined to point to the working directory from which the compiler is invoked, or only absolute paths to the source files are passed to the compiler. Otherwise, the absolute path of the source directory cannot be determined.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The <code translate="no">QT_TESTCASE_BUILDDIR</code> macro is also implicitly defined if CMake is used and the <a href="qttest-module.html" translate="no">QtTest</a> module is linked to the target. You can change the default <code translate="no">QT_TESTCASE_BUILDDIR</code> by setting the QT_TESTCASE_BUILDDIR property on the target.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>For tests that use the <a href="qtest.html#QTEST_APPLESS_MAIN" translate="no">QTEST_APPLESS_MAIN</a>() macro to generate a <code translate="no">main()</code> function, <code translate="no">QFINDTESTDATA</code> will not attempt to find test data relative to <a href="../qtcore/qcoreapplication.html#applicationDirPath" translate="no">QCoreApplication::applicationDirPath</a>(). In practice, this means that tests using <code translate="no">QTEST_APPLESS_MAIN()</code> will fail to find their test data if run from a shadow build tree.</p>
</div>
<!-- @@@QFINDTESTDATA -->
<!-- $$$QSKIP[overload1]$$$QSKIP -->
<h3 class="fn" translate="no" id="QSKIP"><span class="name">QSKIP</span>(<i>description</i>)</h3>
<p>If called from a test function, the QSKIP() macro stops execution of the test without adding a failure to the test log. You can use it to skip tests that wouldn't make sense in the current configuration. For example, a test of font rendering may call QSKIP() if the needed fonts are not installed on the test system.</p>
<p>The text <i translate="no">description</i> is appended to the test log and should contain an explanation of why the test couldn't be executed.</p>
<p>If the test is data-driven, each call to QSKIP() in the test function will skip only the current row of test data, so an unconditional call to QSKIP() will produce one skip message in the test log for each row of test data.</p>
<p>If called from an <code translate="no">_data</code> function, the QSKIP() macro will stop execution of the <code translate="no">_data</code> function and will prevent execution of the associated test function. This entirely omits a data-driven test. To omit individual rows, make them conditional by using a simple <code translate="no">if (condition) newRow(...) &lt;&lt; ...</code> in the <code translate="no">_data</code> function, instead of using QSKIP() in the test function.</p>
<p>If called from <code translate="no">initTestCase_data()</code>, the QSKIP() macro will skip all test and <code translate="no">_data</code> functions. If called from <code translate="no">initTestCase()</code> when there is no <code translate="no">initTestCase_data()</code>, or when it only sets up one row, QSKIP() will likewise skip the whole test. However, if <code translate="no">initTestCase_data()</code> contains more than one row, then <code translate="no">initTestCase()</code> is called (followed by each test and finally the wrap-up) once per row of it. Therefore, a call to QSKIP() in <code translate="no">initTestCase()</code> will merely skip all test functions for the current row of global data, set up by <code translate="no">initTestCase_data()</code>.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function or <code translate="no">_data</code> function that is invoked by the test framework.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (<span class="operator">!</span><span class="type">QSqlDatabase</span><span class="operator">::</span>drivers()<span class="operator">.</span>contains(<span class="string">&quot;SQLITE&quot;</span>))
     QSKIP(<span class="string">&quot;This test requires the SQLITE database driver&quot;</span>);
</pre>
<h5 id="skipping-known-bugs">Skipping Known Bugs</h5>
<p>If a test exposes a known bug that will not be fixed immediately, use the <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>() macro to document the failure and reference the bug tracking identifier for the known issue. When the test is run, expected failures will be marked as XFAIL in the test output and will not be counted as failures when setting the test program's return code. If an expected failure does not occur, the XPASS (unexpected pass) will be reported in the test output and will be counted as a test failure.</p>
<p>For known bugs, <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>() is better than QSKIP() because a developer cannot fix the bug without an XPASS result reminding them that the test needs to be updated too. If QSKIP() is used, there is no reminder to revise or re-enable the test, without which subsequent regressions will not be reported.</p>
<p><b>See also </b><a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>() and <a href="qttest-best-practices-qdoc.html#select-appropriate-mechanisms-to-exclude-tests" translate="no">Select Appropriate Mechanisms to Exclude Tests</a>.</p>
<!-- @@@QSKIP -->
<!-- $$$QTEST[overload1]$$$QTEST -->
<h3 class="fn" translate="no" id="QTEST"><span class="name">QTEST</span>(<i>actual</i>, <i>testElement</i>)</h3>
<p>QTEST() is a convenience macro for <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>() that compares the value <i translate="no">actual</i> with the element <i translate="no">testElement</i> from the test's data. If there is no such element, the test asserts.</p>
<p>Apart from that, QTEST() behaves exactly as <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>().</p>
<p>Instead of writing:</p>
<pre class="cpp" translate="no">
 QFETCH(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span><span class="operator">,</span> myString);
 QCOMPARE(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>(<span class="string">&quot;hello&quot;</span>)<span class="operator">.</span>toUpper()<span class="operator">,</span> myString);
</pre>
<p>you can write:</p>
<pre class="cpp" translate="no">
 QTEST(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>(<span class="string">&quot;hello&quot;</span>)<span class="operator">.</span>toUpper()<span class="operator">,</span> <span class="string">&quot;myString&quot;</span>);
</pre>
<p><b>See also </b><a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>().</p>
<!-- @@@QTEST -->
<!-- $$$QTEST_APPLESS_MAIN[overload1]$$$QTEST_APPLESS_MAIN -->
<h3 class="fn" translate="no" id="QTEST_APPLESS_MAIN"><span class="name">QTEST_APPLESS_MAIN</span>(<i>TestClass</i>)</h3>
<p>Implements a main() function that executes all tests in <i translate="no">TestClass</i>.</p>
<p>Behaves like <a href="qtest.html#QTEST_MAIN" translate="no">QTEST_MAIN</a>(), but doesn't instantiate a <a href="../qtwidgets/qapplication.html" translate="no">QApplication</a> object. Use this macro for really simple stand-alone non-GUI tests.</p>
<p><b>See also </b><a href="qtest.html#QTEST_MAIN" translate="no">QTEST_MAIN</a>().</p>
<!-- @@@QTEST_APPLESS_MAIN -->
<!-- $$$QTEST_GUILESS_MAIN[overload1]$$$QTEST_GUILESS_MAIN -->
<h3 class="fn" translate="no" id="QTEST_GUILESS_MAIN"><span class="name">QTEST_GUILESS_MAIN</span>(<i>TestClass</i>)</h3>
<p>Implements a main() function that instantiates a <a href="../qtcore/qcoreapplication.html" translate="no">QCoreApplication</a> object and the <i translate="no">TestClass</i>, and executes all tests in the order they were defined. Use this macro to build stand-alone executables.</p>
<p>Behaves like <a href="qtest.html#QTEST_MAIN" translate="no">QTEST_MAIN</a>(), but instantiates a <a href="../qtcore/qcoreapplication.html" translate="no">QCoreApplication</a> instead of the <a href="../qtwidgets/qapplication.html" translate="no">QApplication</a> object. Use this macro if your test case doesn't need functionality offered by <a href="../qtwidgets/qapplication.html" translate="no">QApplication</a>, but the event loop is still necessary.</p>
<p><b>See also </b><a href="qtest.html#QTEST_MAIN" translate="no">QTEST_MAIN</a>().</p>
<!-- @@@QTEST_GUILESS_MAIN -->
<!-- $$$QTEST_MAIN[overload1]$$$QTEST_MAIN -->
<h3 class="fn" translate="no" id="QTEST_MAIN"><span class="name">QTEST_MAIN</span>(<i>TestClass</i>)</h3>
<p>Implements a main() function that instantiates an application object and the <i translate="no">TestClass</i>, and executes all tests in the order they were defined. Use this macro to build stand-alone executables.</p>
<p>If <code translate="no">QT_WIDGETS_LIB</code> is defined, the application object will be a <a href="../qtwidgets/qapplication.html" translate="no">QApplication</a>, if <code translate="no">QT_GUI_LIB</code> is defined, the application object will be a <a href="../qtgui/qguiapplication.html" translate="no">QGuiApplication</a>, otherwise it will be a <a href="../qtcore/qcoreapplication.html" translate="no">QCoreApplication</a>. If qmake is used and the configuration includes <code translate="no">QT += widgets</code>, then <code translate="no">QT_WIDGETS_LIB</code> will be defined automatically. Similarly, if qmake is used and the configuration includes <code translate="no">QT += gui</code>, then <code translate="no">QT_GUI_LIB</code> will be defined automatically.</p>
<div class="admonition note">
<p><b>Note: </b>On platforms that have keypad navigation enabled by default, this macro will forcefully disable it if <code translate="no">QT_WIDGETS_LIB</code> is defined. This is done to simplify the usage of key events when writing autotests. If you wish to write a test case that uses keypad navigation, you should enable it either in the <code translate="no">initTestCase()</code> or <code translate="no">init()</code> functions of your test case by calling <a href="../qtwidgets/qapplication.html#setNavigationMode" translate="no">QApplication::setNavigationMode</a>().</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 QTEST_MAIN(TestQString)
</pre>
<p><b>See also </b><a href="qtest.html#QTEST_APPLESS_MAIN" translate="no">QTEST_APPLESS_MAIN</a>(), <a href="qtest.html#QTEST_GUILESS_MAIN" translate="no">QTEST_GUILESS_MAIN</a>(), <a href="qtest.html#qExec" translate="no">QTest::qExec</a>(), and <a href="../qtwidgets/qapplication.html#setNavigationMode" translate="no">QApplication::setNavigationMode</a>().</p>
<!-- @@@QTEST_MAIN -->
<!-- $$$QTRY_COMPARE[overload1]$$$QTRY_COMPARE -->
<h3 class="fn" translate="no" id="QTRY_COMPARE"><span class="name">QTRY_COMPARE</span>(<i>actual</i>, <i>expected</i>)</h3>
<p>Performs a comparison of the <i translate="no">actual</i> and <i translate="no">expected</i> values by invoking <a href="qtest.html#QTRY_COMPARE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_WITH_TIMEOUT</a>() with a timeout of five seconds.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p><b>See also </b><a href="qtest.html#QTRY_COMPARE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_WITH_TIMEOUT</a>(), <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), <a href="qtest.html#QTRY_VERIFY" translate="no">QTRY_VERIFY</a>(), and <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>().</p>
<!-- @@@QTRY_COMPARE -->
<!-- $$$QTRY_COMPARE_EQ[overload1]$$$QTRY_COMPARE_EQ -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_EQ"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_EQ</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>Performs comparison of <i translate="no">computed</i> and <i translate="no">baseline</i> values by invoking <a href="qtest.html#QTRY_COMPARE_EQ_WITH_TIMEOUT" translate="no">QTRY_COMPARE_EQ_WITH_TIMEOUT</a> with a timeout of five seconds.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>() and <a href="qtest.html#QTRY_COMPARE_EQ_WITH_TIMEOUT" translate="no">QTRY_COMPARE_EQ_WITH_TIMEOUT</a>().</p>
<!-- @@@QTRY_COMPARE_EQ -->
<!-- $$$QTRY_COMPARE_EQ_WITH_TIMEOUT[overload1]$$$QTRY_COMPARE_EQ_WITH_TIMEOUT -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_EQ_WITH_TIMEOUT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_EQ_WITH_TIMEOUT</span>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</h3>
<p>This macro is similar to <a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>(), but performs the comparison of the <i translate="no">computed</i> and <i translate="no">baseline</i> values repeatedly, until either the comparison returns <code translate="no">true</code> or the <i translate="no">timeout</i> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>() and <a href="qtest.html#QTRY_COMPARE_EQ" translate="no">QTRY_COMPARE_EQ</a>().</p>
<!-- @@@QTRY_COMPARE_EQ_WITH_TIMEOUT -->
<!-- $$$QTRY_COMPARE_GE[overload1]$$$QTRY_COMPARE_GE -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_GE"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_GE</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>Performs comparison of <i translate="no">computed</i> and <i translate="no">baseline</i> values by invoking <a href="qtest.html#QTRY_COMPARE_GE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_GE_WITH_TIMEOUT</a> with a timeout of five seconds.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>() and <a href="qtest.html#QTRY_COMPARE_GE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_GE_WITH_TIMEOUT</a>().</p>
<!-- @@@QTRY_COMPARE_GE -->
<!-- $$$QTRY_COMPARE_GE_WITH_TIMEOUT[overload1]$$$QTRY_COMPARE_GE_WITH_TIMEOUT -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_GE_WITH_TIMEOUT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_GE_WITH_TIMEOUT</span>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</h3>
<p>This macro is similar to <a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>(), but performs the comparison of the <i translate="no">computed</i> and <i translate="no">baseline</i> values repeatedly, until either the comparison returns <code translate="no">true</code> or the <i translate="no">timeout</i> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>() and <a href="qtest.html#QTRY_COMPARE_GE" translate="no">QTRY_COMPARE_GE</a>().</p>
<!-- @@@QTRY_COMPARE_GE_WITH_TIMEOUT -->
<!-- $$$QTRY_COMPARE_GT[overload1]$$$QTRY_COMPARE_GT -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_GT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_GT</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>Performs comparison of <i translate="no">computed</i> and <i translate="no">baseline</i> values by invoking <a href="qtest.html#QTRY_COMPARE_GT_WITH_TIMEOUT" translate="no">QTRY_COMPARE_GT_WITH_TIMEOUT</a> with a timeout of five seconds.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>() and <a href="qtest.html#QTRY_COMPARE_GT_WITH_TIMEOUT" translate="no">QTRY_COMPARE_GT_WITH_TIMEOUT</a>().</p>
<!-- @@@QTRY_COMPARE_GT -->
<!-- $$$QTRY_COMPARE_GT_WITH_TIMEOUT[overload1]$$$QTRY_COMPARE_GT_WITH_TIMEOUT -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_GT_WITH_TIMEOUT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_GT_WITH_TIMEOUT</span>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</h3>
<p>This macro is similar to <a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>(), but performs the comparison of the <i translate="no">computed</i> and <i translate="no">baseline</i> values repeatedly, until either the comparison returns <code translate="no">true</code> or the <i translate="no">timeout</i> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>() and <a href="qtest.html#QTRY_COMPARE_GT" translate="no">QTRY_COMPARE_GT</a>().</p>
<!-- @@@QTRY_COMPARE_GT_WITH_TIMEOUT -->
<!-- $$$QTRY_COMPARE_LE[overload1]$$$QTRY_COMPARE_LE -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_LE"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_LE</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>Performs comparison of <i translate="no">computed</i> and <i translate="no">baseline</i> values by invoking <a href="qtest.html#QTRY_COMPARE_LE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_LE_WITH_TIMEOUT</a> with a timeout of five seconds.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>() and <a href="qtest.html#QTRY_COMPARE_LE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_LE_WITH_TIMEOUT</a>().</p>
<!-- @@@QTRY_COMPARE_LE -->
<!-- $$$QTRY_COMPARE_LE_WITH_TIMEOUT[overload1]$$$QTRY_COMPARE_LE_WITH_TIMEOUT -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_LE_WITH_TIMEOUT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_LE_WITH_TIMEOUT</span>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</h3>
<p>This macro is similar to <a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>(), but performs the comparison of the <i translate="no">computed</i> and <i translate="no">baseline</i> values repeatedly, until either the comparison returns <code translate="no">true</code> or the <i translate="no">timeout</i> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>() and <a href="qtest.html#QTRY_COMPARE_LE" translate="no">QTRY_COMPARE_LE</a>().</p>
<!-- @@@QTRY_COMPARE_LE_WITH_TIMEOUT -->
<!-- $$$QTRY_COMPARE_LT[overload1]$$$QTRY_COMPARE_LT -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_LT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_LT</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>Performs comparison of <i translate="no">computed</i> and <i translate="no">baseline</i> values by invoking <a href="qtest.html#QTRY_COMPARE_LT_WITH_TIMEOUT" translate="no">QTRY_COMPARE_LT_WITH_TIMEOUT</a> with a timeout of five seconds.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>() and <a href="qtest.html#QTRY_COMPARE_LT_WITH_TIMEOUT" translate="no">QTRY_COMPARE_LT_WITH_TIMEOUT</a>().</p>
<!-- @@@QTRY_COMPARE_LT -->
<!-- $$$QTRY_COMPARE_LT_WITH_TIMEOUT[overload1]$$$QTRY_COMPARE_LT_WITH_TIMEOUT -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_LT_WITH_TIMEOUT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_LT_WITH_TIMEOUT</span>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</h3>
<p>This macro is similar to <a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>(), but performs the comparison of the <i translate="no">computed</i> and <i translate="no">baseline</i> values repeatedly, until either the comparison returns <code translate="no">true</code> or the <i translate="no">timeout</i> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>() and <a href="qtest.html#QTRY_COMPARE_LT" translate="no">QTRY_COMPARE_LT</a>().</p>
<!-- @@@QTRY_COMPARE_LT_WITH_TIMEOUT -->
<!-- $$$QTRY_COMPARE_NE[overload1]$$$QTRY_COMPARE_NE -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_NE"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_NE</span>(<i>computed</i>, <i>baseline</i>)</h3>
<p>Performs comparison of <i translate="no">computed</i> and <i translate="no">baseline</i> values by invoking <a href="qtest.html#QTRY_COMPARE_NE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_NE_WITH_TIMEOUT</a> with a timeout of five seconds.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>() and <a href="qtest.html#QTRY_COMPARE_NE_WITH_TIMEOUT" translate="no">QTRY_COMPARE_NE_WITH_TIMEOUT</a>().</p>
<!-- @@@QTRY_COMPARE_NE -->
<!-- $$$QTRY_COMPARE_NE_WITH_TIMEOUT[overload1]$$$QTRY_COMPARE_NE_WITH_TIMEOUT -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_NE_WITH_TIMEOUT"><code class="details extra" translate="no">[since 6.4]</code> <span class="name">QTRY_COMPARE_NE_WITH_TIMEOUT</span>(<i>computed</i>, <i>baseline</i>, <i>timeout</i>)</h3>
<p>This macro is similar to <a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>(), but performs the comparison of the <i translate="no">computed</i> and <i translate="no">baseline</i> values repeatedly, until either the comparison returns <code translate="no">true</code> or the <i translate="no">timeout</i> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>() and <a href="qtest.html#QTRY_COMPARE_NE" translate="no">QTRY_COMPARE_NE</a>().</p>
<!-- @@@QTRY_COMPARE_NE_WITH_TIMEOUT -->
<!-- $$$QTRY_COMPARE_WITH_TIMEOUT[overload1]$$$QTRY_COMPARE_WITH_TIMEOUT -->
<h3 class="fn" translate="no" id="QTRY_COMPARE_WITH_TIMEOUT"><span class="name">QTRY_COMPARE_WITH_TIMEOUT</span>(<i>actual</i>, <i>expected</i>, <i>timeout</i>)</h3>
<p>The QTRY_COMPARE_WITH_TIMEOUT() macro is similar to <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), but performs the comparison of the <i translate="no">actual</i> and <i translate="no">expected</i> values repeatedly, until either the two values are equal or the <i translate="no">timeout</i> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p><b>See also </b><a href="qtest.html#QTRY_COMPARE" translate="no">QTRY_COMPARE</a>(), <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), <a href="qtest.html#QTRY_VERIFY" translate="no">QTRY_VERIFY</a>(), and <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>().</p>
<!-- @@@QTRY_COMPARE_WITH_TIMEOUT -->
<!-- $$$QTRY_VERIFY2[overload1]$$$QTRY_VERIFY2 -->
<h3 class="fn" translate="no" id="QTRY_VERIFY2"><span class="name">QTRY_VERIFY2</span>(<i>condition</i>, <i>message</i>)</h3>
<p>Checks the <i translate="no">condition</i> by invoking <a href="qtest.html#QTRY_VERIFY2_WITH_TIMEOUT" translate="no">QTRY_VERIFY2_WITH_TIMEOUT</a>() with a timeout of five seconds. If <i translate="no">condition</i> is then still false, <i translate="no">message</i> is output. The <i translate="no">message</i> is a plain C string.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 QTRY_VERIFY2(list<span class="operator">.</span>size() <span class="operator">&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>number(list<span class="operator">.</span>size())<span class="operator">.</span>constData());
</pre>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p><b>See also </b><a href="qtest.html#QTRY_VERIFY2_WITH_TIMEOUT" translate="no">QTRY_VERIFY2_WITH_TIMEOUT</a>(), QTRY_VERIFY2(), <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), <a href="qtest.html#QTRY_COMPARE" translate="no">QTRY_COMPARE</a>(), and <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>().</p>
<!-- @@@QTRY_VERIFY2 -->
<!-- $$$QTRY_VERIFY[overload1]$$$QTRY_VERIFY -->
<h3 class="fn" translate="no" id="QTRY_VERIFY"><span class="name">QTRY_VERIFY</span>(<i>condition</i>)</h3>
<p>Checks the <i translate="no">condition</i> by invoking <a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT" translate="no">QTRY_VERIFY_WITH_TIMEOUT</a>() with a timeout of five seconds.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p><b>See also </b><a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT" translate="no">QTRY_VERIFY_WITH_TIMEOUT</a>(), <a href="qtest.html#QTRY_VERIFY2" translate="no">QTRY_VERIFY2</a>(), <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), <a href="qtest.html#QTRY_COMPARE" translate="no">QTRY_COMPARE</a>(), and <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>().</p>
<!-- @@@QTRY_VERIFY -->
<!-- $$$QTRY_VERIFY2_WITH_TIMEOUT[overload1]$$$QTRY_VERIFY2_WITH_TIMEOUT -->
<h3 class="fn" translate="no" id="QTRY_VERIFY2_WITH_TIMEOUT"><span class="name">QTRY_VERIFY2_WITH_TIMEOUT</span>(<i>condition</i>, <i>message</i>, <i>timeout</i>)</h3>
<p>The QTRY_VERIFY2_WITH_TIMEOUT macro is similar to <a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT" translate="no">QTRY_VERIFY_WITH_TIMEOUT</a>() except that it outputs a verbose <i translate="no">message</i> when <i translate="no">condition</i> is still false after the specified <i translate="no">timeout</i> (in milliseconds). The <i translate="no">message</i> is a plain C string.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 QTRY_VERIFY2_WITH_TIMEOUT(list<span class="operator">.</span>size() <span class="operator">&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>number(list<span class="operator">.</span>size())<span class="operator">.</span>constData()<span class="operator">,</span> <span class="number">10000</span>);
</pre>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p><b>See also </b><a href="qtest.html#QTRY_VERIFY" translate="no">QTRY_VERIFY</a>(), <a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT" translate="no">QTRY_VERIFY_WITH_TIMEOUT</a>(), <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), <a href="qtest.html#QTRY_COMPARE" translate="no">QTRY_COMPARE</a>(), and <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>().</p>
<!-- @@@QTRY_VERIFY2_WITH_TIMEOUT -->
<!-- $$$QTRY_VERIFY_WITH_TIMEOUT[overload1]$$$QTRY_VERIFY_WITH_TIMEOUT -->
<h3 class="fn" translate="no" id="QTRY_VERIFY_WITH_TIMEOUT"><span class="name">QTRY_VERIFY_WITH_TIMEOUT</span>(<i>condition</i>, <i>timeout</i>)</h3>
<p>The QTRY_VERIFY_WITH_TIMEOUT() macro is similar to <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), but checks the <i translate="no">condition</i> repeatedly, until either the condition becomes true or the <i translate="no">timeout</i> (in milliseconds) is reached. Between each evaluation, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p><b>See also </b><a href="qtest.html#QTRY_VERIFY" translate="no">QTRY_VERIFY</a>(), <a href="qtest.html#QTRY_VERIFY2_WITH_TIMEOUT" translate="no">QTRY_VERIFY2_WITH_TIMEOUT</a>(), <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), <a href="qtest.html#QTRY_COMPARE" translate="no">QTRY_COMPARE</a>(), and <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>().</p>
<!-- @@@QTRY_VERIFY_WITH_TIMEOUT -->
<!-- $$$QVERIFY2[overload1]$$$QVERIFY2 -->
<h3 class="fn" translate="no" id="QVERIFY2"><span class="name">QVERIFY2</span>(<i>condition</i>, <i>message</i>)</h3>
<p>The QVERIFY2() macro behaves exactly like <a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), except that it reports a <i translate="no">message</i> when <i translate="no">condition</i> is false. The <i translate="no">message</i> is a plain C string.</p>
<p>The message can also be obtained from a function call that produces a plain C string, such as <a href="../qtcore/qstring.html#qPrintable" translate="no">qPrintable</a>() applied to a <a href="../qtcore/qstring.html" translate="no">QString</a>, which may be built in any of its usual ways, including applying <code translate="no">.args()</code> to format some data.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 QVERIFY2(<span class="type"><a href="../qtcore/qfileinfo.html" translate="no">QFileInfo</a></span>(<span class="string">&quot;file.txt&quot;</span>)<span class="operator">.</span>exists()<span class="operator">,</span> <span class="string">&quot;file.txt does not exist.&quot;</span>);
</pre>
<p>For example, if you have a file object and you are testing its <code translate="no">open()</code> function, you might write a test with a statement like:</p>
<pre class="cpp" translate="no">
 <span class="type">bool</span> opened <span class="operator">=</span> file<span class="operator">.</span>open(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span><span class="operator">::</span>WriteOnly);
 QVERIFY(opened);
</pre>
<p>If this test fails, it will give no clue as to why the file failed to open:</p>
<p><code translate="no">FAIL! : tst_QFile::open_write() 'opened' returned FALSE. ()</code></p>
<p>If there is a more informative error message you could construct from the values being tested, you can use <code translate="no">QVERIFY2()</code> to pass that message along with your test condition, to provide a more informative message on failure:</p>
<pre class="cpp" translate="no">
 QVERIFY2(file<span class="operator">.</span>open(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span><span class="operator">::</span>WriteOnly)<span class="operator">,</span>
          <a href="../qtcore/qstring.html#qPrintable" translate="no">qPrintable</a>(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span>(<span class="string">&quot;open %1: %2&quot;</span>)
                     <span class="operator">.</span>arg(file<span class="operator">.</span>fileName())<span class="operator">.</span>arg(file<span class="operator">.</span>errorString())));
</pre>
<p>If this branch is being tested in the Qt CI system, the above detailed failure message will be inserted into the summary posted to the code-review system:</p>
<p><code translate="no">FAIL! : tst_QFile::open_write() 'opened' returned FALSE. (open /tmp/qt.a3B42Cd: No space left on device)</code></p>
<p><b>See also </b><a href="qtest.html#QVERIFY" translate="no">QVERIFY</a>(), <a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>(), <a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>(), <a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>(), <a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>(), <a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>(), <a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>(), and <a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>().</p>
<!-- @@@QVERIFY2 -->
<!-- $$$QVERIFY[overload1]$$$QVERIFY -->
<h3 class="fn" translate="no" id="QVERIFY"><span class="name">QVERIFY</span>(<i>condition</i>)</h3>
<p>The QVERIFY() macro checks whether the <i translate="no">condition</i> is true or not. If it is true, execution continues. If not, a failure is recorded in the test log and the test won't be executed further.</p>
<p>You can use <a href="qtest.html#QVERIFY2" translate="no">QVERIFY2</a>() when it is practical and valuable to put additional information into the test failure report.</p>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>For example, the following code shows this macro being used to verify that a <a href="qsignalspy.html" translate="no">QSignalSpy</a> object is valid:</p>
<pre class="cpp" translate="no">
 QVERIFY(spy<span class="operator">.</span>isValid());
</pre>
<p>For more information about the failure, use <code translate="no">QCOMPARE(x, y)</code> instead of <code translate="no">QVERIFY(x == y)</code>, because it reports both the expected and actual value when the comparison fails.</p>
<p><b>See also </b><a href="qtest.html#QCOMPARE" translate="no">QCOMPARE</a>(), <a href="qtest.html#QTRY_VERIFY" translate="no">QTRY_VERIFY</a>(), <a href="qsignalspy.html" translate="no">QSignalSpy</a>, <a href="qtest.html#QEXPECT_FAIL" translate="no">QEXPECT_FAIL</a>(), <a href="qtest.html#QCOMPARE_EQ" translate="no">QCOMPARE_EQ</a>(), <a href="qtest.html#QCOMPARE_NE" translate="no">QCOMPARE_NE</a>(), <a href="qtest.html#QCOMPARE_LT" translate="no">QCOMPARE_LT</a>(), <a href="qtest.html#QCOMPARE_LE" translate="no">QCOMPARE_LE</a>(), <a href="qtest.html#QCOMPARE_GT" translate="no">QCOMPARE_GT</a>(), and <a href="qtest.html#QCOMPARE_GE" translate="no">QCOMPARE_GE</a>().</p>
<!-- @@@QVERIFY -->
<!-- $$$QVERIFY_THROWS_EXCEPTION[overload1]$$$QVERIFY_THROWS_EXCEPTION... -->
<h3 class="fn" translate="no" id="QVERIFY_THROWS_EXCEPTION"><code class="details extra" translate="no">[since 6.3]</code> <span class="name">QVERIFY_THROWS_EXCEPTION</span>(<i>exceptiontype</i>, ...)</h3>
<p>The QVERIFY_THROWS_EXCEPTION macro executes the expression given in the variadic argument and expects to catch an exception thrown from the expression.</p>
<p>There are several possible outcomes:</p>
<ul>
<li>If the expression throws an exception that is either the same as <i translate="no">exceptiontype</i> or derived from <i translate="no">exceptiontype</i>, then execution will continue.</li>
<li>Otherwise, if the expression throws no exception, or the exception thrown derives from <code translate="no">std::exception</code>, then a failure will be recorded in the test log and the macro returns early (from enclosing function).</li>
<li>If the thrown exception derives neither from <code translate="no">std::exception</code> nor from <i translate="no">exceptiontype</i>, a failure will be recorded in the test log, and the exception is re-thrown. This avoids problems with e.g. pthread cancellation exceptions.</li>
</ul>
<p>The macro uses variadic arguments so the expression can contain commas that the preprocessor considers argument separators, e.g. as in</p>
<pre class="cpp" translate="no">
 QVERIFY_THROWS_EXCEPTION(std<span class="operator">::</span>bad_alloc<span class="operator">,</span>
 <span class="comment">// macro arguments:      ^ exceptiontype</span>
                          std<span class="operator">::</span>vector<span class="operator">&lt;</span>std<span class="operator">::</span>pair<span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type">long</span><span class="operator">&gt;</span><span class="operator">&gt;</span>{<span class="number">42'000'000'000</span><span class="operator">,</span> {<span class="number">42</span><span class="operator">,</span> <span class="number">42L</span>}});
 <span class="comment">// macro arguments:      \---------- 1 ----------/  \-------- 2 --------/  \3/  \ 4 /</span>
 <span class="comment">//                       \----------------------- expression -----------------------/</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.3.</p>
<!-- @@@QVERIFY_THROWS_EXCEPTION -->
<!-- $$$QVERIFY_THROWS_NO_EXCEPTION[overload1]$$$QVERIFY_THROWS_NO_EXCEPTION... -->
<h3 class="fn" translate="no" id="QVERIFY_THROWS_NO_EXCEPTION"><code class="details extra" translate="no">[since 6.3]</code> <span class="name">QVERIFY_THROWS_NO_EXCEPTION</span>(...)</h3>
<p>The QVERIFY_THROWS_NO_EXCEPTION macro executes the expression given in its variadic argument and tries to catch any exception thrown from the expression.</p>
<p>There are several different outcomes:</p>
<ul>
<li>If the expression does not throw an exception, then execution will continue.</li>
<li>Otherwise, if an exception derived from <code translate="no">std::exception</code> is caught, a failure will be recorded in the test log and the macro returns early (implicit return from enclosing function).</li>
<li>If an exception not derived from <code translate="no">std::exception</code> is caught, a failure will be recorded in the test log and the exception will be re-thrown. This avoids problems with e.g. pthread cancellation exceptions.</li>
</ul>
<p>The macro uses variadic arguments so the expression can contain commas that the preprocessor considers argument separators, e.g. as in</p>
<pre class="cpp" translate="no">
 QVERIFY_THROWS_NO_EXCEPTION(std<span class="operator">::</span>pair<span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type">long</span><span class="operator">&gt;</span>{<span class="number">42</span><span class="operator">,</span> <span class="number">42L</span>});
 <span class="comment">// macro arguments:         \---- 1 ----/  \-- 2 -/  \3 /</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p>
</div>
<p>This macro was introduced in Qt 6.3.</p>
<!-- @@@QVERIFY_THROWS_NO_EXCEPTION -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
