<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qmultimap.qdoc -->
  <meta name="description" content="The QMultiMap class is a template class that provides an associative array with multiple equivalent keys.">
  <title>QMultiMap Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QMultiMap</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QMultiMap Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename Key, typename T&gt; class QMultiMap</span>
<!-- $$$QMultiMap-brief -->
<p>The QMultiMap class is a template class that provides an associative array with multiple equivalent keys. <a href="#details">More...</a></p>
<!-- @@@QMultiMap -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QMultiMap&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qmultimap-members.html">List of all members, including inherited members</a></li>
<li><a href="qmultimap-obsolete.html">Deprecated members</a></li>
<li>QMultiMap is part of <a href="shared.html">Implicitly Shared Classes</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmultimap-const-iterator.html" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmultimap-iterator.html" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmultimap-key-iterator.html" translate="no">key_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#ConstIterator-typedef" translate="no">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#Iterator-typedef" translate="no">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#const_key_value_iterator-typedef" translate="no">const_key_value_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#key_type-typedef" translate="no">key_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#key_value_iterator-typedef" translate="no">key_value_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#mapped_type-typedef" translate="no">mapped_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#size_type-typedef" translate="no">size_type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#QMultiMap-1" translate="no">QMultiMap</a></b>(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#QMultiMap-2" translate="no">QMultiMap</a></b>(const QMap&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#QMultiMap-3" translate="no">QMultiMap</a></b>(QMap&lt;Key, T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#QMultiMap-4" translate="no">QMultiMap</a></b>(const std::multimap&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#QMultiMap-5" translate="no">QMultiMap</a></b>(std::multimap&lt;Key, T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#QMultiMap-7" translate="no">QMultiMap</a></b>(const QMultiMap&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#QMultiMap-6" translate="no">QMultiMap</a></b>(QMultiMap&lt;Key, T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#dtor.QMultiMap" translate="no">~QMultiMap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> auto </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#asKeyValueRange" translate="no">asKeyValueRange</a></b>() &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> auto </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#asKeyValueRange-1" translate="no">asKeyValueRange</a></b>() const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> auto </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#asKeyValueRange-2" translate="no">asKeyValueRange</a></b>() &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> auto </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#asKeyValueRange-3" translate="no">asKeyValueRange</a></b>() const &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#constFind" translate="no">constFind</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#constFind-1" translate="no">constFind</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#constKeyValueBegin" translate="no">constKeyValueBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#constKeyValueEnd" translate="no">constKeyValueEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#contains" translate="no">contains</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#contains-1" translate="no">contains</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::size_type </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#count" translate="no">count</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::size_type </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#count-1" translate="no">count</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::size_type </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#count-2" translate="no">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::pair&lt;QMultiMap&lt;Key, T&gt;::iterator, QMultiMap&lt;Key, T&gt;::iterator&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#equal_range" translate="no">equal_range</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::pair&lt;QMultiMap&lt;Key, T&gt;::const_iterator, QMultiMap&lt;Key, T&gt;::const_iterator&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#equal_range-1" translate="no">equal_range</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#erase" translate="no">erase</a></b>(QMultiMap&lt;Key, T&gt;::const_iterator <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#erase-1" translate="no">erase</a></b>(QMultiMap&lt;Key, T&gt;::const_iterator <i>first</i>, QMultiMap&lt;Key, T&gt;::const_iterator <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#find" translate="no">find</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#find-1" translate="no">find</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#find-3" translate="no">find</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#first" translate="no">first</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#first-1" translate="no">first</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const Key &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#firstKey" translate="no">firstKey</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#insert" translate="no">insert</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#insert-1" translate="no">insert</a></b>(QMultiMap&lt;Key, T&gt;::const_iterator <i>pos</i>, const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Key </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#key" translate="no">key</a></b>(const T &amp;<i>value</i>, const Key &amp;<i>defaultKey</i> = Key()) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::key_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#keyBegin" translate="no">keyBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::key_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#keyEnd" translate="no">keyEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#keyValueBegin" translate="no">keyValueBegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#keyValueBegin-1" translate="no">keyValueBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#keyValueEnd" translate="no">keyValueEnd</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#keyValueEnd-1" translate="no">keyValueEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#keys" translate="no">keys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#keys-1" translate="no">keys</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#last" translate="no">last</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#last-1" translate="no">last</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const Key &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#lastKey" translate="no">lastKey</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#lowerBound" translate="no">lowerBound</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#lowerBound-1" translate="no">lowerBound</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::size_type </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#remove" translate="no">remove</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::size_type </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#remove-1" translate="no">remove</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QMultiMap&lt;Key, T&gt;::size_type </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#removeIf" translate="no">removeIf</a></b>(Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#replace" translate="no">replace</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::size_type </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#swap" translate="no">swap</a></b>(QMultiMap&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#take" translate="no">take</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::multimap&lt;Key, T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#toStdMultiMap" translate="no">toStdMultiMap</a></b>() const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#uniqueKeys" translate="no">uniqueKeys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#unite" translate="no">unite</a></b>(const QMultiMap&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#unite-1" translate="no">unite</a></b>(QMultiMap&lt;Key, T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#upperBound" translate="no">upperBound</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#upperBound-1" translate="no">upperBound</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#value" translate="no">value</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>defaultValue</i> = T()) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#values" translate="no">values</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#values-1" translate="no">values</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#operator-eq" translate="no">operator=</a></b>(const QMultiMap&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#operator-eq-1" translate="no">operator=</a></b>(QMultiMap&lt;Key, T&gt; &amp;&amp;<i>other</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#erase_if" translate="no">erase_if</a></b>(QMultiMap&lt;Key, T&gt; &amp;<i>map</i>, Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#operator-not-eq" translate="no">operator!=</a></b>(const QMultiMap&lt;Key, T&gt; &amp;<i>lhs</i>, const QMultiMap&lt;Key, T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#operator-2b" translate="no">operator+</a></b>(const QMultiMap&lt;Key, T&gt; &amp;<i>lhs</i>, const QMultiMap&lt;Key, T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;Key, T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#operator-2b-eq" translate="no">operator+=</a></b>(QMultiMap&lt;Key, T&gt; &amp;<i>lhs</i>, const QMultiMap&lt;Key, T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#operator-lt-lt-1" translate="no">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QMultiMap&lt;Key, T&gt; &amp;<i>map</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#operator-eq-eq" translate="no">operator==</a></b>(const QMultiMap&lt;Key, T&gt; &amp;<i>lhs</i>, const QMultiMap&lt;Key, T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultimap.html#operator-gt-gt-1" translate="no">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QMultiMap&lt;Key, T&gt; &amp;<i>map</i>)</td></tr>
</table></div>
<!-- $$$QMultiMap-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QMultiMap&lt;Key, T&gt; is one of Qt's generic <a href="containers.html" translate="no">container classes</a>. It stores (key, value) pairs and provides fast lookup by key.</p>
<p>QMultiMap and <a href="qmultihash.html" translate="no">QMultiHash</a> provide very similar functionality. The differences are:</p>
<ul>
<li><a href="qmultihash.html" translate="no">QMultiHash</a> provides average faster lookups than QMultiMap. (See <a href="containers.html#algorithmic-complexity" translate="no">Algorithmic Complexity</a> for details.)</li>
<li>When iterating over a <a href="qmultihash.html" translate="no">QMultiHash</a>, the items are arbitrarily ordered. With QMultiMap, the items are always sorted by key.</li>
<li>The key type of a <a href="qmultihash.html" translate="no">QMultiHash</a> must provide operator==() and a global <a href="qhash.html#qhash" translate="no">qHash</a>(Key) function. The key type of a QMultiMap must provide operator&lt;() specifying a total order. Since Qt 5.8.1 it is also safe to use a pointer type as key, even if the underlying operator&lt;() does not provide a total order.</li>
</ul>
<p>Here's an example QMultiMap with <a href="qstring.html" translate="no">QString</a> keys and <code translate="no">int</code> values:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> multimap;
</pre>
<p>To insert a (key, value) pair into the multi map, you can use <a href="qmultimap.html#insert" translate="no">insert</a>():</p>
<pre class="cpp" translate="no">
 multimap<span class="operator">.</span>insert(<span class="string">&quot;a&quot;</span><span class="operator">,</span> <span class="number">1</span>);
 multimap<span class="operator">.</span>insert(<span class="string">&quot;b&quot;</span><span class="operator">,</span> <span class="number">3</span>);
 multimap<span class="operator">.</span>insert(<span class="string">&quot;c&quot;</span><span class="operator">,</span> <span class="number">7</span>);
 multimap<span class="operator">.</span>insert(<span class="string">&quot;c&quot;</span><span class="operator">,</span> <span class="operator">-</span><span class="number">5</span>);
</pre>
<p>This inserts the following three (key, value) pairs into the QMultiMap: (&quot;a&quot;, 1), (&quot;b&quot;, 3), (&quot;c&quot;, 7), and (&quot;c&quot;, -5); note that duplicate keys are allowed.</p>
<p>To look up a value, use <a href="qmultimap.html#find" translate="no">find</a>() or <a href="qmultimap.html#value" translate="no">value</a>():</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> num2 <span class="operator">=</span> multimap<span class="operator">.</span>value(<span class="string">&quot;a&quot;</span>); <span class="comment">// 1</span>
 <span class="type">int</span> num3 <span class="operator">=</span> multimap<span class="operator">.</span>value(<span class="string">&quot;thirteen&quot;</span>); <span class="comment">// not found; 0</span>
 <span class="type">int</span> num3 <span class="operator">=</span> <span class="number">0</span>;
 <span class="keyword">auto</span> it <span class="operator">=</span> multimap<span class="operator">.</span>constFind(<span class="string">&quot;b&quot;</span>);
 <span class="keyword">if</span> (it <span class="operator">!</span><span class="operator">=</span> multimap<span class="operator">.</span>cend()) {
     num3 <span class="operator">=</span> it<span class="operator">.</span>value();
 }
</pre>
<p>If there is no item with the specified key in the map, these functions return a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a>.</p>
<p>If you want to check whether the map contains a certain key, use <a href="qmultimap.html#contains" translate="no">contains</a>():</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> timeout <span class="operator">=</span> <span class="number">30</span>;
 <span class="keyword">if</span> (multimap<span class="operator">.</span>contains(<span class="string">&quot;TIMEOUT&quot;</span>))
     timeout <span class="operator">=</span> multimap<span class="operator">.</span>value(<span class="string">&quot;TIMEOUT&quot;</span>);

 <span class="comment">// better:</span>
 <span class="keyword">auto</span> it <span class="operator">=</span> multimap<span class="operator">.</span>find(<span class="string">&quot;TIMEOUT&quot;</span>);
 <span class="keyword">if</span> (it <span class="operator">!</span><span class="operator">=</span> multimap<span class="operator">.</span>end())
     timeout <span class="operator">=</span> it<span class="operator">.</span>value();
</pre>
<p>There is also a <a href="qmultimap.html#value" translate="no">value</a>() overload that uses its second argument as a default value if there is no item with the specified key:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> timeout <span class="operator">=</span> multimap<span class="operator">.</span>value(<span class="string">&quot;TIMEOUT&quot;</span><span class="operator">,</span> <span class="number">30</span>);
</pre>
<p>If you want to navigate through all the (key, value) pairs stored in a QMultiMap, you can use an iterator. QMultiMap provides both <a href="java-style-iterators.html#java-style-iterators" translate="no">Java-style iterators</a> (<a href="qmultimapiterator.html" translate="no">QMultiMapIterator</a> and <a href="qmutablemultimapiterator.html" translate="no">QMutableMultiMapIterator</a>) and <a href="containers.html#stl-style-iterators" translate="no">STL-style iterators</a> (<a href="qmultimap-const-iterator.html" translate="no">QMultiMap::const_iterator</a> and <a href="qmultimap-iterator.html" translate="no">QMultiMap::iterator</a>). Here's how to iterate over a QMultiMap&lt;<a href="qstring.html" translate="no">QString</a>, int&gt; using a Java-style iterator:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmultimapiterator.html" translate="no">QMultiMapIterator</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> i(multimap);
 <span class="keyword">while</span> (i<span class="operator">.</span>hasNext()) {
     i<span class="operator">.</span>next();
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <a href="qstring.html#qPrintable" translate="no">qPrintable</a>(i<span class="operator">.</span>key()) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;: &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
 }
</pre>
<p>Here's the same code, but using an STL-style iterator this time:</p>
<pre class="cpp" translate="no">
 <span class="keyword">for</span> (<span class="keyword">auto</span> i <span class="operator">=</span> multimap<span class="operator">.</span>cbegin()<span class="operator">,</span> end <span class="operator">=</span> multimap<span class="operator">.</span>cend(); i <span class="operator">!</span><span class="operator">=</span> end; <span class="operator">+</span><span class="operator">+</span>i)
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <a href="qstring.html#qPrintable" translate="no">qPrintable</a>(i<span class="operator">.</span>key()) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;: &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
</pre>
<p>The items are traversed in ascending key order.</p>
<p>A QMultiMap allows multiple values per key. If you call <a href="qmultimap.html#insert" translate="no">insert</a>() with a key that already exists in the map, a new (key, value) pair will be inserted. For example:</p>
<pre class="cpp" translate="no">
 multimap<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">100</span>);
 multimap<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">2000</span>);
 <span class="comment">// multimap.size() == 2</span>
</pre>
<p>If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <a href="qlist.html" translate="no">QList</a>&lt;T&gt;:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> values <span class="operator">=</span> multimap<span class="operator">.</span>values(<span class="string">&quot;plenty&quot;</span>);
 <span class="keyword">for</span> (<span class="keyword">auto</span> i : std<span class="operator">::</span>as_const(values))
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
</pre>
<p>The items that share the same key are available from most recently to least recently inserted. Another approach is to call <a href="qmultimap.html#find" translate="no">find</a>() to get the STL-style iterator for the first item with a key and iterate from there:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> i <span class="operator">=</span> multimap<span class="operator">.</span>find(<span class="string">&quot;plenty&quot;</span>);
 <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> map<span class="operator">.</span>end() <span class="operator">&amp;</span><span class="operator">&amp;</span> i<span class="operator">.</span>key() <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;plenty&quot;</span>) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">+</span><span class="operator">+</span>i;
 }

 <span class="comment">// better:</span>
 <span class="keyword">auto</span> <span class="operator">[</span>i<span class="operator">,</span> end<span class="operator">]</span> <span class="operator">=</span> multimap<span class="operator">.</span>equal_range(<span class="string">&quot;plenty&quot;</span>);
 <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> end) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">+</span><span class="operator">+</span>i;
 }
</pre>
<p>If you only need to extract the values from a map (not the keys), you can also use range-based for:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmap.html" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> multimap;
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">for</span> (<span class="type">int</span> value : std<span class="operator">::</span>as_const(multimap))
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> value <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
</pre>
<p>Items can be removed from the multi map in several ways. One way is to call <a href="qmultimap.html#remove" translate="no">remove</a>(); this will remove any item with the given key. Another way is to use <a href="qmutablemultimapiterator.html#remove" translate="no">QMutableMultiMapIterator::remove</a>(). In addition, you can clear the entire map using <a href="qmultimap.html#clear" translate="no">clear</a>().</p>
<p>It is possible to merge two multi maps by calling <a href="qmultimap.html#unite" translate="no">unite</a>(), by using operator+(), and by using operator+=(). Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> map1<span class="operator">,</span> map2<span class="operator">,</span> map3;

 map1<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">100</span>);
 map1<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">2000</span>);
 <span class="comment">// map1.size() == 2</span>

 map2<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">5000</span>);
 <span class="comment">// map2.size() == 1</span>

 map3 <span class="operator">=</span> map1 <span class="operator">+</span> map2;
 <span class="comment">// map3.size() == 3</span>
</pre>
<p>QMultiMap's key and value data types must be <a href="containers.html#assignable-data-types" translate="no">assignable data types</a>. This covers most data types you are likely to encounter, but the compiler won't let you, for example, store a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> as a value; instead, store a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> *. In addition, QMultiMap's key type must provide operator&lt;(). <a href="qmap.html" translate="no">QMap</a> uses it to keep its items sorted, and assumes that two keys <code translate="no">x</code> and <code translate="no">y</code> are equal if neither <code translate="no">x &lt; y</code> nor <code translate="no">y &lt; x</code> is true.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#ifndef EMPLOYEE_H</span>
 <span class="preprocessor">#define EMPLOYEE_H</span>

 <span class="keyword">class</span> Employee
 {
 <span class="keyword">public</span>:
     Employee() {}
     Employee(<span class="keyword">const</span> <span class="type"><a href="qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>name<span class="operator">,</span> <span class="type"><a href="qdate.html" translate="no">QDate</a></span> dateOfBirth);
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

 <span class="keyword">private</span>:
     <span class="type"><a href="qstring.html" translate="no">QString</a></span> myName;
     <span class="type"><a href="qdate.html" translate="no">QDate</a></span> myDateOfBirth;
 };

 <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span><span class="operator">&lt;</span>(<span class="keyword">const</span> Employee <span class="operator">&amp;</span>e1<span class="operator">,</span> <span class="keyword">const</span> Employee <span class="operator">&amp;</span>e2)
 {
     <span class="keyword">if</span> (e1<span class="operator">.</span>name() <span class="operator">!</span><span class="operator">=</span> e2<span class="operator">.</span>name())
         <span class="keyword">return</span> e1<span class="operator">.</span>name() <span class="operator">&lt;</span> e2<span class="operator">.</span>name();
     <span class="keyword">return</span> e1<span class="operator">.</span>dateOfBirth() <span class="operator">&lt;</span> e2<span class="operator">.</span>dateOfBirth();
 }

 <span class="preprocessor">#endif // EMPLOYEE_H</span>
</pre>
<p>In the example, we start by comparing the employees' names. If they're equal, we compare their dates of birth to break the tie.</p>
</div>
<p><b>See also </b><a href="qmultimapiterator.html" translate="no">QMultiMapIterator</a>, <a href="qmutablemultimapiterator.html" translate="no">QMutableMultiMapIterator</a>, and <a href="qmultihash.html" translate="no">QMultiHash</a>.</p>
<!-- @@@QMultiMap -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" translate="no" id="ConstIterator-typedef">QMultiMap::<span class="name">ConstIterator</span></h3>
<p>Qt-style synonym for <a href="qmultimap-const-iterator.html" translate="no">QMultiMap::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn" translate="no" id="Iterator-typedef">QMultiMap::<span class="name">Iterator</span></h3>
<p>Qt-style synonym for <a href="qmultimap-iterator.html" translate="no">QMultiMap::iterator</a>.</p>
<!-- @@@Iterator -->
<!-- $$$const_key_value_iterator -->
<h3 class="fn" translate="no" id="const_key_value_iterator-typedef">QMultiMap::<span class="name">const_key_value_iterator</span></h3>
<p>The QMultiMap::const_key_value_iterator typedef provides an STL-style iterator for <a href="qmultimap.html" translate="no">QMultiMap</a>.</p>
<p>QMultiMap::const_key_value_iterator is essentially the same as <a href="qmultimap-const-iterator.html" translate="no">QMultiMap::const_iterator</a> with the difference that operator*() returns a key/value pair instead of a value.</p>
<p><b>See also </b><a href="qkeyvalueiterator.html" translate="no">QKeyValueIterator</a>.</p>
<!-- @@@const_key_value_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" translate="no" id="difference_type-typedef"><code class="details extra" translate="no">[alias]</code> QMultiMap::<span class="name">difference_type</span></h3>
<p>Typedef for ptrdiff_t. Provided for STL compatibility.</p>
<!-- @@@difference_type -->
<!-- $$$key_type -->
<h3 class="fn" translate="no" id="key_type-typedef"><code class="details extra" translate="no">[alias]</code> QMultiMap::<span class="name">key_type</span></h3>
<p>Typedef for Key. Provided for STL compatibility.</p>
<!-- @@@key_type -->
<!-- $$$key_value_iterator -->
<h3 class="fn" translate="no" id="key_value_iterator-typedef">QMultiMap::<span class="name">key_value_iterator</span></h3>
<p>The QMultiMap::key_value_iterator typedef provides an STL-style iterator for <a href="qmultimap.html" translate="no">QMultiMap</a>.</p>
<p>QMultiMap::key_value_iterator is essentially the same as <a href="qmultimap-iterator.html" translate="no">QMultiMap::iterator</a> with the difference that operator*() returns a key/value pair instead of a value.</p>
<p><b>See also </b><a href="qkeyvalueiterator.html" translate="no">QKeyValueIterator</a>.</p>
<!-- @@@key_value_iterator -->
<!-- $$$mapped_type -->
<h3 class="fn" translate="no" id="mapped_type-typedef"><code class="details extra" translate="no">[alias]</code> QMultiMap::<span class="name">mapped_type</span></h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@mapped_type -->
<!-- $$$size_type -->
<h3 class="fn" translate="no" id="size_type-typedef"><code class="details extra" translate="no">[alias]</code> QMultiMap::<span class="name">size_type</span></h3>
<p>Typedef for int. Provided for STL compatibility.</p>
<!-- @@@size_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="asKeyValueRange"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">auto</span> QMultiMap::<span class="name">asKeyValueRange</span>() &</h3><h3 class="fn fngroupitem" translate="no" id="asKeyValueRange-2"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">auto</span> QMultiMap::<span class="name">asKeyValueRange</span>() &&</h3><h3 class="fn fngroupitem" translate="no" id="asKeyValueRange-1"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">auto</span> QMultiMap::<span class="name">asKeyValueRange</span>() const &</h3><h3 class="fn fngroupitem" translate="no" id="asKeyValueRange-3"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">auto</span> QMultiMap::<span class="name">asKeyValueRange</span>() const &&</h3></div>
<p>Returns a range object that allows iteration over this multi map as key/value pairs. For instance, this range object can be used in a range-based for loop, in combination with a structured binding declaration:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> map;
 map<span class="operator">.</span>insert(<span class="string">&quot;January&quot;</span><span class="operator">,</span> <span class="number">1</span>);
 map<span class="operator">.</span>insert(<span class="string">&quot;February&quot;</span><span class="operator">,</span> <span class="number">2</span>);
 <span class="comment">// ...</span>
 map<span class="operator">.</span>insert(<span class="string">&quot;December&quot;</span><span class="operator">,</span> <span class="number">12</span>);

 <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="operator">[</span>key<span class="operator">,</span> value<span class="operator">]</span> : map<span class="operator">.</span>asKeyValueRange()) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <a href="qstring.html#qPrintable" translate="no">qPrintable</a>(key) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;: &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> value <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">-</span><span class="operator">-</span>value; <span class="comment">// convert to JS month indexing</span>
 }
</pre>
<p>Note that both the key and the value obtained this way are references to the ones in the multi map. Specifically, mutating the value will modify the map itself.</p>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qkeyvalueiterator.html" translate="no">QKeyValueIterator</a>.</p>
<!-- @@@ -->
<!-- $$$QMultiMap[overload1]$$$QMultiMap -->
<h3 class="fn" translate="no" id="QMultiMap">QMultiMap::<span class="name">QMultiMap</span>()</h3>
<p>Constructs an empty multi map.</p>
<p><b>See also </b><a href="qmultimap.html#clear" translate="no">clear</a>().</p>
<!-- @@@QMultiMap -->
<!-- $$$QMultiMap$$$QMultiMapstd::initializer_list<std::pair<Key,T>> -->
<h3 class="fn" translate="no" id="QMultiMap-1">QMultiMap::<span class="name">QMultiMap</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">std::pair</span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;&gt; <i>list</i>)</h3>
<p>Constructs a multi map with a copy of each of the elements in the initializer list <i translate="no">list</i>.</p>
<!-- @@@QMultiMap -->
<!-- $$$QMultiMap$$$QMultiMapconstQMap<Key,T>& -->
<h3 class="fn" translate="no" id="QMultiMap-2"><code class="details extra" translate="no">[explicit, since 6.0]</code> QMultiMap::<span class="name">QMultiMap</span>(const <span class="type"><a href="qmap.html" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Constructs a multi map as a copy of <i translate="no">other</i>.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@QMultiMap -->
<!-- $$$QMultiMap$$$QMultiMapQMap<Key,T>&& -->
<h3 class="fn" translate="no" id="QMultiMap-3"><code class="details extra" translate="no">[explicit, since 6.0]</code> QMultiMap::<span class="name">QMultiMap</span>(<span class="type"><a href="qmap.html" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>If <i translate="no">other</i> is shared, constructs a multi map as a copy of <i translate="no">other</i>. Otherwise, constructs a multi map by moving the elements from <i translate="no">other</i>.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@QMultiMap -->
<!-- $$$QMultiMap$$$QMultiMapconststd::multimap<Key,T>& -->
<h3 class="fn" translate="no" id="QMultiMap-4"><code class="details extra" translate="no">[explicit]</code> QMultiMap::<span class="name">QMultiMap</span>(const <span class="type">std::multimap</span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p><b>See also </b><a href="qmultimap.html#toStdMultiMap" translate="no">toStdMultiMap</a>().</p>
<!-- @@@QMultiMap -->
<!-- $$$QMultiMap$$$QMultiMapstd::multimap<Key,T>&& -->
<h3 class="fn" translate="no" id="QMultiMap-5"><code class="details extra" translate="no">[explicit]</code> QMultiMap::<span class="name">QMultiMap</span>(<span class="type">std::multimap</span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Constructs a multi map by moving from <i translate="no">other</i>.</p>
<p><b>See also </b><a href="qmultimap.html#toStdMultiMap" translate="no">toStdMultiMap</a>().</p>
<!-- @@@QMultiMap -->
<!-- $$$QMultiMap$$$QMultiMapconstQMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="QMultiMap-7"><code class="details extra" translate="no">[default]</code> QMultiMap::<span class="name">QMultiMap</span>(const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p>This operation occurs in <a href="containers.html#constant-time" translate="no">constant time</a>, because QMultiMap is <a href="implicit-sharing.html" translate="no">implicitly shared</a>. This makes returning a QMultiMap from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes <a href="containers.html#linear-time" translate="no">linear time</a>.</p>
<p><b>See also </b><a href="qmultimap.html#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QMultiMap -->
<!-- $$$QMultiMap$$$QMultiMapQMultiMap<Key,T>&& -->
<h3 class="fn" translate="no" id="QMultiMap-6"><code class="details extra" translate="no">[default]</code> QMultiMap::<span class="name">QMultiMap</span>(<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a QMultiMap instance, making it point at the same object that <i translate="no">other</i> was pointing to.</p>
<!-- @@@QMultiMap -->
<!-- $$$~QMultiMap[overload1]$$$~QMultiMap -->
<h3 class="fn" translate="no" id="dtor.QMultiMap"><code class="details extra" translate="no">[default]</code> QMultiMap::<span class="name">~QMultiMap</span>()</h3>
<p>Destroys the multi map. References to the values in the multi map, and all iterators over this multi map, become invalid.</p>
<!-- @@@~QMultiMap -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" translate="no" id="begin"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">begin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#constBegin" translate="no">constBegin</a>() and <a href="qmultimap.html#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" translate="no" id="begin-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">begin</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@begin -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" translate="no" id="cbegin"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#begin" translate="no">begin</a>() and <a href="qmultimap.html#cend" translate="no">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" translate="no" id="cend"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#cbegin" translate="no">cbegin</a>() and <a href="qmultimap.html#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QMultiMap::<span class="name">clear</span>()</h3>
<p>Removes all items from the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#remove" translate="no">remove</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" translate="no" id="constBegin"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#begin" translate="no">begin</a>() and <a href="qmultimap.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" translate="no" id="constEnd"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#constBegin" translate="no">constBegin</a>() and <a href="qmultimap.html#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind[overload1]$$$constFindconstKey& -->
<h3 class="fn" translate="no" id="constFind"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">constFind</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>Returns an const iterator pointing to the item with key <i translate="no">key</i> in the multi map.</p>
<p>If the multi map contains no item with key <i translate="no">key</i>, the function returns <a href="qmultimap.html#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="qmultimap.html#find" translate="no">find</a>() and QMultiMap::constFind().</p>
<!-- @@@constFind -->
<!-- $$$constFind$$$constFindconstKey&constT& -->
<h3 class="fn" translate="no" id="constFind-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">constFind</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns an iterator pointing to the item with key <i translate="no">key</i> and the value <i translate="no">value</i> in the map.</p>
<p>If the map contains no such item, the function returns <a href="qmultimap.html#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="qmap.html#constFind" translate="no">QMap::constFind</a>().</p>
<!-- @@@constFind -->
<!-- $$$constKeyValueBegin[overload1]$$$constKeyValueBegin -->
<h3 class="fn" translate="no" id="constKeyValueBegin"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_key_value_iterator</span> QMultiMap::<span class="name">constKeyValueBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first entry in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#keyValueBegin" translate="no">keyValueBegin</a>().</p>
<!-- @@@constKeyValueBegin -->
<!-- $$$constKeyValueEnd[overload1]$$$constKeyValueEnd -->
<h3 class="fn" translate="no" id="constKeyValueEnd"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_key_value_iterator</span> QMultiMap::<span class="name">constKeyValueEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary entry after the last entry in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#constKeyValueBegin" translate="no">constKeyValueBegin</a>().</p>
<!-- @@@constKeyValueEnd -->
<!-- $$$contains[overload1]$$$containsconstKey& -->
<h3 class="fn" translate="no" id="contains"><span class="type">bool</span> QMultiMap::<span class="name">contains</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>Returns <code translate="no">true</code> if the multi map contains an item with key <i translate="no">key</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qmultimap.html#count-2" translate="no">count</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstKey&constT& -->
<h3 class="fn" translate="no" id="contains-1"><span class="type">bool</span> QMultiMap::<span class="name">contains</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns <code translate="no">true</code> if the multi map contains an item with key <i translate="no">key</i> and value <i translate="no">value</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qmultimap.html#count-2" translate="no">count</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstKey& -->
<h3 class="fn" translate="no" id="count"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::size_type</span> QMultiMap::<span class="name">count</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>Returns the number of items associated with key <i translate="no">key</i>.</p>
<p><b>See also </b><a href="qmultimap.html#contains" translate="no">contains</a>() and <a href="qmultimap.html#count-2" translate="no">QMultiMap::count</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countconstKey&constT& -->
<h3 class="fn" translate="no" id="count-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::size_type</span> QMultiMap::<span class="name">count</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns the number of items with key <i translate="no">key</i> and value <i translate="no">value</i>.</p>
<p><b>See also </b><a href="qmultimap.html#contains" translate="no">contains</a>() and <a href="qmultimap.html#count-2" translate="no">QMultiMap::count</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn" translate="no" id="count-2"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::size_type</span> QMultiMap::<span class="name">count</span>() const</h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="qmultimap.html#size" translate="no">size</a>().</p>
<!-- @@@count -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" translate="no" id="empty"><span class="type">bool</span> QMultiMap::<span class="name">empty</span>() const</h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="qmultimap.html#isEmpty" translate="no">isEmpty</a>(), returning true if the map is empty; otherwise returning false.</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">end</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#begin" translate="no">begin</a>() and <a href="qmultimap.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" translate="no" id="end-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">end</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@end -->
<!-- $$$equal_range[overload1]$$$equal_rangeconstKey& -->
<h3 class="fn" translate="no" id="equal_range"><span class="type">std::pair</span>&lt;<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span>, <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span>&gt; QMultiMap::<span class="name">equal_range</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Returns a pair of iterators delimiting the range of values <code translate="no">[first, second)</code>, that are stored under <i translate="no">key</i>.</p>
<!-- @@@equal_range -->
<!-- $$$equal_range$$$equal_rangeconstKey& -->
<h3 class="fn" translate="no" id="equal_range-1"><span class="type">std::pair</span>&lt;<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span>, <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span>&gt; QMultiMap::<span class="name">equal_range</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@equal_range -->
<!-- $$$erase[overload1]$$$eraseQMultiMap<Key,T>::const_iterator -->
<h3 class="fn" translate="no" id="erase"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">erase</span>(<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> <i>pos</i>)</h3>
<p>Removes the (key, value) pair pointed to by the iterator <i translate="no">pos</i> from the multi map, and returns an iterator to the next item in the map.</p>
<div class="admonition note">
<p><b>Note: </b>The iterator <i translate="no">pos</i> must be valid and dereferenceable.</p>
</div>
<p><b>See also </b><a href="qmultimap.html#remove" translate="no">remove</a>().</p>
<!-- @@@erase -->
<!-- $$$erase$$$eraseQMultiMap<Key,T>::const_iteratorQMultiMap<Key,T>::const_iterator -->
<h3 class="fn" translate="no" id="erase-1"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">erase</span>(<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> <i>first</i>, <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> <i>last</i>)</h3>
<p>Removes the (key, value) pairs pointed to by the iterator range [<i translate="no">first</i>, <i translate="no">last</i>) from the multi map. Returns an iterator to the item in the multi map following the last removed element.</p>
<div class="admonition note">
<p><b>Note: </b>The range <code translate="no">[first, last)</code> <i>must</i> be a valid range in <code translate="no">*this</code>.</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qmultimap.html#remove" translate="no">remove</a>().</p>
<!-- @@@erase -->
<!-- $$$find[overload1]$$$findconstKey& -->
<h3 class="fn" translate="no" id="find"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">find</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Returns an iterator pointing to the item with key <i translate="no">key</i> in the multi map.</p>
<p>If the multi map contains no item with key <i translate="no">key</i>, the function returns <a href="qmultimap.html#end" translate="no">end</a>().</p>
<p>If the map contains multiple items with key <i translate="no">key</i>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here's some code that iterates over all the items with the same key:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> i <span class="operator">=</span> multimap<span class="operator">.</span>find(<span class="string">&quot;plenty&quot;</span>);
 <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> map<span class="operator">.</span>end() <span class="operator">&amp;</span><span class="operator">&amp;</span> i<span class="operator">.</span>key() <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;plenty&quot;</span>) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">+</span><span class="operator">+</span>i;
 }

 <span class="comment">// better:</span>
 <span class="keyword">auto</span> <span class="operator">[</span>i<span class="operator">,</span> end<span class="operator">]</span> <span class="operator">=</span> multimap<span class="operator">.</span>equal_range(<span class="string">&quot;plenty&quot;</span>);
 <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> end) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">+</span><span class="operator">+</span>i;
 }
</pre>
<p><b>See also </b><a href="qmultimap.html#constFind" translate="no">constFind</a>(), <a href="qmultimap.html#value" translate="no">value</a>(), <a href="qmultimap.html#values" translate="no">values</a>(), <a href="qmultimap.html#lowerBound" translate="no">lowerBound</a>(), and <a href="qmultimap.html#upperBound" translate="no">upperBound</a>().</p>
<!-- @@@find -->
<!-- $$$find$$$findconstKey& -->
<h3 class="fn" translate="no" id="find-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">find</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@find -->
<!-- $$$find$$$findconstKey&constT& -->
<h3 class="fn" translate="no" id="find-3"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">find</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a const iterator pointing to the item with the given <i translate="no">key</i> and <i translate="no">value</i> in the map.</p>
<p>If the map contains no such item, the function returns <a href="qmultimap.html#end" translate="no">end</a>().</p>
<p>If the map contains multiple items with the specified <i translate="no">key</i>, this function returns a const iterator that points to the most recently inserted value.</p>
<!-- @@@find -->
<!-- $$$first[overload1]$$$first -->
<h3 class="fn" translate="no" id="first"><span class="type">T</span> &amp;QMultiMap::<span class="name">first</span>()</h3>
<p>Returns a reference to the first value in the multi map, that is the value mapped to the smallest key. This function assumes that the multi map is not empty.</p>
<p>When unshared (or const version is called), this executes in <a href="containers.html#constant-time" translate="no">constant time</a>.</p>
<p><b>See also </b><a href="qmultimap.html#last" translate="no">last</a>(), <a href="qmultimap.html#firstKey" translate="no">firstKey</a>(), and <a href="qmultimap.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@first -->
<!-- $$$first$$$first -->
<h3 class="fn" translate="no" id="first-1">const <span class="type">T</span> &amp;QMultiMap::<span class="name">first</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@first -->
<!-- $$$firstKey[overload1]$$$firstKey -->
<h3 class="fn" translate="no" id="firstKey">const <span class="type">Key</span> &amp;QMultiMap::<span class="name">firstKey</span>() const</h3>
<p>Returns a reference to the smallest key in the multi map. This function assumes that the multi map is not empty.</p>
<p>This executes in <a href="containers.html#constant-time" translate="no">constant time</a>.</p>
<p><b>See also </b><a href="qmultimap.html#lastKey" translate="no">lastKey</a>(), <a href="qmultimap.html#first" translate="no">first</a>(), <a href="qmultimap.html#keyBegin" translate="no">keyBegin</a>(), and <a href="qmultimap.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@firstKey -->
<!-- $$$insert[overload1]$$$insertconstKey&constT& -->
<h3 class="fn" translate="no" id="insert"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">insert</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts a new item with the key <i translate="no">key</i> and a value of <i translate="no">value</i>.</p>
<p>If there is already an item with the same key in the map, this function will simply create a new one. (This behavior is different from <a href="qmultimap.html#replace" translate="no">replace</a>(), which overwrites the value of an existing item.)</p>
<p>Returns an iterator pointing to the new element.</p>
<p><b>See also </b><a href="qmultimap.html#replace" translate="no">replace</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertQMultiMap<Key,T>::const_iteratorconstKey&constT& -->
<h3 class="fn" translate="no" id="insert-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">insert</span>(<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> <i>pos</i>, const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts a new item with the key <i translate="no">key</i> and value <i translate="no">value</i> and with hint <i translate="no">pos</i> suggesting where to do the insert.</p>
<p>If <a href="qmultimap.html#constBegin" translate="no">constBegin</a>() is used as hint it indicates that the <i translate="no">key</i> is less than any key in the multi map while <a href="qmultimap.html#constEnd" translate="no">constEnd</a>() suggests that the <i translate="no">key</i> is (strictly) larger than any key in the multi map. Otherwise the hint should meet the condition (<i translate="no">pos</i> - 1).<a href="qmultimap.html#key" translate="no">key</a>() &lt; <i translate="no">key</i> &lt;= pos.<a href="qmultimap.html#key" translate="no">key</a>(). If the hint <i translate="no">pos</i> is wrong it is ignored and a regular insert is done.</p>
<p>If the hint is correct and the multi map is unshared, the insert executes in amortized <a href="containers.html#constant-time" translate="no">constant time</a>.</p>
<p>If there is already an item with the same key in the map, this function will simply create a new one.</p>
<p>When creating a multi map from sorted data inserting the largest key first with <a href="qmultimap.html#constBegin" translate="no">constBegin</a>() is faster than inserting in sorted order with <a href="qmultimap.html#constEnd" translate="no">constEnd</a>(), since <a href="qmultimap.html#constEnd" translate="no">constEnd</a>() - 1 (which is needed to check if the hint is valid) needs <a href="containers.html#logarithmic-time" translate="no">logarithmic time</a>.</p>
<p>Returns an iterator pointing to the new element.</p>
<p><b>Note:</b> Be careful with the hint. Providing an iterator from an older shared instance might crash but there is also a risk that it will silently corrupt both the multi map and the <i translate="no">pos</i> multi map.</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" translate="no" id="isEmpty"><span class="type">bool</span> QMultiMap::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code translate="no">true</code> if the multi map contains no items; otherwise returns false.</p>
<p><b>See also </b><a href="qmultimap.html#size" translate="no">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$key[overload1]$$$keyconstT&constKey& -->
<h3 class="fn" translate="no" id="key"><span class="type">Key</span> QMultiMap::<span class="name">key</span>(const <span class="type">T</span> &amp;<i>value</i>, const <span class="type">Key</span> &amp;<i>defaultKey</i> = Key()) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the first key with value <i translate="no">value</i>, or <i translate="no">defaultKey</i> if the multi map contains no item with value <i translate="no">value</i>. If no <i translate="no">defaultKey</i> is provided the function returns a <a href="containers.html#default-constructed-value" translate="no">default-constructed key</a>.</p>
<p>This function can be slow (<a href="containers.html#linear-time" translate="no">linear time</a>), because <a href="qmultimap.html" translate="no">QMultiMap</a>'s internal data structure is optimized for fast lookup by key, not by value.</p>
<p><b>See also </b><a href="qmultimap.html#value" translate="no">value</a>() and <a href="qmultimap.html#keys" translate="no">keys</a>().</p>
<!-- @@@key -->
<!-- $$$keyBegin[overload1]$$$keyBegin -->
<h3 class="fn" translate="no" id="keyBegin"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::key_iterator</span> QMultiMap::<span class="name">keyBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first key in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#keyEnd" translate="no">keyEnd</a>() and <a href="qmultimap.html#firstKey" translate="no">firstKey</a>().</p>
<!-- @@@keyBegin -->
<!-- $$$keyEnd[overload1]$$$keyEnd -->
<h3 class="fn" translate="no" id="keyEnd"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::key_iterator</span> QMultiMap::<span class="name">keyEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last key in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#keyBegin" translate="no">keyBegin</a>() and <a href="qmultimap.html#lastKey" translate="no">lastKey</a>().</p>
<!-- @@@keyEnd -->
<!-- $$$keyValueBegin[overload1]$$$keyValueBegin -->
<h3 class="fn" translate="no" id="keyValueBegin"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::key_value_iterator</span> QMultiMap::<span class="name">keyValueBegin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first entry in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#keyValueEnd" translate="no">keyValueEnd</a>().</p>
<!-- @@@keyValueBegin -->
<!-- $$$keyValueBegin$$$keyValueBegin -->
<h3 class="fn" translate="no" id="keyValueBegin-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_key_value_iterator</span> QMultiMap::<span class="name">keyValueBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first entry in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#keyValueEnd" translate="no">keyValueEnd</a>().</p>
<!-- @@@keyValueBegin -->
<!-- $$$keyValueEnd[overload1]$$$keyValueEnd -->
<h3 class="fn" translate="no" id="keyValueEnd"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::key_value_iterator</span> QMultiMap::<span class="name">keyValueEnd</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary entry after the last entry in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#keyValueBegin" translate="no">keyValueBegin</a>().</p>
<!-- @@@keyValueEnd -->
<!-- $$$keyValueEnd$$$keyValueEnd -->
<h3 class="fn" translate="no" id="keyValueEnd-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_key_value_iterator</span> QMultiMap::<span class="name">keyValueEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary entry after the last entry in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#keyValueBegin" translate="no">keyValueBegin</a>().</p>
<!-- @@@keyValueEnd -->
<!-- $$$keys[overload1]$$$keys -->
<h3 class="fn" translate="no" id="keys"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">Key</span>&gt; QMultiMap::<span class="name">keys</span>() const</h3>
<p>Returns a list containing all the keys in the multi map in ascending order. Keys that occur multiple times in the multi map also occur multiple times in the list.</p>
<p>The order is guaranteed to be the same as that used by <a href="qmultimap.html#values" translate="no">values</a>().</p>
<p>This function creates a new list, in <a href="containers.html#linear-time" translate="no">linear time</a>. The time and memory use that entails can be avoided by iterating from <a href="qmultimap.html#keyBegin" translate="no">keyBegin</a>() to <a href="qmultimap.html#keyEnd" translate="no">keyEnd</a>().</p>
<p><b>See also </b><a href="qmultimap.html#values" translate="no">values</a>() and <a href="qmultimap.html#key" translate="no">key</a>().</p>
<!-- @@@keys -->
<!-- $$$keys$$$keysconstT& -->
<h3 class="fn" translate="no" id="keys-1"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">Key</span>&gt; QMultiMap::<span class="name">keys</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a list containing all the keys associated with value <i translate="no">value</i> in ascending order.</p>
<p>This function can be slow (<a href="containers.html#linear-time" translate="no">linear time</a>), because <a href="qmultimap.html" translate="no">QMultiMap</a>'s internal data structure is optimized for fast lookup by key, not by value.</p>
<!-- @@@keys -->
<!-- $$$last[overload1]$$$last -->
<h3 class="fn" translate="no" id="last"><span class="type">T</span> &amp;QMultiMap::<span class="name">last</span>()</h3>
<p>Returns a reference to the last value in the multi map, that is the value mapped to the largest key. This function assumes that the map is not empty.</p>
<p>When unshared (or const version is called), this executes in <a href="containers.html#logarithmic-time" translate="no">logarithmic time</a>.</p>
<p><b>See also </b><a href="qmultimap.html#first" translate="no">first</a>(), <a href="qmultimap.html#lastKey" translate="no">lastKey</a>(), and <a href="qmultimap.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@last -->
<!-- $$$last$$$last -->
<h3 class="fn" translate="no" id="last-1">const <span class="type">T</span> &amp;QMultiMap::<span class="name">last</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@last -->
<!-- $$$lastKey[overload1]$$$lastKey -->
<h3 class="fn" translate="no" id="lastKey">const <span class="type">Key</span> &amp;QMultiMap::<span class="name">lastKey</span>() const</h3>
<p>Returns a reference to the largest key in the multi map. This function assumes that the multi map is not empty.</p>
<p>This executes in <a href="containers.html#logarithmic-time" translate="no">logarithmic time</a>.</p>
<p><b>See also </b><a href="qmultimap.html#firstKey" translate="no">firstKey</a>(), <a href="qmultimap.html#last" translate="no">last</a>(), <a href="qmultimap.html#keyEnd" translate="no">keyEnd</a>(), and <a href="qmultimap.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@lastKey -->
<!-- $$$lowerBound[overload1]$$$lowerBoundconstKey& -->
<h3 class="fn" translate="no" id="lowerBound"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">lowerBound</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Returns an iterator pointing to the first item with key <i translate="no">key</i> in the map. If the map contains no item with key <i translate="no">key</i>, the function returns an iterator to the nearest item with a greater key.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> multimap;
 multimap<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="string">&quot;one&quot;</span>);
 multimap<span class="operator">.</span>insert(<span class="number">5</span><span class="operator">,</span> <span class="string">&quot;five&quot;</span>);
 multimap<span class="operator">.</span>insert(<span class="number">5</span><span class="operator">,</span> <span class="string">&quot;five (2)&quot;</span>);
 multimap<span class="operator">.</span>insert(<span class="number">10</span><span class="operator">,</span> <span class="string">&quot;ten&quot;</span>);

 multimap<span class="operator">.</span>lowerBound(<span class="number">0</span>);      <span class="comment">// returns iterator to (1, &quot;one&quot;)</span>
 multimap<span class="operator">.</span>lowerBound(<span class="number">1</span>);      <span class="comment">// returns iterator to (1, &quot;one&quot;)</span>
 multimap<span class="operator">.</span>lowerBound(<span class="number">2</span>);      <span class="comment">// returns iterator to (5, &quot;five&quot;)</span>
 multimap<span class="operator">.</span>lowerBound(<span class="number">5</span>);      <span class="comment">// returns iterator to (5, &quot;five&quot;)</span>
 multimap<span class="operator">.</span>lowerBound(<span class="number">6</span>);      <span class="comment">// returns iterator to (10, &quot;ten&quot;)</span>
 multimap<span class="operator">.</span>lowerBound(<span class="number">10</span>);     <span class="comment">// returns iterator to (10, &quot;ten&quot;)</span>
 multimap<span class="operator">.</span>lowerBound(<span class="number">999</span>);    <span class="comment">// returns end()</span>
</pre>
<p>If the map contains multiple items with key <i translate="no">key</i>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here's some code that iterates over all the items with the same key:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmap.html" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> multimap;
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="type"><a href="qmap.html" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>const_iterator i <span class="operator">=</span> multimap<span class="operator">.</span>lowerBound(<span class="string">&quot;HDR&quot;</span>);
 <span class="type"><a href="qmap.html" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>const_iterator upperBound <span class="operator">=</span> multimap<span class="operator">.</span>upperBound(<span class="string">&quot;HDR&quot;</span>);
 <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> upperBound) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">+</span><span class="operator">+</span>i;
 }
</pre>
<p><b>See also </b><a href="qmultimap.html#upperBound" translate="no">upperBound</a>() and <a href="qmultimap.html#find" translate="no">find</a>().</p>
<!-- @@@lowerBound -->
<!-- $$$lowerBound$$$lowerBoundconstKey& -->
<h3 class="fn" translate="no" id="lowerBound-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">lowerBound</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@lowerBound -->
<!-- $$$remove[overload1]$$$removeconstKey& -->
<h3 class="fn" translate="no" id="remove"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::size_type</span> QMultiMap::<span class="name">remove</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Removes all the items that have the key <i translate="no">key</i> from the multi map. Returns the number of items removed.</p>
<p><b>See also </b><a href="qmultimap.html#clear" translate="no">clear</a>() and <a href="qmultimap.html#take" translate="no">take</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstKey&constT& -->
<h3 class="fn" translate="no" id="remove-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::size_type</span> QMultiMap::<span class="name">remove</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Removes all the items that have the key <i translate="no">key</i> and value <i translate="no">value</i> from the multi map. Returns the number of items removed.</p>
<p><b>See also </b><a href="qmultimap.html#clear" translate="no">clear</a>() and <a href="qmultimap.html#take" translate="no">take</a>().</p>
<!-- @@@remove -->
<!-- $$$removeIf[overload1]$$$removeIfPredicate -->
<h3 class="fn" translate="no" id="removeIf"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Predicate&gt; <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::size_type</span> QMultiMap::<span class="name">removeIf</span>(<span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i translate="no">pred</i> returns true from the multi map.</p>
<p>The function supports predicates which take either an argument of type <code translate="no">QMultiMap&lt;Key, T&gt;::iterator</code>, or an argument of type <code translate="no">std::pair&lt;const Key &amp;, T &amp;&gt;</code>.</p>
<p>Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qmultimap.html#clear" translate="no">clear</a>() and <a href="qmultimap.html#take" translate="no">take</a>().</p>
<!-- @@@removeIf -->
<!-- $$$replace[overload1]$$$replaceconstKey&constT& -->
<h3 class="fn" translate="no" id="replace"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">replace</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts a new item with the key <i translate="no">key</i> and a value of <i translate="no">value</i>.</p>
<p>If there is already an item with the key <i translate="no">key</i>, that item's value is replaced with <i translate="no">value</i>.</p>
<p>If there are multiple items with the key <i translate="no">key</i>, the most recently inserted item's value is replaced with <i translate="no">value</i>.</p>
<p>Returns an iterator pointing to the new/updated element.</p>
<p><b>See also </b><a href="qmultimap.html#insert" translate="no">insert</a>().</p>
<!-- @@@replace -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::size_type</span> QMultiMap::<span class="name">size</span>() const</h3>
<p>Returns the number of (key, value) pairs in the multi map.</p>
<p><b>See also </b><a href="qmultimap.html#isEmpty" translate="no">isEmpty</a>() and <a href="qmultimap.html#count-2" translate="no">count</a>().</p>
<!-- @@@size -->
<!-- $$$swap[overload1]$$$swapQMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QMultiMap::<span class="name">swap</span>(<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Swaps multi map <i translate="no">other</i> with this multi map. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$take[overload1]$$$takeconstKey& -->
<h3 class="fn" translate="no" id="take"><span class="type">T</span> QMultiMap::<span class="name">take</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Removes the item with the key <i translate="no">key</i> from the multi map and returns the value associated with it.</p>
<p>If the item does not exist in the multi map, the function simply returns a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a>. If there are multiple items for <i translate="no">key</i> in the map, only the most recently inserted one is removed and returned.</p>
<p>If you don't use the return value, <a href="qmultimap.html#remove" translate="no">remove</a>() is more efficient.</p>
<p><b>See also </b><a href="qmultimap.html#remove" translate="no">remove</a>().</p>
<!-- @@@take -->
<!-- $$$toStdMultiMap[overload1]$$$toStdMultiMap -->
<h3 class="fn" translate="no" id="toStdMultiMap"><span class="type">std::multimap</span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; QMultiMap::<span class="name">toStdMultiMap</span>() const &</h3>
<p>Returns an STL multi map equivalent to this <a href="qmultimap.html" translate="no">QMultiMap</a>.</p>
<!-- @@@toStdMultiMap -->
<!-- $$$uniqueKeys[overload1]$$$uniqueKeys -->
<h3 class="fn" translate="no" id="uniqueKeys"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">Key</span>&gt; QMultiMap::<span class="name">uniqueKeys</span>() const</h3>
<p>Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map occur only once in the returned list.</p>
<!-- @@@uniqueKeys -->
<!-- $$$unite[overload1]$$$uniteconstQMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="unite"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiMap::<span class="name">unite</span>(const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Inserts all the items in the <i translate="no">other</i> map into this map. If a key is common to both maps, the resulting map will contain the key multiple times.</p>
<!-- @@@unite -->
<!-- $$$unite$$$uniteQMultiMap<Key,T>&& -->
<h3 class="fn" translate="no" id="unite-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiMap::<span class="name">unite</span>(<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Moves all the items from the <i translate="no">other</i> map into this map. If a key is common to both maps, the resulting map will contain the key multiple times.</p>
<p>If <i translate="no">other</i> is shared, then the items will be copied instead.</p>
<!-- @@@unite -->
<!-- $$$upperBound[overload1]$$$upperBoundconstKey& -->
<h3 class="fn" translate="no" id="upperBound"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiMap::<span class="name">upperBound</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Returns an iterator pointing to the item that immediately follows the last item with key <i translate="no">key</i> in the map. If the map contains no item with key <i translate="no">key</i>, the function returns an iterator to the nearest item with a greater key.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> multimap;
 multimap<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="string">&quot;one&quot;</span>);
 multimap<span class="operator">.</span>insert(<span class="number">5</span><span class="operator">,</span> <span class="string">&quot;five&quot;</span>);
 multimap<span class="operator">.</span>insert(<span class="number">5</span><span class="operator">,</span> <span class="string">&quot;five (2)&quot;</span>);
 multimap<span class="operator">.</span>insert(<span class="number">10</span><span class="operator">,</span> <span class="string">&quot;ten&quot;</span>);

 multimap<span class="operator">.</span>upperBound(<span class="number">0</span>);      <span class="comment">// returns iterator to (1, &quot;one&quot;)</span>
 multimap<span class="operator">.</span>upperBound(<span class="number">1</span>);      <span class="comment">// returns iterator to (5, &quot;five&quot;)</span>
 multimap<span class="operator">.</span>upperBound(<span class="number">2</span>);      <span class="comment">// returns iterator to (5, &quot;five&quot;)</span>
 multimap<span class="operator">.</span>lowerBound(<span class="number">5</span>);      <span class="comment">// returns iterator to (5, &quot;five (2)&quot;)</span>
 multimap<span class="operator">.</span>lowerBound(<span class="number">6</span>);      <span class="comment">// returns iterator to (10, &quot;ten&quot;)</span>
 multimap<span class="operator">.</span>upperBound(<span class="number">10</span>);     <span class="comment">// returns end()</span>
 multimap<span class="operator">.</span>upperBound(<span class="number">999</span>);    <span class="comment">// returns end()</span>
</pre>
<p><b>See also </b><a href="qmultimap.html#lowerBound" translate="no">lowerBound</a>() and <a href="qmultimap.html#find" translate="no">find</a>().</p>
<!-- @@@upperBound -->
<!-- $$$upperBound$$$upperBoundconstKey& -->
<h3 class="fn" translate="no" id="upperBound-1"><span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiMap::<span class="name">upperBound</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@upperBound -->
<!-- $$$value[overload1]$$$valueconstKey&constT& -->
<h3 class="fn" translate="no" id="value"><span class="type">T</span> QMultiMap::<span class="name">value</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>defaultValue</i> = T()) const</h3>
<p>Returns the value associated with the key <i translate="no">key</i>.</p>
<p>If the multi map contains no item with key <i translate="no">key</i>, the function returns <i translate="no">defaultValue</i>. If no <i translate="no">defaultValue</i> is specified, the function returns a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a>. If there are multiple items for <i translate="no">key</i> in the multi map, the value of the most recently inserted one is returned.</p>
<p><b>See also </b><a href="qmultimap.html#key" translate="no">key</a>(), <a href="qmultimap.html#values" translate="no">values</a>(), and <a href="qmultimap.html#contains" translate="no">contains</a>().</p>
<!-- @@@value -->
<!-- $$$values[overload1]$$$values -->
<h3 class="fn" translate="no" id="values"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QMultiMap::<span class="name">values</span>() const</h3>
<p>Returns a list containing all the values in the map, in ascending order of their keys. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</p>
<p><b>See also </b><a href="qmultimap.html#keys" translate="no">keys</a>() and <a href="qmultimap.html#value" translate="no">value</a>().</p>
<!-- @@@values -->
<!-- $$$values$$$valuesconstKey& -->
<h3 class="fn" translate="no" id="values-1"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QMultiMap::<span class="name">values</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>Returns a list containing all the values associated with key <i translate="no">key</i>, from the most recently inserted to the least recently inserted one.</p>
<p><b>See also </b><a href="qmultimap.html#keys" translate="no">keys</a>() and <a href="qmultimap.html#value" translate="no">value</a>().</p>
<!-- @@@values -->
<!-- $$$operator=[overload1]$$$operator=constQMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="operator-eq"><code class="details extra" translate="no">[default]</code> <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiMap::<span class="name">operator=</span>(const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Assigns <i translate="no">other</i> to this multi map and returns a reference to this multi map.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QMultiMap<Key,T>&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[default]</code> <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiMap::<span class="name">operator=</span>(<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qmultimap.html" translate="no">QMultiMap</a> instance.</p>
<!-- @@@operator= -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$erase_if[overload1]$$$erase_ifQMultiMap<Key,T>&Predicate -->
<h3 class="fn" translate="no" id="erase_if"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Key, typename T, typename Predicate&gt; <span class="type">qsizetype</span> <span class="name">erase_if</span>(<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>map</i>, <span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i translate="no">pred</i> returns true from the multi map <i translate="no">map</i>.</p>
<p>The function supports predicates which take either an argument of type <code translate="no">QMultiMap&lt;Key, T&gt;::iterator</code>, or an argument of type <code translate="no">std::pair&lt;const Key &amp;, T &amp;&gt;</code>.</p>
<p>Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@erase_if -->
<!-- $$$operator!=[overload1]$$$operator!=constQMultiMap<Key,T>&constQMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="operator-not-eq"><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">lhs</i> is not equal to <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>Two multi maps are considered equal if they contain the same (key, value) pairs, in the same order (which matters for duplicate keys).</p>
<p>This function requires the key and the value types to implement <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qmultimap.html#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator+[overload1]$$$operator+constQMultiMap<Key,T>&constQMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="operator-2b">template &lt;typename Key, typename T&gt; <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; <span class="name">operator+</span>(const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns a map that contains all the items in the <i translate="no">lhs</i> map in addition to all the items in <i translate="no">rhs</i>. If a key is common to both maps, the resulting map will contain the key multiple times.</p>
<p><b>See also </b><a href="qmultimap.html#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+=[overload1]$$$operator+=QMultiMap<Key,T>&constQMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="operator-2b-eq">template &lt;typename Key, typename T&gt; <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; <span class="name">operator+=</span>(<span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Inserts all the items in the <i translate="no">rhs</i> map into the <i translate="no">lhs</i> map and returns the resulting map.</p>
<p><b>See also </b><a href="qmultimap.html#insert" translate="no">insert</a>() and <a href="qmultimap.html#operator-2b" translate="no">operator+</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator<<$$$operator<<QDataStream&constQMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="operator-lt-lt-1">template &lt;typename Key, typename T&gt; <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>map</i>)</h3>
<p>Writes the multi map <i translate="no">map</i> to stream <i translate="no">out</i>.</p>
<p>This function requires the key and value types to implement <code translate="no">operator&lt;&lt;()</code>.</p>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Format of the QDataStream operators</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator==[overload1]$$$operator==constQMultiMap<Key,T>&constQMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">lhs</i> is equal to <i translate="no">rhs</i>; otherwise returns false.</p>
<p>Two multi maps are considered equal if they contain the same (key, value) pairs, in the same order (which matters for duplicate keys).</p>
<p>This function requires the key and the value types to implement <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qmultimap.html#operator-not-eq" translate="no">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator>>$$$operator>>QDataStream&QMultiMap<Key,T>& -->
<h3 class="fn" translate="no" id="operator-gt-gt-1">template &lt;typename Key, typename T&gt; <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qmultimap.html#QMultiMap" translate="no">QMultiMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>map</i>)</h3>
<p>Reads a map from stream <i translate="no">in</i> into <i translate="no">map</i>.</p>
<p>This function requires the key and value types to implement <code translate="no">operator&gt;&gt;()</code>.</p>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Format of the QDataStream operators</a>.</p>
<!-- @@@operator>> -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
