<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qjnienvironment.cpp -->
  <meta name="description" content="The QJniEnvironment class provides access to the JNI Environment (JNIEnv).">
  <title>QJniEnvironment Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QJniEnvironment</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QJniEnvironment Class</h1>
<!-- $$$QJniEnvironment-brief -->
<p>The QJniEnvironment class provides access to the JNI Environment (JNIEnv). <a href="#details">More...</a></p>
<!-- @@@QJniEnvironment -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QJniEnvironment&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.1</td></tr>
</table></div>
<ul>
<li><a href="qjnienvironment-members.html">List of all members, including inherited members</a></li>
<li><a href="qjnienvironment-obsolete.html">Deprecated members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#OutputMode-enum" translate="no">OutputMode</a></b> { Silent, Verbose }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#QJniEnvironment" translate="no">QJniEnvironment</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#dtor.QJniEnvironment" translate="no">~QJniEnvironment</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#checkAndClearExceptions" translate="no">checkAndClearExceptions</a></b>(QJniEnvironment::OutputMode <i>outputMode</i> = OutputMode::Verbose)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> jclass </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#findClass" translate="no">findClass</a></b>(const char *<i>className</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> jfieldID </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#findField" translate="no">findField</a></b>(jclass <i>clazz</i>, const char *<i>fieldName</i>, const char *<i>signature</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> jfieldID </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#findField-1" translate="no">findField</a></b>(jclass <i>clazz</i>, const char *<i>fieldName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> jmethodID </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#findMethod" translate="no">findMethod</a></b>(jclass <i>clazz</i>, const char *<i>methodName</i>, const char *<i>signature</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> jmethodID </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#findMethod-1" translate="no">findMethod</a></b>(jclass <i>clazz</i>, const char *<i>methodName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> jfieldID </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#findStaticField" translate="no">findStaticField</a></b>(jclass <i>clazz</i>, const char *<i>fieldName</i>, const char *<i>signature</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> jfieldID </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#findStaticField-1" translate="no">findStaticField</a></b>(jclass <i>clazz</i>, const char *<i>fieldName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> jmethodID </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#findStaticMethod" translate="no">findStaticMethod</a></b>(jclass <i>clazz</i>, const char *<i>methodName</i>, const char *<i>signature</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> jmethodID </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#findStaticMethod-1" translate="no">findStaticMethod</a></b>(jclass <i>clazz</i>, const char *<i>methodName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> JNIEnv *</td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#jniEnv" translate="no">jniEnv</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#registerNativeMethods" translate="no">registerNativeMethods</a></b>(const char *<i>className</i>, const JNINativeMethod[] <i>methods</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#registerNativeMethods-1" translate="no">registerNativeMethods</a></b>(jclass <i>clazz</i>, const JNINativeMethod[] <i>methods</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#registerNativeMethods-2" translate="no">registerNativeMethods</a></b>(const char *<i>className</i>, std::initializer_list&lt;JNINativeMethod&gt; <i>methods</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#registerNativeMethods-3" translate="no">registerNativeMethods</a></b>(jclass <i>clazz</i>, std::initializer_list&lt;JNINativeMethod&gt; <i>methods</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> JNIEnv &amp;</td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#operator-2a" translate="no">operator*</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> JNIEnv *</td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#operator--gt" translate="no">operator-&gt;</a></b>() const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#checkAndClearExceptions-1" translate="no">checkAndClearExceptions</a></b>(JNIEnv *<i>env</i>, QJniEnvironment::OutputMode <i>outputMode</i> = OutputMode::Verbose)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> JNIEnv *</td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#getJniEnv" translate="no">getJniEnv</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> JavaVM *</td><td class="memItemRight bottomAlign"><b><a href="qjnienvironment.html#javaVM" translate="no">javaVM</a></b>()</td></tr>
</table></div>
<!-- $$$QJniEnvironment-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>When using JNI, the <a href="https://developer.android.com/training/articles/perf-jni#javavm-and-jnienv" translate="no">JNIEnv</a> class is a pointer to a function table and a member function for each JNI function that indirects through the table. <code translate="no">JNIEnv</code> provides most of the JNI functions. Every C++ native function receives a <code translate="no">JNIEnv</code> as the first argument. The JNI environment cannot be shared between threads.</p>
<p>Since <code translate="no">JNIEnv</code> doesn't do much error checking, such as exception checking and clearing, QJniEnvironment allows you to do that easily.</p>
<p>For more information about JNIEnv, see <a href="https://docs.oracle.com/en/java/javase/13/docs/specs/jni/functions.html#interface-function-table" translate="no">Java: Interface Function Table</a>.</p>
<div class="admonition note">
<p><b>Note: </b>This API has been designed and tested for use with Android. It has not been tested for other platforms.</p>
</div>
</div>
<!-- @@@QJniEnvironment -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$OutputMode$$$Silent$$$Verbose -->
<h3 class="fn" translate="no" id="OutputMode-enum">enum class QJniEnvironment::<span class="name">OutputMode</span></h3>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QJniEnvironment::OutputMode::Silent</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The exceptions are cleaned silently</td></tr>
<tr><td class="topAlign"><code translate="no">QJniEnvironment::OutputMode::Verbose</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Prints the exceptions and their stack backtrace as an error to <code translate="no">stderr</code> stream.</td></tr>
</table></div>
<!-- @@@OutputMode -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QJniEnvironment[overload1]$$$QJniEnvironment -->
<h3 class="fn" translate="no" id="QJniEnvironment">QJniEnvironment::<span class="name">QJniEnvironment</span>()</h3>
<p>Constructs a new JNI Environment object and attaches the current thread to the Java VM.</p>
<!-- @@@QJniEnvironment -->
<!-- $$$~QJniEnvironment[overload1]$$$~QJniEnvironment -->
<h3 class="fn" translate="no" id="dtor.QJniEnvironment"><code class="details extra" translate="no">[noexcept]</code> QJniEnvironment::<span class="name">~QJniEnvironment</span>()</h3>
<p>Detaches the current thread from the Java VM and destroys the <a href="qjnienvironment.html" translate="no">QJniEnvironment</a> object. This will clear any pending exception by calling <a href="qjnienvironment.html#checkAndClearExceptions" translate="no">checkAndClearExceptions</a>().</p>
<!-- @@@~QJniEnvironment -->
<!-- $$$checkAndClearExceptions[overload1]$$$checkAndClearExceptionsQJniEnvironment::OutputMode -->
<h3 class="fn" translate="no" id="checkAndClearExceptions"><span class="type">bool</span> QJniEnvironment::<span class="name">checkAndClearExceptions</span>(<span class="type"><a href="qjnienvironment.html#OutputMode-enum" translate="no">QJniEnvironment::OutputMode</a></span> <i>outputMode</i> = OutputMode::Verbose)</h3>
<p>Cleans any pending exceptions either silently or reporting stack backtrace, depending on the <i translate="no">outputMode</i>.</p>
<p>In contrast to <a href="qjniobject.html" translate="no">QJniObject</a>, which handles exceptions internally, if you make JNI calls directly via <code translate="no">JNIEnv</code>, you need to clear any potential exceptions after the call using this function. For more information about <code translate="no">JNIEnv</code> calls that can throw an exception, see <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html" translate="no">JNI Functions</a>.</p>
<p>Returns <code translate="no">true</code> when a pending exception was cleared.</p>
<!-- @@@checkAndClearExceptions -->
<!-- $$$checkAndClearExceptions$$$checkAndClearExceptionsJNIEnv*QJniEnvironment::OutputMode -->
<h3 class="fn" translate="no" id="checkAndClearExceptions-1"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QJniEnvironment::<span class="name">checkAndClearExceptions</span>(<span class="type">JNIEnv</span> *<i>env</i>, <span class="type"><a href="qjnienvironment.html#OutputMode-enum" translate="no">QJniEnvironment::OutputMode</a></span> <i>outputMode</i> = OutputMode::Verbose)</h3>
<p>Cleans any pending exceptions for <i translate="no">env</i>, either silently or reporting stack backtrace, depending on the <i translate="no">outputMode</i>. This is useful when you already have a <code translate="no">JNIEnv</code> pointer such as in a native function implementation.</p>
<p>In contrast to <a href="qjniobject.html" translate="no">QJniObject</a>, which handles exceptions internally, if you make JNI calls directly via <code translate="no">JNIEnv</code>, you need to clear any potential exceptions after the call using this function. For more information about <code translate="no">JNIEnv</code> calls that can throw an exception, see <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html" translate="no">JNI Functions</a>.</p>
<p>Returns <code translate="no">true</code> when a pending exception was cleared.</p>
<!-- @@@checkAndClearExceptions -->
<!-- $$$findClass[overload1]$$$findClassconstchar* -->
<h3 class="fn" translate="no" id="findClass"><span class="type">jclass</span> QJniEnvironment::<span class="name">findClass</span>(const <span class="type">char</span> *<i>className</i>)</h3>
<p>Searches for <i translate="no">className</i> using all available class loaders. Qt on Android uses a custom class loader to load all the .jar files and it must be used to find any classes that are created by that class loader because these classes are not visible when using the default class loader.</p>
<p>Returns the class pointer or null if <i translate="no">className</i> is not found.</p>
<p>A use case for this function is searching for a class to call a JNI method that takes a <code translate="no">jclass</code>. This can be useful when doing multiple JNI calls on the same class object which can a bit faster than using a class name in each call. Additionally, this call looks for internally cached classes first before doing a JNI call, and returns such a class if found. The following code snippet creates an instance of the class <code translate="no">CustomClass</code> and then calls the <code translate="no">printFromJava()</code> method:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjnienvironment.html#QJniEnvironment" translate="no">QJniEnvironment</a></span> env;
 jclass javaClass <span class="operator">=</span> env<span class="operator">.</span>findClass(<span class="string">&quot;org/qtproject/example/android/CustomClass&quot;</span>);
 <span class="type"><a href="qjniobject.html" translate="no">QJniObject</a></span> javaMessage <span class="operator">=</span> <span class="type"><a href="qjniobject.html" translate="no">QJniObject</a></span><span class="operator">::</span>fromString(<span class="string">&quot;findClass example&quot;</span>);
 <span class="type"><a href="qjniobject.html" translate="no">QJniObject</a></span><span class="operator">::</span>callStaticMethod<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span>(javaClass<span class="operator">,</span> <span class="string">&quot;printFromJava&quot;</span><span class="operator">,</span>
                                    <span class="string">&quot;(Ljava/lang/String;)V&quot;</span><span class="operator">,</span> javaMessage<span class="operator">.</span>object<span class="operator">&lt;</span>jstring<span class="operator">&gt;</span>());
</pre>
<div class="admonition note">
<p><b>Note: </b>This call returns a global reference to the class object from the internally cached classes.</p>
</div>
<!-- @@@findClass -->
<!-- $$$findField[overload1]$$$findFieldjclassconstchar*constchar* -->
<h3 class="fn" translate="no" id="findField"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">jfieldID</span> QJniEnvironment::<span class="name">findField</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>fieldName</i>, const <span class="type">char</span> *<i>signature</i>)</h3>
<p>Searches for a member field of a class <i translate="no">clazz</i>. The field is specified by its <i translate="no">fieldName</i> and <i translate="no">signature</i>.</p>
<p>Returns the field ID or <code translate="no">nullptr</code> if the field is not found.</p>
<p>A usecase for this method is searching for class fields and caching their IDs, so that they could later be used for getting/setting the fields.</p>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@findField -->
<!-- $$$findField$$$findFieldjclassconstchar* -->
<h3 class="fn" translate="no" id="findField-1"><code class="details extra" translate="no">[since 6.4]</code> template &lt;typename T&gt; <span class="type">jfieldID</span> QJniEnvironment::<span class="name">findField</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>fieldName</i>)</h3>
<p>Searches for a member field of a class <i translate="no">clazz</i>. The field is specified by its <i translate="no">fieldName</i>. The signature of the field is deduced from the template parameter.</p>
<p>Returns the field ID or <code translate="no">nullptr</code> if the field is not found.</p>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@findField -->
<!-- $$$findMethod[overload1]$$$findMethodjclassconstchar*constchar* -->
<h3 class="fn" translate="no" id="findMethod"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">jmethodID</span> QJniEnvironment::<span class="name">findMethod</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>methodName</i>, const <span class="type">char</span> *<i>signature</i>)</h3>
<p>Searches for an instance method of a class <i translate="no">clazz</i>. The method is specified by its <i translate="no">methodName</i> and <i translate="no">signature</i>.</p>
<p>Returns the method ID or <code translate="no">nullptr</code> if the method is not found.</p>
<p>A usecase for this method is searching for class methods and caching their IDs, so that they could later be used for calling the methods.</p>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@findMethod -->
<!-- $$$findMethod$$$findMethodjclassconstchar* -->
<h3 class="fn" translate="no" id="findMethod-1"><code class="details extra" translate="no">[since 6.4]</code> template &lt;typename... Args&gt; <span class="type">jmethodID</span> QJniEnvironment::<span class="name">findMethod</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>methodName</i>)</h3>
<p>Searches for an instance method of a class <i translate="no">clazz</i>. The method is specified by its <i translate="no">methodName</i>, the signature is deduced from the template parameters.</p>
<p>Returns the method ID or <code translate="no">nullptr</code> if the method is not found.</p>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@findMethod -->
<!-- $$$findStaticField[overload1]$$$findStaticFieldjclassconstchar*constchar* -->
<h3 class="fn" translate="no" id="findStaticField"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">jfieldID</span> QJniEnvironment::<span class="name">findStaticField</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>fieldName</i>, const <span class="type">char</span> *<i>signature</i>)</h3>
<p>Searches for a static field of a class <i translate="no">clazz</i>. The field is specified by its <i translate="no">fieldName</i> and <i translate="no">signature</i>.</p>
<p>Returns the field ID or <code translate="no">nullptr</code> if the field is not found.</p>
<p>A usecase for this method is searching for class fields and caching their IDs, so that they could later be used for getting/setting the fields.</p>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@findStaticField -->
<!-- $$$findStaticField$$$findStaticFieldjclassconstchar* -->
<h3 class="fn" translate="no" id="findStaticField-1"><code class="details extra" translate="no">[since 6.4]</code> template &lt;typename T&gt; <span class="type">jfieldID</span> QJniEnvironment::<span class="name">findStaticField</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>fieldName</i>)</h3>
<p>Searches for a static field of a class <i translate="no">clazz</i>. The field is specified by its <i translate="no">fieldName</i>. The signature of the field is deduced from the template parameter.</p>
<p>Returns the field ID or <code translate="no">nullptr</code> if the field is not found.</p>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@findStaticField -->
<!-- $$$findStaticMethod[overload1]$$$findStaticMethodjclassconstchar*constchar* -->
<h3 class="fn" translate="no" id="findStaticMethod"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">jmethodID</span> QJniEnvironment::<span class="name">findStaticMethod</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>methodName</i>, const <span class="type">char</span> *<i>signature</i>)</h3>
<p>Searches for a static method of a class <i translate="no">clazz</i>. The method is specified by its <i translate="no">methodName</i> and <i translate="no">signature</i>.</p>
<p>Returns the method ID or <code translate="no">nullptr</code> if the method is not found.</p>
<p>A usecase for this method is searching for class methods and caching their IDs, so that they could later be used for calling the methods.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjnienvironment.html#QJniEnvironment" translate="no">QJniEnvironment</a></span> env;
 jclass javaClass <span class="operator">=</span> env<span class="operator">.</span>findClass(<span class="string">&quot;org/qtproject/example/android/CustomClass&quot;</span>);
 jmethodID methodId <span class="operator">=</span> env<span class="operator">.</span>findStaticMethod(javaClass<span class="operator">,</span>
                                           <span class="string">&quot;staticJavaMethod&quot;</span><span class="operator">,</span>
                                           <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);
 <span class="type"><a href="qjniobject.html" translate="no">QJniObject</a></span> javaMessage <span class="operator">=</span> <span class="type"><a href="qjniobject.html" translate="no">QJniObject</a></span><span class="operator">::</span>fromString(<span class="string">&quot;findStaticMethod example&quot;</span>);
 <span class="type"><a href="qjniobject.html" translate="no">QJniObject</a></span><span class="operator">::</span>callStaticMethod<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span>(javaClass<span class="operator">,</span>
                                    methodId<span class="operator">,</span>
                                    javaMessage<span class="operator">.</span>object<span class="operator">&lt;</span>jstring<span class="operator">&gt;</span>());
</pre>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@findStaticMethod -->
<!-- $$$findStaticMethod$$$findStaticMethodjclassconstchar* -->
<h3 class="fn" translate="no" id="findStaticMethod-1"><code class="details extra" translate="no">[since 6.4]</code> template &lt;typename... Args&gt; <span class="type">jmethodID</span> QJniEnvironment::<span class="name">findStaticMethod</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>methodName</i>)</h3>
<p>Searches for an instance method of a class <i translate="no">clazz</i>. The method is specified by its <i translate="no">methodName</i>, the signature is deduced from the template parameters.</p>
<p>Returns the method ID or <code translate="no">nullptr</code> if the method is not found.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qjnienvironment.html#QJniEnvironment" translate="no">QJniEnvironment</a></span> env;
 jclass javaClass <span class="operator">=</span> env<span class="operator">.</span>findClass(<span class="string">&quot;org/qtproject/example/android/CustomClass&quot;</span>);
 jmethodID methodId <span class="operator">=</span> env<span class="operator">.</span>findStaticMethod<span class="operator">&lt;</span><span class="type">void</span><span class="operator">,</span> jstring<span class="operator">&gt;</span>(javaClass<span class="operator">,</span> <span class="string">&quot;staticJavaMethod&quot;</span>);
 <span class="type"><a href="qjniobject.html" translate="no">QJniObject</a></span> javaMessage <span class="operator">=</span> <span class="type"><a href="qjniobject.html" translate="no">QJniObject</a></span><span class="operator">::</span>fromString(<span class="string">&quot;findStaticMethod example&quot;</span>);
 <span class="type"><a href="qjniobject.html" translate="no">QJniObject</a></span><span class="operator">::</span>callStaticMethod<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span>(javaClass<span class="operator">,</span>
                                    methodId<span class="operator">,</span>
                                    javaMessage<span class="operator">.</span>object<span class="operator">&lt;</span>jstring<span class="operator">&gt;</span>());
</pre>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@findStaticMethod -->
<!-- $$$getJniEnv[overload1]$$$getJniEnv -->
<h3 class="fn" translate="no" id="getJniEnv"><code class="details extra" translate="no">[static]</code> <span class="type">JNIEnv</span> *QJniEnvironment::<span class="name">getJniEnv</span>()</h3>
<p>Returns the JNIEnv pointer for the current thread.</p>
<p>The current thread will be attached to the Java VM.</p>
<!-- @@@getJniEnv -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">bool</span> QJniEnvironment::<span class="name">isValid</span>() const</h3>
<p>Returns <code translate="no">true</code> if this instance holds a valid JNIEnv object.</p>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@isValid -->
<!-- $$$javaVM[overload1]$$$javaVM -->
<h3 class="fn" translate="no" id="javaVM"><code class="details extra" translate="no">[static]</code> <span class="type">JavaVM</span> *QJniEnvironment::<span class="name">javaVM</span>()</h3>
<p>Returns the Java VM interface for the current process. Although it might be possible to have multiple Java VMs per process, Android allows only one.</p>
<!-- @@@javaVM -->
<!-- $$$jniEnv[overload1]$$$jniEnv -->
<h3 class="fn" translate="no" id="jniEnv"><span class="type">JNIEnv</span> *QJniEnvironment::<span class="name">jniEnv</span>() const</h3>
<p>Returns the JNI Environment's <code translate="no">JNIEnv</code> pointer.</p>
<!-- @@@jniEnv -->
<!-- $$$registerNativeMethods[overload1]$$$registerNativeMethodsconstchar*constJNINativeMethod[]int -->
<h3 class="fn" translate="no" id="registerNativeMethods"><span class="type">bool</span> QJniEnvironment::<span class="name">registerNativeMethods</span>(const <span class="type">char</span> *<i>className</i>, const <span class="type">JNINativeMethod</span>[] <i>methods</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>Registers the Java methods in the array <i translate="no">methods</i> of size <i translate="no">size</i>, each of which can call native C++ functions from class <i translate="no">className</i>. These methods must be registered before any attempt to call them.</p>
<p>Returns <code translate="no">true</code> if the registration is successful, otherwise <code translate="no">false</code>.</p>
<p>Each element in the methods array consists of:</p>
<ul>
<li>The Java method name</li>
<li>Method signature</li>
<li>The C++ functions that will be executed</li>
</ul>
<pre class="cpp" translate="no">
 <span class="keyword">const</span> JNINativeMethod methods<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span>
                         {{<span class="string">&quot;callNativeOne&quot;</span><span class="operator">,</span> <span class="string">&quot;(I)V&quot;</span><span class="operator">,</span> <span class="keyword">reinterpret_cast</span><span class="operator">&lt;</span><span class="type">void</span> <span class="operator">*</span><span class="operator">&gt;</span>(fromJavaOne)}<span class="operator">,</span>
                         {<span class="string">&quot;callNativeTwo&quot;</span><span class="operator">,</span> <span class="string">&quot;(I)V&quot;</span><span class="operator">,</span> <span class="keyword">reinterpret_cast</span><span class="operator">&lt;</span><span class="type">void</span> <span class="operator">*</span><span class="operator">&gt;</span>(fromJavaTwo)}};
 <span class="type"><a href="qjnienvironment.html#QJniEnvironment" translate="no">QJniEnvironment</a></span> env;
 env<span class="operator">.</span>registerNativeMethods(<span class="string">&quot;org/qtproject/android/TestJavaClass&quot;</span><span class="operator">,</span> methods<span class="operator">,</span> <span class="number">2</span>);
</pre>
<!-- @@@registerNativeMethods -->
<!-- $$$registerNativeMethods$$$registerNativeMethodsjclassconstJNINativeMethod[]int -->
<h3 class="fn" translate="no" id="registerNativeMethods-1"><span class="type">bool</span> QJniEnvironment::<span class="name">registerNativeMethods</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">JNINativeMethod</span>[] <i>methods</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>This is an overloaded function.</p>
<p>This overload uses a previously cached jclass instance <i translate="no">clazz</i>.</p>
<pre class="cpp" translate="no">
 JNINativeMethod methods<span class="operator">[</span><span class="operator">]</span> {{<span class="string">&quot;callNativeOne&quot;</span><span class="operator">,</span> <span class="string">&quot;(I)V&quot;</span><span class="operator">,</span> <span class="keyword">reinterpret_cast</span><span class="operator">&lt;</span><span class="type">void</span> <span class="operator">*</span><span class="operator">&gt;</span>(fromJavaOne)}<span class="operator">,</span>
                            {<span class="string">&quot;callNativeTwo&quot;</span><span class="operator">,</span> <span class="string">&quot;(I)V&quot;</span><span class="operator">,</span> <span class="keyword">reinterpret_cast</span><span class="operator">&lt;</span><span class="type">void</span> <span class="operator">*</span><span class="operator">&gt;</span>(fromJavaTwo)}};
 <span class="type"><a href="qjnienvironment.html#QJniEnvironment" translate="no">QJniEnvironment</a></span> env;
 jclass clazz <span class="operator">=</span> env<span class="operator">.</span>findClass(<span class="string">&quot;org/qtproject/android/TestJavaClass&quot;</span>);
 env<span class="operator">.</span>registerNativeMethods(clazz<span class="operator">,</span> methods<span class="operator">,</span> <span class="number">2</span>);
</pre>
<!-- @@@registerNativeMethods -->
<!-- $$$registerNativeMethods$$$registerNativeMethodsconstchar*std::initializer_list<JNINativeMethod> -->
<h3 class="fn" translate="no" id="registerNativeMethods-2"><span class="type">bool</span> QJniEnvironment::<span class="name">registerNativeMethods</span>(const <span class="type">char</span> *<i>className</i>, <span class="type">std::initializer_list</span>&lt;<span class="type">JNINativeMethod</span>&gt; <i>methods</i>)</h3>
<p>This is an overloaded function.</p>
<p>Registers the native functions methods in <i translate="no">methods</i> for the Java class <i translate="no">className</i>. Returns <code translate="no">true</code> if the registration is successful, otherwise <code translate="no">false</code>.</p>
<!-- @@@registerNativeMethods -->
<!-- $$$registerNativeMethods$$$registerNativeMethodsjclassstd::initializer_list<JNINativeMethod> -->
<h3 class="fn" translate="no" id="registerNativeMethods-3"><span class="type">bool</span> QJniEnvironment::<span class="name">registerNativeMethods</span>(<span class="type">jclass</span> <i>clazz</i>, <span class="type">std::initializer_list</span>&lt;<span class="type">JNINativeMethod</span>&gt; <i>methods</i>)</h3>
<p>This is an overloaded function.</p>
<p>Registers the native functions methods in <i translate="no">methods</i> for the Java class <i translate="no">clazz</i>. Returns <code translate="no">true</code> if the registration is successful, otherwise <code translate="no">false</code>.</p>
<!-- @@@registerNativeMethods -->
<!-- $$$operator*[overload1]$$$operator* -->
<h3 class="fn" translate="no" id="operator-2a"><span class="type">JNIEnv</span> &amp;QJniEnvironment::<span class="name">operator*</span>() const</h3>
<p>Returns the JNI Environment's <code translate="no">JNIEnv</code> object.</p>
<!-- @@@operator* -->
<!-- $$$operator->[overload1]$$$operator-> -->
<h3 class="fn" translate="no" id="operator--gt"><span class="type">JNIEnv</span> *QJniEnvironment::<span class="name">operator-&gt;</span>() const</h3>
<p>Provides access to the JNI Environment's <code translate="no">JNIEnv</code> pointer.</p>
<!-- @@@operator-> -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
