<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qstring.cpp -->
  <meta name="description" content="The QString class provides a Unicode character string.">
  <title>QString Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QString</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#initializing-a-string">Initializing a string</a></li>
<li class="level2"><a href="#manipulating-string-data">Manipulating string data</a></li>
<li class="level2"><a href="#querying-string-data">Querying string data</a></li>
<li class="level2"><a href="#converting-between-encoded-string-data-and-qstring">Converting between encoded string data and QString</a></li>
<li class="level2"><a href="#distinction-between-null-and-empty-strings">Distinction between null and empty strings</a></li>
<li class="level2"><a href="#number-formats">Number formats</a></li>
<li class="level2"><a href="#more-efficient-string-construction">More efficient string construction</a></li>
<li class="level2"><a href="#maximum-size-and-out-of-memory-conditions">Maximum size and out-of-memory conditions</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QString Class</h1>
<!-- $$$QString-brief -->
<p>The QString class provides a Unicode character string. <a href="#details">More...</a></p>
<!-- @@@QString -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QString&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qstring-members.html">List of all members, including inherited members</a></li>
<li><a href="qstring-obsolete.html">Deprecated members</a></li>
<li>QString is part of <a href="shared.html">Implicitly Shared Classes</a> and <a href="../qtdoc/string-processing.html">Classes for String Data</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#ConstIterator-typedef" translate="no">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#Iterator-typedef" translate="no">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#NormalizationForm-enum" translate="no">NormalizationForm</a></b> { NormalizationForm_D, NormalizationForm_C, NormalizationForm_KD, NormalizationForm_KC }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#SectionFlag-enum" translate="no">SectionFlag</a></b> { SectionDefault, SectionSkipEmpty, SectionIncludeLeadingSep, SectionIncludeTrailingSep, SectionCaseInsensitiveSeps }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#SectionFlag-enum" translate="no">SectionFlags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#const_iterator-typedef" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#const_pointer-typedef" translate="no">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#const_reference-typedef" translate="no">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#iterator-typedefx" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#pointer-typedef" translate="no">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#reference-typedef" translate="no">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#reverse_iterator-typedef" translate="no">reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#value_type-typedef" translate="no">value_type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString" translate="no">QString</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-1" translate="no">QString</a></b>(const QChar *<i>unicode</i>, qsizetype <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-2" translate="no">QString</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-3" translate="no">QString</a></b>(qsizetype <i>size</i>, QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-4" translate="no">QString</a></b>(QLatin1StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-5" translate="no">QString</a></b>(const int *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-8" translate="no">QString</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-9" translate="no">QString</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-6" translate="no">QString</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-7" translate="no">QString</a></b>(QString &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#dtor.QString" translate="no">~QString</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append" translate="no">append</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-1" translate="no">append</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-2" translate="no">append</a></b>(const QChar *<i>str</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-3" translate="no">append</a></b>(QStringView <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-4" translate="no">append</a></b>(QLatin1StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-5" translate="no">append</a></b>(QUtf8StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-6" translate="no">append</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-7" translate="no">append</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg" translate="no">arg</a></b>(const QString &amp;<i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-1" translate="no">arg</a></b>(qlonglong <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-2" translate="no">arg</a></b>(qulonglong <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-3" translate="no">arg</a></b>(long <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-4" translate="no">arg</a></b>(ulong <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-5" translate="no">arg</a></b>(int <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-6" translate="no">arg</a></b>(uint <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-7" translate="no">arg</a></b>(short <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-8" translate="no">arg</a></b>(ushort <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-9" translate="no">arg</a></b>(double <i>a</i>, int <i>fieldWidth</i> = 0, char <i>format</i> = 'g', int <i>precision</i> = -1, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-10" translate="no">arg</a></b>(char <i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-11" translate="no">arg</a></b>(QChar <i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-12" translate="no">arg</a></b>(QStringView <i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-13" translate="no">arg</a></b>(QLatin1StringView <i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = u' ') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-14" translate="no">arg</a></b>(Args &amp;&amp;... <i>args</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#assign" translate="no">assign</a></b>(QAnyStringView <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#assign-1" translate="no">assign</a></b>(qsizetype <i>n</i>, QChar <i>c</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#assign-2" translate="no">assign</a></b>(InputIterator <i>first</i>, InputIterator <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#at" translate="no">at</a></b>(qsizetype <i>position</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#back" translate="no">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#back-1" translate="no">back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#capacity" translate="no">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#chop" translate="no">chop</a></b>(qsizetype <i>n</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#chopped" translate="no">chopped</a></b>(qsizetype <i>len</i>) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#chopped-1" translate="no">chopped</a></b>(qsizetype <i>len</i>) &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-1" translate="no">compare</a></b>(const QString &amp;<i>other</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-2" translate="no">compare</a></b>(QLatin1StringView <i>other</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-3" translate="no">compare</a></b>(QStringView <i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-4" translate="no">compare</a></b>(QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#constData" translate="no">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains" translate="no">contains</a></b>(const QString &amp;<i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-1" translate="no">contains</a></b>(QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-2" translate="no">contains</a></b>(QLatin1StringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-3" translate="no">contains</a></b>(QStringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-4" translate="no">contains</a></b>(const QRegularExpression &amp;<i>re</i>, QRegularExpressionMatch *<i>rmatch</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count" translate="no">count</a></b>(const QString &amp;<i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count-2" translate="no">count</a></b>(QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count-3" translate="no">count</a></b>(QStringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count-4" translate="no">count</a></b>(const QRegularExpression &amp;<i>re</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#crbegin" translate="no">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#crend" translate="no">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#data" translate="no">data</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#data-1" translate="no">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#endsWith" translate="no">endsWith</a></b>(const QString &amp;<i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#endsWith-1" translate="no">endsWith</a></b>(QStringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#endsWith-2" translate="no">endsWith</a></b>(QLatin1StringView <i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#endsWith-3" translate="no">endsWith</a></b>(QChar <i>c</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QString::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#erase" translate="no">erase</a></b>(QString::const_iterator <i>first</i>, QString::const_iterator <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QString::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#erase-1" translate="no">erase</a></b>(QString::const_iterator <i>it</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fill" translate="no">fill</a></b>(QChar <i>ch</i>, qsizetype <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#first" translate="no">first</a></b>(qsizetype <i>n</i>) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#first-1" translate="no">first</a></b>(qsizetype <i>n</i>) &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#front" translate="no">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#front-1" translate="no">front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf" translate="no">indexOf</a></b>(QLatin1StringView <i>str</i>, qsizetype <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-1" translate="no">indexOf</a></b>(QChar <i>ch</i>, qsizetype <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-2" translate="no">indexOf</a></b>(const QString &amp;<i>str</i>, qsizetype <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-3" translate="no">indexOf</a></b>(QStringView <i>str</i>, qsizetype <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-4" translate="no">indexOf</a></b>(const QRegularExpression &amp;<i>re</i>, qsizetype <i>from</i> = 0, QRegularExpressionMatch *<i>rmatch</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert" translate="no">insert</a></b>(qsizetype <i>position</i>, const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-1" translate="no">insert</a></b>(qsizetype <i>position</i>, QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-2" translate="no">insert</a></b>(qsizetype <i>position</i>, const QChar *<i>unicode</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-3" translate="no">insert</a></b>(qsizetype <i>position</i>, QStringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-4" translate="no">insert</a></b>(qsizetype <i>position</i>, QLatin1StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-5" translate="no">insert</a></b>(qsizetype <i>position</i>, QUtf8StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-6" translate="no">insert</a></b>(qsizetype <i>position</i>, const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-7" translate="no">insert</a></b>(qsizetype <i>position</i>, const QByteArray &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isLower" translate="no">isLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isNull" translate="no">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isRightToLeft" translate="no">isRightToLeft</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isUpper" translate="no">isUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isValidUtf16" translate="no">isValidUtf16</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#last" translate="no">last</a></b>(qsizetype <i>n</i>) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#last-1" translate="no">last</a></b>(qsizetype <i>n</i>) &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf" translate="no">lastIndexOf</a></b>(const QString &amp;<i>str</i>, qsizetype <i>from</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-1" translate="no">lastIndexOf</a></b>(QChar <i>c</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-2" translate="no">lastIndexOf</a></b>(QChar <i>ch</i>, qsizetype <i>from</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-3" translate="no">lastIndexOf</a></b>(QLatin1StringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-4" translate="no">lastIndexOf</a></b>(QLatin1StringView <i>str</i>, qsizetype <i>from</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-5" translate="no">lastIndexOf</a></b>(const QString &amp;<i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-6" translate="no">lastIndexOf</a></b>(QStringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-7" translate="no">lastIndexOf</a></b>(QStringView <i>str</i>, qsizetype <i>from</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-8" translate="no">lastIndexOf</a></b>(const QRegularExpression &amp;<i>re</i>, QRegularExpressionMatch *<i>rmatch</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-9" translate="no">lastIndexOf</a></b>(const QRegularExpression &amp;<i>re</i>, qsizetype <i>from</i>, QRegularExpressionMatch *<i>rmatch</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#left" translate="no">left</a></b>(qsizetype <i>n</i>) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#left-1" translate="no">left</a></b>(qsizetype <i>n</i>) &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#leftJustified" translate="no">leftJustified</a></b>(qsizetype <i>width</i>, QChar <i>fill</i> = u' ', bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#length" translate="no">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#localeAwareCompare-1" translate="no">localeAwareCompare</a></b>(const QString &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#localeAwareCompare-2" translate="no">localeAwareCompare</a></b>(QStringView <i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#mid" translate="no">mid</a></b>(qsizetype <i>position</i>, qsizetype <i>n</i> = -1) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#mid-1" translate="no">mid</a></b>(qsizetype <i>position</i>, qsizetype <i>n</i> = -1) &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#normalized" translate="no">normalized</a></b>(QString::NormalizationForm <i>mode</i>, QChar::UnicodeVersion <i>version</i> = QChar::Unicode_Unassigned) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend" translate="no">prepend</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-1" translate="no">prepend</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-2" translate="no">prepend</a></b>(const QChar *<i>str</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-3" translate="no">prepend</a></b>(QStringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-4" translate="no">prepend</a></b>(QLatin1StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-5" translate="no">prepend</a></b>(QUtf8StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-6" translate="no">prepend</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-7" translate="no">prepend</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#push_back" translate="no">push_back</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#push_back-1" translate="no">push_back</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#push_front" translate="no">push_front</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#push_front-1" translate="no">push_front</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rbegin" translate="no">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rbegin-1" translate="no">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove" translate="no">remove</a></b>(qsizetype <i>position</i>, qsizetype <i>n</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove-1" translate="no">remove</a></b>(QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove-2" translate="no">remove</a></b>(QLatin1StringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove-3" translate="no">remove</a></b>(const QString &amp;<i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove-4" translate="no">remove</a></b>(const QRegularExpression &amp;<i>re</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#removeAt" translate="no">removeAt</a></b>(qsizetype <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#removeFirst" translate="no">removeFirst</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#removeIf" translate="no">removeIf</a></b>(Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#removeLast" translate="no">removeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rend" translate="no">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rend-1" translate="no">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#repeated" translate="no">repeated</a></b>(qsizetype <i>times</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace" translate="no">replace</a></b>(qsizetype <i>position</i>, qsizetype <i>n</i>, const QString &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-1" translate="no">replace</a></b>(qsizetype <i>position</i>, qsizetype <i>n</i>, QChar <i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-2" translate="no">replace</a></b>(qsizetype <i>position</i>, qsizetype <i>n</i>, const QChar *<i>after</i>, qsizetype <i>alen</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-3" translate="no">replace</a></b>(QChar <i>before</i>, QChar <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-4" translate="no">replace</a></b>(const QChar *<i>before</i>, qsizetype <i>blen</i>, const QChar *<i>after</i>, qsizetype <i>alen</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-5" translate="no">replace</a></b>(QLatin1StringView <i>before</i>, QLatin1StringView <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-6" translate="no">replace</a></b>(QLatin1StringView <i>before</i>, const QString &amp;<i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-7" translate="no">replace</a></b>(const QString &amp;<i>before</i>, QLatin1StringView <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-8" translate="no">replace</a></b>(const QString &amp;<i>before</i>, const QString &amp;<i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-9" translate="no">replace</a></b>(QChar <i>ch</i>, const QString &amp;<i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-10" translate="no">replace</a></b>(QChar <i>c</i>, QLatin1StringView <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-11" translate="no">replace</a></b>(const QRegularExpression &amp;<i>re</i>, const QString &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#reserve" translate="no">reserve</a></b>(qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#resize" translate="no">resize</a></b>(qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#resize-1" translate="no">resize</a></b>(qsizetype <i>newSize</i>, QChar <i>fillChar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#right" translate="no">right</a></b>(qsizetype <i>n</i>) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#right-1" translate="no">right</a></b>(qsizetype <i>n</i>) &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rightJustified" translate="no">rightJustified</a></b>(qsizetype <i>width</i>, QChar <i>fill</i> = u' ', bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#section" translate="no">section</a></b>(QChar <i>sep</i>, qsizetype <i>start</i>, qsizetype <i>end</i> = -1, QString::SectionFlags <i>flags</i> = SectionDefault) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#section-1" translate="no">section</a></b>(const QString &amp;<i>sep</i>, qsizetype <i>start</i>, qsizetype <i>end</i> = -1, QString::SectionFlags <i>flags</i> = SectionDefault) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#section-2" translate="no">section</a></b>(const QRegularExpression &amp;<i>re</i>, qsizetype <i>start</i>, qsizetype <i>end</i> = -1, QString::SectionFlags <i>flags</i> = SectionDefault) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum" translate="no">setNum</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-1" translate="no">setNum</a></b>(short <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-2" translate="no">setNum</a></b>(ushort <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-3" translate="no">setNum</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-4" translate="no">setNum</a></b>(long <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-5" translate="no">setNum</a></b>(ulong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-6" translate="no">setNum</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-7" translate="no">setNum</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-8" translate="no">setNum</a></b>(float <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-9" translate="no">setNum</a></b>(double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setRawData" translate="no">setRawData</a></b>(const QChar *<i>unicode</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setUnicode" translate="no">setUnicode</a></b>(const QChar *<i>unicode</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setUtf16" translate="no">setUtf16</a></b>(const ushort *<i>unicode</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#shrink_to_fit" translate="no">shrink_to_fit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#simplified" translate="no">simplified</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#sliced" translate="no">sliced</a></b>(qsizetype <i>pos</i>, qsizetype <i>n</i>) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#sliced-1" translate="no">sliced</a></b>(qsizetype <i>pos</i>) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#sliced-2" translate="no">sliced</a></b>(qsizetype <i>pos</i>) &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#sliced-3" translate="no">sliced</a></b>(qsizetype <i>pos</i>, qsizetype <i>n</i>) &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#split" translate="no">split</a></b>(const QString &amp;<i>sep</i>, Qt::SplitBehavior <i>behavior</i> = Qt::KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#split-1" translate="no">split</a></b>(QChar <i>sep</i>, Qt::SplitBehavior <i>behavior</i> = Qt::KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#split-2" translate="no">split</a></b>(const QRegularExpression &amp;<i>re</i>, Qt::SplitBehavior <i>behavior</i> = Qt::KeepEmptyParts) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#squeeze" translate="no">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#startsWith" translate="no">startsWith</a></b>(const QString &amp;<i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#startsWith-1" translate="no">startsWith</a></b>(QStringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#startsWith-2" translate="no">startsWith</a></b>(QLatin1StringView <i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#startsWith-3" translate="no">startsWith</a></b>(QChar <i>c</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#swap" translate="no">swap</a></b>(QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CFStringRef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toCFString" translate="no">toCFString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toCaseFolded" translate="no">toCaseFolded</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toDouble" translate="no">toDouble</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> emscripten::val </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toEcmaString" translate="no">toEcmaString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toFloat" translate="no">toFloat</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toHtmlEscaped" translate="no">toHtmlEscaped</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toInt" translate="no">toInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLatin1" translate="no">toLatin1</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> long </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLong" translate="no">toLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qlonglong </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLongLong" translate="no">toLongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLower" translate="no">toLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> NSString *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toNSString" translate="no">toNSString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> short </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toShort" translate="no">toShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::string </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toStdString" translate="no">toStdString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::u16string </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toStdU16String" translate="no">toStdU16String</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::u32string </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toStdU32String" translate="no">toStdU32String</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::wstring </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toStdWString" translate="no">toStdWString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUInt" translate="no">toUInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ulong </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toULong" translate="no">toULong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qulonglong </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toULongLong" translate="no">toULongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ushort </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUShort" translate="no">toUShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;uint&gt; </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUcs4" translate="no">toUcs4</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUpper" translate="no">toUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUtf8" translate="no">toUtf8</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toWCharArray" translate="no">toWCharArray</a></b>(wchar_t *<i>array</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> decltype(qTokenize(*this, std::forward&lt;Needle&gt;(needle), flags...)) </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#tokenize" translate="no">tokenize</a></b>(Needle &amp;&amp;<i>sep</i>, Flags... <i>flags</i>) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> decltype(qTokenize(std::move(*this), std::forward&lt;Needle&gt;(needle), flags...)) </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#tokenize-1" translate="no">tokenize</a></b>(Needle &amp;&amp;<i>sep</i>, Flags... <i>flags</i>) const &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> decltype(qTokenize(std::move(*this), std::forward&lt;Needle&gt;(needle), flags...)) </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#tokenize-2" translate="no">tokenize</a></b>(Needle &amp;&amp;<i>sep</i>, Flags... <i>flags</i>) &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#trimmed" translate="no">trimmed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#truncate" translate="no">truncate</a></b>(qsizetype <i>position</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#unicode" translate="no">unicode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const ushort *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#utf16" translate="no">utf16</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> std::u16string_view </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-std-3a-3au16string_view" translate="no">operator std::u16string_view</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq-9" translate="no">operator!=</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq-10" translate="no">operator!=</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq" translate="no">operator+=</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-1" translate="no">operator+=</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-2" translate="no">operator+=</a></b>(QStringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-3" translate="no">operator+=</a></b>(QLatin1StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-4" translate="no">operator+=</a></b>(QUtf8StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-5" translate="no">operator+=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-6" translate="no">operator+=</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-9" translate="no">operator&lt;</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-10" translate="no">operator&lt;</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq-9" translate="no">operator&lt;=</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq-10" translate="no">operator&lt;=</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq" translate="no">operator=</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-1" translate="no">operator=</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-2" translate="no">operator=</a></b>(QLatin1StringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-3" translate="no">operator=</a></b>(QString &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-4" translate="no">operator=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-5" translate="no">operator=</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-9" translate="no">operator==</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-10" translate="no">operator==</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-9" translate="no">operator&gt;</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-10" translate="no">operator&gt;</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq-9" translate="no">operator&gt;=</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq-10" translate="no">operator&gt;=</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-5b-5d" translate="no">operator[]</a></b>(qsizetype <i>position</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-5b-5d-1" translate="no">operator[]</a></b>(qsizetype <i>position</i>) const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#asprintf" translate="no">asprintf</a></b>(const char *<i>cformat</i>, ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare" translate="no">compare</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-5" translate="no">compare</a></b>(const QString &amp;<i>s1</i>, QLatin1StringView <i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-6" translate="no">compare</a></b>(QLatin1StringView <i>s1</i>, const QString &amp;<i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-7" translate="no">compare</a></b>(const QString &amp;<i>s1</i>, QStringView <i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-8" translate="no">compare</a></b>(QStringView <i>s1</i>, const QString &amp;<i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromCFString" translate="no">fromCFString</a></b>(CFStringRef <i>string</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromEcmaString" translate="no">fromEcmaString</a></b>(emscripten::val <i>jsString</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLatin1" translate="no">fromLatin1</a></b>(const char *<i>str</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLatin1-1" translate="no">fromLatin1</a></b>(QByteArrayView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLatin1-2" translate="no">fromLatin1</a></b>(const QByteArray &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a></b>(const char *<i>str</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLocal8Bit-1" translate="no">fromLocal8Bit</a></b>(QByteArrayView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLocal8Bit-2" translate="no">fromLocal8Bit</a></b>(const QByteArray &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromNSString" translate="no">fromNSString</a></b>(const NSString *<i>string</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromRawData" translate="no">fromRawData</a></b>(const QChar *<i>unicode</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromStdString" translate="no">fromStdString</a></b>(const std::string &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromStdU16String" translate="no">fromStdU16String</a></b>(const std::u16string &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromStdU32String" translate="no">fromStdU32String</a></b>(const std::u32string &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromStdWString" translate="no">fromStdWString</a></b>(const std::wstring &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUcs4" translate="no">fromUcs4</a></b>(const char32_t *<i>unicode</i>, qsizetype <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf8" translate="no">fromUtf8</a></b>(const char *<i>str</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf8-1" translate="no">fromUtf8</a></b>(QByteArrayView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf8-2" translate="no">fromUtf8</a></b>(const QByteArray &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf8-3" translate="no">fromUtf8</a></b>(const int *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf8-4" translate="no">fromUtf8</a></b>(const int *<i>str</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf16" translate="no">fromUtf16</a></b>(const char16_t *<i>unicode</i>, qsizetype <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromWCharArray" translate="no">fromWCharArray</a></b>(const wchar_t *<i>string</i>, qsizetype <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#localeAwareCompare" translate="no">localeAwareCompare</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#localeAwareCompare-3" translate="no">localeAwareCompare</a></b>(QStringView <i>s1</i>, QStringView <i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number" translate="no">number</a></b>(long <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-1" translate="no">number</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-2" translate="no">number</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-3" translate="no">number</a></b>(ulong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-4" translate="no">number</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-5" translate="no">number</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-6" translate="no">number</a></b>(double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#vasprintf" translate="no">vasprintf</a></b>(const char *<i>cformat</i>, va_list <i>ap</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#erase-3" translate="no">erase</a></b>(QString &amp;<i>s</i>, const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#erase_if-1" translate="no">erase_if</a></b>(QString &amp;<i>s</i>, Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq" translate="no">operator!=</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq-1" translate="no">operator!=</a></b>(const QString &amp;<i>s1</i>, QLatin1StringView <i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq-11" translate="no">operator!=</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-22-22_s" translate="no">operator&quot;&quot;_s</a></b>(const char16_t *<i>str</i>, size_t <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b" translate="no">operator+</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-1" translate="no">operator+</a></b>(QString &amp;&amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-2" translate="no">operator+</a></b>(const QString &amp;<i>s1</i>, const char *<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-3" translate="no">operator+</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-1" translate="no">operator&lt;</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-2" translate="no">operator&lt;</a></b>(const QString &amp;<i>s1</i>, QLatin1StringView <i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-3" translate="no">operator&lt;</a></b>(QLatin1StringView <i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-11" translate="no">operator&lt;</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-lt-8" translate="no">operator&lt;&lt;</a></b>(QDataStream &amp;<i>stream</i>, const QString &amp;<i>string</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq" translate="no">operator&lt;=</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq-1" translate="no">operator&lt;=</a></b>(const QString &amp;<i>s1</i>, QLatin1StringView <i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq-2" translate="no">operator&lt;=</a></b>(QLatin1StringView <i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq-11" translate="no">operator&lt;=</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-1" translate="no">operator==</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-2" translate="no">operator==</a></b>(const QString &amp;<i>s1</i>, QLatin1StringView <i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-3" translate="no">operator==</a></b>(QLatin1StringView <i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-11" translate="no">operator==</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt" translate="no">operator&gt;</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-1" translate="no">operator&gt;</a></b>(const QString &amp;<i>s1</i>, QLatin1StringView <i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-2" translate="no">operator&gt;</a></b>(QLatin1StringView <i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-11" translate="no">operator&gt;</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq" translate="no">operator&gt;=</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq-1" translate="no">operator&gt;=</a></b>(const QString &amp;<i>s1</i>, QLatin1StringView <i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq-2" translate="no">operator&gt;=</a></b>(QLatin1StringView <i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq-11" translate="no">operator&gt;=</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-gt-3" translate="no">operator&gt;&gt;</a></b>(QDataStream &amp;<i>stream</i>, QString &amp;<i>string</i>)</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QStringLiteral" translate="no">QStringLiteral</a></b>(<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QT_NO_CAST_TO_ASCII" translate="no">QT_NO_CAST_TO_ASCII</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII" translate="no">QT_RESTRICTED_CAST_FROM_ASCII</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#qPrintable" translate="no">qPrintable</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const wchar_t *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#qUtf16Printable" translate="no">qUtf16Printable</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#qUtf8Printable" translate="no">qUtf8Printable</a></b>(const QString &amp;<i>str</i>)</td></tr>
</table></div>
<!-- $$$QString-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QString stores a string of 16-bit <a href="qchar.html" translate="no">QChar</a>s, where each <a href="qchar.html" translate="no">QChar</a> corresponds to one UTF-16 code unit. (Unicode characters with code values above 65535 are stored using surrogate pairs, that is, two consecutive <a href="qchar.html" translate="no">QChar</a>s.)</p>
<p><a href="../qtdoc/unicode.html" translate="no">Unicode</a> is an international standard that supports most of the writing systems in use today. It is a superset of US-ASCII (ANSI X3.4-1986) and Latin-1 (ISO 8859-1), and all the US-ASCII/Latin-1 characters are available at the same code positions.</p>
<p>Behind the scenes, QString uses <a href="implicit-sharing.html" translate="no">implicit sharing</a> (copy-on-write) to reduce memory usage and to avoid the needless copying of data. This also helps reduce the inherent overhead of storing 16-bit characters instead of 8-bit characters.</p>
<p>In addition to QString, Qt also provides the <a href="qbytearray.html" translate="no">QByteArray</a> class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, QString is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications are easy to translate if you want to expand your application's market at some point. Two prominent cases where <a href="qbytearray.html" translate="no">QByteArray</a> is appropriate are when you need to store raw binary data, and when memory conservation is critical (like in embedded systems).</p>
<h3 id="initializing-a-string">Initializing a string</h3>
<p>One way to initialize a QString is to pass a <code translate="no">const char *</code> to its constructor. For example, the following code creates a QString of size 5 containing the data &quot;Hello&quot;:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;
</pre>
<p>QString converts the <code translate="no">const char *</code> data into Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>In all of the QString functions that take <code translate="no">const char *</code> parameters, the <code translate="no">const char *</code> is interpreted as a classic C-style <code translate="no">'\\0'</code>-terminated string. Except where the function's name overtly indicates some other encoding, such <code translate="no">const char *</code> parameters are assumed to be encoded in UTF-8.</p>
<p>You can also provide string data as an array of <a href="qchar.html" translate="no">QChar</a>s:</p>
<pre class="cpp" translate="no">
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span> data<span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> { <span class="number">0x0055</span><span class="operator">,</span> <span class="number">0x006e</span><span class="operator">,</span> <span class="number">0x10e3</span><span class="operator">,</span> <span class="number">0x03a3</span> };
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str(data<span class="operator">,</span> <span class="number">4</span>);
</pre>
<p>QString makes a deep copy of the <a href="qchar.html" translate="no">QChar</a> data, so you can modify it later without experiencing side effects. You can avoid taking a deep copy of the character data by using <a href="qstringview.html" translate="no">QStringView</a> or <a href="qstring.html#fromRawData" translate="no">QString::fromRawData</a>() instead.</p>
<p>Another approach is to set the size of the string using <a href="qstring.html#resize" translate="no">resize</a>() and to initialize the data character per character. QString uses 0-based indexes, just like C++ arrays. To access the character at a particular index position, you can use <a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>(). On non-<code translate="no">const</code> strings, <a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>() returns a reference to a character that can be used on the left side of an assignment. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;
 str<span class="operator">.</span>resize(<span class="number">4</span>);

 str<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="char">'U'</span>);
 str<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="char">'n'</span>);
 str<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="number">0x10e3</span>);
 str<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="number">0x03a3</span>);
</pre>
<p>For read-only access, an alternative syntax is to use the <a href="qstring.html#at" translate="no">at</a>() function:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;

 <span class="keyword">for</span> (qsizetype i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> str<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i) {
     <span class="keyword">if</span> (str<span class="operator">.</span>at(i) <span class="operator">&gt;</span><span class="operator">=</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="char">'a'</span>) <span class="operator">&amp;</span><span class="operator">&amp;</span> str<span class="operator">.</span>at(i) <span class="operator">&lt;</span><span class="operator">=</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="char">'f'</span>))
         <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Found character in range [a-f]&quot;</span>;
 }
</pre>
<p>The <a href="qstring.html#at" translate="no">at</a>() function can be faster than <a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>() because it never causes a <a href="implicit-sharing.html#deep-copy" translate="no">deep copy</a> to occur. Alternatively, use the <a href="qstring.html#first" translate="no">first</a>(), <a href="qstring.html#last" translate="no">last</a>(), or <a href="qstring.html#sliced" translate="no">sliced</a>() functions to extract several characters at a time.</p>
<p>A QString can embed '\0' characters (<a href="qchar.html#SpecialCharacter-enum" translate="no">QChar::Null</a>). The <a href="qstring.html#size" translate="no">size</a>() function always returns the size of the whole string, including embedded '\0' characters.</p>
<p>After a call to the <a href="qstring.html#resize" translate="no">resize</a>() function, newly allocated characters have undefined values. To set all the characters in the string to a particular value, use the <a href="qstring.html#fill" translate="no">fill</a>() function.</p>
<p>QString provides dozens of overloads designed to simplify string usage. For example, if you want to compare a QString with a string literal, you can write code like this and it will work as expected:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;

 <span class="keyword">if</span> (str <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;auto&quot;</span> <span class="operator">|</span><span class="operator">|</span> str <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;extern&quot;</span>
         <span class="operator">|</span><span class="operator">|</span> str <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;static&quot;</span> <span class="operator">|</span><span class="operator">|</span> str <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;register&quot;</span>) {
     <span class="comment">// ...</span>
 }
</pre>
<p>You can also pass string literals to functions that take QStrings as arguments, invoking the QString(const char *) constructor. Similarly, you can pass a QString to a function that takes a <code translate="no">const char *</code> argument using the <a href="qstring.html#qPrintable" translate="no">qPrintable</a>() macro, which returns the given QString as a <code translate="no">const char *</code>. This is equivalent to calling &lt;QString&gt;.<a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>().<a href="qstring.html#constData" translate="no">constData</a>().</p>
<h3 id="manipulating-string-data">Manipulating string data</h3>
<p>QString provides the following basic functions for modifying the character data: <a href="qstring.html#append" translate="no">append</a>(), <a href="qstring.html#prepend" translate="no">prepend</a>(), <a href="qstring.html#insert" translate="no">insert</a>(), <a href="qstring.html#replace" translate="no">replace</a>(), and <a href="qstring.html#remove" translate="no">remove</a>(). For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;and&quot;</span>;
 str<span class="operator">.</span>prepend(<span class="string">&quot;rock &quot;</span>);     <span class="comment">// str == &quot;rock and&quot;</span>
 str<span class="operator">.</span>append(<span class="string">&quot; roll&quot;</span>);        <span class="comment">// str == &quot;rock and roll&quot;</span>
 str<span class="operator">.</span>replace(<span class="number">5</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="string">&quot;&amp;&quot;</span>);   <span class="comment">// str == &quot;rock &amp; roll&quot;</span>
</pre>
<p>In the above example, the <a href="qstring.html#replace" translate="no">replace</a>() function's first two arguments are the position from which to start replacing and the number of characters that should be replaced.</p>
<p>When data-modifying functions increase the size of the string, QString may reallocate the memory in which it holds its data. When this happens, QString expands by more than it immediately needs so as to have space for further expansion without reallocation until the size of the string has significantly increased.</p>
<p>The <a href="qstring.html#insert" translate="no">insert</a>(), <a href="qstring.html#remove" translate="no">remove</a>(), and, when replacing a sub-string with one of different size, <a href="qstring.html#replace" translate="no">replace</a>() functions can be slow (<a href="containers.html#linear-time" translate="no">linear time</a>) for large strings because they require moving many characters in the string by at least one position in memory.</p>
<p>If you are building a QString gradually and know in advance approximately how many characters the QString will contain, you can call <a href="qstring.html#reserve" translate="no">reserve</a>(), asking QString to preallocate a certain amount of memory. You can also call <a href="qstring.html#capacity" translate="no">capacity</a>() to find out how much memory the QString actually has allocated.</p>
<p>QString provides <a href="containers.html#stl-style-iterators" translate="no">STL-style iterators</a> (<a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a> and <a href="qstring.html#iterator-typedefx" translate="no">QString::iterator</a>). In practice, iterators are handy when working with generic algorithms provided by the C++ standard library.</p>
<div class="admonition note">
<p><b>Note: </b>Iterators over a QString, and references to individual characters within one, cannot be relied on to remain valid when any non-<code translate="no">const</code> method of the QString is called. Accessing such an iterator or reference after the call to a non-<code translate="no">const</code> method leads to undefined behavior. When stability for iterator-like functionality is required, you should use indexes instead of iterators, as they are not tied to QString's internal state and thus do not get invalidated.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Due to <a href="implicit-sharing.html" translate="no">implicit sharing</a>, the first non-<code translate="no">const</code> operator or function used on a given QString may cause it to internally perform a deep copy of its data. This invalidates all iterators over the string and references to individual characters within it. Do not call non-const functions while keeping iterators. Accessing an iterator or reference after it has been invalidated leads to undefined behavior. See the <a href="containers.html#implicit-sharing-iterator-problem" translate="no">Implicit sharing iterator problem</a> section for more information.</p>
</div>
<p>A frequent requirement is to remove or simplify the spacing between visible characters in a string. The characters that make up that spacing are those for which <a href="qchar.html#isSpace" translate="no">isSpace</a>() returns <code translate="no">true</code>, such as the simple space <code translate="no">' '</code>, the horizontal tab <code translate="no">'\\t'</code> and the newline <code translate="no">'\\n'</code>. To obtain a copy of a string leaving out any spacing from its start and end, use <a href="qstring.html#trimmed" translate="no">trimmed</a>(). To also replace each sequence of spacing characters within the string with a simple space, <code translate="no">' '</code>, use <a href="qstring.html#simplified" translate="no">simplified</a>().</p>
<p>If you want to find all occurrences of a particular character or substring in a QString, use the <a href="qstring.html#indexOf" translate="no">indexOf</a>() or <a href="qstring.html#lastIndexOf" translate="no">lastIndexOf</a>() functions.The former searches forward, the latter searches backward. Either can be told an index position from which to start their search. Each returns the index position of the character or substring if they find it; otherwise, they return -1. For example, here is a typical loop that finds all occurrences of a particular substring:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;&quot;</span>;
 qsizetype j <span class="operator">=</span> <span class="number">0</span>;

 <span class="keyword">while</span> ((j <span class="operator">=</span> str<span class="operator">.</span>indexOf(<span class="string">&quot;&lt;b&gt;&quot;</span><span class="operator">,</span> j)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Found &lt;b&gt; tag at index position&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> j;
     <span class="operator">+</span><span class="operator">+</span>j;
 }
</pre>
<p>QString provides many functions for converting numbers into strings and strings into numbers. See the <a href="qstring.html#arg" translate="no">arg</a>() functions, the <a href="qstring.html#setNum" translate="no">setNum</a>() functions, the <a href="qstring.html#number" translate="no">number</a>() static functions, and the <a href="qstring.html#toInt" translate="no">toInt</a>(), <a href="qstring.html#toDouble" translate="no">toDouble</a>(), and similar functions.</p>
<p>To get an uppercase or lowercase version of a string, use <a href="qstring.html#toUpper" translate="no">toUpper</a>() or <a href="qstring.html#toLower" translate="no">toLower</a>().</p>
<p>Lists of strings are handled by the <a href="qstringlist.html" translate="no">QStringList</a> class. You can split a string into a list of strings using the <a href="qstring.html#split" translate="no">split</a>() function, and join a list of strings into a single string with an optional separator using <a href="qstringlist.html#join" translate="no">QStringList::join</a>(). You can obtain a filtered list from a string list by selecting the entries in it that contain a particular substring or match a particular <a href="qregularexpression.html" translate="no">QRegularExpression</a>. See <a href="qstringlist.html#filter" translate="no">QStringList::filter</a>() for details.</p>
<h3 id="querying-string-data">Querying string data</h3>
<p>To see if a QString starts or ends with a particular substring, use <a href="qstring.html#startsWith" translate="no">startsWith</a>() or <a href="qstring.html#endsWith" translate="no">endsWith</a>(). To check whether a QString contains a specific character or substring, use the <a href="qstring.html#contains" translate="no">contains</a>() function. To find out how many times a particular character or substring occurs in a string, use count().</p>
<p>To obtain a pointer to the actual character data, call <a href="qstring.html#data" translate="no">data</a>() or <a href="qstring.html#constData" translate="no">constData</a>(). These functions return a pointer to the beginning of the <a href="qchar.html" translate="no">QChar</a> data. The pointer is guaranteed to remain valid until a non-<code translate="no">const</code> function is called on the QString.</p>
<h4 id="comparing-strings">Comparing strings</h4>
<p>QStrings can be compared using overloaded operators such as <a href="qstring.html#operator-lt-1" translate="no">operator&lt;</a>(), <a href="qstring.html#operator-lt-eq" translate="no">operator&lt;=</a>(), <a href="qstring.html#operator-eq-eq-1" translate="no">operator==</a>(), <a href="qstring.html#operator-gt-eq" translate="no">operator&gt;=</a>(), and so on. The comparison is based exclusively on the lexicographical order of the two strings, seen as sequences of UTF-16 code units. It is very fast but is not what a human would expect; the <a href="qstring.html#localeAwareCompare" translate="no">QString::localeAwareCompare</a>() function is usually a better choice for sorting user-interface strings, when such a comparison is available.</p>
<p>When Qt is linked with the ICU library (which it usually is), its locale-aware sorting is used. Otherwise, platform-specific solutions are used:</p>
<ul>
<li>On Windows, <a href="qstring.html#localeAwareCompare" translate="no">localeAwareCompare</a>() uses the current user locale, as set in the <b translate="no">regional</b> and <b translate="no">language</b> options portion of <b translate="no">Control Panel</b>.</li>
<li>On macOS and iOS, <a href="qstring.html#localeAwareCompare" translate="no">localeAwareCompare</a>() compares according to the <b translate="no">Order for sorted lists</b> setting in the <b translate="no">International preferences</b> panel.</li>
<li>On other Unix-like systems, the comparison falls back to the system library's <code translate="no">strcoll()</code>.</li>
</ul>
<h3 id="converting-between-encoded-string-data-and-qstring">Converting between encoded string data and QString</h3>
<p>QString provides the following functions that return a <code translate="no">const char *</code> version of the string as <a href="qbytearray.html" translate="no">QByteArray</a>: <a href="qstring.html#toUtf8" translate="no">toUtf8</a>(), <a href="qstring.html#toLatin1" translate="no">toLatin1</a>(), and <a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>().</p>
<ul>
<li><a href="qstring.html#toLatin1" translate="no">toLatin1</a>() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.</li>
<li><a href="qstring.html#toUtf8" translate="no">toUtf8</a>() returns a UTF-8 encoded 8-bit string. UTF-8 is a superset of US-ASCII (ANSI X3.4-1986) that supports the entire Unicode character set through multibyte sequences.</li>
<li><a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>() returns an 8-bit string using the system's local encoding. This is the same as <a href="qstring.html#toUtf8" translate="no">toUtf8</a>() on Unix systems.</li>
</ul>
<p>To convert from one of these encodings, QString provides <a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(), and <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>(). Other encodings are supported through the <a href="qstringencoder.html" translate="no">QStringEncoder</a> and <a href="qstringdecoder.html" translate="no">QStringDecoder</a> classes.</p>
<p>As mentioned above, QString provides a lot of functions and operators that make it easy to interoperate with <code translate="no">const char *</code> strings. But this functionality is a double-edged sword: It makes QString more convenient to use if all strings are US-ASCII or Latin-1, but there is always the risk that an implicit conversion from or to <code translate="no">const char *</code> is done using the wrong 8-bit encoding. To minimize these risks, you can turn off these implicit conversions by defining some of the following preprocessor symbols:</p>
<ul>
<li><a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> disables automatic conversions from C string literals and pointers to Unicode.</li>
<li><a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII" translate="no">QT_RESTRICTED_CAST_FROM_ASCII</a> allows automatic conversions from C characters and character arrays but disables automatic conversions from character pointers to Unicode.</li>
<li><a href="qstring.html#QT_NO_CAST_TO_ASCII" translate="no">QT_NO_CAST_TO_ASCII</a> disables automatic conversion from QString to C strings.</li>
</ul>
<p>You then need to explicitly call <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(), <a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>() to construct a QString from an 8-bit string, or use the lightweight <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> class. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> url <span class="operator">=</span> <span class="string">&quot;https://www.unicode.org/&quot;</span>_L1;
</pre>
<p>Similarly, you must call <a href="qstring.html#toLatin1" translate="no">toLatin1</a>(), <a href="qstring.html#toUtf8" translate="no">toUtf8</a>(), or <a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>() explicitly to convert the QString to an 8-bit string.</p>
<div class="table"><table class="generic" width="100%">
 <thead><tr class="qt-style"><th >Note for C Programmers</th></tr></thead>
<tr valign="top" class="odd"><td >Due to C++'s type system and the fact that QString is <a href="implicit-sharing.html" translate="no">implicitly shared</a>, QStrings may be treated like <code translate="no">int</code>s or other basic types. For example:<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> Widget<span class="operator">::</span>boolToString(<span class="type">bool</span> b)
 {
     <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> result;
     <span class="keyword">if</span> (b)
         result <span class="operator">=</span> <span class="string">&quot;True&quot;</span>;
     <span class="keyword">else</span>
         result <span class="operator">=</span> <span class="string">&quot;False&quot;</span>;
     <span class="keyword">return</span> result;
 }
</pre>
<p>The <code translate="no">result</code> variable is a normal variable allocated on the stack. When <code translate="no">return</code> is called, and because we're returning by value, the copy constructor is called and a copy of the string is returned. No actual copying takes place thanks to the implicit sharing.</p>
</td></tr>
</table></div>
<h3 id="distinction-between-null-and-empty-strings">Distinction between null and empty strings</h3>
<p>For historical reasons, QString distinguishes between null and empty strings. A <i>null</i> string is a string that is initialized using QString's default constructor or by passing <code translate="no">nullptr</code> to the constructor. An <i>empty</i> string is any string with size 0. A null string is always empty, but an empty string isn't necessarily null:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>()<span class="operator">.</span>isNull();               <span class="comment">// returns true</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>()<span class="operator">.</span>isEmpty();              <span class="comment">// returns true</span>

 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isNull();             <span class="comment">// returns false</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isEmpty();            <span class="comment">// returns true</span>

 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isNull();          <span class="comment">// returns false</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isEmpty();         <span class="comment">// returns false</span>
</pre>
<p>All functions except <a href="qstring.html#isNull" translate="no">isNull</a>() treat null strings the same as empty strings. For example, <a href="qstring.html#toUtf8" translate="no">toUtf8</a>().<a href="qstring.html#constData" translate="no">constData</a>() returns a valid pointer (not <code translate="no">nullptr</code>) to a '\0' character for a null string. We recommend that you always use the <a href="qstring.html#isEmpty" translate="no">isEmpty</a>() function and avoid <a href="qstring.html#isNull" translate="no">isNull</a>().</p>
<h3 id="number-formats">Number formats</h3>
<p>When a <a href="qstring.html#arg" translate="no">QString::arg</a>() <code translate="no">'%'</code> format specifier includes the <code translate="no">'L'</code> locale qualifier, and the base is ten (its default), the default locale is used. This can be set using <a href="qlocale.html#setDefault" translate="no">QLocale::setDefault</a>(). For more refined control of localized string representations of numbers, see <a href="qlocale.html#toString" translate="no">QLocale::toString</a>(). All other number formatting done by QString follows the C locale's representation of numbers.</p>
<p>When <a href="qstring.html#arg" translate="no">QString::arg</a>() applies left-padding to numbers, the fill character <code translate="no">'0'</code> is treated specially. If the number is negative, its minus sign appears before the zero-padding. If the field is localized, the locale-appropriate zero character is used in place of <code translate="no">'0'</code>. For floating-point numbers, this special treatment only applies if the number is finite.</p>
<h4 id="floating-point-formats">Floating-point formats</h4>
<p>In member functions (for example, <a href="qstring.html#arg" translate="no">arg</a>() and <a href="qstring.html#number" translate="no">number</a>()) that format floating-point numbers (<code translate="no">float</code> or <code translate="no">double</code>) as strings, the representation used can be controlled by a choice of <i>format</i> and <i>precision</i>, whose meanings are as for <a href="qlocale.html#toString-8" translate="no">QLocale::toString</a>(double, char, int).</p>
<p>If the selected <i>format</i> includes an exponent, localized forms follow the locale's convention on digits in the exponent. For non-localized formatting, the exponent shows its sign and includes at least two digits, left-padding with zero if needed.</p>
<h3 id="more-efficient-string-construction">More efficient string construction</h3>
<p>Many strings are known at compile time. The QString constructor from C++ string literals will copy the contents of the string, treating the contents as UTF-8. This requires memory allocation and re-encoding string data, operations that will happen at runtime. If the string data is known at compile time, you can use the <a href="qstring.html#QStringLiteral" translate="no">QStringLiteral</a> macro or similarly <code translate="no">operator&quot;&quot;_s</code> to create QString's payload at compile time instead.</p>
<p>Using the QString <code translate="no">'+'</code> operator, it is easy to construct a complex string from multiple substrings. You will often write code like this:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> foo;
     <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> type <span class="operator">=</span> <span class="string">&quot;long&quot;</span>;

     foo <span class="operator">=</span> <span class="string">&quot;vector&lt;&quot;</span>_L1 <span class="operator">+</span> type <span class="operator">+</span> <span class="string">&quot;&gt;::iterator&quot;</span>_L1;

     <span class="keyword">if</span> (foo<span class="operator">.</span>startsWith(<span class="string">&quot;(&quot;</span> <span class="operator">+</span> type <span class="operator">+</span> <span class="string">&quot;) 0x&quot;</span>))
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>There is nothing wrong with either of these string constructions, but there are a few hidden inefficiencies:</p>
<p>First, repeated use of the <code translate="no">'+'</code> operator may lead to multiple memory allocations. When concatenating <i>n</i> substrings, where <i>n &gt; 2</i>, there can be as many as <i>n - 1</i> calls to the memory allocator.</p>
<p>These allocations can be optimized by an internal class <code translate="no">QStringBuilder</code>. This class is marked internal and does not appear in the documentation, because you aren't meant to instantiate it in your code. Its use will be automatic, as described below. The class is found in <code translate="no">src/corelib/tools/qstringbuilder.cpp</code> if you want to have a look at it.</p>
<p><code translate="no">QStringBuilder</code> uses expression templates and reimplements the <code translate="no">'%'</code> operator so that when you use <code translate="no">'%'</code> for string concatenation instead of <code translate="no">'+'</code>, multiple substring concatenations will be postponed until the final result is about to be assigned to a QString. At this point, the amount of memory required for the final result is known. The memory allocator is then called <i>once</i> to get the required space, and the substrings are copied into it one by one.</p>
<p>Additional efficiency is gained by inlining and reducing reference counting (the QString created from a <code translate="no">QStringBuilder</code> has a ref count of 1, whereas <a href="qstring.html#append" translate="no">QString::append</a>() needs an extra test).</p>
<p>There are two ways you can access this improved method of string construction. The straightforward way is to include <code translate="no">QStringBuilder</code> wherever you want to use it and use the <code translate="no">'%'</code> operator instead of <code translate="no">'+'</code> when concatenating strings:</p>
<pre class="cpp" translate="no">
     <span class="preprocessor">#include &lt;QStringBuilder&gt;</span>

     <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> hello(<span class="string">&quot;hello&quot;</span>);
     <span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> el <span class="operator">=</span> <span class="type"><a href="qstringview.html" translate="no">QStringView</a></span>{ hello }<span class="operator">.</span>mid(<span class="number">2</span><span class="operator">,</span> <span class="number">3</span>);
     QLatin1StringView world(<span class="string">&quot;world&quot;</span>);
     <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> message <span class="operator">=</span>  hello <span class="operator">%</span> el <span class="operator">%</span> world <span class="operator">%</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="char">'!'</span>);
</pre>
<p>A more global approach, which is more convenient but not entirely source-compatible, is to define <code translate="no">QT_USE_QSTRINGBUILDER</code> (by adding it to the compiler flags) at build time. This will make concatenating strings with <code translate="no">'+'</code> work the same way as <code translate="no">QStringBuilder's</code> <code translate="no">'%'</code>.</p>
<div class="admonition note">
<p><b>Note: </b>Using automatic type deduction (for example, by using the <code translate="no">auto</code> keyword) with the result of string concatenation when QStringBuilder is enabled will show that the concatenation is indeed an object of a QStringBuilder specialization:</p>
</div>
<pre class="cpp" translate="no">
     <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str(<span class="string">&quot;QStringBuilder&quot;</span>);

     <span class="comment">// &quot;s&quot; type is deduced as QStringBuilder&lt;...&gt;</span>
     <span class="keyword">auto</span> s <span class="operator">=</span> <span class="string">&quot;Like hot glue, &quot;</span> <span class="operator">%</span> str <span class="operator">%</span> <span class="string">&quot; concatenates strings&quot;</span>;

     <span class="comment">// Similarly the return type of this lambda is deduced as QStringBuilder&lt;...&gt;</span>
     <span class="keyword">auto</span> concatenateStr <span class="operator">=</span> <span class="operator">[</span><span class="operator">]</span>() {
         <span class="keyword">return</span> <span class="string">&quot;Like hot glue, &quot;</span> <span class="operator">%</span> str <span class="operator">%</span> <span class="string">&quot; concatenates strings&quot;</span>;
     };
</pre>
<p>This does not cause any harm, as QStringBuilder will implicitly convert to QString when required. If this is undesirable, then one should specify the necessary types instead of having the compiler deduce them:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;Like hot glue, &quot;</span> <span class="operator">%</span> str <span class="operator">%</span> <span class="string">&quot; concatenates strings&quot;</span>;

     <span class="comment">// With a lambda, specify a trailing return type:</span>
     <span class="keyword">auto</span> concatenateStr <span class="operator">=</span> <span class="operator">[</span><span class="operator">]</span>() <span class="operator">-</span><span class="operator">&gt;</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> {
         <span class="keyword">return</span> <span class="string">&quot;Like hot glue, &quot;</span> <span class="operator">%</span> str <span class="operator">%</span> <span class="string">&quot; concatenates strings&quot;</span>;
     };
</pre>
<h3 id="maximum-size-and-out-of-memory-conditions">Maximum size and out-of-memory conditions</h3>
<p>The maximum size of QString depends on the architecture. Most 64-bit systems can allocate more than 2 GB of memory, with a typical limit of 2^63 bytes. The actual value also depends on the overhead required for managing the data block. As a result, you can expect a maximum size of 2 GB minus overhead on 32-bit platforms and 2^63 bytes minus overhead on 64-bit platforms. The number of elements that can be stored in a QString is this maximum size divided by the size of <a href="qchar.html" translate="no">QChar</a>.</p>
<p>When memory allocation fails, QString throws a <code translate="no">std::bad_alloc</code> exception if the application was compiled with exception support. Out-of-memory conditions in Qt containers are the only cases where Qt will throw exceptions. If exceptions are disabled, then running out of memory is undefined behavior.</p>
<div class="admonition note">
<p><b>Note: </b>Target operating systems may impose limits on how much memory an application can allocate, in total, or on the size of individual allocations. This may further restrict the size of string a QString can hold. Mitigating or controlling the behavior these limits cause is beyond the scope of the Qt API.</p>
</div>
</div>
<p><b>See also </b><a href="qstring.html#fromRawData" translate="no">fromRawData</a>(), <a href="qchar.html" translate="no">QChar</a>, <a href="qstringview.html" translate="no">QStringView</a>, <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>, and <a href="qbytearray.html" translate="no">QByteArray</a>.</p>
<!-- @@@QString -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" translate="no" id="ConstIterator-typedef">QString::<span class="name">ConstIterator</span></h3>
<p>Qt-style synonym for <a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn" translate="no" id="Iterator-typedef">QString::<span class="name">Iterator</span></h3>
<p>Qt-style synonym for <a href="qstring.html#iterator-typedefx" translate="no">QString::iterator</a>.</p>
<!-- @@@Iterator -->
<!-- $$$NormalizationForm$$$NormalizationForm_D$$$NormalizationForm_C$$$NormalizationForm_KD$$$NormalizationForm_KC -->
<h3 class="fn" translate="no" id="NormalizationForm-enum">enum QString::<span class="name">NormalizationForm</span></h3>
<p>This enum describes the various normalized forms of Unicode text.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QString::NormalizationForm_D</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Canonical Decomposition</td></tr>
<tr><td class="topAlign"><code translate="no">QString::NormalizationForm_C</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Canonical Decomposition followed by Canonical Composition</td></tr>
<tr><td class="topAlign"><code translate="no">QString::NormalizationForm_KD</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Compatibility Decomposition</td></tr>
<tr><td class="topAlign"><code translate="no">QString::NormalizationForm_KC</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Compatibility Decomposition followed by Canonical Composition</td></tr>
</table></div>
<p><b>See also </b><a href="qstring.html#normalized" translate="no">normalized</a>() and <a href="https://www.unicode.org/reports/tr15/" translate="no">Unicode Standard Annex #15</a>.</p>
<!-- @@@NormalizationForm -->
<!-- $$$SectionFlag$$$SectionDefault$$$SectionSkipEmpty$$$SectionIncludeLeadingSep$$$SectionIncludeTrailingSep$$$SectionCaseInsensitiveSeps -->
<h3 class="flags" id="SectionFlag-enum">enum QString::<span class="name">SectionFlag</span><br/>flags QString::<span class="name">SectionFlags</span></h3>
<p>This enum specifies flags that can be used to affect various aspects of the <a href="qstring.html#section" translate="no">section</a>() function's behavior with respect to separators and empty fields.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QString::SectionDefault</code></td><td class="topAlign tblval"><code translate="no">0x00</code></td><td class="topAlign">Empty fields are counted, leading and trailing separators are not included, and the separator is compared case sensitively.</td></tr>
<tr><td class="topAlign"><code translate="no">QString::SectionSkipEmpty</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Treat empty fields as if they don't exist, i.e. they are not considered as far as <i>start</i> and <i>end</i> are concerned.</td></tr>
<tr><td class="topAlign"><code translate="no">QString::SectionIncludeLeadingSep</code></td><td class="topAlign tblval"><code translate="no">0x02</code></td><td class="topAlign">Include the leading separator (if any) in the result string.</td></tr>
<tr><td class="topAlign"><code translate="no">QString::SectionIncludeTrailingSep</code></td><td class="topAlign tblval"><code translate="no">0x04</code></td><td class="topAlign">Include the trailing separator (if any) in the result string.</td></tr>
<tr><td class="topAlign"><code translate="no">QString::SectionCaseInsensitiveSeps</code></td><td class="topAlign tblval"><code translate="no">0x08</code></td><td class="topAlign">Compare the separator case-insensitively.</td></tr>
</table></div>
<p>The SectionFlags type is a typedef for <a href="qflags.html">QFlags</a>&lt;SectionFlag&gt;. It stores an OR combination of SectionFlag values.</p>
<p><b>See also </b><a href="qstring.html#section" translate="no">section</a>().</p>
<!-- @@@SectionFlag -->
<!-- $$$const_iterator -->
<h3 class="fn" translate="no" id="const_iterator-typedef">QString::<span class="name">const_iterator</span></h3>
<p><b>See also </b><a href="qstring.html#iterator-typedefx" translate="no">QString::iterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" translate="no" id="const_pointer-typedef">QString::<span class="name">const_pointer</span></h3>
<p>The QString::const_pointer typedef provides an STL-style const pointer to a <a href="qstring.html" translate="no">QString</a> element (<a href="qchar.html" translate="no">QChar</a>).</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" translate="no" id="const_reference-typedef">QString::<span class="name">const_reference</span></h3>
<!-- @@@const_reference -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" translate="no" id="const_reverse_iterator-typedef">QString::<span class="name">const_reverse_iterator</span></h3>
<p><b>See also </b><a href="qstring.html#reverse_iterator-typedef" translate="no">QString::reverse_iterator</a> and <a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" translate="no" id="difference_type-typedef">QString::<span class="name">difference_type</span></h3>
<!-- @@@difference_type -->
<!-- $$$iterator -->
<h3 class="fn" translate="no" id="iterator-typedefx">QString::<span class="name">iterator</span></h3>
<p><b>See also </b><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$pointer -->
<h3 class="fn" translate="no" id="pointer-typedef">QString::<span class="name">pointer</span></h3>
<p>The QString::pointer typedef provides an STL-style pointer to a <a href="qstring.html" translate="no">QString</a> element (<a href="qchar.html" translate="no">QChar</a>).</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" translate="no" id="reference-typedef">QString::<span class="name">reference</span></h3>
<!-- @@@reference -->
<!-- $$$reverse_iterator -->
<h3 class="fn" translate="no" id="reverse_iterator-typedef">QString::<span class="name">reverse_iterator</span></h3>
<p><b>See also </b><a href="qstring.html#const_reverse_iterator-typedef" translate="no">QString::const_reverse_iterator</a> and <a href="qstring.html#iterator-typedefx" translate="no">QString::iterator</a>.</p>
<!-- @@@reverse_iterator -->
<!-- $$$size_type -->
<h3 class="fn" translate="no" id="size_type-typedef">QString::<span class="name">size_type</span></h3>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" translate="no" id="value_type-typedef">QString::<span class="name">value_type</span></h3>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="left-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">left</span>(<span class="type">qsizetype</span> <i>n</i>) &&</h3><h3 class="fn fngroupitem" translate="no" id="left"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">left</span>(<span class="type">qsizetype</span> <i>n</i>) const &</h3></div>
<p>Returns a substring that contains the <i translate="no">n</i> leftmost characters of the string.</p>
<p>If you know that <i translate="no">n</i> cannot be out of bounds, use <a href="qstring.html#first" translate="no">first</a>() instead in new code, because it is faster.</p>
<p>The entire string is returned if <i translate="no">n</i> is greater than or equal to <a href="qstring.html#size" translate="no">size</a>(), or less than zero.</p>
<p><b>See also </b><a href="qstring.html#first" translate="no">first</a>(), <a href="qstring.html#last" translate="no">last</a>(), <a href="qstring.html#startsWith" translate="no">startsWith</a>(), <a href="qstring.html#chopped" translate="no">chopped</a>(), <a href="qstring.html#chop" translate="no">chop</a>(), and <a href="qstring.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="right-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">right</span>(<span class="type">qsizetype</span> <i>n</i>) &&</h3><h3 class="fn fngroupitem" translate="no" id="right"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">right</span>(<span class="type">qsizetype</span> <i>n</i>) const &</h3></div>
<p>Returns a substring that contains the <i translate="no">n</i> rightmost characters of the string.</p>
<p>If you know that <i translate="no">n</i> cannot be out of bounds, use <a href="qstring.html#last" translate="no">last</a>() instead in new code, because it is faster.</p>
<p>The entire string is returned if <i translate="no">n</i> is greater than or equal to <a href="qstring.html#size" translate="no">size</a>(), or less than zero.</p>
<p><b>See also </b><a href="qstring.html#endsWith" translate="no">endsWith</a>(), <a href="qstring.html#last" translate="no">last</a>(), <a href="qstring.html#first" translate="no">first</a>(), <a href="qstring.html#sliced" translate="no">sliced</a>(), <a href="qstring.html#chopped" translate="no">chopped</a>(), <a href="qstring.html#chop" translate="no">chop</a>(), and <a href="qstring.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="mid-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">mid</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type">qsizetype</span> <i>n</i> = -1) &&</h3><h3 class="fn fngroupitem" translate="no" id="mid"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">mid</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type">qsizetype</span> <i>n</i> = -1) const &</h3></div>
<p>Returns a string that contains <i translate="no">n</i> characters of this string, starting at the specified <i translate="no">position</i> index.</p>
<p>If you know that <i translate="no">position</i> and <i translate="no">n</i> cannot be out of bounds, use <a href="qstring.html#sliced" translate="no">sliced</a>() instead in new code, because it is faster.</p>
<p>Returns a null string if the <i translate="no">position</i> index exceeds the length of the string. If there are less than <i translate="no">n</i> characters available in the string starting at the given <i translate="no">position</i>, or if <i translate="no">n</i> is -1 (default), the function returns all characters that are available from the specified <i translate="no">position</i>.</p>
<p><b>See also </b><a href="qstring.html#first" translate="no">first</a>(), <a href="qstring.html#last" translate="no">last</a>(), <a href="qstring.html#sliced" translate="no">sliced</a>(), <a href="qstring.html#chopped" translate="no">chopped</a>(), <a href="qstring.html#chop" translate="no">chop</a>(), and <a href="qstring.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="first-1"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">first</span>(<span class="type">qsizetype</span> <i>n</i>) &&</h3><h3 class="fn fngroupitem" translate="no" id="first"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">first</span>(<span class="type">qsizetype</span> <i>n</i>) const &</h3></div>
<p>Returns a string that contains the first <i translate="no">n</i> characters of this string.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">n</i> &lt; 0 or <i translate="no">n</i> &gt; <a href="qstring.html#size" translate="no">size</a>().</p>
</div>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> x<span class="operator">.</span>first(<span class="number">4</span>);      <span class="comment">// y == &quot;Pine&quot;</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qstring.html#last" translate="no">last</a>(), <a href="qstring.html#sliced" translate="no">sliced</a>(), <a href="qstring.html#startsWith" translate="no">startsWith</a>(), <a href="qstring.html#chopped" translate="no">chopped</a>(), <a href="qstring.html#chop" translate="no">chop</a>(), and <a href="qstring.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="last-1"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">last</span>(<span class="type">qsizetype</span> <i>n</i>) &&</h3><h3 class="fn fngroupitem" translate="no" id="last"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">last</span>(<span class="type">qsizetype</span> <i>n</i>) const &</h3></div>
<p>Returns the string that contains the last <i translate="no">n</i> characters of this string.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">n</i> &lt; 0 or <i translate="no">n</i> &gt; <a href="qstring.html#size" translate="no">size</a>().</p>
</div>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> x<span class="operator">.</span>last(<span class="number">5</span>);      <span class="comment">// y == &quot;apple&quot;</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qstring.html#first" translate="no">first</a>(), <a href="qstring.html#sliced" translate="no">sliced</a>(), <a href="qstring.html#endsWith" translate="no">endsWith</a>(), <a href="qstring.html#chopped" translate="no">chopped</a>(), <a href="qstring.html#chop" translate="no">chop</a>(), and <a href="qstring.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="sliced-3"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>n</i>) &&</h3><h3 class="fn fngroupitem" translate="no" id="sliced"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>n</i>) const &</h3></div>
<p>Returns a string that contains <i translate="no">n</i> characters of this string, starting at position <i translate="no">pos</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">pos</i> &lt; 0, <i translate="no">n</i> &lt; 0, or <i translate="no">pos</i> + <i translate="no">n</i> &gt; <a href="qstring.html#size" translate="no">size</a>().</p>
</div>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Nine pineapples&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> x<span class="operator">.</span>sliced(<span class="number">5</span><span class="operator">,</span> <span class="number">4</span>);            <span class="comment">// y == &quot;pine&quot;</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> z <span class="operator">=</span> x<span class="operator">.</span>sliced(<span class="number">5</span>);               <span class="comment">// z == &quot;pineapples&quot;</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qstring.html#first" translate="no">first</a>(), <a href="qstring.html#last" translate="no">last</a>(), <a href="qstring.html#chopped" translate="no">chopped</a>(), <a href="qstring.html#chop" translate="no">chop</a>(), and <a href="qstring.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="sliced-2"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>) &&</h3><h3 class="fn fngroupitem" translate="no" id="sliced-1"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>) const &</h3></div>
<p>This is an overloaded function.</p>
<p>Returns a string that contains the portion of this string starting at position <i translate="no">pos</i> and extending to its end.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">pos</i> &lt; 0 or <i translate="no">pos</i> &gt; <a href="qstring.html#size" translate="no">size</a>().</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qstring.html#first" translate="no">first</a>(), <a href="qstring.html#last" translate="no">last</a>(), <a href="qstring.html#sliced" translate="no">sliced</a>(), <a href="qstring.html#chopped" translate="no">chopped</a>(), <a href="qstring.html#chop" translate="no">chop</a>(), and <a href="qstring.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="chopped-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">chopped</span>(<span class="type">qsizetype</span> <i>len</i>) &&</h3><h3 class="fn fngroupitem" translate="no" id="chopped"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">chopped</span>(<span class="type">qsizetype</span> <i>len</i>) const &</h3></div>
<p>Returns a string that contains the <a href="qstring.html#size" translate="no">size</a>() - <i translate="no">len</i> leftmost characters of this string.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined if <i translate="no">len</i> is negative or greater than <a href="qstring.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qstring.html#endsWith" translate="no">endsWith</a>(), <a href="qstring.html#first" translate="no">first</a>(), <a href="qstring.html#last" translate="no">last</a>(), <a href="qstring.html#sliced" translate="no">sliced</a>(), <a href="qstring.html#chop" translate="no">chop</a>(), and <a href="qstring.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<h3 class="fn fngroupitem" translate="no" id="arg-14">template &lt;typename... Args&gt; <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type">Args</span> &amp;&amp;... <i>args</i>) const</h3>
<p>Replaces occurrences of <code translate="no">%N</code> in this string with the corresponding argument from <i translate="no">args</i>. The arguments are not positional: the first of the <i translate="no">args</i> replaces the <code translate="no">%N</code> with the lowest <code translate="no">N</code> (all of them), the second of the <i translate="no">args</i> the <code translate="no">%N</code> with the next-lowest <code translate="no">N</code> etc.</p>
<p><code translate="no">Args</code> can consist of anything that implicitly converts to <a href="qstring.html" translate="no">QString</a>, <a href="qstringview.html" translate="no">QStringView</a> or <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>.</p>
<p>In addition, the following types are also supported: <a href="qchar.html" translate="no">QChar</a>, <a href="qlatin1char.html" translate="no">QLatin1Char</a>.</p>
<p><b>See also </b><a href="qstring.html#arg" translate="no">QString::arg</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="tokenize-2"><code class="details extra" translate="no">[noexcept(...), since 6.0]</code> template &lt;typename Needle, typename... Flags&gt; <span class="type">decltype</span>(<span class="type"><a href="qstringtokenizer.html#qTokenize" translate="no">qTokenize</a></span>(<span class="type">std::move</span>(*<span class="type">this</span>), <span class="type">std::forward</span>&lt;<span class="type">Needle</span>&gt;(<span class="type">needle</span>), <span class="type">flags</span>...)) QString::<span class="name">tokenize</span>(<span class="type">Needle</span> &amp;&amp;<i>sep</i>, <span class="type">Flags</span>... <i>flags</i>) &&</h3><h3 class="fn fngroupitem" translate="no" id="tokenize"><code class="details extra" translate="no">[noexcept(...), since 6.0]</code> template &lt;typename Needle, typename... Flags&gt; <span class="type">decltype</span>(<span class="type"><a href="qstringtokenizer.html#qTokenize" translate="no">qTokenize</a></span>(*<span class="type">this</span>, <span class="type">std::forward</span>&lt;<span class="type">Needle</span>&gt;(<span class="type">needle</span>), <span class="type">flags</span>...)) QString::<span class="name">tokenize</span>(<span class="type">Needle</span> &amp;&amp;<i>sep</i>, <span class="type">Flags</span>... <i>flags</i>) const &</h3><h3 class="fn fngroupitem" translate="no" id="tokenize-1"><code class="details extra" translate="no">[noexcept(...), since 6.0]</code> template &lt;typename Needle, typename... Flags&gt; <span class="type">decltype</span>(<span class="type"><a href="qstringtokenizer.html#qTokenize" translate="no">qTokenize</a></span>(<span class="type">std::move</span>(*<span class="type">this</span>), <span class="type">std::forward</span>&lt;<span class="type">Needle</span>&gt;(<span class="type">needle</span>), <span class="type">flags</span>...)) QString::<span class="name">tokenize</span>(<span class="type">Needle</span> &amp;&amp;<i>sep</i>, <span class="type">Flags</span>... <i>flags</i>) const &&</h3></div>
<p>Splits the string into substring views wherever <i translate="no">sep</i> occurs, and returns a lazy sequence of those strings.</p>
<p>Equivalent to</p>
<pre class="cpp" translate="no">
 <span class="keyword">return</span> <span class="type"><a href="qstringtokenizer.html" translate="no">QStringTokenizer</a></span>{std<span class="operator">::</span>forward<span class="operator">&lt;</span>Needle<span class="operator">&gt;</span>(sep)<span class="operator">,</span> flags<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>};
</pre>
<p>except it works without C++17 Class Template Argument Deduction (CTAD) enabled in the compiler.</p>
<p>See <a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> for how <i translate="no">sep</i> and <i translate="no">flags</i> interact to form the result.</p>
<div class="admonition note">
<p><b>Note: </b>While this function returns <a href="qstringtokenizer.html" translate="no">QStringTokenizer</a>, you should never, ever, name its template arguments explicitly. If you can use C++17 Class Template Argument Deduction (CTAD), you may write</p>
</div>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstringtokenizer.html" translate="no">QStringTokenizer</a></span> result <span class="operator">=</span> sv<span class="operator">.</span>tokenize(sep);
</pre>
<p>(without template arguments). If you can't use C++17 CTAD, you must store the return value only in <code translate="no">auto</code> variables:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> result <span class="operator">=</span> sv<span class="operator">.</span>tokenize(sep);
</pre>
<p>This is because the template arguments of <a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> have a very subtle dependency on the specific <a href="qstring.html#tokenize" translate="no">tokenize</a>() overload from which they are returned, and they don't usually correspond to the type used for the separator.</p>
<p>This function was introduced in Qt 6.0.</p>
<div class="admonition note">
<p><b>Note: </b> (1) does not throw any exception when &quot;noexcept(qTokenize(std::declval&lt;QString&gt;(), std::forward&lt;Needle&gt;(needle), flags...))&quot; is true.</p>
</div>
<div class="admonition note">
<p><b>Note: </b> (2) does not throw any exception when &quot;noexcept(qTokenize(std::declval&lt;const QString &amp;&gt;(), std::forward&lt;Needle&gt;(needle), flags...))&quot; is true.</p>
</div>
<div class="admonition note">
<p><b>Note: </b> (3) does not throw any exception when &quot;noexcept(qTokenize(std::declval&lt;const QString&gt;(), std::forward&lt;Needle&gt;(needle), flags...))&quot; is true.</p>
</div>
<p><b>See also </b><a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> and <a href="qstringtokenizer.html#qTokenize" translate="no">qTokenize</a>().</p>
<!-- @@@ -->
<!-- $$$QString[overload1]$$$QString -->
<h3 class="fn" translate="no" id="QString"><code class="details extra" translate="no">[constexpr noexcept]</code> QString::<span class="name">QString</span>()</h3>
<p>Constructs a null string. Null strings are also considered empty.</p>
<p><b>See also </b><a href="qstring.html#isEmpty" translate="no">isEmpty</a>(), <a href="qstring.html#isNull" translate="no">isNull</a>(), and <a href="qstring.html#distinction-between-null-and-empty-strings" translate="no">Distinction Between Null and Empty Strings</a>.</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringconstQChar*qsizetype -->
<h3 class="fn" translate="no" id="QString-1"><code class="details extra" translate="no">[explicit]</code> QString::<span class="name">QString</span>(const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>unicode</i>, <span class="type">qsizetype</span> <i>size</i> = -1)</h3>
<p>Constructs a string initialized with the first <i translate="no">size</i> characters of the <a href="qchar.html" translate="no">QChar</a> array <i translate="no">unicode</i>.</p>
<p>If <i translate="no">unicode</i> is 0, a null string is constructed.</p>
<p>If <i translate="no">size</i> is negative, <i translate="no">unicode</i> is assumed to point to a \0'-terminated array and its length is determined dynamically. The terminating null character is not considered part of the string.</p>
<p>QString makes a deep copy of the string data. The unicode data is copied as is and the Byte Order Mark is preserved if present.</p>
<p><b>See also </b><a href="qstring.html#fromRawData" translate="no">fromRawData</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringQChar -->
<h3 class="fn" translate="no" id="QString-2">QString::<span class="name">QString</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>)</h3>
<p>Constructs a string of size 1 containing the character <i translate="no">ch</i>.</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringqsizetypeQChar -->
<h3 class="fn" translate="no" id="QString-3">QString::<span class="name">QString</span>(<span class="type">qsizetype</span> <i>size</i>, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>)</h3>
<p>Constructs a string of the given <i translate="no">size</i> with every character set to <i translate="no">ch</i>.</p>
<p><b>See also </b><a href="qstring.html#fill" translate="no">fill</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringQLatin1StringView -->
<h3 class="fn" translate="no" id="QString-4">QString::<span class="name">QString</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>)</h3>
<p>Constructs a copy of the Latin-1 string viewed by <i translate="no">str</i>.</p>
<p><b>See also </b><a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringconstint* -->
<h3 class="fn" translate="no" id="QString-5"><code class="details extra" translate="no">[since 6.1]</code> QString::<span class="name">QString</span>(const <span class="type">int</span> *<i>str</i>)</h3>
<p>Constructs a string initialized with the UTF-8 string <i translate="no">str</i>. The given const char8_t pointer is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>(), and <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringconstchar* -->
<h3 class="fn" translate="no" id="QString-8">QString::<span class="name">QString</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>Constructs a string initialized with the 8-bit string <i translate="no">str</i>. The given const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this constructor by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<div class="admonition note">
<p><b>Note: </b>Defining <a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII" translate="no">QT_RESTRICTED_CAST_FROM_ASCII</a> also disables this constructor, but enables a <code translate="no">QString(const char (&amp;ch)[N])</code> constructor instead. Using non-literal input, or input with embedded NUL characters, or non-7-bit characters is undefined in this case.</p>
</div>
<p><b>See also </b><a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>(), and <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringconstQByteArray& -->
<h3 class="fn" translate="no" id="QString-9">QString::<span class="name">QString</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Constructs a string initialized with the byte array <i translate="no">ba</i>. The given byte array is converted to Unicode using <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>().</p>
<p>You can disable this constructor by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<div class="admonition note">
<p><b>Note: </b>Any null ('\0') bytes in the byte array will be included in this string, converted to Unicode null characters (U+0000). This behavior is different from Qt 5.x.</p>
</div>
<p><b>See also </b><a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>(), and <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringconstQString& -->
<h3 class="fn" translate="no" id="QString-6"><code class="details extra" translate="no">[noexcept]</code> QString::<span class="name">QString</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p>This operation takes <a href="containers.html#constant-time" translate="no">constant time</a>, because QString is <a href="implicit-sharing.html" translate="no">implicitly shared</a>. This makes returning a QString from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <a href="containers.html#linear-time" translate="no">linear time</a>.</p>
<p><b>See also </b><a href="qstring.html#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringQString&& -->
<h3 class="fn" translate="no" id="QString-7"><code class="details extra" translate="no">[noexcept]</code> QString::<span class="name">QString</span>(<span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a QString instance, making it point at the same object that <i translate="no">other</i> was pointing to.</p>
<!-- @@@QString -->
<!-- $$$~QString[overload1]$$$~QString -->
<h3 class="fn" translate="no" id="dtor.QString"><code class="details extra" translate="no">[noexcept]</code> QString::<span class="name">~QString</span>()</h3>
<p>Destroys the string.</p>
<!-- @@@~QString -->
<!-- $$$append[overload1]$$$appendconstQString& -->
<h3 class="fn" translate="no" id="append"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">append</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>)</h3>
<p>Appends the string <i translate="no">str</i> onto the end of this string.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;free&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;dom&quot;</span>;

 x<span class="operator">.</span>append(y);
 <span class="comment">// x == &quot;freedom&quot;</span>
</pre>
<p>This is the same as using the <a href="qstring.html#insert" translate="no">insert</a>() function:</p>
<pre class="cpp" translate="no">
 x<span class="operator">.</span>insert(x<span class="operator">.</span>size()<span class="operator">,</span> y);
</pre>
<p>The append() function is typically very fast (<a href="containers.html#constant-time" translate="no">constant time</a>), because <a href="qstring.html" translate="no">QString</a> preallocates extra space at the end of the string data so it can grow without reallocating the entire string each time.</p>
<p><b>See also </b><a href="qstring.html#operator-2b-eq" translate="no">operator+=</a>(), <a href="qstring.html#prepend" translate="no">prepend</a>(), and <a href="qstring.html#insert" translate="no">insert</a>().</p>
<!-- @@@append -->
<!-- $$$append$$$appendQChar -->
<h3 class="fn" translate="no" id="append-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">append</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>)</h3>
<p>This function overloads append().</p>
<p>Appends the character <i translate="no">ch</i> to this string.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstQChar*qsizetype -->
<h3 class="fn" translate="no" id="append-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">append</span>(const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>str</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>This function overloads append().</p>
<p>Appends <i translate="no">len</i> characters from the <a href="qchar.html" translate="no">QChar</a> array <i translate="no">str</i> to this string.</p>
<!-- @@@append -->
<!-- $$$append$$$appendQStringView -->
<h3 class="fn" translate="no" id="append-3"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">append</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>v</i>)</h3>
<p>This function overloads append().</p>
<p>Appends the given string view <i translate="no">v</i> to this string and returns the result.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@append -->
<!-- $$$append$$$appendQLatin1StringView -->
<h3 class="fn" translate="no" id="append-4"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">append</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>)</h3>
<p>This function overloads append().</p>
<p>Appends the Latin-1 string viewed by <i translate="no">str</i> to this string.</p>
<!-- @@@append -->
<!-- $$$append$$$appendQUtf8StringView -->
<h3 class="fn" translate="no" id="append-5"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">append</span>(<span class="type"><a href="qutf8stringview.html" translate="no">QUtf8StringView</a></span> <i>str</i>)</h3>
<p>This function overloads append().</p>
<p>Appends the UTF-8 string view <i translate="no">str</i> to this string.</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstchar* -->
<h3 class="fn" translate="no" id="append-6"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">append</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This function overloads append().</p>
<p>Appends the string <i translate="no">str</i> to this string. The given const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstQByteArray& -->
<h3 class="fn" translate="no" id="append-7"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">append</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>This function overloads append().</p>
<p>Appends the byte array <i translate="no">ba</i> to this string. The given byte array is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@append -->
<!-- $$$arg[overload1]$$$argconstQString&intQChar -->
<h3 class="fn" translate="no" id="arg"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>Returns a copy of this string with the lowest numbered place marker replaced by string <i translate="no">a</i>, i.e., <code translate="no">%1</code>, <code translate="no">%2</code>, ..., <code translate="no">%99</code>.</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that argument <i translate="no">a</i> shall occupy. If <i translate="no">a</i> requires less space than <i translate="no">fieldWidth</i>, it is padded to <i translate="no">fieldWidth</i> with character <i translate="no">fillChar</i>. A positive <i translate="no">fieldWidth</i> produces right-aligned text. A negative <i translate="no">fieldWidth</i> produces left-aligned text.</p>
<p>This example shows how we might create a <code translate="no">status</code> string for reporting progress while processing a list of files:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> i;           <span class="comment">// current file's number</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> total;       <span class="comment">// number of files to process</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> fileName;    <span class="comment">// current file's name</span>

 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> status <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;Processing file %1 of %2: %3&quot;</span>)
                 <span class="operator">.</span>arg(i)<span class="operator">.</span>arg(total)<span class="operator">.</span>arg(fileName);
</pre>
<p>First, <code translate="no">arg(i)</code> replaces <code translate="no">%1</code>. Then <code translate="no">arg(total)</code> replaces <code translate="no">%2</code>. Finally, <code translate="no">arg(fileName)</code> replaces <code translate="no">%3</code>.</p>
<p>One advantage of using arg() over <a href="qstring.html#asprintf" translate="no">asprintf</a>() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest numbered unreplaced place marker, no matter where it appears. Also, if place marker <code translate="no">%i</code> appears more than once in the string, the arg() replaces all of them.</p>
<p>If there is no unreplaced place marker remaining, a warning message is output and the result is undefined. Place marker numbers must be in the range 1 to 99.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argqlonglongintintQChar -->
<h3 class="fn" translate="no" id="arg-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qttypes.html#qlonglong-typedef" translate="no">qlonglong</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> is padded to and filled with the character <i translate="no">fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i translate="no">base</i> argument specifies the base to use when converting the integer <i translate="no">a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p><b>See also </b><a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argqulonglongintintQChar -->
<h3 class="fn" translate="no" id="arg-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qttypes.html#qulonglong-typedef" translate="no">qulonglong</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> is padded to and filled with the character <i translate="no">fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i translate="no">base</i> argument specifies the base to use when converting the integer <i translate="no">a</i> into a string. <i translate="no">base</i> must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p><b>See also </b><a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@arg -->
<!-- $$$arg$$$arglongintintQChar -->
<h3 class="fn" translate="no" id="arg-3"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type">long</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> is padded to and filled with the character <i translate="no">fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i translate="no">a</i> argument is expressed in the given <i translate="no">base</i>, which is 10 by default and must be between 2 and 36.</p>
<p>The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i translate="no">a</i>. The conversion uses the default locale. The default locale is determined from the system's locale settings at application startup. It can be changed using <a href="qlocale.html#setDefault" translate="no">QLocale::setDefault</a>(). The 'L' flag is ignored if <i translate="no">base</i> is not 10.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;
 str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;Decimal 63 is %1 in hexadecimal&quot;</span>)
         <span class="operator">.</span>arg(<span class="number">63</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">16</span>);
 <span class="comment">// str == &quot;Decimal 63 is 3f in hexadecimal&quot;</span>

 <span class="type"><a href="qlocale.html" translate="no">QLocale</a></span><span class="operator">::</span>setDefault(<span class="type"><a href="qlocale.html" translate="no">QLocale</a></span>(<span class="type"><a href="qlocale.html" translate="no">QLocale</a></span><span class="operator">::</span>English<span class="operator">,</span> <span class="type"><a href="qlocale.html" translate="no">QLocale</a></span><span class="operator">::</span>UnitedStates));
 str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;%1 %L2 %L3&quot;</span>)
         <span class="operator">.</span>arg(<span class="number">12345</span>)
         <span class="operator">.</span>arg(<span class="number">12345</span>)
         <span class="operator">.</span>arg(<span class="number">12345</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">16</span>);
 <span class="comment">// str == &quot;12345 12,345 3039&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argulongintintQChar -->
<h3 class="fn" translate="no" id="arg-4"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qttypes.html#ulong-typedef" translate="no">ulong</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> is padded to and filled with the character <i translate="no">fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i translate="no">base</i> argument specifies the base to use when converting the integer <i translate="no">a</i> to a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p><b>See also </b><a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argintintintQChar -->
<h3 class="fn" translate="no" id="arg-5"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type">int</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p>The <i translate="no">a</i> argument is expressed in base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36. For bases other than 10, <i translate="no">a</i> is treated as an unsigned integer.</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> is padded to and filled with the character <i translate="no">fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i translate="no">a</i>. The conversion uses the default locale, set by <a href="qlocale.html#setDefault" translate="no">QLocale::setDefault</a>(). If no default locale was specified, the system locale is used. The 'L' flag is ignored if <i translate="no">base</i> is not 10.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;
 str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;Decimal 63 is %1 in hexadecimal&quot;</span>)
         <span class="operator">.</span>arg(<span class="number">63</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">16</span>);
 <span class="comment">// str == &quot;Decimal 63 is 3f in hexadecimal&quot;</span>

 <span class="type"><a href="qlocale.html" translate="no">QLocale</a></span><span class="operator">::</span>setDefault(<span class="type"><a href="qlocale.html" translate="no">QLocale</a></span>(<span class="type"><a href="qlocale.html" translate="no">QLocale</a></span><span class="operator">::</span>English<span class="operator">,</span> <span class="type"><a href="qlocale.html" translate="no">QLocale</a></span><span class="operator">::</span>UnitedStates));
 str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;%1 %L2 %L3&quot;</span>)
         <span class="operator">.</span>arg(<span class="number">12345</span>)
         <span class="operator">.</span>arg(<span class="number">12345</span>)
         <span class="operator">.</span>arg(<span class="number">12345</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">16</span>);
 <span class="comment">// str == &quot;12345 12,345 3039&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@arg -->
<!-- $$$arg$$$arguintintintQChar -->
<h3 class="fn" translate="no" id="arg-6"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p>The <i translate="no">base</i> argument specifies the base to use when converting the integer <i translate="no">a</i> into a string. The base must be between 2 and 36.</p>
<p><b>See also </b><a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argshortintintQChar -->
<h3 class="fn" translate="no" id="arg-7"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type">short</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> is padded to and filled with the character <i translate="no">fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i translate="no">base</i> argument specifies the base to use when converting the integer <i translate="no">a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p><b>See also </b><a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argushortintintQChar -->
<h3 class="fn" translate="no" id="arg-8"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qttypes.html#ushort-typedef" translate="no">ushort</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> is padded to and filled with the character <i translate="no">fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i translate="no">base</i> argument specifies the base to use when converting the integer <i translate="no">a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p><b>See also </b><a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argdoubleintcharintQChar -->
<h3 class="fn" translate="no" id="arg-9"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type">double</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = -1, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p>Argument <i translate="no">a</i> is formatted according to the specified <i translate="no">format</i> and <i translate="no">precision</i>. See <a href="qstring.html#floating-point-formats" translate="no">Floating-point Formats</a> for details.</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> is padded to and filled with the character <i translate="no">fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<pre class="cpp" translate="no">
 <span class="type">double</span> d <span class="operator">=</span> <span class="number">12.34</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;delta: %1&quot;</span>)<span class="operator">.</span>arg(d<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="char">'E'</span><span class="operator">,</span> <span class="number">3</span>);
 <span class="comment">// str == &quot;delta: 1.234E+01&quot;</span>
</pre>
<p><b>See also </b><a href="qlocale.html#toString" translate="no">QLocale::toString</a>(), <a href="qlocale.html#FloatingPointPrecisionOption-enum" translate="no">QLocale::FloatingPointPrecisionOption</a>, and <a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argcharintQChar -->
<h3 class="fn" translate="no" id="arg-10"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type">char</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<p>The <i translate="no">a</i> argument is interpreted as a Latin-1 character.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argQCharintQChar -->
<h3 class="fn" translate="no" id="arg-11"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This function overloads arg().</p>
<!-- @@@arg -->
<!-- $$$arg$$$argQStringViewintQChar -->
<h3 class="fn" translate="no" id="arg-12"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This is an overloaded function.</p>
<p>Returns a copy of this string with the lowest-numbered place-marker replaced by string <i translate="no">a</i>, i.e., <code translate="no">%1</code>, <code translate="no">%2</code>, ..., <code translate="no">%99</code>.</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> shall occupy. If <i translate="no">a</i> requires less space than <i translate="no">fieldWidth</i>, it is padded to <i translate="no">fieldWidth</i> with character <i translate="no">fillChar</i>. A positive <i translate="no">fieldWidth</i> produces right-aligned text. A negative <i translate="no">fieldWidth</i> produces left-aligned text.</p>
<p>This example shows how we might create a <code translate="no">status</code> string for reporting progress while processing a list of files:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> i;                <span class="comment">// current file's number</span>
 <span class="type">int</span> total;            <span class="comment">// number of files to process</span>
 <span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> fileName; <span class="comment">// current file's name</span>

 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> status <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;Processing file %1 of %2: %3&quot;</span>)
                 <span class="operator">.</span>arg(i)<span class="operator">.</span>arg(total)<span class="operator">.</span>arg(fileName);
</pre>
<p>First, <code translate="no">arg(i)</code> replaces <code translate="no">%1</code>. Then <code translate="no">arg(total)</code> replaces <code translate="no">%2</code>. Finally, <code translate="no">arg(fileName)</code> replaces <code translate="no">%3</code>.</p>
<p>One advantage of using arg() over <a href="qstring.html#asprintf" translate="no">asprintf</a>() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker <code translate="no">%i</code> appears more than once in the string, arg() replaces all of them.</p>
<p>If there is no unreplaced place-marker remaining, a warning message is printed and the result is undefined. Place-marker numbers must be in the range 1 to 99.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argQLatin1StringViewintQChar -->
<h3 class="fn" translate="no" id="arg-13"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i> = u' ') const</h3>
<p>This is an overloaded function.</p>
<p>Returns a copy of this string with the lowest-numbered place-marker replaced by the Latin-1 string viewed by <i translate="no">a</i>, i.e., <code translate="no">%1</code>, <code translate="no">%2</code>, ..., <code translate="no">%99</code>.</p>
<p><i translate="no">fieldWidth</i> specifies the minimum amount of space that <i translate="no">a</i> shall occupy. If <i translate="no">a</i> requires less space than <i translate="no">fieldWidth</i>, it is padded to <i translate="no">fieldWidth</i> with character <i translate="no">fillChar</i>. A positive <i translate="no">fieldWidth</i> produces right-aligned text. A negative <i translate="no">fieldWidth</i> produces left-aligned text.</p>
<p>One advantage of using arg() over <a href="qstring.html#asprintf" translate="no">asprintf</a>() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker <code translate="no">%i</code> appears more than once in the string, arg() replaces all of them.</p>
<p>If there is no unreplaced place-marker remaining, a warning message is printed and the result is undefined. Place-marker numbers must be in the range 1 to 99.</p>
<!-- @@@arg -->
<!-- $$$asprintf[overload1]$$$asprintfconstchar*... -->
<h3 class="fn" translate="no" id="asprintf"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">asprintf</span>(const <span class="type">char</span> *<i>cformat</i>, ...)</h3>
<p>Safely builds a formatted string from the format string <i translate="no">cformat</i> and an arbitrary list of arguments.</p>
<p>The format string supports the conversion specifiers, length modifiers, and flags provided by printf() in the standard C++ library. The <i translate="no">cformat</i> string and <code translate="no">%s</code> arguments must be UTF-8 encoded.</p>
<div class="admonition note">
<p><b>Note: </b>The <code translate="no">%lc</code> escape sequence expects a unicode character of type <code translate="no">char16_t</code>, or <code translate="no">ushort</code> (as returned by <a href="qchar.html#unicode" translate="no">QChar::unicode</a>()). The <code translate="no">%ls</code> escape sequence expects a pointer to a zero-terminated array of unicode characters of type <code translate="no">char16_t</code>, or ushort (as returned by <a href="qstring.html#utf16" translate="no">QString::utf16</a>()). This is at odds with the printf() in the standard C++ library, which defines <code translate="no">%lc</code> to print a wchar_t and <code translate="no">%ls</code> to print a <code translate="no">wchar_t*</code>, and might also produce compiler warnings on platforms where the size of <code translate="no">wchar_t</code> is not 16 bits.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>We do not recommend using QString::asprintf() in new Qt code. Instead, consider using <a href="qtextstream.html" translate="no">QTextStream</a> or <a href="qstring.html#arg" translate="no">arg</a>(), both of which support Unicode strings seamlessly and are type-safe. Here is an example that uses <a href="qtextstream.html" translate="no">QTextStream</a>:</p>
</div>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> result;
 <span class="type"><a href="qtextstream.html" translate="no">QTextStream</a></span>(<span class="operator">&amp;</span>result) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;pi = &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3.14</span>;
 <span class="comment">// result == &quot;pi = 3.14&quot;</span>
</pre>
<p>For <a href="qobject.html#tr" translate="no">translations</a>, especially if the strings contains more than one escape sequence, you should consider using the <a href="qstring.html#arg" translate="no">arg</a>() function instead. This allows the order of the replacements to be controlled by the translator.</p>
<p><b>See also </b><a href="qstring.html#arg" translate="no">arg</a>().</p>
<!-- @@@asprintf -->
<!-- $$$assign[overload1]$$$assignQAnyStringView -->
<h3 class="fn" translate="no" id="assign"><code class="details extra" translate="no">[since 6.6]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">assign</span>(<span class="type"><a href="qanystringview.html" translate="no">QAnyStringView</a></span> <i>v</i>)</h3>
<p>Replaces the contents of this string with a copy of <i translate="no">v</i> and returns a reference to this string.</p>
<p>The size of this string will be equal to the size of <i translate="no">v</i>, converted to UTF-16 as if by <code translate="no">v.toString()</code>. Unlike <a href="qanystringview.html#toString" translate="no">QAnyStringView::toString</a>(), however, this function only allocates memory if the estimated size exceeds the capacity of this string or this string is shared.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qanystringview.html#toString" translate="no">QAnyStringView::toString</a>().</p>
<!-- @@@assign -->
<!-- $$$assign$$$assignqsizetypeQChar -->
<h3 class="fn" translate="no" id="assign-1"><code class="details extra" translate="no">[since 6.6]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">assign</span>(<span class="type">qsizetype</span> <i>n</i>, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>c</i>)</h3>
<p>Replaces the contents of this string with <i translate="no">n</i> copies of <i translate="no">c</i> and returns a reference to this string.</p>
<p>The size of this string will be equal to <i translate="no">n</i>, which has to be non-negative.</p>
<p>This function will only allocate memory if <i translate="no">n</i> exceeds the capacity of this string or this string is shared.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qstring.html#fill" translate="no">fill</a>().</p>
<!-- @@@assign -->
<!-- $$$assign$$$assignInputIteratorInputIterator -->
<h3 class="fn" translate="no" id="assign-2"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename InputIterator, QString::if_compatible_iterator&lt;InputIterator&gt; = true> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">assign</span>(<span class="type">InputIterator</span> <i>first</i>, <span class="type">InputIterator</span> <i>last</i>)</h3>
<p>Replaces the contents of this string with a copy of the elements in the iterator range [<i translate="no">first</i>, <i translate="no">last</i>) and returns a reference to this string.</p>
<p>The size of this string will be equal to the decoded length of the elements in the range [<i translate="no">first</i>, <i translate="no">last</i>), which need not be the same as the length of the range itself, because this function transparently recodes the input character set to UTF-16.</p>
<p>This function will only allocate memory if the number of elements in the range, or, for non-UTF-16-encoded input, the maximum possible size of the resulting string, exceeds the capacity of this string, or if this string is shared.</p>
<div class="admonition note">
<p><b>Note: </b>This function overload only participates in overload resolution if <code translate="no">InputIterator</code> meets the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator" translate="no">LegacyInputIterator</a> and the <code translate="no">value_type</code> of <code translate="no">InputIterator</code> is one of the following character types:</p>
</div>
<ul>
<li><a href="qchar.html" translate="no">QChar</a></li>
<li><a href="qlatin1char.html" translate="no">QLatin1Char</a></li>
<li><code translate="no">char</code></li>
<li><code translate="no">unsigned char</code></li>
<li><code translate="no">signed char</code></li>
<li><code translate="no">char8_t</code></li>
<li><code translate="no">char16_t</code></li>
<li>(on platforms, such as Windows, where it is a 16-bit type) <code translate="no">wchar_t</code></li>
<li><code translate="no">char32_t</code></li>
</ul>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined if either argument is an iterator into *this or [<i translate="no">first</i>, <i translate="no">last</i>) is not a valid range.</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@assign -->
<!-- $$$at[overload1]$$$atqsizetype -->
<h3 class="fn" translate="no" id="at">const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> QString::<span class="name">at</span>(<span class="type">qsizetype</span> <i>position</i>) const</h3>
<p>Returns the character at the given index <i translate="no">position</i> in the string.</p>
<p>The <i translate="no">position</i> must be a valid index position in the string (i.e., 0 &lt;= <i translate="no">position</i> &lt; <a href="qstring.html#size" translate="no">size</a>()).</p>
<p><b>See also </b><a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" translate="no" id="back"><span class="type"><a href="qchar.html" translate="no">QChar</a></span> QString::<span class="name">back</span>() const</h3>
<p>Returns the last character in the string. Same as <code translate="no">at(size() - 1)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty string constitutes undefined behavior.</p>
</div>
<p><b>See also </b><a href="qstring.html#front" translate="no">front</a>(), <a href="qstring.html#at" translate="no">at</a>(), and <a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$back$$$back -->
<h3 class="fn" translate="no" id="back-1"><span class="type"><a href="qchar.html" translate="no">QChar</a></span> &amp;QString::<span class="name">back</span>()</h3>
<p>Returns a reference to the last character in the string. Same as <code translate="no">operator[](size() - 1)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty string constitutes undefined behavior.</p>
</div>
<p><b>See also </b><a href="qstring.html#front" translate="no">front</a>(), <a href="qstring.html#at" translate="no">at</a>(), and <a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" translate="no" id="begin"><span class="type"><a href="qstring.html#iterator-typedefx" translate="no">QString::iterator</a></span> QString::<span class="name">begin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first character in the string.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#constBegin" translate="no">constBegin</a>() and <a href="qstring.html#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" translate="no" id="begin-1"><span class="type"><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a></span> QString::<span class="name">begin</span>() const</h3>
<p>This function overloads begin().</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" translate="no" id="capacity"><span class="type">qsizetype</span> QString::<span class="name">capacity</span>() const</h3>
<p>Returns the maximum number of characters that can be stored in the string without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qstring.html" translate="no">QString</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many characters are in the string, call <a href="qstring.html#size" translate="no">size</a>().</p>
<div class="admonition note">
<p><b>Note: </b>a statically allocated string will report a capacity of 0, even if it's not empty.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The free space position in the allocated memory block is undefined. In other words, one should not assume that the free memory is always located after the initialized elements.</p>
</div>
<p><b>See also </b><a href="qstring.html#reserve" translate="no">reserve</a>() and <a href="qstring.html#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" translate="no" id="cbegin"><span class="type"><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a></span> QString::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first character in the string.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#begin" translate="no">begin</a>() and <a href="qstring.html#cend" translate="no">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" translate="no" id="cend"><span class="type"><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a></span> QString::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing just after the last character in the string.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#cbegin" translate="no">cbegin</a>() and <a href="qstring.html#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$chop[overload1]$$$chopqsizetype -->
<h3 class="fn" translate="no" id="chop"><span class="type">void</span> QString::<span class="name">chop</span>(<span class="type">qsizetype</span> <i>n</i>)</h3>
<p>Removes <i translate="no">n</i> characters from the end of the string.</p>
<p>If <i translate="no">n</i> is greater than or equal to <a href="qstring.html#size" translate="no">size</a>(), the result is an empty string; if <i translate="no">n</i> is negative, it is equivalent to passing zero.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str(<span class="string">&quot;LOGOUT\r\n&quot;</span>);
 str<span class="operator">.</span>chop(<span class="number">2</span>);
 <span class="comment">// str == &quot;LOGOUT&quot;</span>
</pre>
<p>If you want to remove characters from the <i>beginning</i> of the string, use <a href="qstring.html#remove" translate="no">remove</a>() instead.</p>
<p><b>See also </b><a href="qstring.html#truncate" translate="no">truncate</a>(), <a href="qstring.html#resize" translate="no">resize</a>(), <a href="qstring.html#remove" translate="no">remove</a>(), and <a href="qstringview.html#chop" translate="no">QStringView::chop</a>().</p>
<!-- @@@chop -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QString::<span class="name">clear</span>()</h3>
<p>Clears the contents of the string and makes it null.</p>
<p><b>See also </b><a href="qstring.html#resize" translate="no">resize</a>() and <a href="qstring.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@clear -->
<!-- $$$compare[overload1]$$$compareconstQString&constQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare"><code class="details extra" translate="no">[static noexcept]</code> <span class="type">int</span> QString::<span class="name">compare</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>Compares the string <i translate="no">s1</i> with the string <i translate="no">s2</i> and returns a negative integer if <i translate="no">s1</i> is less than <i translate="no">s2</i>, a positive integer if it is greater than <i translate="no">s2</i>, and zero if they are equal.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the comparison is case-sensitive; otherwise the comparison is case-insensitive.</p>
<p>Case sensitive comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-visible strings with <a href="qstring.html#localeAwareCompare" translate="no">localeAwareCompare</a>().</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> x <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span><span class="operator">::</span>compare(<span class="string">&quot;aUtO&quot;</span><span class="operator">,</span> <span class="string">&quot;AuTo&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseInsensitive);  <span class="comment">// x == 0</span>
 <span class="type">int</span> y <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span><span class="operator">::</span>compare(<span class="string">&quot;auto&quot;</span><span class="operator">,</span> <span class="string">&quot;Car&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseSensitive);     <span class="comment">// y &gt; 0</span>
 <span class="type">int</span> z <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span><span class="operator">::</span>compare(<span class="string">&quot;auto&quot;</span><span class="operator">,</span> <span class="string">&quot;Car&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseInsensitive);   <span class="comment">// z &lt; 0</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>This function treats null strings the same as empty strings, for more details see <a href="qstring.html#distinction-between-null-and-empty-strings" translate="no">Distinction Between Null and Empty Strings</a>.</p>
</div>
<p><b>See also </b><a href="qstring.html#operator-eq-eq-1" translate="no">operator==</a>(), <a href="qstring.html#operator-lt-1" translate="no">operator&lt;</a>(), <a href="qstring.html#operator-gt" translate="no">operator&gt;</a>(), and <a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">int</span> QString::<span class="name">compare</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>other</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads compare().</p>
<p>Lexically compares this string with the string <i translate="no">other</i> and returns a negative integer if this string is less than <i translate="no">other</i>, a positive integer if it is greater than <i translate="no">other</i>, and zero if they are equal.</p>
<p>Same as compare(*this, <i translate="no">other</i>, <i translate="no">cs</i>).</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareQLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare-2"><code class="details extra" translate="no">[noexcept]</code> <span class="type">int</span> QString::<span class="name">compare</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>other</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads compare().</p>
<p>Same as compare(*this, <i translate="no">other</i>, <i translate="no">cs</i>).</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareQStringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type">int</span> QString::<span class="name">compare</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>s</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads compare().</p>
<p>Performs a comparison of this with <i translate="no">s</i>, using the case sensitivity setting <i translate="no">cs</i>.</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareQCharQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare-4"><code class="details extra" translate="no">[noexcept]</code> <span class="type">int</span> QString::<span class="name">compare</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads compare().</p>
<p>Performs a comparison of this with <i translate="no">ch</i>, using the case sensitivity setting <i translate="no">cs</i>.</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareconstQString&QLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare-5"><code class="details extra" translate="no">[static noexcept]</code> <span class="type">int</span> QString::<span class="name">compare</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s2</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads compare().</p>
<p>Performs a comparison of <i translate="no">s1</i> and <i translate="no">s2</i>, using the case sensitivity setting <i translate="no">cs</i>.</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareQLatin1StringViewconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare-6"><code class="details extra" translate="no">[static noexcept]</code> <span class="type">int</span> QString::<span class="name">compare</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads compare().</p>
<p>Performs a comparison of <i translate="no">s1</i> and <i translate="no">s2</i>, using the case sensitivity setting <i translate="no">cs</i>.</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareconstQString&QStringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare-7"><code class="details extra" translate="no">[static noexcept]</code> <span class="type">int</span> QString::<span class="name">compare</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, <span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>s2</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads compare().</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareQStringViewconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare-8"><code class="details extra" translate="no">[static noexcept]</code> <span class="type">int</span> QString::<span class="name">compare</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads compare().</p>
<!-- @@@compare -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" translate="no" id="constBegin"><span class="type"><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a></span> QString::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first character in the string.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#begin" translate="no">begin</a>() and <a href="qstring.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constData[overload1]$$$constData -->
<h3 class="fn" translate="no" id="constData">const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *QString::<span class="name">constData</span>() const</h3>
<p>Returns a pointer to the data stored in the <a href="qstring.html" translate="no">QString</a>. The pointer can be used to access the characters that compose the string.</p>
<p>Note that the pointer remains valid only as long as the string is not modified.</p>
<div class="admonition note">
<p><b>Note: </b>The returned string may not be '\0'-terminated. Use <a href="qstring.html#size" translate="no">size</a>() to determine the length of the array.</p>
</div>
<p><b>See also </b><a href="qstring.html#data" translate="no">data</a>(), <a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>(), and <a href="qstring.html#fromRawData" translate="no">fromRawData</a>().</p>
<!-- @@@constData -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" translate="no" id="constEnd"><span class="type"><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a></span> QString::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing just after the last character in the string.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#constBegin" translate="no">constBegin</a>() and <a href="qstring.html#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$contains[overload1]$$$containsconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="contains"><span class="type">bool</span> QString::<span class="name">contains</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns <code translate="no">true</code> if this string contains an occurrence of the string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Peter Pan&quot;</span>;
 str<span class="operator">.</span>contains(<span class="string">&quot;peter&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseInsensitive);    <span class="comment">// returns true</span>
</pre>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>() and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsQCharQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="contains-1"><span class="type">bool</span> QString::<span class="name">contains</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads contains().</p>
<p>Returns <code translate="no">true</code> if this string contains an occurrence of the character <i translate="no">ch</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsQLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="contains-2"><span class="type">bool</span> QString::<span class="name">contains</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads contains().</p>
<p>Returns <code translate="no">true</code> if this string contains an occurrence of the latin-1 string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsQStringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="contains-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QString::<span class="name">contains</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads contains().</p>
<p>Returns <code translate="no">true</code> if this string contains an occurrence of the string view <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>() and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQRegularExpression&QRegularExpressionMatch* -->
<h3 class="fn" translate="no" id="contains-4"><span class="type">bool</span> QString::<span class="name">contains</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type"><a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> *<i>rmatch</i> = nullptr) const</h3>
<p>Returns <code translate="no">true</code> if the regular expression <i translate="no">re</i> matches somewhere in this string; otherwise returns <code translate="no">false</code>.</p>
<p>If the match is successful and <i translate="no">rmatch</i> is not <code translate="no">nullptr</code>, it also writes the results of the match into the <a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a> object pointed to by <i translate="no">rmatch</i>.</p>
<p><b>See also </b><a href="qregularexpression.html#match" translate="no">QRegularExpression::match</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="count"><span class="type">qsizetype</span> QString::<span class="name">count</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns the number of (potentially overlapping) occurrences of the string <i translate="no">str</i> in this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p><b>See also </b><a href="qstring.html#contains" translate="no">contains</a>() and <a href="qstring.html#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countQCharQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="count-2"><span class="type">qsizetype</span> QString::<span class="name">count</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads count().</p>
<p>Returns the number of occurrences of character <i translate="no">ch</i> in the string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p><b>See also </b><a href="qstring.html#contains" translate="no">contains</a>() and <a href="qstring.html#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countQStringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="count-3"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">qsizetype</span> QString::<span class="name">count</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads count().</p>
<p>Returns the number of (potentially overlapping) occurrences of the string view <i translate="no">str</i> in this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qstring.html#contains" translate="no">contains</a>() and <a href="qstring.html#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countconstQRegularExpression& -->
<h3 class="fn" translate="no" id="count-4"><span class="type">qsizetype</span> QString::<span class="name">count</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>) const</h3>
<p>This function overloads count().</p>
<p>Returns the number of times the regular expression <i translate="no">re</i> matches in the string.</p>
<p>For historical reasons, this function counts overlapping matches, so in the example below, there are four instances of &quot;ana&quot; or &quot;ama&quot;:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;banana and panama&quot;</span>;
 str<span class="operator">.</span>count(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;a[nm]a&quot;</span>));    <span class="comment">// returns 4</span>
</pre>
<p>This behavior is different from simply iterating over the matches in the string using <a href="qregularexpressionmatchiterator.html" translate="no">QRegularExpressionMatchIterator</a>.</p>
<p><b>See also </b><a href="qregularexpression.html#globalMatch" translate="no">QRegularExpression::globalMatch</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" translate="no" id="crbegin"><span class="type"><a href="qstring.html#const_reverse_iterator-typedef" translate="no">QString::const_reverse_iterator</a></span> QString::<span class="name">crbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first character in the string, in reverse order.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#begin" translate="no">begin</a>(), <a href="qstring.html#rbegin" translate="no">rbegin</a>(), and <a href="qstring.html#rend" translate="no">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" translate="no" id="crend"><span class="type"><a href="qstring.html#const_reverse_iterator-typedef" translate="no">QString::const_reverse_iterator</a></span> QString::<span class="name">crend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing just after the last character in the string, in reverse order.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#end" translate="no">end</a>(), <a href="qstring.html#rend" translate="no">rend</a>(), and <a href="qstring.html#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" translate="no" id="data"><span class="type"><a href="qchar.html" translate="no">QChar</a></span> *QString::<span class="name">data</span>()</h3>
<p>Returns a pointer to the data stored in the <a href="qstring.html" translate="no">QString</a>. The pointer can be used to access and modify the characters that compose the string.</p>
<p>Unlike <a href="qstring.html#constData" translate="no">constData</a>() and <a href="qstring.html#unicode" translate="no">unicode</a>(), the returned data is always '\0'-terminated.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;
 <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <span class="operator">*</span>data <span class="operator">=</span> str<span class="operator">.</span>data();
 <span class="keyword">while</span> (<span class="operator">!</span>data<span class="operator">-</span><span class="operator">&gt;</span>isNull()) {
     <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> data<span class="operator">-</span><span class="operator">&gt;</span>unicode();
     <span class="operator">+</span><span class="operator">+</span>data;
 }
</pre>
<p>Note that the pointer remains valid only as long as the string is not modified by other means. For read-only access, <a href="qstring.html#constData" translate="no">constData</a>() is faster because it never causes a <a href="implicit-sharing.html#deep-copy" translate="no">deep copy</a> to occur.</p>
<p><b>See also </b><a href="qstring.html#constData" translate="no">constData</a>() and <a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$data -->
<h3 class="fn" translate="no" id="data-1">const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *QString::<span class="name">data</span>() const</h3>
<p>This is an overloaded function.</p>
<div class="admonition note">
<p><b>Note: </b>The returned string may not be '\0'-terminated. Use <a href="qstring.html#size" translate="no">size</a>() to determine the length of the array.</p>
</div>
<p><b>See also </b><a href="qstring.html#fromRawData" translate="no">fromRawData</a>().</p>
<!-- @@@data -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end"><span class="type"><a href="qstring.html#iterator-typedefx" translate="no">QString::iterator</a></span> QString::<span class="name">end</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing just after the last character in the string.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#begin" translate="no">begin</a>() and <a href="qstring.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" translate="no" id="end-1"><span class="type"><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a></span> QString::<span class="name">end</span>() const</h3>
<p>This function overloads end().</p>
<!-- @@@end -->
<!-- $$$endsWith[overload1]$$$endsWithconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="endsWith"><span class="type">bool</span> QString::<span class="name">endsWith</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns <code translate="no">true</code> if the string ends with <i translate="no">s</i>; otherwise returns <code translate="no">false</code>.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Bananas&quot;</span>;
 str<span class="operator">.</span>endsWith(<span class="string">&quot;anas&quot;</span>);         <span class="comment">// returns true</span>
 str<span class="operator">.</span>endsWith(<span class="string">&quot;pple&quot;</span>);         <span class="comment">// returns false</span>
</pre>
<p><b>See also </b><a href="qstring.html#startsWith" translate="no">startsWith</a>().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithQStringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="endsWith-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QString::<span class="name">endsWith</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads endsWith().</p>
<p>Returns <code translate="no">true</code> if the string ends with the string view <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p><b>See also </b><a href="qstring.html#startsWith" translate="no">startsWith</a>().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithQLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="endsWith-2"><span class="type">bool</span> QString::<span class="name">endsWith</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads endsWith().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithQCharQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="endsWith-3"><span class="type">bool</span> QString::<span class="name">endsWith</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>c</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns <code translate="no">true</code> if the string ends with <i translate="no">c</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function overloads endsWith().</p>
<!-- @@@endsWith -->
<!-- $$$erase[overload1]$$$eraseQString::const_iteratorQString::const_iterator -->
<h3 class="fn" translate="no" id="erase"><code class="details extra" translate="no">[since 6.1]</code> <span class="type"><a href="qstring.html#iterator-typedefx" translate="no">QString::iterator</a></span> QString::<span class="name">erase</span>(<span class="type"><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a></span> <i>first</i>, <span class="type"><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a></span> <i>last</i>)</h3>
<p>Removes from the string the characters in the half-open range [ <i translate="no">first</i> , <i translate="no">last</i> ). Returns an iterator to the character immediately after the last erased character (i.e. the character referred to by <i translate="no">last</i> before the erase).</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@erase -->
<!-- $$$erase$$$eraseQString::const_iterator -->
<h3 class="fn" translate="no" id="erase-1"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qstring.html#iterator-typedefx" translate="no">QString::iterator</a></span> QString::<span class="name">erase</span>(<span class="type"><a href="qstring.html#const_iterator-typedef" translate="no">QString::const_iterator</a></span> <i>it</i>)</h3>
<p>Removes the character denoted by <code translate="no">it</code> from the string. Returns an iterator to the character immediately after the erased character.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> c <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;
 <span class="keyword">auto</span> it <span class="operator">=</span> c<span class="operator">.</span>erase(c<span class="operator">.</span>cbegin()); <span class="comment">// c is now &quot;bcdefg&quot;; &quot;it&quot; points to &quot;b&quot;</span>
</pre>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@erase -->
<!-- $$$fill[overload1]$$$fillQCharqsizetype -->
<h3 class="fn" translate="no" id="fill"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">fill</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>, <span class="type">qsizetype</span> <i>size</i> = -1)</h3>
<p>Sets every character in the string to character <i translate="no">ch</i>. If <i translate="no">size</i> is different from -1 (default), the string is resized to <i translate="no">size</i> beforehand.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Berlin&quot;</span>;
 str<span class="operator">.</span>fill(<span class="char">'z'</span>);
 <span class="comment">// str == &quot;zzzzzz&quot;</span>

 str<span class="operator">.</span>fill(<span class="char">'A'</span><span class="operator">,</span> <span class="number">2</span>);
 <span class="comment">// str == &quot;AA&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#resize" translate="no">resize</a>().</p>
<!-- @@@fill -->
<!-- $$$fromCFString[overload1]$$$fromCFStringCFStringRef -->
<h3 class="fn" translate="no" id="fromCFString"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromCFString</span>(<span class="type">CFStringRef</span> <i>string</i>)</h3>
<p>Constructs a new <a href="qstring.html" translate="no">QString</a> containing a copy of the <i translate="no">string</i> CFString.</p>
<div class="admonition note">
<p><b>Note: </b>this function is only available on macOS and iOS.</p>
</div>
<!-- @@@fromCFString -->
<!-- $$$fromEcmaString[overload1]$$$fromEcmaStringemscripten::val -->
<h3 class="fn" translate="no" id="fromEcmaString"><code class="details extra" translate="no">[static, since 6.6]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromEcmaString</span>(<span class="type">emscripten::val</span> <i>jsString</i>)</h3>
<p>Converts the <a href="https://262.ecma-international.org/#sec-string-object" translate="no">ECMAScript string</a> <i translate="no">jsString</i> to <a href="qstring.html" translate="no">QString</a>. Behavior is undefined if the provided parameter is not a string.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qstring.html#toEcmaString" translate="no">toEcmaString</a>().</p>
<!-- @@@fromEcmaString -->
<!-- $$$fromLatin1[overload1]$$$fromLatin1constchar*qsizetype -->
<h3 class="fn" translate="no" id="fromLatin1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromLatin1</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the first <i translate="no">size</i> characters of the Latin-1 string <i translate="no">str</i>.</p>
<p>If <i translate="no">size</i> is <code translate="no">-1</code>, <code translate="no">strlen(str)</code> is used instead.</p>
<p><b>See also </b><a href="qstring.html#toLatin1" translate="no">toLatin1</a>(), <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(), and <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>().</p>
<!-- @@@fromLatin1 -->
<!-- $$$fromLatin1$$$fromLatin1QByteArrayView -->
<h3 class="fn" translate="no" id="fromLatin1-1"><code class="details extra" translate="no">[static, since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromLatin1</span>(<span class="type"><a href="qbytearrayview.html" translate="no">QByteArrayView</a></span> <i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the Latin-1 string <i translate="no">str</i>.</p>
<div class="admonition note">
<p><b>Note: </b>: any null ('\0') bytes in the byte array will be included in this string, converted to Unicode null characters (U+0000).</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@fromLatin1 -->
<!-- $$$fromLatin1$$$fromLatin1constQByteArray& -->
<h3 class="fn" translate="no" id="fromLatin1-2"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromLatin1</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the Latin-1 string <i translate="no">str</i>.</p>
<div class="admonition note">
<p><b>Note: </b>: any null ('\0') bytes in the byte array will be included in this string, converted to Unicode null characters (U+0000). This behavior is different from Qt 5.x.</p>
</div>
<!-- @@@fromLatin1 -->
<!-- $$$fromLocal8Bit[overload1]$$$fromLocal8Bitconstchar*qsizetype -->
<h3 class="fn" translate="no" id="fromLocal8Bit"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromLocal8Bit</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the first <i translate="no">size</i> characters of the 8-bit string <i translate="no">str</i>.</p>
<p>If <i translate="no">size</i> is <code translate="no">-1</code>, <code translate="no">strlen(str)</code> is used instead.</p>
<p>On Unix systems this is equivalent to <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(). Note that on Apple systems this function does not take <a href="https://developer.apple.com/documentation/foundation/nsstring/1410091-defaultcstringencoding?language=objc" translate="no">NSString.defaultCStringEncoding</a> or <a href="https://developer.apple.com/documentation/corefoundation/1541720-cfstringgetsystemencoding?language=objc" translate="no">CFStringGetSystemEncoding()</a> into account, as these functions typically return the legacy &quot;Western (Mac OS Roman)&quot; encoding, which should not be used on modern Apple operating systems. On Windows the system's current code page is used.</p>
<p><b>See also </b><a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>(), <a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), and <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>().</p>
<!-- @@@fromLocal8Bit -->
<!-- $$$fromLocal8Bit$$$fromLocal8BitQByteArrayView -->
<h3 class="fn" translate="no" id="fromLocal8Bit-1"><code class="details extra" translate="no">[static, since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromLocal8Bit</span>(<span class="type"><a href="qbytearrayview.html" translate="no">QByteArrayView</a></span> <i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the 8-bit string <i translate="no">str</i>.</p>
<p>On Unix systems this is equivalent to <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(). Note that on Apple systems this function does not take <a href="https://developer.apple.com/documentation/foundation/nsstring/1410091-defaultcstringencoding?language=objc" translate="no">NSString.defaultCStringEncoding</a> or <a href="https://developer.apple.com/documentation/corefoundation/1541720-cfstringgetsystemencoding?language=objc" translate="no">CFStringGetSystemEncoding()</a> into account, as these functions typically return the legacy &quot;Western (Mac OS Roman)&quot; encoding, which should not be used on modern Apple operating systems. On Windows the system's current code page is used.</p>
<div class="admonition note">
<p><b>Note: </b>: any null ('\0') bytes in the byte array will be included in this string, converted to Unicode null characters (U+0000).</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@fromLocal8Bit -->
<!-- $$$fromLocal8Bit$$$fromLocal8BitconstQByteArray& -->
<h3 class="fn" translate="no" id="fromLocal8Bit-2"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromLocal8Bit</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the 8-bit string <i translate="no">str</i>.</p>
<p>On Unix systems this is equivalent to <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(). Note that on Apple systems this function does not take <a href="https://developer.apple.com/documentation/foundation/nsstring/1410091-defaultcstringencoding?language=objc" translate="no">NSString.defaultCStringEncoding</a> or <a href="https://developer.apple.com/documentation/corefoundation/1541720-cfstringgetsystemencoding?language=objc" translate="no">CFStringGetSystemEncoding()</a> into account, as these functions typically return the legacy &quot;Western (Mac OS Roman)&quot; encoding, which should not be used on modern Apple operating systems. On Windows the system's current code page is used.</p>
<div class="admonition note">
<p><b>Note: </b>: any null ('\0') bytes in the byte array will be included in this string, converted to Unicode null characters (U+0000). This behavior is different from Qt 5.x.</p>
</div>
<!-- @@@fromLocal8Bit -->
<!-- $$$fromNSString[overload1]$$$fromNSStringconstNSString* -->
<h3 class="fn" translate="no" id="fromNSString"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromNSString</span>(const <span class="type">NSString</span> *<i>string</i>)</h3>
<p>Constructs a new <a href="qstring.html" translate="no">QString</a> containing a copy of the <i translate="no">string</i> NSString.</p>
<div class="admonition note">
<p><b>Note: </b>this function is only available on macOS and iOS.</p>
</div>
<!-- @@@fromNSString -->
<!-- $$$fromRawData[overload1]$$$fromRawDataconstQChar*qsizetype -->
<h3 class="fn" translate="no" id="fromRawData"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromRawData</span>(const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>unicode</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Constructs a <a href="qstring.html" translate="no">QString</a> that uses the first <i translate="no">size</i> Unicode characters in the array <i translate="no">unicode</i>. The data in <i translate="no">unicode</i> is <i>not</i> copied. The caller must be able to guarantee that <i translate="no">unicode</i> will not be deleted or modified as long as the <a href="qstring.html" translate="no">QString</a> (or an unmodified copy of it) exists.</p>
<p>Any attempts to modify the <a href="qstring.html" translate="no">QString</a> or copies of it will cause it to create a deep copy of the data, ensuring that the raw data isn't modified.</p>
<p>Here is an example of how we can use a <a href="qregularexpression.html" translate="no">QRegularExpression</a> on raw data in memory without requiring to copy the data into a <a href="qstring.html" translate="no">QString</a>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> pattern(<span class="string">&quot;\u00A4&quot;</span>);
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span> unicode<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
         <span class="number">0x005A</span><span class="operator">,</span> <span class="number">0x007F</span><span class="operator">,</span> <span class="number">0x00A4</span><span class="operator">,</span> <span class="number">0x0060</span><span class="operator">,</span>
         <span class="number">0x1009</span><span class="operator">,</span> <span class="number">0x0020</span><span class="operator">,</span> <span class="number">0x0020</span>};
 qsizetype size <span class="operator">=</span> <span class="keyword">sizeof</span>(unicode) <span class="operator">/</span> <span class="keyword">sizeof</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span>);

 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span><span class="operator">::</span>fromRawData(unicode<span class="operator">,</span> size);
 <span class="keyword">if</span> (str<span class="operator">.</span>contains(pattern) {
     <span class="comment">// ...</span>
 }
</pre>
<div class="admonition warning">
<p><b>Warning: </b>A string created with fromRawData() is <i>not</i> '\0'-terminated, unless the raw data contains a '\0' character at position <i translate="no">size</i>. This means <a href="qstring.html#unicode" translate="no">unicode</a>() will <i>not</i> return a '\0'-terminated string (although <a href="qstring.html#utf16" translate="no">utf16</a>() does, at the cost of copying the raw data).</p>
</div>
<p><b>See also </b><a href="qstring.html#fromUtf16" translate="no">fromUtf16</a>() and <a href="qstring.html#setRawData" translate="no">setRawData</a>().</p>
<!-- @@@fromRawData -->
<!-- $$$fromStdString[overload1]$$$fromStdStringconststd::string& -->
<h3 class="fn" translate="no" id="fromStdString"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromStdString</span>(const <span class="type">std::string</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i translate="no">str</i> string. The given string is assumed to be encoded in UTF-8, and is converted to <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p><b>See also </b><a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>(), <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(), and <a href="qbytearray.html#fromStdString" translate="no">QByteArray::fromStdString</a>().</p>
<!-- @@@fromStdString -->
<!-- $$$fromStdU16String[overload1]$$$fromStdU16Stringconststd::u16string& -->
<h3 class="fn" translate="no" id="fromStdU16String"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromStdU16String</span>(const <span class="type">std::u16string</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i translate="no">str</i> string. The given string is assumed to be encoded in UTF-16, and is converted to <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf16" translate="no">fromUtf16</a>() function.</p>
<p><b>See also </b><a href="qstring.html#fromUtf16" translate="no">fromUtf16</a>(), <a href="qstring.html#fromStdWString" translate="no">fromStdWString</a>(), and <a href="qstring.html#fromStdU32String" translate="no">fromStdU32String</a>().</p>
<!-- @@@fromStdU16String -->
<!-- $$$fromStdU32String[overload1]$$$fromStdU32Stringconststd::u32string& -->
<h3 class="fn" translate="no" id="fromStdU32String"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromStdU32String</span>(const <span class="type">std::u32string</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i translate="no">str</i> string. The given string is assumed to be encoded in UCS-4, and is converted to <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUcs4" translate="no">fromUcs4</a>() function.</p>
<p><b>See also </b><a href="qstring.html#fromUcs4" translate="no">fromUcs4</a>(), <a href="qstring.html#fromStdWString" translate="no">fromStdWString</a>(), and <a href="qstring.html#fromStdU16String" translate="no">fromStdU16String</a>().</p>
<!-- @@@fromStdU32String -->
<!-- $$$fromStdWString[overload1]$$$fromStdWStringconststd::wstring& -->
<h3 class="fn" translate="no" id="fromStdWString"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromStdWString</span>(const <span class="type">std::wstring</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i translate="no">str</i> string. The given string is assumed to be encoded in utf16 if the size of wchar_t is 2 bytes (e.g. on windows) and ucs4 if the size of wchar_t is 4 bytes (most Unix systems).</p>
<p><b>See also </b><a href="qstring.html#fromUtf16" translate="no">fromUtf16</a>(), <a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>(), <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(), <a href="qstring.html#fromUcs4" translate="no">fromUcs4</a>(), <a href="qstring.html#fromStdU16String" translate="no">fromStdU16String</a>(), and <a href="qstring.html#fromStdU32String" translate="no">fromStdU32String</a>().</p>
<!-- @@@fromStdWString -->
<!-- $$$fromUcs4[overload1]$$$fromUcs4constchar32_t*qsizetype -->
<h3 class="fn" translate="no" id="fromUcs4"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromUcs4</span>(const <span class="type">char32_t</span> *<i>unicode</i>, <span class="type">qsizetype</span> <i>size</i> = -1)</h3>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the first <i translate="no">size</i> characters of the Unicode string <i translate="no">unicode</i> (ISO-10646-UCS-4 encoded).</p>
<p>If <i translate="no">size</i> is -1 (default), <i translate="no">unicode</i> must be \0'-terminated.</p>
<p><b>See also </b><a href="qstring.html#toUcs4" translate="no">toUcs4</a>(), <a href="qstring.html#fromUtf16" translate="no">fromUtf16</a>(), <a href="qstring.html#utf16" translate="no">utf16</a>(), <a href="qstring.html#setUtf16" translate="no">setUtf16</a>(), <a href="qstring.html#fromWCharArray" translate="no">fromWCharArray</a>(), and <a href="qstring.html#fromStdU32String" translate="no">fromStdU32String</a>().</p>
<!-- @@@fromUcs4 -->
<!-- $$$fromUtf8[overload1]$$$fromUtf8constchar*qsizetype -->
<h3 class="fn" translate="no" id="fromUtf8"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromUtf8</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the first <i translate="no">size</i> bytes of the UTF-8 string <i translate="no">str</i>.</p>
<p>If <i translate="no">size</i> is <code translate="no">-1</code>, <code translate="no">strlen(str)</code> is used instead.</p>
<p>UTF-8 is a Unicode codec and can represent all characters in a Unicode string like <a href="qstring.html" translate="no">QString</a>. However, invalid sequences are possible with UTF-8 and, if any such are found, they will be replaced with one or more &quot;replacement characters&quot;, or suppressed. These include non-Unicode sequences, non-characters, overlong sequences or surrogate codepoints encoded into UTF-8.</p>
<p>This function can be used to process incoming data incrementally as long as all UTF-8 characters are terminated within the incoming data. Any unterminated characters at the end of the string will be replaced or suppressed. In order to do stateful decoding, please use <a href="qstringdecoder.html" translate="no">QStringDecoder</a>.</p>
<p><b>See also </b><a href="qstring.html#toUtf8" translate="no">toUtf8</a>(), <a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), and <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>().</p>
<!-- @@@fromUtf8 -->
<!-- $$$fromUtf8$$$fromUtf8QByteArrayView -->
<h3 class="fn" translate="no" id="fromUtf8-1"><code class="details extra" translate="no">[static, since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromUtf8</span>(<span class="type"><a href="qbytearrayview.html" translate="no">QByteArrayView</a></span> <i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the UTF-8 string <i translate="no">str</i>.</p>
<div class="admonition note">
<p><b>Note: </b>: any null ('\0') bytes in the byte array will be included in this string, converted to Unicode null characters (U+0000).</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@fromUtf8 -->
<!-- $$$fromUtf8$$$fromUtf8constQByteArray& -->
<h3 class="fn" translate="no" id="fromUtf8-2"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromUtf8</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the UTF-8 string <i translate="no">str</i>.</p>
<div class="admonition note">
<p><b>Note: </b>: any null ('\0') bytes in the byte array will be included in this string, converted to Unicode null characters (U+0000). This behavior is different from Qt 5.x.</p>
</div>
<!-- @@@fromUtf8 -->
<!-- $$$fromUtf8$$$fromUtf8constint* -->
<h3 class="fn" translate="no" id="fromUtf8-3"><code class="details extra" translate="no">[static, since 6.1]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromUtf8</span>(const <span class="type">int</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>This overload is only available when compiling in C++20 mode.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@fromUtf8 -->
<!-- $$$fromUtf8$$$fromUtf8constint*qsizetype -->
<h3 class="fn" translate="no" id="fromUtf8-4"><code class="details extra" translate="no">[static, since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromUtf8</span>(const <span class="type">int</span> *<i>str</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>This is an overloaded function.</p>
<p>This overload is only available when compiling in C++20 mode.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@fromUtf8 -->
<!-- $$$fromUtf16[overload1]$$$fromUtf16constchar16_t*qsizetype -->
<h3 class="fn" translate="no" id="fromUtf16"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromUtf16</span>(const <span class="type">char16_t</span> *<i>unicode</i>, <span class="type">qsizetype</span> <i>size</i> = -1)</h3>
<p>Returns a <a href="qstring.html" translate="no">QString</a> initialized with the first <i translate="no">size</i> characters of the Unicode string <i translate="no">unicode</i> (ISO-10646-UTF-16 encoded).</p>
<p>If <i translate="no">size</i> is -1 (default), <i translate="no">unicode</i> must be \0'-terminated.</p>
<p>This function checks for a Byte Order Mark (BOM). If it is missing, host byte order is assumed.</p>
<p>This function is slow compared to the other Unicode conversions. Use <a href="qstring.html" translate="no">QString</a>(const <a href="qchar.html" translate="no">QChar</a> *, qsizetype) or <a href="qstring.html" translate="no">QString</a>(const <a href="qchar.html" translate="no">QChar</a> *) if possible.</p>
<p><a href="qstring.html" translate="no">QString</a> makes a deep copy of the Unicode data.</p>
<p><b>See also </b><a href="qstring.html#utf16" translate="no">utf16</a>(), <a href="qstring.html#setUtf16" translate="no">setUtf16</a>(), and <a href="qstring.html#fromStdU16String" translate="no">fromStdU16String</a>().</p>
<!-- @@@fromUtf16 -->
<!-- $$$fromWCharArray[overload1]$$$fromWCharArrayconstwchar_t*qsizetype -->
<h3 class="fn" translate="no" id="fromWCharArray"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">fromWCharArray</span>(const <span class="type">wchar_t</span> *<i>string</i>, <span class="type">qsizetype</span> <i>size</i> = -1)</h3>
<p>Returns a copy of the <i translate="no">string</i>, where the encoding of <i translate="no">string</i> depends on the size of wchar. If wchar is 4 bytes, the <i translate="no">string</i> is interpreted as UCS-4, if wchar is 2 bytes it is interpreted as UTF-16.</p>
<p>If <i translate="no">size</i> is -1 (default), the <i translate="no">string</i> must be '\0'-terminated.</p>
<p><b>See also </b><a href="qstring.html#fromUtf16" translate="no">fromUtf16</a>(), <a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>(), <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(), <a href="qstring.html#fromUcs4" translate="no">fromUcs4</a>(), and <a href="qstring.html#fromStdWString" translate="no">fromStdWString</a>().</p>
<!-- @@@fromWCharArray -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" translate="no" id="front"><span class="type"><a href="qchar.html" translate="no">QChar</a></span> QString::<span class="name">front</span>() const</h3>
<p>Returns the first character in the string. Same as <code translate="no">at(0)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty string constitutes undefined behavior.</p>
</div>
<p><b>See also </b><a href="qstring.html#back" translate="no">back</a>(), <a href="qstring.html#at" translate="no">at</a>(), and <a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$front$$$front -->
<h3 class="fn" translate="no" id="front-1"><span class="type"><a href="qchar.html" translate="no">QChar</a></span> &amp;QString::<span class="name">front</span>()</h3>
<p>Returns a reference to the first character in the string. Same as <code translate="no">operator[](0)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty string constitutes undefined behavior.</p>
</div>
<p><b>See also </b><a href="qstring.html#back" translate="no">back</a>(), <a href="qstring.html#at" translate="no">at</a>(), and <a href="qstring.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$indexOf[overload1]$$$indexOfQLatin1StringViewqsizetypeQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="indexOf"><span class="type">qsizetype</span> QString::<span class="name">indexOf</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>, <span class="type">qsizetype</span> <i>from</i> = 0, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns the index position of the first occurrence of the Latin-1 string viewed by <i translate="no">str</i> in this string, searching forward from index position <i translate="no">from</i>. Returns -1 if <i translate="no">str</i> is not found.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;sticky question&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;sti&quot;</span>;
 x<span class="operator">.</span>indexOf(y);               <span class="comment">// returns 0</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">1</span>);            <span class="comment">// returns 10</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">10</span>);           <span class="comment">// returns 10</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">11</span>);           <span class="comment">// returns -1</span>
</pre>
<p>If <i translate="no">from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p><b>See also </b><a href="qstring.html#lastIndexOf" translate="no">lastIndexOf</a>(), <a href="qstring.html#contains" translate="no">contains</a>(), and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfQCharqsizetypeQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="indexOf-1"><span class="type">qsizetype</span> QString::<span class="name">indexOf</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>, <span class="type">qsizetype</span> <i>from</i> = 0, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads indexOf().</p>
<p>Returns the index position of the first occurrence of the character <i translate="no">ch</i> in this string, searching forward from index position <i translate="no">from</i>. Returns -1 if <i translate="no">ch</i> is not found.</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfconstQString&qsizetypeQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="indexOf-2"><span class="type">qsizetype</span> QString::<span class="name">indexOf</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>, <span class="type">qsizetype</span> <i>from</i> = 0, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns the index position of the first occurrence of the string <i translate="no">str</i> in this string, searching forward from index position <i translate="no">from</i>. Returns -1 if <i translate="no">str</i> is not found.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;sticky question&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;sti&quot;</span>;
 x<span class="operator">.</span>indexOf(y);               <span class="comment">// returns 0</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">1</span>);            <span class="comment">// returns 10</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">10</span>);           <span class="comment">// returns 10</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">11</span>);           <span class="comment">// returns -1</span>
</pre>
<p>If <i translate="no">from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p><b>See also </b><a href="qstring.html#lastIndexOf" translate="no">lastIndexOf</a>(), <a href="qstring.html#contains" translate="no">contains</a>(), and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfQStringViewqsizetypeQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="indexOf-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QString::<span class="name">indexOf</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>, <span class="type">qsizetype</span> <i>from</i> = 0, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads indexOf().</p>
<p>Returns the index position of the first occurrence of the string view <i translate="no">str</i> in this string, searching forward from index position <i translate="no">from</i>. Returns -1 if <i translate="no">str</i> is not found.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>If <i translate="no">from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p><b>See also </b><a href="qstringview.html#indexOf" translate="no">QStringView::indexOf</a>(), <a href="qstring.html#lastIndexOf" translate="no">lastIndexOf</a>(), <a href="qstring.html#contains" translate="no">contains</a>(), and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfconstQRegularExpression&qsizetypeQRegularExpressionMatch* -->
<h3 class="fn" translate="no" id="indexOf-4"><span class="type">qsizetype</span> QString::<span class="name">indexOf</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type">qsizetype</span> <i>from</i> = 0, <span class="type"><a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> *<i>rmatch</i> = nullptr) const</h3>
<p>Returns the index position of the first match of the regular expression <i translate="no">re</i> in the string, searching forward from index position <i translate="no">from</i>. Returns -1 if <i translate="no">re</i> didn't match anywhere.</p>
<p>If the match is successful and <i translate="no">rmatch</i> is not <code translate="no">nullptr</code>, it also writes the results of the match into the <a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a> object pointed to by <i translate="no">rmatch</i>.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
 str<span class="operator">.</span>indexOf(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>)<span class="operator">,</span> <span class="number">0</span>);       <span class="comment">// returns 4</span>

 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
 <span class="type"><a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> match;
 str<span class="operator">.</span>indexOf(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>)<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">&amp;</span>match);       <span class="comment">// returns 4</span>
 <span class="comment">// match.captured() == mi</span>
</pre>
<!-- @@@indexOf -->
<!-- $$$insert[overload1]$$$insertqsizetypeconstQString& -->
<h3 class="fn" translate="no" id="insert"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>position</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>)</h3>
<p>Inserts the string <i translate="no">str</i> at the given index <i translate="no">position</i> and returns a reference to this string.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Meal&quot;</span>;
 str<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;ontr&quot;</span>));
 <span class="comment">// str == &quot;Montreal&quot;</span>
</pre>
<p>This string grows to accommodate the insertion. If <i translate="no">position</i> is beyond the end of the string, space characters are appended to the string to reach this <i translate="no">position</i>, followed by <i translate="no">str</i>.</p>
<p><b>See also </b><a href="qstring.html#append" translate="no">append</a>(), <a href="qstring.html#prepend" translate="no">prepend</a>(), <a href="qstring.html#replace" translate="no">replace</a>(), and <a href="qstring.html#remove" translate="no">remove</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeQChar -->
<h3 class="fn" translate="no" id="insert-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>)</h3>
<p>This function overloads insert().</p>
<p>Inserts <i translate="no">ch</i> at the given index <i translate="no">position</i> in the string.</p>
<p>This string grows to accommodate the insertion. If <i translate="no">position</i> is beyond the end of the string, space characters are appended to the string to reach this <i translate="no">position</i>, followed by <i translate="no">ch</i>.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeconstQChar*qsizetype -->
<h3 class="fn" translate="no" id="insert-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>position</i>, const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>unicode</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>This function overloads insert().</p>
<p>Inserts the first <i translate="no">size</i> characters of the <a href="qchar.html" translate="no">QChar</a> array <i translate="no">unicode</i> at the given index <i translate="no">position</i> in the string.</p>
<p>This string grows to accommodate the insertion. If <i translate="no">position</i> is beyond the end of the string, space characters are appended to the string to reach this <i translate="no">position</i>, followed by <i translate="no">size</i> characters of the <a href="qchar.html" translate="no">QChar</a> array <i translate="no">unicode</i>.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeQStringView -->
<h3 class="fn" translate="no" id="insert-3"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>)</h3>
<p>This function overloads insert().</p>
<p>Inserts the string view <i translate="no">str</i> at the given index <i translate="no">position</i> and returns a reference to this string.</p>
<p>This string grows to accommodate the insertion. If <i translate="no">position</i> is beyond the end of the string, space characters are appended to the string to reach this <i translate="no">position</i>, followed by <i translate="no">str</i>.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeQLatin1StringView -->
<h3 class="fn" translate="no" id="insert-4"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>)</h3>
<p>This function overloads insert().</p>
<p>Inserts the Latin-1 string viewed by <i translate="no">str</i> at the given index <i translate="no">position</i>.</p>
<p>This string grows to accommodate the insertion. If <i translate="no">position</i> is beyond the end of the string, space characters are appended to the string to reach this <i translate="no">position</i>, followed by <i translate="no">str</i>.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeQUtf8StringView -->
<h3 class="fn" translate="no" id="insert-5"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type"><a href="qutf8stringview.html" translate="no">QUtf8StringView</a></span> <i>str</i>)</h3>
<p>This function overloads insert().</p>
<p>Inserts the UTF-8 string view <i translate="no">str</i> at the given index <i translate="no">position</i>.</p>
<div class="admonition note">
<p><b>Note: </b>Inserting variable-width UTF-8-encoded string data is conceptually slower than inserting fixed-width string data such as UTF-16 (<a href="qstringview.html" translate="no">QStringView</a>) or Latin-1 (<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>) and should thus be used sparingly.</p>
</div>
<p>This string grows to accommodate the insertion. If <i translate="no">position</i> is beyond the end of the string, space characters are appended to the string to reach this <i translate="no">position</i>, followed by <i translate="no">str</i>.</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeconstchar* -->
<h3 class="fn" translate="no" id="insert-6"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>position</i>, const <span class="type">char</span> *<i>str</i>)</h3>
<p>This function overloads insert().</p>
<p>Inserts the C string <i translate="no">str</i> at the given index <i translate="no">position</i> and returns a reference to this string.</p>
<p>This string grows to accommodate the insertion. If <i translate="no">position</i> is beyond the end of the string, space characters are appended to the string to reach this <i translate="no">position</i>, followed by <i translate="no">str</i>.</p>
<p>This function is not available when <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> is defined.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeconstQByteArray& -->
<h3 class="fn" translate="no" id="insert-7"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>position</i>, const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>str</i>)</h3>
<p>This function overloads insert().</p>
<p>Interprets the contents of <i translate="no">str</i> as UTF-8, inserts the Unicode string it encodes at the given index <i translate="no">position</i> and returns a reference to this string.</p>
<p>This string grows to accommodate the insertion. If <i translate="no">position</i> is beyond the end of the string, space characters are appended to the string to reach this <i translate="no">position</i>, followed by <i translate="no">str</i>.</p>
<p>This function is not available when <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> is defined.</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" translate="no" id="isEmpty"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QString::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code translate="no">true</code> if the string has no characters; otherwise returns <code translate="no">false</code>.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>()<span class="operator">.</span>isEmpty();            <span class="comment">// returns true</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isEmpty();          <span class="comment">// returns true</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;x&quot;</span>)<span class="operator">.</span>isEmpty();         <span class="comment">// returns false</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns false</span>
</pre>
<p><b>See also </b><a href="qstring.html#size" translate="no">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$isLower[overload1]$$$isLower -->
<h3 class="fn" translate="no" id="isLower"><span class="type">bool</span> QString::<span class="name">isLower</span>() const</h3>
<p>Returns <code translate="no">true</code> if the string is lowercase, that is, it's identical to its <a href="qstring.html#toLower" translate="no">toLower</a>() folding.</p>
<p>Note that this does <i>not</i> mean that the string does not contain uppercase letters (some uppercase letters do not have a lowercase folding; they are left unchanged by <a href="qstring.html#toLower" translate="no">toLower</a>()). For more information, refer to the Unicode standard, section 3.13.</p>
<p><b>See also </b><a href="qchar.html#toLower" translate="no">QChar::toLower</a>() and <a href="qstring.html#isUpper" translate="no">isUpper</a>().</p>
<!-- @@@isLower -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" translate="no" id="isNull"><span class="type">bool</span> QString::<span class="name">isNull</span>() const</h3>
<p>Returns <code translate="no">true</code> if this string is null; otherwise returns <code translate="no">false</code>.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>()<span class="operator">.</span>isNull();             <span class="comment">// returns true</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isNull();           <span class="comment">// returns false</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>
</pre>
<p>Qt makes a distinction between null strings and empty strings for historical reasons. For most applications, what matters is whether or not a string contains any data, and this can be determined using the <a href="qstring.html#isEmpty" translate="no">isEmpty</a>() function.</p>
<p><b>See also </b><a href="qstring.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@isNull -->
<!-- $$$isRightToLeft[overload1]$$$isRightToLeft -->
<h3 class="fn" translate="no" id="isRightToLeft"><span class="type">bool</span> QString::<span class="name">isRightToLeft</span>() const</h3>
<p>Returns <code translate="no">true</code> if the string is read right to left.</p>
<p><b>See also </b><a href="qstringview.html#isRightToLeft" translate="no">QStringView::isRightToLeft</a>().</p>
<!-- @@@isRightToLeft -->
<!-- $$$isUpper[overload1]$$$isUpper -->
<h3 class="fn" translate="no" id="isUpper"><span class="type">bool</span> QString::<span class="name">isUpper</span>() const</h3>
<p>Returns <code translate="no">true</code> if the string is uppercase, that is, it's identical to its <a href="qstring.html#toUpper" translate="no">toUpper</a>() folding.</p>
<p>Note that this does <i>not</i> mean that the string does not contain lowercase letters (some lowercase letters do not have a uppercase folding; they are left unchanged by <a href="qstring.html#toUpper" translate="no">toUpper</a>()). For more information, refer to the Unicode standard, section 3.13.</p>
<p><b>See also </b><a href="qchar.html#toUpper" translate="no">QChar::toUpper</a>() and <a href="qstring.html#isLower" translate="no">isLower</a>().</p>
<!-- @@@isUpper -->
<!-- $$$isValidUtf16[overload1]$$$isValidUtf16 -->
<h3 class="fn" translate="no" id="isValidUtf16"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QString::<span class="name">isValidUtf16</span>() const</h3>
<p>Returns <code translate="no">true</code> if the string contains valid UTF-16 encoded data, or <code translate="no">false</code> otherwise.</p>
<p>Note that this function does not perform any special validation of the data; it merely checks if it can be successfully decoded from UTF-16. The data is assumed to be in host byte order; the presence of a BOM is meaningless.</p>
<p><b>See also </b><a href="qstringview.html#isValidUtf16" translate="no">QStringView::isValidUtf16</a>().</p>
<!-- @@@isValidUtf16 -->
<!-- $$$lastIndexOf[overload1]$$$lastIndexOfconstQString&qsizetypeQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="lastIndexOf"><span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>, <span class="type">qsizetype</span> <i>from</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns the index position of the last occurrence of the string <i translate="no">str</i> in this string, searching backward from index position <i translate="no">from</i>.</p>
<p>If <i translate="no">from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p>Returns -1 if <i translate="no">str</i> is not found.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;crazy azimuths&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;az&quot;</span>;
 x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>When searching for a 0-length <i translate="no">str</i>, the match at the end of the data is excluded from the search by a negative <i translate="no">from</i>, even though <code translate="no">-1</code> is normally thought of as searching from the end of the string: the match at the end is <i>after</i> the last character, so it is excluded. To include such a final empty match, either give a positive value for <i translate="no">from</i> or omit the <i translate="no">from</i> parameter entirely.</p>
</div>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>(), <a href="qstring.html#contains" translate="no">contains</a>(), and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQCharQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="lastIndexOf-1"><code class="details extra" translate="no">[noexcept, since 6.3]</code> <span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>c</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads lastIndexOf().</p>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQCharqsizetypeQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="lastIndexOf-2"><span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>, <span class="type">qsizetype</span> <i>from</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads lastIndexOf().</p>
<p>Returns the index position of the last occurrence of the character <i translate="no">ch</i> in this string, searching backward from index position <i translate="no">from</i>.</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="lastIndexOf-3"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads lastIndexOf().</p>
<p>Returns the index position of the last occurrence of the string <i translate="no">str</i> in this string. Returns -1 if <i translate="no">str</i> is not found.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;crazy azimuths&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;az&quot;</span>;
 x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>
</pre>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>(), <a href="qstring.html#contains" translate="no">contains</a>(), and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQLatin1StringViewqsizetypeQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="lastIndexOf-4"><span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>, <span class="type">qsizetype</span> <i>from</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads lastIndexOf().</p>
<p>Returns the index position of the last occurrence of the Latin-1 string viewed by <i translate="no">str</i> in this string, searching backward from index position <i translate="no">from</i>.</p>
<p>If <i translate="no">from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p>Returns -1 if <i translate="no">str</i> is not found.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;crazy azimuths&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;az&quot;</span>;
 x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>When searching for a 0-length <i translate="no">str</i>, the match at the end of the data is excluded from the search by a negative <i translate="no">from</i>, even though <code translate="no">-1</code> is normally thought of as searching from the end of the string: the match at the end is <i>after</i> the last character, so it is excluded. To include such a final empty match, either give a positive value for <i translate="no">from</i> or omit the <i translate="no">from</i> parameter entirely.</p>
</div>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>(), <a href="qstring.html#contains" translate="no">contains</a>(), and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="lastIndexOf-5"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads lastIndexOf().</p>
<p>Returns the index position of the last occurrence of the string <i translate="no">str</i> in this string. Returns -1 if <i translate="no">str</i> is not found.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;crazy azimuths&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;az&quot;</span>;
 x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>
</pre>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>(), <a href="qstring.html#contains" translate="no">contains</a>(), and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQStringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="lastIndexOf-6"><code class="details extra" translate="no">[noexcept, since 6.2]</code> <span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads lastIndexOf().</p>
<p>Returns the index position of the last occurrence of the string view <i translate="no">str</i> in this string. Returns -1 if <i translate="no">str</i> is not found.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>(), <a href="qstring.html#contains" translate="no">contains</a>(), and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQStringViewqsizetypeQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="lastIndexOf-7"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>, <span class="type">qsizetype</span> <i>from</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads lastIndexOf().</p>
<p>Returns the index position of the last occurrence of the string view <i translate="no">str</i> in this string, searching backward from index position <i translate="no">from</i>.</p>
<p>If <i translate="no">from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p>Returns -1 if <i translate="no">str</i> is not found.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<div class="admonition note">
<p><b>Note: </b>When searching for a 0-length <i translate="no">str</i>, the match at the end of the data is excluded from the search by a negative <i translate="no">from</i>, even though <code translate="no">-1</code> is normally thought of as searching from the end of the string: the match at the end is <i>after</i> the last character, so it is excluded. To include such a final empty match, either give a positive value for <i translate="no">from</i> or omit the <i translate="no">from</i> parameter entirely.</p>
</div>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>(), <a href="qstring.html#contains" translate="no">contains</a>(), and <a href="qstring-obsolete.html#count-1" translate="no">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstQRegularExpression&QRegularExpressionMatch* -->
<h3 class="fn" translate="no" id="lastIndexOf-8"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type"><a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> *<i>rmatch</i> = nullptr) const</h3>
<p>This function overloads lastIndexOf().</p>
<p>Returns the index position of the last match of the regular expression <i translate="no">re</i> in the string. Returns -1 if <i translate="no">re</i> didn't match anywhere.</p>
<p>If the match is successful and <i translate="no">rmatch</i> is not <code translate="no">nullptr</code>, it also writes the results of the match into the <a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a> object pointed to by <i translate="no">rmatch</i>.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
 str<span class="operator">.</span>lastIndexOf(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>));      <span class="comment">// returns 8</span>

 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
 <span class="type"><a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> match;
 str<span class="operator">.</span>lastIndexOf(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>)<span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">&amp;</span>match);      <span class="comment">// returns 8</span>
 <span class="comment">// match.captured() == mu</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>Due to how the regular expression matching algorithm works, this function will actually match repeatedly from the beginning of the string until the end of the string is reached.</p>
</div>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstQRegularExpression&qsizetypeQRegularExpressionMatch* -->
<h3 class="fn" translate="no" id="lastIndexOf-9"><span class="type">qsizetype</span> QString::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type">qsizetype</span> <i>from</i>, <span class="type"><a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> *<i>rmatch</i> = nullptr) const</h3>
<p>Returns the index position of the last match of the regular expression <i translate="no">re</i> in the string, which starts before the index position <i translate="no">from</i>.</p>
<p>If <i translate="no">from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p>Returns -1 if <i translate="no">re</i> didn't match anywhere.</p>
<p>If the match is successful and <i translate="no">rmatch</i> is not <code translate="no">nullptr</code>, it also writes the results of the match into the <a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a> object pointed to by <i translate="no">rmatch</i>.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
 str<span class="operator">.</span>lastIndexOf(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>));      <span class="comment">// returns 8</span>

 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
 <span class="type"><a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> match;
 str<span class="operator">.</span>lastIndexOf(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>)<span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">&amp;</span>match);      <span class="comment">// returns 8</span>
 <span class="comment">// match.captured() == mu</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>Due to how the regular expression matching algorithm works, this function will actually match repeatedly from the beginning of the string until the position <i translate="no">from</i> is reached.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When searching for a regular expression <i translate="no">re</i> that may match 0 characters, the match at the end of the data is excluded from the search by a negative <i translate="no">from</i>, even though <code translate="no">-1</code> is normally thought of as searching from the end of the string: the match at the end is <i>after</i> the last character, so it is excluded. To include such a final empty match, either give a positive value for <i translate="no">from</i> or omit the <i translate="no">from</i> parameter entirely.</p>
</div>
<!-- @@@lastIndexOf -->
<!-- $$$leftJustified[overload1]$$$leftJustifiedqsizetypeQCharbool -->
<h3 class="fn" translate="no" id="leftJustified"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">leftJustified</span>(<span class="type">qsizetype</span> <i>width</i>, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fill</i> = u' ', <span class="type">bool</span> <i>truncate</i> = false) const</h3>
<p>Returns a string of size <i translate="no">width</i> that contains this string padded by the <i translate="no">fill</i> character.</p>
<p>If <i translate="no">truncate</i> is <code translate="no">false</code> and the <a href="qstring.html#size" translate="no">size</a>() of the string is more than <i translate="no">width</i>, then the returned string is a copy of the string.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> t <span class="operator">=</span> s<span class="operator">.</span>leftJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);    <span class="comment">// t == &quot;apple...&quot;</span>
</pre>
<p>If <i translate="no">truncate</i> is <code translate="no">true</code> and the <a href="qstring.html#size" translate="no">size</a>() of the string is more than <i translate="no">width</i>, then any characters in a copy of the string after position <i translate="no">width</i> are removed, and the copy is returned.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
 str <span class="operator">=</span> str<span class="operator">.</span>leftJustified(<span class="number">5</span><span class="operator">,</span> <span class="char">'.'</span><span class="operator">,</span> <span class="keyword">true</span>);    <span class="comment">// str == &quot;Pinea&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#rightJustified" translate="no">rightJustified</a>().</p>
<!-- @@@leftJustified -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" translate="no" id="length"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QString::<span class="name">length</span>() const</h3>
<p>Returns the number of characters in this string. Equivalent to <a href="qstring.html#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="qstring.html#resize" translate="no">resize</a>().</p>
<!-- @@@length -->
<!-- $$$localeAwareCompare[overload1]$$$localeAwareCompareconstQString&constQString& -->
<h3 class="fn" translate="no" id="localeAwareCompare"><code class="details extra" translate="no">[static]</code> <span class="type">int</span> QString::<span class="name">localeAwareCompare</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Compares <i translate="no">s1</i> with <i translate="no">s2</i> and returns an integer less than, equal to, or greater than zero if <i translate="no">s1</i> is less than, equal to, or greater than <i translate="no">s2</i>.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p><b>See also </b><a href="qstring.html#compare" translate="no">compare</a>(), <a href="qlocale.html" translate="no">QLocale</a>, and <a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@localeAwareCompare -->
<!-- $$$localeAwareCompare$$$localeAwareCompareconstQString& -->
<h3 class="fn" translate="no" id="localeAwareCompare-1"><span class="type">int</span> QString::<span class="name">localeAwareCompare</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>other</i>) const</h3>
<p>This function overloads localeAwareCompare().</p>
<p>Compares this string with the <i translate="no">other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the <i translate="no">other</i> string.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>Same as <code translate="no">localeAwareCompare(*this, other)</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@localeAwareCompare -->
<!-- $$$localeAwareCompare$$$localeAwareCompareQStringView -->
<h3 class="fn" translate="no" id="localeAwareCompare-2"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">int</span> QString::<span class="name">localeAwareCompare</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>other</i>) const</h3>
<p>This function overloads localeAwareCompare().</p>
<p>Compares this string with the <i translate="no">other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the <i translate="no">other</i> string.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>Same as <code translate="no">localeAwareCompare(*this, other)</code>.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@localeAwareCompare -->
<!-- $$$localeAwareCompare$$$localeAwareCompareQStringViewQStringView -->
<h3 class="fn" translate="no" id="localeAwareCompare-3"><code class="details extra" translate="no">[static, since 6.0]</code> <span class="type">int</span> QString::<span class="name">localeAwareCompare</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>s1</i>, <span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>s2</i>)</h3>
<p>This function overloads localeAwareCompare().</p>
<p>Compares <i translate="no">s1</i> with <i translate="no">s2</i> and returns an integer less than, equal to, or greater than zero if <i translate="no">s1</i> is less than, equal to, or greater than <i translate="no">s2</i>.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@localeAwareCompare -->
<!-- $$$normalized[overload1]$$$normalizedQString::NormalizationFormQChar::UnicodeVersion -->
<h3 class="fn" translate="no" id="normalized"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">normalized</span>(<span class="type"><a href="qstring.html#NormalizationForm-enum" translate="no">QString::NormalizationForm</a></span> <i>mode</i>, <span class="type"><a href="qchar.html#UnicodeVersion-enum" translate="no">QChar::UnicodeVersion</a></span> <i>version</i> = QChar::Unicode_Unassigned) const</h3>
<p>Returns the string in the given Unicode normalization <i translate="no">mode</i>, according to the given <i translate="no">version</i> of the Unicode standard.</p>
<!-- @@@normalized -->
<!-- $$$number[overload1]$$$numberlongint -->
<h3 class="fn" translate="no" id="number"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">number</span>(<span class="type">long</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>Returns a string equivalent of the number <i translate="no">n</i> according to the specified <i translate="no">base</i>.</p>
<p>The base is 10 by default and must be between 2 and 36. For bases other than 10, <i translate="no">n</i> is treated as an unsigned integer.</p>
<p>The formatting always uses <a href="qlocale.html#Language-enum" translate="no">QLocale::C</a>, i.e., English/UnitedStates. To get a localized string representation of a number, use <a href="qlocale.html#toString" translate="no">QLocale::toString</a>() with the appropriate locale.</p>
<pre class="cpp" translate="no">
 <span class="type">long</span> a <span class="operator">=</span> <span class="number">63</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> s <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span><span class="operator">::</span>number(a<span class="operator">,</span> <span class="number">16</span>);             <span class="comment">// s == &quot;3f&quot;</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> t <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span><span class="operator">::</span>number(a<span class="operator">,</span> <span class="number">16</span>)<span class="operator">.</span>toUpper();     <span class="comment">// t == &quot;3F&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#setNum" translate="no">setNum</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberintint -->
<h3 class="fn" translate="no" id="number-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">number</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@number -->
<!-- $$$number$$$numberuintint -->
<h3 class="fn" translate="no" id="number-2"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">number</span>(<span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@number -->
<!-- $$$number$$$numberulongint -->
<h3 class="fn" translate="no" id="number-3"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">number</span>(<span class="type"><a href="qttypes.html#ulong-typedef" translate="no">ulong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@number -->
<!-- $$$number$$$numberqlonglongint -->
<h3 class="fn" translate="no" id="number-4"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">number</span>(<span class="type"><a href="qttypes.html#qlonglong-typedef" translate="no">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@number -->
<!-- $$$number$$$numberqulonglongint -->
<h3 class="fn" translate="no" id="number-5"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">number</span>(<span class="type"><a href="qttypes.html#qulonglong-typedef" translate="no">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@number -->
<!-- $$$number$$$numberdoublecharint -->
<h3 class="fn" translate="no" id="number-6"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">number</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = 6)</h3>
<p>Returns a string representing the floating-point number <i translate="no">n</i>.</p>
<p>Returns a string that represents <i translate="no">n</i>, formatted according to the specified <i translate="no">format</i> and <i translate="no">precision</i>.</p>
<p>For formats with an exponent, the exponent will show its sign and have at least two digits, left-padding the exponent with zero if needed.</p>
<p><b>See also </b><a href="qstring.html#setNum" translate="no">setNum</a>(), <a href="qlocale.html#toString" translate="no">QLocale::toString</a>(), <a href="qlocale.html#FloatingPointPrecisionOption-enum" translate="no">QLocale::FloatingPointPrecisionOption</a>, and <a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@number -->
<!-- $$$prepend[overload1]$$$prependconstQString& -->
<h3 class="fn" translate="no" id="prepend"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">prepend</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>)</h3>
<p>Prepends the string <i translate="no">str</i> to the beginning of this string and returns a reference to this string.</p>
<p>This operation is typically very fast (<a href="containers.html#constant-time" translate="no">constant time</a>), because <a href="qstring.html" translate="no">QString</a> preallocates extra space at the beginning of the string data, so it can grow without reallocating the entire string each time.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;ship&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;air&quot;</span>;
 x<span class="operator">.</span>prepend(y);
 <span class="comment">// x == &quot;airship&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#append" translate="no">append</a>() and <a href="qstring.html#insert" translate="no">insert</a>().</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependQChar -->
<h3 class="fn" translate="no" id="prepend-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">prepend</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>)</h3>
<p>This function overloads prepend().</p>
<p>Prepends the character <i translate="no">ch</i> to this string.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstQChar*qsizetype -->
<h3 class="fn" translate="no" id="prepend-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">prepend</span>(const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>str</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>This function overloads prepend().</p>
<p>Prepends <i translate="no">len</i> characters from the <a href="qchar.html" translate="no">QChar</a> array <i translate="no">str</i> to this string and returns a reference to this string.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependQStringView -->
<h3 class="fn" translate="no" id="prepend-3"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">prepend</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>)</h3>
<p>This function overloads prepend().</p>
<p>Prepends the string view <i translate="no">str</i> to the beginning of this string and returns a reference to this string.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependQLatin1StringView -->
<h3 class="fn" translate="no" id="prepend-4"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">prepend</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>)</h3>
<p>This function overloads prepend().</p>
<p>Prepends the Latin-1 string viewed by <i translate="no">str</i> to this string.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependQUtf8StringView -->
<h3 class="fn" translate="no" id="prepend-5"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">prepend</span>(<span class="type"><a href="qutf8stringview.html" translate="no">QUtf8StringView</a></span> <i>str</i>)</h3>
<p>This function overloads prepend().</p>
<p>Prepends the UTF-8 string view <i translate="no">str</i> to this string.</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstchar* -->
<h3 class="fn" translate="no" id="prepend-6"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">prepend</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This function overloads prepend().</p>
<p>Prepends the string <i translate="no">str</i> to this string. The const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstQByteArray& -->
<h3 class="fn" translate="no" id="prepend-7"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">prepend</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>This function overloads prepend().</p>
<p>Prepends the byte array <i translate="no">ba</i> to this string. The byte array is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@prepend -->
<!-- $$$push_back[overload1]$$$push_backconstQString& -->
<h3 class="fn" translate="no" id="push_back"><span class="type">void</span> QString::<span class="name">push_back</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>other</i>)</h3>
<p>This function is provided for STL compatibility, appending the given <i translate="no">other</i> string onto the end of this string. It is equivalent to <code translate="no">append(other)</code>.</p>
<p><b>See also </b><a href="qstring.html#append" translate="no">append</a>().</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backQChar -->
<h3 class="fn" translate="no" id="push_back-1"><span class="type">void</span> QString::<span class="name">push_back</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the given <i translate="no">ch</i> character onto the end of this string.</p>
<!-- @@@push_back -->
<!-- $$$push_front[overload1]$$$push_frontconstQString& -->
<h3 class="fn" translate="no" id="push_front"><span class="type">void</span> QString::<span class="name">push_front</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>other</i>)</h3>
<p>This function is provided for STL compatibility, prepending the given <i translate="no">other</i> string to the beginning of this string. It is equivalent to <code translate="no">prepend(other)</code>.</p>
<p><b>See also </b><a href="qstring.html#prepend" translate="no">prepend</a>().</p>
<!-- @@@push_front -->
<!-- $$$push_front$$$push_frontQChar -->
<h3 class="fn" translate="no" id="push_front-1"><span class="type">void</span> QString::<span class="name">push_front</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends the given <i translate="no">ch</i> character to the beginning of this string.</p>
<!-- @@@push_front -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" translate="no" id="rbegin"><span class="type"><a href="qstring.html#reverse_iterator-typedef" translate="no">QString::reverse_iterator</a></span> QString::<span class="name">rbegin</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first character in the string, in reverse order.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#begin" translate="no">begin</a>(), <a href="qstring.html#crbegin" translate="no">crbegin</a>(), and <a href="qstring.html#rend" translate="no">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" translate="no" id="rbegin-1"><span class="type"><a href="qstring.html#const_reverse_iterator-typedef" translate="no">QString::const_reverse_iterator</a></span> QString::<span class="name">rbegin</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@rbegin -->
<!-- $$$remove[overload1]$$$removeqsizetypeqsizetype -->
<h3 class="fn" translate="no" id="remove"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">remove</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type">qsizetype</span> <i>n</i>)</h3>
<p>Removes <i translate="no">n</i> characters from the string, starting at the given <i translate="no">position</i> index, and returns a reference to the string.</p>
<p>If the specified <i translate="no">position</i> index is within the string, but <i translate="no">position</i> + <i translate="no">n</i> is beyond the end of the string, the string is truncated at the specified <i translate="no">position</i>.</p>
<p>If <i translate="no">n</i> is &lt;= 0 nothing is changed.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;Montreal&quot;</span>;
 s<span class="operator">.</span>remove(<span class="number">1</span><span class="operator">,</span> <span class="number">4</span>);
 <span class="comment">// s == &quot;Meal&quot;</span>
</pre>
<p>Element removal will preserve the string's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qstring.html#squeeze" translate="no">squeeze</a>() after the last change to the string's size.</p>
<p><b>See also </b><a href="qstring.html#insert" translate="no">insert</a>() and <a href="qstring.html#replace" translate="no">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeQCharQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="remove-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">remove</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>Removes every occurrence of the character <i translate="no">ch</i> in this string, and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> t <span class="operator">=</span> <span class="string">&quot;Ali Baba&quot;</span>;
 t<span class="operator">.</span>remove(<span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="char">'a'</span>)<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseInsensitive);
 <span class="comment">// t == &quot;li Bb&quot;</span>
</pre>
<p>This is the same as <code translate="no">replace(ch, &quot;&quot;, cs)</code>.</p>
<p>Element removal will preserve the string's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qstring.html#squeeze" translate="no">squeeze</a>() after the last change to the string's size.</p>
<p><b>See also </b><a href="qstring.html#replace" translate="no">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeQLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="remove-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">remove</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This is an overloaded function.</p>
<p>Removes every occurrence of the given Latin-1 string viewed by <i translate="no">str</i> from this string, and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>This is the same as <code translate="no">replace(str, &quot;&quot;, cs)</code>.</p>
<p>Element removal will preserve the string's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qstring.html#squeeze" translate="no">squeeze</a>() after the last change to the string's size.</p>
<p><b>See also </b><a href="qstring.html#replace" translate="no">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="remove-3"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">remove</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>Removes every occurrence of the given <i translate="no">str</i> string in this string, and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>This is the same as <code translate="no">replace(str, &quot;&quot;, cs)</code>.</p>
<p>Element removal will preserve the string's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qstring.html#squeeze" translate="no">squeeze</a>() after the last change to the string's size.</p>
<p><b>See also </b><a href="qstring.html#replace" translate="no">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstQRegularExpression& -->
<h3 class="fn" translate="no" id="remove-4"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">remove</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>)</h3>
<p>Removes every occurrence of the regular expression <i translate="no">re</i> in the string, and returns a reference to the string. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> r <span class="operator">=</span> <span class="string">&quot;Telephone&quot;</span>;
 r<span class="operator">.</span>remove(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;[aeiou].&quot;</span>));
 <span class="comment">// r == &quot;The&quot;</span>
</pre>
<p>Element removal will preserve the string's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qstring.html#squeeze" translate="no">squeeze</a>() after the last change to the string's size.</p>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>(), <a href="qstring.html#lastIndexOf" translate="no">lastIndexOf</a>(), and <a href="qstring.html#replace" translate="no">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$removeAt[overload1]$$$removeAtqsizetype -->
<h3 class="fn" translate="no" id="removeAt"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">removeAt</span>(<span class="type">qsizetype</span> <i>pos</i>)</h3>
<p>Removes the character at index <i translate="no">pos</i>. If <i translate="no">pos</i> is out of bounds (i.e. <i translate="no">pos</i> &gt;= <a href="qstring.html#size" translate="no">size</a>()), this function does nothing.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qstring.html#remove" translate="no">remove</a>().</p>
<!-- @@@removeAt -->
<!-- $$$removeFirst[overload1]$$$removeFirst -->
<h3 class="fn" translate="no" id="removeFirst"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">removeFirst</span>()</h3>
<p>Removes the first character in this string. If the string is empty, this function does nothing.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qstring.html#remove" translate="no">remove</a>().</p>
<!-- @@@removeFirst -->
<!-- $$$removeIf[overload1]$$$removeIfPredicate -->
<h3 class="fn" translate="no" id="removeIf"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Predicate&gt; <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">removeIf</span>(<span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i translate="no">pred</i> returns true from the string. Returns a reference to the string.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qstring.html#remove" translate="no">remove</a>().</p>
<!-- @@@removeIf -->
<!-- $$$removeLast[overload1]$$$removeLast -->
<h3 class="fn" translate="no" id="removeLast"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">removeLast</span>()</h3>
<p>Removes the last character in this string. If the string is empty, this function does nothing.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qstring.html#remove" translate="no">remove</a>().</p>
<!-- @@@removeLast -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" translate="no" id="rend"><span class="type"><a href="qstring.html#reverse_iterator-typedef" translate="no">QString::reverse_iterator</a></span> QString::<span class="name">rend</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing just after the last character in the string, in reverse order.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qstring.html" translate="no">QString</a> is modified.</p>
</div>
<p><b>See also </b><a href="qstring.html#end" translate="no">end</a>(), <a href="qstring.html#crend" translate="no">crend</a>(), and <a href="qstring.html#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" translate="no" id="rend-1"><span class="type"><a href="qstring.html#const_reverse_iterator-typedef" translate="no">QString::const_reverse_iterator</a></span> QString::<span class="name">rend</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@rend -->
<!-- $$$repeated[overload1]$$$repeatedqsizetype -->
<h3 class="fn" translate="no" id="repeated"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">repeated</span>(<span class="type">qsizetype</span> <i>times</i>) const</h3>
<p>Returns a copy of this string repeated the specified number of <i translate="no">times</i>.</p>
<p>If <i translate="no">times</i> is less than 1, an empty string is returned.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str(<span class="string">&quot;ab&quot;</span>);
 str<span class="operator">.</span>repeated(<span class="number">4</span>);            <span class="comment">// returns &quot;abababab&quot;</span>
</pre>
<!-- @@@repeated -->
<!-- $$$replace[overload1]$$$replaceqsizetypeqsizetypeconstQString& -->
<h3 class="fn" translate="no" id="replace"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type">qsizetype</span> <i>n</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>after</i>)</h3>
<p>Replaces <i translate="no">n</i> characters beginning at index <i translate="no">position</i> with the string <i translate="no">after</i> and returns a reference to this string.</p>
<div class="admonition note">
<p><b>Note: </b>If the specified <i translate="no">position</i> index is within the string, but <i translate="no">position</i> + <i translate="no">n</i> goes outside the strings range, then <i translate="no">n</i> will be adjusted to stop at the end of the string.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Say yes!&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;no&quot;</span>;
 x<span class="operator">.</span>replace(<span class="number">4</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> y);
 <span class="comment">// x == &quot;Say no!&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#insert" translate="no">insert</a>() and <a href="qstring.html#remove" translate="no">remove</a>().</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceqsizetypeqsizetypeQChar -->
<h3 class="fn" translate="no" id="replace-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type">qsizetype</span> <i>n</i>, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>after</i>)</h3>
<p>This function overloads replace().</p>
<p>Replaces <i translate="no">n</i> characters beginning at index <i translate="no">position</i> with the character <i translate="no">after</i> and returns a reference to this string.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceqsizetypeqsizetypeconstQChar*qsizetype -->
<h3 class="fn" translate="no" id="replace-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type">qsizetype</span> <i>position</i>, <span class="type">qsizetype</span> <i>n</i>, const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>after</i>, <span class="type">qsizetype</span> <i>alen</i>)</h3>
<p>This function overloads replace().</p>
<p>Replaces <i translate="no">n</i> characters beginning at index <i translate="no">position</i> with the first <i translate="no">alen</i> characters of the <a href="qchar.html" translate="no">QChar</a> array <i translate="no">after</i> and returns a reference to this string.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQCharQCharQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="replace-3"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>before</i>, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>after</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads replace().</p>
<p>Replaces every occurrence of the character <i translate="no">before</i> with the character <i translate="no">after</i> and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQChar*qsizetypeconstQChar*qsizetypeQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="replace-4"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>before</i>, <span class="type">qsizetype</span> <i>blen</i>, const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>after</i>, <span class="type">qsizetype</span> <i>alen</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads replace().</p>
<p>Replaces each occurrence in this string of the first <i translate="no">blen</i> characters of <i translate="no">before</i> with the first <i translate="no">alen</i> characters of <i translate="no">after</i> and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQLatin1StringViewQLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="replace-5"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>before</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>after</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads replace().</p>
<p>Replaces every occurrence in this string of the Latin-1 string viewed by <i translate="no">before</i> with the Latin-1 string viewed by <i translate="no">after</i>, and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<div class="admonition note">
<p><b>Note: </b>The text is not rescanned after a replacement.</p>
</div>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQLatin1StringViewconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="replace-6"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>before</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>after</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads replace().</p>
<p>Replaces every occurrence in this string of the Latin-1 string viewed by <i translate="no">before</i> with the string <i translate="no">after</i>, and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<div class="admonition note">
<p><b>Note: </b>The text is not rescanned after a replacement.</p>
</div>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQString&QLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="replace-7"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>before</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>after</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads replace().</p>
<p>Replaces every occurrence of the string <i translate="no">before</i> with the string <i translate="no">after</i> and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<div class="admonition note">
<p><b>Note: </b>The text is not rescanned after a replacement.</p>
</div>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQString&constQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="replace-8"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>before</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>after</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads replace().</p>
<p>Replaces every occurrence of the string <i translate="no">before</i> with the string <i translate="no">after</i> and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;colour behaviour flavour neighbour&quot;</span>;
 str<span class="operator">.</span>replace(<span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;ou&quot;</span>)<span class="operator">,</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>(<span class="string">&quot;o&quot;</span>));
 <span class="comment">// str == &quot;color behavior flavor neighbor&quot;</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>The replacement text is not rescanned after it is inserted.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> equis <span class="operator">=</span> <span class="string">&quot;xxxxxx&quot;</span>;
 equis<span class="operator">.</span>replace(<span class="string">&quot;xx&quot;</span><span class="operator">,</span> <span class="string">&quot;x&quot;</span>);
 <span class="comment">// equis == &quot;xxx&quot;</span>
</pre>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQCharconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="replace-9"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>after</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads replace().</p>
<p>Replaces every occurrence of the character <i translate="no">ch</i> in the string with <i translate="no">after</i> and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQCharQLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="replace-10"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>c</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>after</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>This function overloads replace().</p>
<p>Replaces every occurrence of the character <i translate="no">c</i> with the string <i translate="no">after</i> and returns a reference to this string.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<div class="admonition note">
<p><b>Note: </b>The text is not rescanned after a replacement.</p>
</div>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQRegularExpression&constQString& -->
<h3 class="fn" translate="no" id="replace-11"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">replace</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>after</i>)</h3>
<p>This function overloads replace().</p>
<p>Replaces every occurrence of the regular expression <i translate="no">re</i> in the string with <i translate="no">after</i>. Returns a reference to the string. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;Banana&quot;</span>;
 s<span class="operator">.</span>replace(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;a[mn]&quot;</span>)<span class="operator">,</span> <span class="string">&quot;ox&quot;</span>);
 <span class="comment">// s == &quot;Boxoxa&quot;</span>
</pre>
<p>For regular expressions containing capturing groups, occurrences of <b>\1</b>, <b>\2</b>, ..., in <i translate="no">after</i> are replaced with the string captured by the corresponding capturing group.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> t <span class="operator">=</span> <span class="string">&quot;A &lt;i&gt;bon mot&lt;/i&gt;.&quot;</span>;
 t<span class="operator">.</span>replace(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;&lt;i&gt;([^&lt;]*)&lt;/i&gt;&quot;</span>)<span class="operator">,</span> <span class="string">&quot;\\emph{\\1}&quot;</span>);
 <span class="comment">// t == &quot;A \\emph{bon mot}.&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#indexOf" translate="no">indexOf</a>(), <a href="qstring.html#lastIndexOf" translate="no">lastIndexOf</a>(), <a href="qstring.html#remove" translate="no">remove</a>(), <a href="qregularexpression.html" translate="no">QRegularExpression</a>, and <a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a>.</p>
<!-- @@@replace -->
<!-- $$$reserve[overload1]$$$reserveqsizetype -->
<h3 class="fn" translate="no" id="reserve"><span class="type">void</span> QString::<span class="name">reserve</span>(<span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Ensures the string has space for at least <i translate="no">size</i> characters.</p>
<p>If you know in advance how large a string will be, you can call this function to save repeated reallocation while building it. This can improve performance when building a string incrementally. A long sequence of operations that add to a string may trigger several reallocations, the last of which may leave you with significantly more space than you need. This is less efficient than doing a single allocation of the right size at the start.</p>
<p>If in doubt about how much space shall be needed, it is usually better to use an upper bound as <i translate="no">size</i>, or a high estimate of the most likely size, if a strict upper bound would be much bigger than this. If <i translate="no">size</i> is an underestimate, the string will grow as needed once the reserved size is exceeded, which may lead to a larger allocation than your best overestimate would have and will slow the operation that triggers it.</p>
<div class="admonition warning">
<p><b>Warning: </b>reserve() reserves memory but does not change the size of the string. Accessing data beyond the end of the string is undefined behavior. If you need to access memory beyond the current end of the string, use <a href="qstring.html#resize" translate="no">resize</a>().</p>
</div>
<p>This function is useful for code that needs to build up a long string and wants to avoid repeated reallocation. In this example, we want to add to the string until some condition is <code translate="no">true</code>, and we're fairly sure that size is large enough to make a call to reserve() worthwhile:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> result;
 qsizetype maxSize;
 <span class="type">bool</span> condition;
 <span class="type"><a href="qchar.html" translate="no">QChar</a></span> nextChar;

 result<span class="operator">.</span>reserve(maxSize);

 <span class="keyword">while</span> (condition)
     result<span class="operator">.</span>append(nextChar);

 result<span class="operator">.</span>squeeze();
</pre>
<p><b>See also </b><a href="qstring.html#squeeze" translate="no">squeeze</a>(), <a href="qstring.html#capacity" translate="no">capacity</a>(), and <a href="qstring.html#resize" translate="no">resize</a>().</p>
<!-- @@@reserve -->
<!-- $$$resize[overload1]$$$resizeqsizetype -->
<h3 class="fn" translate="no" id="resize"><span class="type">void</span> QString::<span class="name">resize</span>(<span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Sets the size of the string to <i translate="no">size</i> characters.</p>
<p>If <i translate="no">size</i> is greater than the current size, the string is extended to make it <i translate="no">size</i> characters long with the extra characters added to the end. The new characters are uninitialized.</p>
<p>If <i translate="no">size</i> is less than the current size, characters beyond position <i translate="no">size</i> are excluded from the string.</p>
<div class="admonition note">
<p><b>Note: </b>While resize() will grow the capacity if needed, it never shrinks capacity. To shed excess capacity, use <a href="qstring.html#squeeze" translate="no">squeeze</a>().</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;
 s<span class="operator">.</span>resize(<span class="number">5</span>);
 <span class="comment">// s == &quot;Hello&quot;</span>

 s<span class="operator">.</span>resize(<span class="number">8</span>);
 <span class="comment">// s == &quot;Hello???&quot; (where ? stands for any character)</span>
</pre>
<p>If you want to append a certain number of identical characters to the string, use the <a href="qstring.html#resize-1" translate="no">resize</a>(qsizetype, QChar) overload.</p>
<p>If you want to expand the string so that it reaches a certain width and fill the new positions with a particular character, use the <a href="qstring.html#leftJustified" translate="no">leftJustified</a>() function:</p>
<p>If <i translate="no">size</i> is negative, it is equivalent to passing zero.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> r <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;
 r <span class="operator">=</span> r<span class="operator">.</span>leftJustified(<span class="number">10</span><span class="operator">,</span> <span class="char">' '</span>);
 <span class="comment">// r == &quot;Hello     &quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#truncate" translate="no">truncate</a>(), <a href="qstring.html#reserve" translate="no">reserve</a>(), and <a href="qstring.html#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@resize -->
<!-- $$$resize$$$resizeqsizetypeQChar -->
<h3 class="fn" translate="no" id="resize-1"><span class="type">void</span> QString::<span class="name">resize</span>(<span class="type">qsizetype</span> <i>newSize</i>, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fillChar</i>)</h3>
<p>This is an overloaded function.</p>
<p>Unlike <a href="qstring.html#resize" translate="no">resize</a>(qsizetype), this overload initializes the new characters to <i translate="no">fillChar</i>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> t <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;
 r<span class="operator">.</span>resize(t<span class="operator">.</span>size() <span class="operator">+</span> <span class="number">10</span><span class="operator">,</span> <span class="char">'X'</span>);
 <span class="comment">// t == &quot;HelloXXXXXXXXXX&quot;</span>
</pre>
<!-- @@@resize -->
<!-- $$$rightJustified[overload1]$$$rightJustifiedqsizetypeQCharbool -->
<h3 class="fn" translate="no" id="rightJustified"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">rightJustified</span>(<span class="type">qsizetype</span> <i>width</i>, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>fill</i> = u' ', <span class="type">bool</span> <i>truncate</i> = false) const</h3>
<p>Returns a string of <a href="qstring.html#size" translate="no">size</a>() <i translate="no">width</i> that contains the <i translate="no">fill</i> character followed by the string. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> t <span class="operator">=</span> s<span class="operator">.</span>rightJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);    <span class="comment">// t == &quot;...apple&quot;</span>
</pre>
<p>If <i translate="no">truncate</i> is <code translate="no">false</code> and the <a href="qstring.html#size" translate="no">size</a>() of the string is more than <i translate="no">width</i>, then the returned string is a copy of the string.</p>
<p>If <i translate="no">truncate</i> is true and the <a href="qstring.html#size" translate="no">size</a>() of the string is more than <i translate="no">width</i>, then the resulting string is truncated at position <i translate="no">width</i>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
 str <span class="operator">=</span> str<span class="operator">.</span>rightJustified(<span class="number">5</span><span class="operator">,</span> <span class="char">'.'</span><span class="operator">,</span> <span class="keyword">true</span>);    <span class="comment">// str == &quot;Pinea&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#leftJustified" translate="no">leftJustified</a>().</p>
<!-- @@@rightJustified -->
<!-- $$$section[overload1]$$$sectionQCharqsizetypeqsizetypeQString::SectionFlags -->
<h3 class="fn" translate="no" id="section"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">section</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>sep</i>, <span class="type">qsizetype</span> <i>start</i>, <span class="type">qsizetype</span> <i>end</i> = -1, <span class="type"><a href="qstring.html#SectionFlag-enum" translate="no">QString::SectionFlags</a></span> <i>flags</i> = SectionDefault) const</h3>
<p>This function returns a section of the string.</p>
<p>This string is treated as a sequence of fields separated by the character, <i translate="no">sep</i>. The returned string consists of the fields from position <i translate="no">start</i> to position <i translate="no">end</i> inclusive. If <i translate="no">end</i> is not specified, all fields from position <i translate="no">start</i> to the end of the string are included. Fields are numbered 0, 1, 2, etc., counting from the left, and -1, -2, etc., counting from right to left.</p>
<p>The <i translate="no">flags</i> argument can be used to affect some aspects of the function's behavior, e.g. whether to be case sensitive, whether to skip empty fields and how to deal with leading and trailing separators; see <a href="qstring.html#SectionFlag-enum" translate="no">SectionFlags</a>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> csv <span class="operator">=</span> <span class="string">&quot;forename,middlename,surname,phone&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> path <span class="operator">=</span> <span class="string">&quot;/usr/local/bin/myapp&quot;</span>; <span class="comment">// First field is empty</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span><span class="operator">::</span>SectionFlag flag <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span><span class="operator">::</span>SectionSkipEmpty;

 str <span class="operator">=</span> csv<span class="operator">.</span>section(<span class="char">','</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span>);   <span class="comment">// str == &quot;surname&quot;</span>
 str <span class="operator">=</span> path<span class="operator">.</span>section(<span class="char">'/'</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">4</span>);  <span class="comment">// str == &quot;bin/myapp&quot;</span>
 str <span class="operator">=</span> path<span class="operator">.</span>section(<span class="char">'/'</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> flag); <span class="comment">// str == &quot;myapp&quot;</span>
</pre>
<p>If <i translate="no">start</i> or <i translate="no">end</i> is negative, we count fields from the right of the string, the right-most field being -1, the one from right-most field being -2, and so on.</p>
<pre class="cpp" translate="no">
 str <span class="operator">=</span> csv<span class="operator">.</span>section(<span class="char">','</span><span class="operator">,</span> <span class="operator">-</span><span class="number">3</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span>);  <span class="comment">// str == &quot;middlename,surname&quot;</span>
 str <span class="operator">=</span> path<span class="operator">.</span>section(<span class="char">'/'</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span>); <span class="comment">// str == &quot;myapp&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#split" translate="no">split</a>().</p>
<!-- @@@section -->
<!-- $$$section$$$sectionconstQString&qsizetypeqsizetypeQString::SectionFlags -->
<h3 class="fn" translate="no" id="section-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">section</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>sep</i>, <span class="type">qsizetype</span> <i>start</i>, <span class="type">qsizetype</span> <i>end</i> = -1, <span class="type"><a href="qstring.html#SectionFlag-enum" translate="no">QString::SectionFlags</a></span> <i>flags</i> = SectionDefault) const</h3>
<p>This function overloads section().</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> data <span class="operator">=</span> <span class="string">&quot;forename**middlename**surname**phone&quot;</span>;

 str <span class="operator">=</span> data<span class="operator">.</span>section(<span class="string">&quot;**&quot;</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span>); <span class="comment">// str == &quot;surname&quot;</span>
 str <span class="operator">=</span> data<span class="operator">.</span>section(<span class="string">&quot;**&quot;</span><span class="operator">,</span> <span class="operator">-</span><span class="number">3</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span>); <span class="comment">// str == &quot;middlename**surname&quot;</span>
</pre>
<p><b>See also </b><a href="qstring.html#split" translate="no">split</a>().</p>
<!-- @@@section -->
<!-- $$$section$$$sectionconstQRegularExpression&qsizetypeqsizetypeQString::SectionFlags -->
<h3 class="fn" translate="no" id="section-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">section</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type">qsizetype</span> <i>start</i>, <span class="type">qsizetype</span> <i>end</i> = -1, <span class="type"><a href="qstring.html#SectionFlag-enum" translate="no">QString::SectionFlags</a></span> <i>flags</i> = SectionDefault) const</h3>
<p>This function overloads section().</p>
<p>This string is treated as a sequence of fields separated by the regular expression, <i translate="no">re</i>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> line <span class="operator">=</span> <span class="string">&quot;forename\tmiddlename  surname \t \t phone&quot;</span>;
 <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> sep(<span class="string">&quot;\\s+&quot;</span>);
 str <span class="operator">=</span> line<span class="operator">.</span>section(sep<span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span>); <span class="comment">// str == &quot;surname&quot;</span>
 str <span class="operator">=</span> line<span class="operator">.</span>section(sep<span class="operator">,</span> <span class="operator">-</span><span class="number">3</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span>); <span class="comment">// str == &quot;middlename  surname&quot;</span>
</pre>
<div class="admonition warning">
<p><b>Warning: </b>Using this <a href="qregularexpression.html" translate="no">QRegularExpression</a> version is much more expensive than the overloaded string and character versions.</p>
</div>
<p><b>See also </b><a href="qstring.html#split" translate="no">split</a>() and <a href="qstring.html#simplified" translate="no">simplified</a>().</p>
<!-- @@@section -->
<!-- $$$setNum[overload1]$$$setNumintint -->
<h3 class="fn" translate="no" id="setNum"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>Sets the string to the printed value of <i translate="no">n</i> in the specified <i translate="no">base</i>, and returns a reference to the string.</p>
<p>The base is 10 by default and must be between 2 and 36.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;
 str<span class="operator">.</span>setNum(<span class="number">1234</span>);       <span class="comment">// str == &quot;1234&quot;</span>
</pre>
<p>The formatting always uses <a href="qlocale.html#Language-enum" translate="no">QLocale::C</a>, i.e., English/UnitedStates. To get a localized string representation of a number, use <a href="qlocale.html#toString" translate="no">QLocale::toString</a>() with the appropriate locale.</p>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumshortint -->
<h3 class="fn" translate="no" id="setNum-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">short</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumushortint -->
<h3 class="fn" translate="no" id="setNum-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qttypes.html#ushort-typedef" translate="no">ushort</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumuintint -->
<h3 class="fn" translate="no" id="setNum-3"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumlongint -->
<h3 class="fn" translate="no" id="setNum-4"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">long</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumulongint -->
<h3 class="fn" translate="no" id="setNum-5"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qttypes.html#ulong-typedef" translate="no">ulong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqlonglongint -->
<h3 class="fn" translate="no" id="setNum-6"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qttypes.html#qlonglong-typedef" translate="no">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqulonglongint -->
<h3 class="fn" translate="no" id="setNum-7"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qttypes.html#qulonglong-typedef" translate="no">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumfloatcharint -->
<h3 class="fn" translate="no" id="setNum-8"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">float</span> <i>n</i>, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = 6)</h3>
<p>This is an overloaded function.</p>
<p>Sets the string to the printed value of <i translate="no">n</i>, formatted according to the given <i translate="no">format</i> and <i translate="no">precision</i>, and returns a reference to the string.</p>
<p>The formatting always uses <a href="qlocale.html#Language-enum" translate="no">QLocale::C</a>, i.e., English/UnitedStates. To get a localized string representation of a number, use <a href="qlocale.html#toString" translate="no">QLocale::toString</a>() with the appropriate locale.</p>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumdoublecharint -->
<h3 class="fn" translate="no" id="setNum-9"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = 6)</h3>
<p>This is an overloaded function.</p>
<p>Sets the string to the printed value of <i translate="no">n</i>, formatted according to the given <i translate="no">format</i> and <i translate="no">precision</i>, and returns a reference to the string.</p>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qlocale.html#FloatingPointPrecisionOption-enum" translate="no">QLocale::FloatingPointPrecisionOption</a>, and <a href="qstring.html#number-formats" translate="no">Number Formats</a>.</p>
<!-- @@@setNum -->
<!-- $$$setRawData[overload1]$$$setRawDataconstQChar*qsizetype -->
<h3 class="fn" translate="no" id="setRawData"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setRawData</span>(const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>unicode</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Resets the <a href="qstring.html" translate="no">QString</a> to use the first <i translate="no">size</i> Unicode characters in the array <i translate="no">unicode</i>. The data in <i translate="no">unicode</i> is <i>not</i> copied. The caller must be able to guarantee that <i translate="no">unicode</i> will not be deleted or modified as long as the <a href="qstring.html" translate="no">QString</a> (or an unmodified copy of it) exists.</p>
<p>This function can be used instead of <a href="qstring.html#fromRawData" translate="no">fromRawData</a>() to re-use existings <a href="qstring.html" translate="no">QString</a> objects to save memory re-allocations.</p>
<p><b>See also </b><a href="qstring.html#fromRawData" translate="no">fromRawData</a>().</p>
<!-- @@@setRawData -->
<!-- $$$setUnicode[overload1]$$$setUnicodeconstQChar*qsizetype -->
<h3 class="fn" translate="no" id="setUnicode"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setUnicode</span>(const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *<i>unicode</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Resizes the string to <i translate="no">size</i> characters and copies <i translate="no">unicode</i> into the string.</p>
<p>If <i translate="no">unicode</i> is <code translate="no">nullptr</code>, nothing is copied, but the string is still resized to <i translate="no">size</i>.</p>
<p><b>See also </b><a href="qstring.html#unicode" translate="no">unicode</a>() and <a href="qstring.html#setUtf16" translate="no">setUtf16</a>().</p>
<!-- @@@setUnicode -->
<!-- $$$setUtf16[overload1]$$$setUtf16constushort*qsizetype -->
<h3 class="fn" translate="no" id="setUtf16"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">setUtf16</span>(const <span class="type"><a href="qttypes.html#ushort-typedef" translate="no">ushort</a></span> *<i>unicode</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Resizes the string to <i translate="no">size</i> characters and copies <i translate="no">unicode</i> into the string.</p>
<p>If <i translate="no">unicode</i> is <code translate="no">nullptr</code>, nothing is copied, but the string is still resized to <i translate="no">size</i>.</p>
<p>Note that unlike <a href="qstring.html#fromUtf16" translate="no">fromUtf16</a>(), this function does not consider BOMs and possibly differing byte ordering.</p>
<p><b>See also </b><a href="qstring.html#utf16" translate="no">utf16</a>() and <a href="qstring.html#setUnicode" translate="no">setUnicode</a>().</p>
<!-- @@@setUtf16 -->
<!-- $$$shrink_to_fit[overload1]$$$shrink_to_fit -->
<h3 class="fn" translate="no" id="shrink_to_fit"><span class="type">void</span> QString::<span class="name">shrink_to_fit</span>()</h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="qstring.html#squeeze" translate="no">squeeze</a>().</p>
<p><b>See also </b><a href="qstring.html#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@shrink_to_fit -->
<!-- $$$simplified[overload1]$$$simplified -->
<h3 class="fn" translate="no" id="simplified"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">simplified</span>() const</h3>
<p>Returns a string that has whitespace removed from the start and the end, and that has each sequence of internal whitespace replaced with a single space.</p>
<p>Whitespace means any character for which <a href="qchar.html#isSpace" translate="no">QChar::isSpace</a>() returns <code translate="no">true</code>. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;  lots\t of\nwhitespace\r\n &quot;</span>;
 str <span class="operator">=</span> str<span class="operator">.</span>simplified();
 <span class="comment">// str == &quot;lots of whitespace&quot;;</span>
</pre>
<p><b>See also </b><a href="qstring.html#trimmed" translate="no">trimmed</a>().</p>
<!-- @@@simplified -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QString::<span class="name">size</span>() const</h3>
<p>Returns the number of characters in this string.</p>
<p>The last character in the string is at position size() - 1.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;
 qsizetype n <span class="operator">=</span> str<span class="operator">.</span>size();   <span class="comment">// n == 5</span>
 str<span class="operator">.</span>data()<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;              <span class="comment">// returns 'W'</span>
 str<span class="operator">.</span>data()<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;              <span class="comment">// returns 'd'</span>
</pre>
<p><b>See also </b><a href="qstring.html#isEmpty" translate="no">isEmpty</a>() and <a href="qstring.html#resize" translate="no">resize</a>().</p>
<!-- @@@size -->
<!-- $$$split[overload1]$$$splitconstQString&Qt::SplitBehaviorQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="split"><span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> QString::<span class="name">split</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>sep</i>, <span class="type"><a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SplitBehavior</a></span> <i>behavior</i> = Qt::KeepEmptyParts, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Splits the string into substrings wherever <i translate="no">sep</i> occurs, and returns the list of those strings. If <i translate="no">sep</i> does not match anywhere in the string, split() returns a single-element list containing this string.</p>
<p><i translate="no">cs</i> specifies whether <i translate="no">sep</i> should be matched case sensitively or case insensitively.</p>
<p>If <i translate="no">behavior</i> is <a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SkipEmptyParts</a>, empty entries don't appear in the result. By default, empty entries are kept.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="type"><a href="qstring.html#QStringLiteral" translate="no">QStringLiteral</a></span>(<span class="string">&quot;a,,b,c&quot;</span>);

 <span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> list1 <span class="operator">=</span> str<span class="operator">.</span>split(u<span class="char">','</span>);
 <span class="comment">// list1: [ &quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot; ]</span>

 <span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> list2 <span class="operator">=</span> str<span class="operator">.</span>split(u<span class="char">','</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>SkipEmptyParts);
 <span class="comment">// list2: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span>
</pre>
<p>If <i translate="no">sep</i> is empty, split() returns an empty string, followed by each of the string's characters, followed by another empty string:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;
 <span class="keyword">auto</span> parts <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>());
 <span class="comment">// parts: {&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;}</span>
</pre>
<p>To understand this behavior, recall that the empty string matches everywhere, so the above is qualitatively the same as:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;/a/b/c/&quot;</span>;
 <span class="keyword">auto</span> parts <span class="operator">=</span> str<span class="operator">.</span>split(u<span class="char">'/'</span>);
 <span class="comment">// parts: {&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;}</span>
</pre>
<p><b>See also </b><a href="qstringlist.html#join" translate="no">QStringList::join</a>() and <a href="qstring.html#section" translate="no">section</a>().</p>
<!-- @@@split -->
<!-- $$$split$$$splitQCharQt::SplitBehaviorQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="split-1"><span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> QString::<span class="name">split</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>sep</i>, <span class="type"><a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SplitBehavior</a></span> <i>behavior</i> = Qt::KeepEmptyParts, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@split -->
<!-- $$$split$$$splitconstQRegularExpression&Qt::SplitBehavior -->
<h3 class="fn" translate="no" id="split-2"><span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> QString::<span class="name">split</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type"><a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SplitBehavior</a></span> <i>behavior</i> = Qt::KeepEmptyParts) const</h3>
<p>This is an overloaded function.</p>
<p>Splits the string into substrings wherever the regular expression <i translate="no">re</i> matches, and returns the list of those strings. If <i translate="no">re</i> does not match anywhere in the string, split() returns a single-element list containing this string.</p>
<p>Here is an example where we extract the words in a sentence using one or more whitespace characters as the separator:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;
 <span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> list;

 str <span class="operator">=</span> <span class="string">&quot;Some  text\n\twith  strange whitespace.&quot;</span>;
 list <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;\\s+&quot;</span>));
 <span class="comment">// list: [ &quot;Some&quot;, &quot;text&quot;, &quot;with&quot;, &quot;strange&quot;, &quot;whitespace.&quot; ]</span>
</pre>
<p>Here is a similar example, but this time we use any sequence of non-word characters as the separator:</p>
<pre class="cpp" translate="no">
 str <span class="operator">=</span> <span class="string">&quot;This time, a normal English sentence.&quot;</span>;
 list <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;\\W+&quot;</span>)<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>SkipEmptyParts);
 <span class="comment">// list: [ &quot;This&quot;, &quot;time&quot;, &quot;a&quot;, &quot;normal&quot;, &quot;English&quot;, &quot;sentence&quot; ]</span>
</pre>
<p>Here is a third example where we use a zero-length assertion, <b>\b</b> (word boundary), to split the string into an alternating sequence of non-word and word tokens:</p>
<pre class="cpp" translate="no">
 str <span class="operator">=</span> <span class="string">&quot;Now: this sentence fragment.&quot;</span>;
 list <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="string">&quot;\\b&quot;</span>));
 <span class="comment">// list: [ &quot;&quot;, &quot;Now&quot;, &quot;: &quot;, &quot;this&quot;, &quot; &quot;, &quot;sentence&quot;, &quot; &quot;, &quot;fragment&quot;, &quot;.&quot; ]</span>
</pre>
<p><b>See also </b><a href="qstringlist.html#join" translate="no">QStringList::join</a>() and <a href="qstring.html#section" translate="no">section</a>().</p>
<!-- @@@split -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" translate="no" id="squeeze"><span class="type">void</span> QString::<span class="name">squeeze</span>()</h3>
<p>Releases any memory not required to store the character data.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qstring.html" translate="no">QString</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b>See also </b><a href="qstring.html#reserve" translate="no">reserve</a>() and <a href="qstring.html#capacity" translate="no">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$startsWith[overload1]$$$startsWithconstQString&Qt::CaseSensitivity -->
<h3 class="fn" translate="no" id="startsWith"><span class="type">bool</span> QString::<span class="name">startsWith</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns <code translate="no">true</code> if the string starts with <i translate="no">s</i>; otherwise returns <code translate="no">false</code>.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Bananas&quot;</span>;
 str<span class="operator">.</span>startsWith(<span class="string">&quot;Ban&quot;</span>);     <span class="comment">// returns true</span>
 str<span class="operator">.</span>startsWith(<span class="string">&quot;Car&quot;</span>);     <span class="comment">// returns false</span>
</pre>
<p><b>See also </b><a href="qstring.html#endsWith" translate="no">endsWith</a>().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithQStringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="startsWith-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QString::<span class="name">startsWith</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if the string starts with the string view <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>If <i translate="no">cs</i> is <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> (the default), the search is case-sensitive; otherwise the search is case-insensitive.</p>
<p><b>See also </b><a href="qstring.html#endsWith" translate="no">endsWith</a>().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithQLatin1StringViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="startsWith-2"><span class="type">bool</span> QString::<span class="name">startsWith</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads startsWith().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithQCharQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="startsWith-3"><span class="type">bool</span> QString::<span class="name">startsWith</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>c</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>This function overloads startsWith().</p>
<p>Returns <code translate="no">true</code> if the string starts with <i translate="no">c</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@startsWith -->
<!-- $$$swap[overload1]$$$swapQString& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QString::<span class="name">swap</span>(<span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>other</i>)</h3>
<p>Swaps string <i translate="no">other</i> with this string. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$toCFString[overload1]$$$toCFString -->
<h3 class="fn" translate="no" id="toCFString"><span class="type">CFStringRef</span> QString::<span class="name">toCFString</span>() const</h3>
<p>Creates a CFString from a <a href="qstring.html" translate="no">QString</a>.</p>
<p>The caller owns the CFString and is responsible for releasing it.</p>
<div class="admonition note">
<p><b>Note: </b>this function is only available on macOS and iOS.</p>
</div>
<!-- @@@toCFString -->
<!-- $$$toCaseFolded[overload1]$$$toCaseFolded -->
<h3 class="fn" translate="no" id="toCaseFolded"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">toCaseFolded</span>() const</h3>
<p>Returns the case folded equivalent of the string. For most Unicode characters this is the same as <a href="qstring.html#toLower" translate="no">toLower</a>().</p>
<!-- @@@toCaseFolded -->
<!-- $$$toDouble[overload1]$$$toDoublebool* -->
<h3 class="fn" translate="no" id="toDouble"><span class="type">double</span> QString::<span class="name">toDouble</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the string converted to a <code translate="no">double</code> value.</p>
<p>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;1234.56&quot;</span>;
 <span class="type">double</span> val <span class="operator">=</span> str<span class="operator">.</span>toDouble();   <span class="comment">// val == 1234.56</span>
</pre>
<div class="admonition warning">
<p><b>Warning: </b>The <a href="qstring.html" translate="no">QString</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
</div>
<pre class="cpp" translate="no">
 <span class="type">bool</span> ok;
 <span class="type">double</span> d;

 d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>( <span class="string">&quot;1234.56e-02&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == true, d == 12.3456</span>

 d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>( <span class="string">&quot;1234.56e-02 Volt&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == false, d == 0</span>
</pre>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toDouble" translate="no">QLocale::toDouble</a>()</p>
<pre class="cpp" translate="no">
 d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>( <span class="string">&quot;1234,56&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == false</span>
 d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>( <span class="string">&quot;1234.56&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == true, d == 1234.56</span>
</pre>
<p>For historical reasons, this function does not handle thousands group separators. If you need to convert such numbers, use <a href="qlocale.html#toDouble" translate="no">QLocale::toDouble</a>().</p>
<pre class="cpp" translate="no">
 d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>( <span class="string">&quot;1,234,567.89&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == false</span>
 d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span>( <span class="string">&quot;1234567.89&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == true</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qlocale.html#setDefault" translate="no">QLocale::setDefault</a>(), <a href="qlocale.html#toDouble" translate="no">QLocale::toDouble</a>(), and <a href="qstring.html#trimmed" translate="no">trimmed</a>().</p>
<!-- @@@toDouble -->
<!-- $$$toEcmaString[overload1]$$$toEcmaString -->
<h3 class="fn" translate="no" id="toEcmaString"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">emscripten::val</span> QString::<span class="name">toEcmaString</span>() const</h3>
<p>Converts this object to an <a href="https://262.ecma-international.org/#sec-string-object" translate="no">ECMAScript string</a>.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qstring.html#fromEcmaString" translate="no">fromEcmaString</a>().</p>
<!-- @@@toEcmaString -->
<!-- $$$toFloat[overload1]$$$toFloatbool* -->
<h3 class="fn" translate="no" id="toFloat"><span class="type">float</span> QString::<span class="name">toFloat</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the string converted to a <code translate="no">float</code> value.</p>
<p>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition warning">
<p><b>Warning: </b>The <a href="qstring.html" translate="no">QString</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
</div>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toFloat" translate="no">QLocale::toFloat</a>()</p>
<p>For historical reasons, this function does not handle thousands group separators. If you need to convert such numbers, use <a href="qlocale.html#toFloat" translate="no">QLocale::toFloat</a>().</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str1 <span class="operator">=</span> <span class="string">&quot;1234.56&quot;</span>;
 str1<span class="operator">.</span>toFloat();             <span class="comment">// returns 1234.56</span>

 <span class="type">bool</span> ok;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str2 <span class="operator">=</span> <span class="string">&quot;R2D2&quot;</span>;
 str2<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);          <span class="comment">// returns 0.0, sets ok to false</span>

 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str3 <span class="operator">=</span> <span class="string">&quot;1234.56 Volt&quot;</span>;
 str3<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);          <span class="comment">// returns 0.0, sets ok to false</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qstring.html#toDouble" translate="no">toDouble</a>(), <a href="qstring.html#toInt" translate="no">toInt</a>(), <a href="qlocale.html#toFloat" translate="no">QLocale::toFloat</a>(), and <a href="qstring.html#trimmed" translate="no">trimmed</a>().</p>
<!-- @@@toFloat -->
<!-- $$$toHtmlEscaped[overload1]$$$toHtmlEscaped -->
<h3 class="fn" translate="no" id="toHtmlEscaped"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">toHtmlEscaped</span>() const</h3>
<p>Converts a plain text string to an HTML string with HTML metacharacters <code translate="no">&lt;</code>, <code translate="no">&gt;</code>, <code translate="no">&amp;</code>, and <code translate="no">&quot;</code> replaced by HTML entities.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> plain <span class="operator">=</span> <span class="string">&quot;#include &lt;QtCore&gt;&quot;</span>
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> html <span class="operator">=</span> plain<span class="operator">.</span>toHtmlEscaped();
 <span class="comment">// html == &quot;#include &amp;lt;QtCore&amp;gt;&quot;</span>
</pre>
<!-- @@@toHtmlEscaped -->
<!-- $$$toInt[overload1]$$$toIntbool*int -->
<h3 class="fn" translate="no" id="toInt"><span class="type">int</span> QString::<span class="name">toInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code translate="no">int</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<p>If <i translate="no">base</i> is 0, the C language convention is used: if the string begins with &quot;0x&quot;, base 16 is used; otherwise, if the string begins with &quot;0b&quot;, base 2 is used; otherwise, if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toInt" translate="no">QLocale::toInt</a>()</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
 <span class="type">bool</span> ok;
 <span class="type">int</span> hex <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);       <span class="comment">// hex == 255, ok == true</span>
 <span class="type">int</span> dec <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);       <span class="comment">// dec == 0, ok == false</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<div class="admonition note">
<p><b>Note: </b>Support for the &quot;0b&quot; prefix was added in Qt 6.4.</p>
</div>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qstring.html#toUInt" translate="no">toUInt</a>(), <a href="qstring.html#toDouble" translate="no">toDouble</a>(), and <a href="qlocale.html#toInt" translate="no">QLocale::toInt</a>().</p>
<!-- @@@toInt -->
<!-- $$$toLatin1[overload1]$$$toLatin1 -->
<h3 class="fn" translate="no" id="toLatin1"><span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> QString::<span class="name">toLatin1</span>() const</h3>
<p>Returns a Latin-1 representation of the string as a <a href="qbytearray.html" translate="no">QByteArray</a>.</p>
<p>The returned byte array is undefined if the string contains non-Latin1 characters. Those characters may be suppressed or replaced with a question mark.</p>
<p><b>See also </b><a href="qstring.html#fromLatin1" translate="no">fromLatin1</a>(), <a href="qstring.html#toUtf8" translate="no">toUtf8</a>(), <a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>(), and <a href="qstringencoder.html" translate="no">QStringEncoder</a>.</p>
<!-- @@@toLatin1 -->
<!-- $$$toLocal8Bit[overload1]$$$toLocal8Bit -->
<h3 class="fn" translate="no" id="toLocal8Bit"><span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> QString::<span class="name">toLocal8Bit</span>() const</h3>
<p>Returns the local 8-bit representation of the string as a <a href="qbytearray.html" translate="no">QByteArray</a>.</p>
<p>On Unix systems this is equivalent to <a href="qstring.html#toUtf8" translate="no">toUtf8</a>(). Note that on Apple systems this function does not take <a href="https://developer.apple.com/documentation/foundation/nsstring/1410091-defaultcstringencoding?language=objc" translate="no">NSString.defaultCStringEncoding</a> or <a href="https://developer.apple.com/documentation/corefoundation/1541720-cfstringgetsystemencoding?language=objc" translate="no">CFStringGetSystemEncoding()</a> into account, as these functions typically return the legacy &quot;Western (Mac OS Roman)&quot; encoding, which should not be used on modern Apple operating systems. On Windows the system's current code page is used.</p>
<p>If this string contains any characters that cannot be encoded in the local 8-bit encoding, the returned byte array is undefined. Those characters may be suppressed or replaced by another.</p>
<p><b>See also </b><a href="qstring.html#fromLocal8Bit" translate="no">fromLocal8Bit</a>(), <a href="qstring.html#toLatin1" translate="no">toLatin1</a>(), <a href="qstring.html#toUtf8" translate="no">toUtf8</a>(), and <a href="qstringencoder.html" translate="no">QStringEncoder</a>.</p>
<!-- @@@toLocal8Bit -->
<!-- $$$toLong[overload1]$$$toLongbool*int -->
<h3 class="fn" translate="no" id="toLong"><span class="type">long</span> QString::<span class="name">toLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to a <code translate="no">long</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<p>If <i translate="no">base</i> is 0, the C language convention is used: if the string begins with &quot;0x&quot;, base 16 is used; otherwise, if the string begins with &quot;0b&quot;, base 2 is used; otherwise, if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toLongLong" translate="no">QLocale::toLongLong</a>()</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
 <span class="type">bool</span> ok;

 <span class="type">long</span> hex <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
 <span class="type">long</span> dec <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<div class="admonition note">
<p><b>Note: </b>Support for the &quot;0b&quot; prefix was added in Qt 6.4.</p>
</div>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qstring.html#toULong" translate="no">toULong</a>(), <a href="qstring.html#toInt" translate="no">toInt</a>(), and <a href="qlocale.html#toInt" translate="no">QLocale::toInt</a>().</p>
<!-- @@@toLong -->
<!-- $$$toLongLong[overload1]$$$toLongLongbool*int -->
<h3 class="fn" translate="no" id="toLongLong"><span class="type"><a href="qttypes.html#qlonglong-typedef" translate="no">qlonglong</a></span> QString::<span class="name">toLongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to a <code translate="no">long long</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<p>If <i translate="no">base</i> is 0, the C language convention is used: if the string begins with &quot;0x&quot;, base 16 is used; otherwise, if the string begins with &quot;0b&quot;, base 2 is used; otherwise, if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toLongLong" translate="no">QLocale::toLongLong</a>()</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
 <span class="type">bool</span> ok;

 <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toLongLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);      <span class="comment">// hex == 255, ok == true</span>
 <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toLongLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);      <span class="comment">// dec == 0, ok == false</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<div class="admonition note">
<p><b>Note: </b>Support for the &quot;0b&quot; prefix was added in Qt 6.4.</p>
</div>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qstring.html#toULongLong" translate="no">toULongLong</a>(), <a href="qstring.html#toInt" translate="no">toInt</a>(), and <a href="qlocale.html#toLongLong" translate="no">QLocale::toLongLong</a>().</p>
<!-- @@@toLongLong -->
<!-- $$$toLower[overload1]$$$toLower -->
<h3 class="fn" translate="no" id="toLower"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">toLower</span>() const</h3>
<p>Returns a lowercase copy of the string.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;The Qt PROJECT&quot;</span>;
 str <span class="operator">=</span> str<span class="operator">.</span>toLower();        <span class="comment">// str == &quot;the qt project&quot;</span>
</pre>
<p>The case conversion will always happen in the 'C' locale. For locale-dependent case folding use <a href="qlocale.html#toLower" translate="no">QLocale::toLower</a>()</p>
<p><b>See also </b><a href="qstring.html#toUpper" translate="no">toUpper</a>() and <a href="qlocale.html#toLower" translate="no">QLocale::toLower</a>().</p>
<!-- @@@toLower -->
<!-- $$$toNSString[overload1]$$$toNSString -->
<h3 class="fn" translate="no" id="toNSString"><span class="type">NSString</span> *QString::<span class="name">toNSString</span>() const</h3>
<p>Creates a NSString from a <a href="qstring.html" translate="no">QString</a>.</p>
<p>The NSString is autoreleased.</p>
<div class="admonition note">
<p><b>Note: </b>this function is only available on macOS and iOS.</p>
</div>
<!-- @@@toNSString -->
<!-- $$$toShort[overload1]$$$toShortbool*int -->
<h3 class="fn" translate="no" id="toShort"><span class="type">short</span> QString::<span class="name">toShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to a <code translate="no">short</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<p>If <i translate="no">base</i> is 0, the C language convention is used: if the string begins with &quot;0x&quot;, base 16 is used; otherwise, if the string begins with &quot;0b&quot;, base 2 is used; otherwise, if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toShort" translate="no">QLocale::toShort</a>()</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
 <span class="type">bool</span> ok;

 <span class="type">short</span> hex <span class="operator">=</span> str<span class="operator">.</span>toShort(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);   <span class="comment">// hex == 255, ok == true</span>
 <span class="type">short</span> dec <span class="operator">=</span> str<span class="operator">.</span>toShort(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);   <span class="comment">// dec == 0, ok == false</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<div class="admonition note">
<p><b>Note: </b>Support for the &quot;0b&quot; prefix was added in Qt 6.4.</p>
</div>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qstring.html#toUShort" translate="no">toUShort</a>(), <a href="qstring.html#toInt" translate="no">toInt</a>(), and <a href="qlocale.html#toShort" translate="no">QLocale::toShort</a>().</p>
<!-- @@@toShort -->
<!-- $$$toStdString[overload1]$$$toStdString -->
<h3 class="fn" translate="no" id="toStdString"><span class="type">std::string</span> QString::<span class="name">toStdString</span>() const</h3>
<p>Returns a std::string object with the data contained in this <a href="qstring.html" translate="no">QString</a>. The Unicode data is converted into 8-bit characters using the <a href="qstring.html#toUtf8" translate="no">toUtf8</a>() function.</p>
<p>This method is mostly useful to pass a <a href="qstring.html" translate="no">QString</a> to a function that accepts a std::string object.</p>
<p><b>See also </b><a href="qstring.html#toLatin1" translate="no">toLatin1</a>(), <a href="qstring.html#toUtf8" translate="no">toUtf8</a>(), <a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>(), and <a href="qbytearray.html#toStdString" translate="no">QByteArray::toStdString</a>().</p>
<!-- @@@toStdString -->
<!-- $$$toStdU16String[overload1]$$$toStdU16String -->
<h3 class="fn" translate="no" id="toStdU16String"><span class="type">std::u16string</span> QString::<span class="name">toStdU16String</span>() const</h3>
<p>Returns a std::u16string object with the data contained in this <a href="qstring.html" translate="no">QString</a>. The Unicode data is the same as returned by the <a href="qstring.html#utf16" translate="no">utf16</a>() method.</p>
<p><b>See also </b><a href="qstring.html#utf16" translate="no">utf16</a>(), <a href="qstring.html#toStdWString" translate="no">toStdWString</a>(), and <a href="qstring.html#toStdU32String" translate="no">toStdU32String</a>().</p>
<!-- @@@toStdU16String -->
<!-- $$$toStdU32String[overload1]$$$toStdU32String -->
<h3 class="fn" translate="no" id="toStdU32String"><span class="type">std::u32string</span> QString::<span class="name">toStdU32String</span>() const</h3>
<p>Returns a std::u32string object with the data contained in this <a href="qstring.html" translate="no">QString</a>. The Unicode data is the same as returned by the <a href="qstring.html#toUcs4" translate="no">toUcs4</a>() method.</p>
<p><b>See also </b><a href="qstring.html#toUcs4" translate="no">toUcs4</a>(), <a href="qstring.html#toStdWString" translate="no">toStdWString</a>(), and <a href="qstring.html#toStdU16String" translate="no">toStdU16String</a>().</p>
<!-- @@@toStdU32String -->
<!-- $$$toStdWString[overload1]$$$toStdWString -->
<h3 class="fn" translate="no" id="toStdWString"><span class="type">std::wstring</span> QString::<span class="name">toStdWString</span>() const</h3>
<p>Returns a std::wstring object with the data contained in this <a href="qstring.html" translate="no">QString</a>. The std::wstring is encoded in UTF-16 on platforms where wchar_t is 2 bytes wide (for example, Windows) and in UTF-32 on platforms where wchar_t is 4 bytes wide (most Unix systems).</p>
<p>This method is mostly useful to pass a <a href="qstring.html" translate="no">QString</a> to a function that accepts a std::wstring object.</p>
<p><b>See also </b><a href="qstring.html#utf16" translate="no">utf16</a>(), <a href="qstring.html#toLatin1" translate="no">toLatin1</a>(), <a href="qstring.html#toUtf8" translate="no">toUtf8</a>(), <a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>(), <a href="qstring.html#toStdU16String" translate="no">toStdU16String</a>(), and <a href="qstring.html#toStdU32String" translate="no">toStdU32String</a>().</p>
<!-- @@@toStdWString -->
<!-- $$$toUInt[overload1]$$$toUIntbool*int -->
<h3 class="fn" translate="no" id="toUInt"><span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span> QString::<span class="name">toUInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code translate="no">unsigned int</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<p>If <i translate="no">base</i> is 0, the C language convention is used: if the string begins with &quot;0x&quot;, base 16 is used; otherwise, if the string begins with &quot;0b&quot;, base 2 is used; otherwise, if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toUInt" translate="no">QLocale::toUInt</a>()</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
 <span class="type">bool</span> ok;

 <span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toUInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
 <span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toUInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<div class="admonition note">
<p><b>Note: </b>Support for the &quot;0b&quot; prefix was added in Qt 6.4.</p>
</div>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qstring.html#toInt" translate="no">toInt</a>(), and <a href="qlocale.html#toUInt" translate="no">QLocale::toUInt</a>().</p>
<!-- @@@toUInt -->
<!-- $$$toULong[overload1]$$$toULongbool*int -->
<h3 class="fn" translate="no" id="toULong"><span class="type"><a href="qttypes.html#ulong-typedef" translate="no">ulong</a></span> QString::<span class="name">toULong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code translate="no">unsigned long</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<p>If <i translate="no">base</i> is 0, the C language convention is used: if the string begins with &quot;0x&quot;, base 16 is used; otherwise, if the string begins with &quot;0b&quot;, base 2 is used; otherwise, if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toULongLong" translate="no">QLocale::toULongLong</a>()</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
 <span class="type">bool</span> ok;

 <span class="type"><a href="qttypes.html#ulong-typedef" translate="no">ulong</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toULong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);   <span class="comment">// hex == 255, ok == true</span>
 <span class="type"><a href="qttypes.html#ulong-typedef" translate="no">ulong</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toULong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);   <span class="comment">// dec == 0, ok == false</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<div class="admonition note">
<p><b>Note: </b>Support for the &quot;0b&quot; prefix was added in Qt 6.4.</p>
</div>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>() and <a href="qlocale.html#toUInt" translate="no">QLocale::toUInt</a>().</p>
<!-- @@@toULong -->
<!-- $$$toULongLong[overload1]$$$toULongLongbool*int -->
<h3 class="fn" translate="no" id="toULongLong"><span class="type"><a href="qttypes.html#qulonglong-typedef" translate="no">qulonglong</a></span> QString::<span class="name">toULongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code translate="no">unsigned long long</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<p>If <i translate="no">base</i> is 0, the C language convention is used: if the string begins with &quot;0x&quot;, base 16 is used; otherwise, if the string begins with &quot;0b&quot;, base 2 is used; otherwise, if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toULongLong" translate="no">QLocale::toULongLong</a>()</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
 <span class="type">bool</span> ok;

 <span class="type"><a href="qttypes.html#quint64-typedef" translate="no">quint64</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toULongLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);    <span class="comment">// hex == 255, ok == true</span>
 <span class="type"><a href="qttypes.html#quint64-typedef" translate="no">quint64</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toULongLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);    <span class="comment">// dec == 0, ok == false</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<div class="admonition note">
<p><b>Note: </b>Support for the &quot;0b&quot; prefix was added in Qt 6.4.</p>
</div>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qstring.html#toLongLong" translate="no">toLongLong</a>(), and <a href="qlocale.html#toULongLong" translate="no">QLocale::toULongLong</a>().</p>
<!-- @@@toULongLong -->
<!-- $$$toUShort[overload1]$$$toUShortbool*int -->
<h3 class="fn" translate="no" id="toUShort"><span class="type"><a href="qttypes.html#ushort-typedef" translate="no">ushort</a></span> QString::<span class="name">toUShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code translate="no">unsigned short</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<p>If <i translate="no">base</i> is 0, the C language convention is used: if the string begins with &quot;0x&quot;, base 16 is used; otherwise, if the string begins with &quot;0b&quot;, base 2 is used; otherwise, if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale-dependent conversion use <a href="qlocale.html#toUShort" translate="no">QLocale::toUShort</a>()</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
 <span class="type">bool</span> ok;

 <span class="type"><a href="qttypes.html#ushort-typedef" translate="no">ushort</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toUShort(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
 <span class="type"><a href="qttypes.html#ushort-typedef" translate="no">ushort</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toUShort(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>
</pre>
<p>This function ignores leading and trailing whitespace.</p>
<div class="admonition note">
<p><b>Note: </b>Support for the &quot;0b&quot; prefix was added in Qt 6.4.</p>
</div>
<p><b>See also </b><a href="qstring.html#number" translate="no">number</a>(), <a href="qstring.html#toShort" translate="no">toShort</a>(), and <a href="qlocale.html#toUShort" translate="no">QLocale::toUShort</a>().</p>
<!-- @@@toUShort -->
<!-- $$$toUcs4[overload1]$$$toUcs4 -->
<h3 class="fn" translate="no" id="toUcs4"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span>&gt; QString::<span class="name">toUcs4</span>() const</h3>
<p>Returns a UCS-4/UTF-32 representation of the string as a <a href="qlist.html" translate="no">QList</a>&lt;uint&gt;.</p>
<p>UCS-4 is a Unicode codec and therefore it is lossless. All characters from this string will be encoded in UCS-4. Any invalid sequence of code units in this string is replaced by the Unicode's replacement character (<a href="qchar.html#SpecialCharacter-enum" translate="no">QChar::ReplacementCharacter</a>, which corresponds to <code translate="no">U+FFFD</code>).</p>
<p>The returned list is not \0'-terminated.</p>
<p><b>See also </b><a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(), <a href="qstring.html#toUtf8" translate="no">toUtf8</a>(), <a href="qstring.html#toLatin1" translate="no">toLatin1</a>(), <a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>(), <a href="qstringencoder.html" translate="no">QStringEncoder</a>, <a href="qstring.html#fromUcs4" translate="no">fromUcs4</a>(), and <a href="qstring.html#toWCharArray" translate="no">toWCharArray</a>().</p>
<!-- @@@toUcs4 -->
<!-- $$$toUpper[overload1]$$$toUpper -->
<h3 class="fn" translate="no" id="toUpper"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">toUpper</span>() const</h3>
<p>Returns an uppercase copy of the string.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;TeXt&quot;</span>;
 str <span class="operator">=</span> str<span class="operator">.</span>toUpper();        <span class="comment">// str == &quot;TEXT&quot;</span>
</pre>
<p>The case conversion will always happen in the 'C' locale. For locale-dependent case folding use <a href="qlocale.html#toUpper" translate="no">QLocale::toUpper</a>()</p>
<p><b>See also </b><a href="qstring.html#toLower" translate="no">toLower</a>() and <a href="qlocale.html#toLower" translate="no">QLocale::toLower</a>().</p>
<!-- @@@toUpper -->
<!-- $$$toUtf8[overload1]$$$toUtf8 -->
<h3 class="fn" translate="no" id="toUtf8"><span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> QString::<span class="name">toUtf8</span>() const</h3>
<p>Returns a UTF-8 representation of the string as a <a href="qbytearray.html" translate="no">QByteArray</a>.</p>
<p>UTF-8 is a Unicode codec and can represent all characters in a Unicode string like <a href="qstring.html" translate="no">QString</a>.</p>
<p><b>See also </b><a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>(), <a href="qstring.html#toLatin1" translate="no">toLatin1</a>(), <a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>(), and <a href="qstringencoder.html" translate="no">QStringEncoder</a>.</p>
<!-- @@@toUtf8 -->
<!-- $$$toWCharArray[overload1]$$$toWCharArraywchar_t* -->
<h3 class="fn" translate="no" id="toWCharArray"><span class="type">qsizetype</span> QString::<span class="name">toWCharArray</span>(<span class="type">wchar_t</span> *<i>array</i>) const</h3>
<p>Fills the <i translate="no">array</i> with the data contained in this <a href="qstring.html" translate="no">QString</a> object. The array is encoded in UTF-16 on platforms where wchar_t is 2 bytes wide (e.g. windows) and in UCS-4 on platforms where wchar_t is 4 bytes wide (most Unix systems).</p>
<p><i translate="no">array</i> has to be allocated by the caller and contain enough space to hold the complete string (allocating the array with the same length as the string is always sufficient).</p>
<p>This function returns the actual length of the string in <i translate="no">array</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not append a null character to the array.</p>
</div>
<p><b>See also </b><a href="qstring.html#utf16" translate="no">utf16</a>(), <a href="qstring.html#toUcs4" translate="no">toUcs4</a>(), <a href="qstring.html#toLatin1" translate="no">toLatin1</a>(), <a href="qstring.html#toUtf8" translate="no">toUtf8</a>(), <a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>(), <a href="qstring.html#toStdWString" translate="no">toStdWString</a>(), and <a href="qstringview.html#toWCharArray" translate="no">QStringView::toWCharArray</a>().</p>
<!-- @@@toWCharArray -->
<!-- $$$trimmed[overload1]$$$trimmed -->
<h3 class="fn" translate="no" id="trimmed"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">trimmed</span>() const</h3>
<p>Returns a string that has whitespace removed from the start and the end.</p>
<p>Whitespace means any character for which <a href="qchar.html#isSpace" translate="no">QChar::isSpace</a>() returns <code translate="no">true</code>. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;  lots\t of\nwhitespace\r\n &quot;</span>;
 str <span class="operator">=</span> str<span class="operator">.</span>trimmed();
 <span class="comment">// str == &quot;lots\t of\nwhitespace&quot;</span>
</pre>
<p>Unlike <a href="qstring.html#simplified" translate="no">simplified</a>(), trimmed() leaves internal whitespace alone.</p>
<p><b>See also </b><a href="qstring.html#simplified" translate="no">simplified</a>().</p>
<!-- @@@trimmed -->
<!-- $$$truncate[overload1]$$$truncateqsizetype -->
<h3 class="fn" translate="no" id="truncate"><span class="type">void</span> QString::<span class="name">truncate</span>(<span class="type">qsizetype</span> <i>position</i>)</h3>
<p>Truncates the string at the given <i translate="no">position</i> index.</p>
<p>If the specified <i translate="no">position</i> index is beyond the end of the string, nothing happens.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Vladivostok&quot;</span>;
 str<span class="operator">.</span>truncate(<span class="number">4</span>);
 <span class="comment">// str == &quot;Vlad&quot;</span>
</pre>
<p>If <i translate="no">position</i> is negative, it is equivalent to passing zero.</p>
<p><b>See also </b><a href="qstring.html#chop" translate="no">chop</a>(), <a href="qstring.html#resize" translate="no">resize</a>(), <a href="qstring.html#first" translate="no">first</a>(), and <a href="qstringview.html#truncate" translate="no">QStringView::truncate</a>().</p>
<!-- @@@truncate -->
<!-- $$$unicode[overload1]$$$unicode -->
<h3 class="fn" translate="no" id="unicode">const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> *QString::<span class="name">unicode</span>() const</h3>
<p>Returns a Unicode representation of the string. The result remains valid until the string is modified.</p>
<div class="admonition note">
<p><b>Note: </b>The returned string may not be '\0'-terminated. Use <a href="qstring.html#size" translate="no">size</a>() to determine the length of the array.</p>
</div>
<p><b>See also </b><a href="qstring.html#setUnicode" translate="no">setUnicode</a>(), <a href="qstring.html#utf16" translate="no">utf16</a>(), and <a href="qstring.html#fromRawData" translate="no">fromRawData</a>().</p>
<!-- @@@unicode -->
<!-- $$$utf16[overload1]$$$utf16 -->
<h3 class="fn" translate="no" id="utf16">const <span class="type"><a href="qttypes.html#ushort-typedef" translate="no">ushort</a></span> *QString::<span class="name">utf16</span>() const</h3>
<p>Returns the <a href="qstring.html" translate="no">QString</a> as a '\0'-terminated array of unsigned shorts. The result remains valid until the string is modified.</p>
<p>The returned string is in host byte order.</p>
<p><b>See also </b><a href="qstring.html#setUtf16" translate="no">setUtf16</a>() and <a href="qstring.html#unicode" translate="no">unicode</a>().</p>
<!-- @@@utf16 -->
<!-- $$$vasprintf[overload1]$$$vasprintfconstchar*va_list -->
<h3 class="fn" translate="no" id="vasprintf"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> QString::<span class="name">vasprintf</span>(const <span class="type">char</span> *<i>cformat</i>, <span class="type">va_list</span> <i>ap</i>)</h3>
<p>Equivalent method to <a href="qstring.html#asprintf" translate="no">asprintf</a>(), but takes a va_list <i translate="no">ap</i> instead a list of variable arguments. See the <a href="qstring.html#asprintf" translate="no">asprintf</a>() documentation for an explanation of <i translate="no">cformat</i>.</p>
<p>This method does not call the va_end macro, the caller is responsible to call va_end on <i translate="no">ap</i>.</p>
<p><b>See also </b><a href="qstring.html#asprintf" translate="no">asprintf</a>().</p>
<!-- @@@vasprintf -->
<!-- $$$operator std::u16string_view[overload1]$$$operator std::u16string_view -->
<h3 class="fn" translate="no" id="operator-std-3a-3au16string_view"><code class="details extra" translate="no">[noexcept, since 6.7]</code> <span class="type">std::u16string_view</span> QString::<span class="name">operator std::u16string_view</span>() const</h3>
<p>Converts this <a href="qstring.html" translate="no">QString</a> object to a <code translate="no">std::u16string_view</code> object.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@operator std::u16string_view -->
<!-- $$$operator!=$$$operator!=constchar* -->
<h3 class="fn" translate="no" id="operator-not-eq-9"><span class="type">bool</span> QString::<span class="name">operator!=</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>This function overloads operator!=().</p>
<p>The <i translate="no">other</i> const char pointer is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQByteArray& -->
<h3 class="fn" translate="no" id="operator-not-eq-10"><span class="type">bool</span> QString::<span class="name">operator!=</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>This function overloads operator!=().</p>
<p>The <i translate="no">other</i> byte array is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator!= -->
<!-- $$$operator+=[overload1]$$$operator+=constQString& -->
<h3 class="fn" translate="no" id="operator-2b-eq"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator+=</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>other</i>)</h3>
<p>Appends the string <i translate="no">other</i> onto the end of this string and returns a reference to this string.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;free&quot;</span>;
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;dom&quot;</span>;
 x <span class="operator">+</span><span class="operator">=</span> y;
 <span class="comment">// x == &quot;freedom&quot;</span>
</pre>
<p>This operation is typically very fast (<a href="containers.html#constant-time" translate="no">constant time</a>), because <a href="qstring.html" translate="no">QString</a> preallocates extra space at the end of the string data so it can grow without reallocating the entire string each time.</p>
<p><b>See also </b><a href="qstring.html#append" translate="no">append</a>() and <a href="qstring.html#prepend" translate="no">prepend</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=QChar -->
<h3 class="fn" translate="no" id="operator-2b-eq-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator+=</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>)</h3>
<p>This function overloads operator+=().</p>
<p>Appends the character <i translate="no">ch</i> to the string.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=QStringView -->
<h3 class="fn" translate="no" id="operator-2b-eq-2"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator+=</span>(<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span> <i>str</i>)</h3>
<p>This function overloads operator+=().</p>
<p>Appends the string view <i translate="no">str</i> to this string.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-2b-eq-3"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator+=</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>)</h3>
<p>This function overloads operator+=().</p>
<p>Appends the Latin-1 string viewed by <i translate="no">str</i> to this string.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=QUtf8StringView -->
<h3 class="fn" translate="no" id="operator-2b-eq-4"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator+=</span>(<span class="type"><a href="qutf8stringview.html" translate="no">QUtf8StringView</a></span> <i>str</i>)</h3>
<p>This function overloads operator+=().</p>
<p>Appends the UTF-8 string view <i translate="no">str</i> to this string.</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constchar* -->
<h3 class="fn" translate="no" id="operator-2b-eq-5"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator+=</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This function overloads operator+=().</p>
<p>Appends the string <i translate="no">str</i> to this string. The const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constQByteArray& -->
<h3 class="fn" translate="no" id="operator-2b-eq-6"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator+=</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>This function overloads operator+=().</p>
<p>Appends the byte array <i translate="no">ba</i> to this string. The byte array is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the <i translate="no">ba</i> byte array, they will be included in the transformation.</p>
<p>You can disable this function by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator+= -->
<!-- $$$operator<$$$operator<constchar* -->
<h3 class="fn" translate="no" id="operator-lt-9"><span class="type">bool</span> QString::<span class="name">operator&lt;</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if this string is lexically less than string <i translate="no">other</i>. Otherwise returns <code translate="no">false</code>.</p>
<p>This function overloads operator&lt;().</p>
<p>The <i translate="no">other</i> const char pointer is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constQByteArray& -->
<h3 class="fn" translate="no" id="operator-lt-10"><span class="type">bool</span> QString::<span class="name">operator&lt;</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>This function overloads operator&lt;().</p>
<p>The <i translate="no">other</i> byte array is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator< -->
<!-- $$$operator<=$$$operator<=constchar* -->
<h3 class="fn" translate="no" id="operator-lt-eq-9"><span class="type">bool</span> QString::<span class="name">operator&lt;=</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>This function overloads operator&lt;=().</p>
<p>The <i translate="no">other</i> const char pointer is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constQByteArray& -->
<h3 class="fn" translate="no" id="operator-lt-eq-10"><span class="type">bool</span> QString::<span class="name">operator&lt;=</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>This function overloads operator&lt;=().</p>
<p>The <i translate="no">other</i> byte array is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator<= -->
<!-- $$$operator=[overload1]$$$operator=constQString& -->
<h3 class="fn" translate="no" id="operator-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator=</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>other</i>)</h3>
<p>Assigns <i translate="no">other</i> to this string and returns a reference to this string.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QChar -->
<h3 class="fn" translate="no" id="operator-eq-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator=</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>ch</i>)</h3>
<p>This function overloads operator=().</p>
<p>Sets the string to contain the single character <i translate="no">ch</i>.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-eq-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator=</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>str</i>)</h3>
<p>This function overloads operator=().</p>
<p>Assigns the Latin-1 string viewed by <i translate="no">str</i> to this string.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QString&& -->
<h3 class="fn" translate="no" id="operator-eq-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator=</span>(<span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qstring.html" translate="no">QString</a> instance.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=constchar* -->
<h3 class="fn" translate="no" id="operator-eq-4"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator=</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This function overloads operator=().</p>
<p>Assigns <i translate="no">str</i> to this string. The const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> or <a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII" translate="no">QT_RESTRICTED_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=constQByteArray& -->
<h3 class="fn" translate="no" id="operator-eq-5"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;QString::<span class="name">operator=</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>This function overloads operator=().</p>
<p>Assigns <i translate="no">ba</i> to this string. The byte array is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator= -->
<!-- $$$operator==$$$operator==constchar* -->
<h3 class="fn" translate="no" id="operator-eq-eq-9"><span class="type">bool</span> QString::<span class="name">operator==</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>This function overloads operator==().</p>
<p>The <i translate="no">other</i> const char pointer is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQByteArray& -->
<h3 class="fn" translate="no" id="operator-eq-eq-10"><span class="type">bool</span> QString::<span class="name">operator==</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>This function overloads operator==().</p>
<p>The <i translate="no">other</i> byte array is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<p>Returns <code translate="no">true</code> if this string is lexically equal to the parameter string <i translate="no">other</i>. Otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator== -->
<!-- $$$operator>$$$operator>constchar* -->
<h3 class="fn" translate="no" id="operator-gt-9"><span class="type">bool</span> QString::<span class="name">operator&gt;</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>This function overloads operator&gt;().</p>
<p>The <i translate="no">other</i> const char pointer is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constQByteArray& -->
<h3 class="fn" translate="no" id="operator-gt-10"><span class="type">bool</span> QString::<span class="name">operator&gt;</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>This function overloads operator&gt;().</p>
<p>The <i translate="no">other</i> byte array is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator> -->
<!-- $$$operator>=$$$operator>=constchar* -->
<h3 class="fn" translate="no" id="operator-gt-eq-9"><span class="type">bool</span> QString::<span class="name">operator&gt;=</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>This function overloads operator&gt;=().</p>
<p>The <i translate="no">other</i> const char pointer is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constQByteArray& -->
<h3 class="fn" translate="no" id="operator-gt-eq-10"><span class="type">bool</span> QString::<span class="name">operator&gt;=</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>This function overloads operator&gt;=().</p>
<p>The <i translate="no">other</i> byte array is converted to a <a href="qstring.html" translate="no">QString</a> using the <a href="qstring.html#fromUtf8" translate="no">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator by defining <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr" translate="no">QObject::tr</a>(), for example.</p>
<!-- @@@operator>= -->
<!-- $$$operator[][overload1]$$$operator[]qsizetype -->
<h3 class="fn" translate="no" id="operator-5b-5d"><span class="type"><a href="qchar.html" translate="no">QChar</a></span> &amp;QString::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>position</i>)</h3>
<p>Returns the character at the specified <i translate="no">position</i> in the string as a modifiable reference.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> str;

 <span class="keyword">if</span> (str<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="char">'?'</span>))
     str<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html" translate="no">QChar</a></span>(<span class="char">'_'</span>);
</pre>
<p><b>See also </b><a href="qstring.html#at" translate="no">at</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]qsizetype -->
<h3 class="fn" translate="no" id="operator-5b-5d-1">const <span class="type"><a href="qchar.html" translate="no">QChar</a></span> QString::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>position</i>) const</h3>
<p>This function overloads operator[]().</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="operator-2b-1"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> <span class="name">operator+</span>(<span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;&amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-2b"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3></div>
<p>Returns a string which is the result of concatenating <i translate="no">s1</i> and <i translate="no">s2</i>.</p>
<!-- @@@ -->
<!-- $$$erase$$$eraseQString&constT& -->
<h3 class="fn" translate="no" id="erase-3"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename T&gt; <span class="type">qsizetype</span> <span class="name">erase</span>(<span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s</i>, const <span class="type">T</span> &amp;<i>t</i>)</h3>
<p>Removes all elements that compare equal to <i translate="no">t</i> from the string <i translate="no">s</i>. Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qstring.html#erase_if-1" translate="no">erase_if</a>.</p>
<!-- @@@erase -->
<!-- $$$erase_if$$$erase_ifQString&Predicate -->
<h3 class="fn" translate="no" id="erase_if-1"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Predicate&gt; <span class="type">qsizetype</span> <span class="name">erase_if</span>(<span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s</i>, <span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i translate="no">pred</i> returns true from the string <i translate="no">s</i>. Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qstring.html#erase" translate="no">erase</a>.</p>
<!-- @@@erase_if -->
<!-- $$$operator!=[overload1]$$$operator!=constQString&constQString& -->
<h3 class="fn" translate="no" id="operator-not-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if string <i translate="no">s1</i> is not equal to string <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQString&QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-not-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if string <i translate="no">s1</i> is not equal to string <i translate="no">s2</i>. Otherwise returns <code translate="no">false</code>.</p>
<p>This function overloads operator!=().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constchar*constQString& -->
<h3 class="fn" translate="no" id="operator-not-eq-11"><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is not equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<p>For <i translate="no">s1</i> != 0, this is equivalent to <code translate="no">compare(</code> <i translate="no">s1</i>, <i translate="no">s2</i> <code translate="no">) != 0</code>. Note that no string is equal to <i translate="no">s1</i> being 0.</p>
<!-- @@@operator!= -->
<!-- $$$operator""_s[overload1]$$$operator""_sconstchar16_t*size_t -->
<h3 class="fn" translate="no" id="operator-22-22_s"><code class="details extra" translate="no">[noexcept, since 6.4]</code> <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> <span class="name">operator&quot;&quot;_s</span>(const <span class="type">char16_t</span> *<i>str</i>, <span class="type">size_t</span> <i>size</i>)</h3>
<p>Literal operator that creates a <a href="qstring.html" translate="no">QString</a> out of the first <i translate="no">size</i> characters in the char16_t string literal <i translate="no">str</i>.</p>
<p>The <a href="qstring.html" translate="no">QString</a> is created at compile time, and the generated string data is stored in the read-only segment of the compiled object file. Duplicate literals may share the same read-only memory. This functionality is interchangeable with <a href="qstring.html#QStringLiteral" translate="no">QStringLiteral</a>, but saves typing when many string literals are present in the code.</p>
<p>The following code creates a <a href="qstring.html" translate="no">QString</a>:</p>
<pre class="cpp" translate="no">
 <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="type">Qt</span><span class="operator">::</span>Literals<span class="operator">::</span>StringLiterals;

 <span class="keyword">auto</span> str <span class="operator">=</span> u<span class="string">&quot;hello&quot;</span>_s;
</pre>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qt-literals-stringliterals.html" translate="no">Qt::Literals::StringLiterals</a>.</p>
<!-- @@@operator""_s -->
<!-- $$$operator+$$$operator+constQString&constchar* -->
<h3 class="fn" translate="no" id="operator-2b-2"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type">char</span> *<i>s2</i>)</h3>
<p>Returns a string which is the result of concatenating <i translate="no">s1</i> and <i translate="no">s2</i> (<i translate="no">s2</i> is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">QString::fromUtf8</a>() function).</p>
<p><b>See also </b><a href="qstring.html#fromUtf8" translate="no">QString::fromUtf8</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constchar*constQString& -->
<h3 class="fn" translate="no" id="operator-2b-3"><span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> <span class="name">operator+</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns a string which is the result of concatenating <i translate="no">s1</i> and <i translate="no">s2</i> (<i translate="no">s1</i> is converted to Unicode using the <a href="qstring.html#fromUtf8" translate="no">QString::fromUtf8</a>() function).</p>
<p><b>See also </b><a href="qstring.html#fromUtf8" translate="no">QString::fromUtf8</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator<$$$operator<constQString&constQString& -->
<h3 class="fn" translate="no" id="operator-lt-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>This function overloads operator&lt;().</p>
<p>Returns <code translate="no">true</code> if string <i translate="no">s1</i> is lexically less than string <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constQString&QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-lt-2"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s2</i>)</h3>
<p>This function overloads operator&lt;().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically less than <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<QLatin1StringViewconstQString& -->
<h3 class="fn" translate="no" id="operator-lt-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&lt;</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>This function overloads operator&lt;().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically less than <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constchar*constQString& -->
<h3 class="fn" translate="no" id="operator-lt-11"><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically less than <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>. For <i translate="no">s1</i> != 0, this is equivalent to <code translate="no">compare(s1, s2) &lt; 0</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator< -->
<!-- $$$operator<<$$$operator<<QDataStream&constQString& -->
<h3 class="fn" translate="no" id="operator-lt-lt-8"><span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>stream</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>string</i>)</h3>
<p>Writes the given <i translate="no">string</i> to the specified <i translate="no">stream</i>.</p>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator<=[overload1]$$$operator<=constQString&constQString& -->
<h3 class="fn" translate="no" id="operator-lt-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if string <i translate="no">s1</i> is lexically less than or equal to string <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constQString&QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-lt-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s2</i>)</h3>
<p>This function overloads operator&lt;=().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically less than or equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=QLatin1StringViewconstQString& -->
<h3 class="fn" translate="no" id="operator-lt-eq-2"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&lt;=</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>This function overloads operator&lt;=().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically less than or equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constchar*constQString& -->
<h3 class="fn" translate="no" id="operator-lt-eq-11"><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically less than or equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>. For <i translate="no">s1</i> != 0, this is equivalent to <code translate="no">compare(s1, s2) &lt;= 0</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator<= -->
<!-- $$$operator==$$$operator==constQString&constQString& -->
<h3 class="fn" translate="no" id="operator-eq-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>This function overloads operator==().</p>
<p>Returns <code translate="no">true</code> if string <i translate="no">s1</i> is equal to string <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<div class="admonition note">
<p><b>Note: </b>This function treats null strings the same as empty strings, for more details see <a href="qstring.html#distinction-between-null-and-empty-strings" translate="no">Distinction Between Null and Empty Strings</a>.</p>
</div>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQString&QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-eq-eq-2"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s2</i>)</h3>
<p>This function overloads operator==().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==QLatin1StringViewconstQString& -->
<h3 class="fn" translate="no" id="operator-eq-eq-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator==</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>This function overloads operator==().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constchar*constQString& -->
<h3 class="fn" translate="no" id="operator-eq-eq-11"><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>This function overloads operator==().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>. Note that no string is equal to <i translate="no">s1</i> being 0.</p>
<p>Equivalent to <code translate="no">s1 != 0 &amp;&amp; compare(s1, s2) == 0</code>.</p>
<!-- @@@operator== -->
<!-- $$$operator>[overload1]$$$operator>constQString&constQString& -->
<h3 class="fn" translate="no" id="operator-gt"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if string <i translate="no">s1</i> is lexically greater than string <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constQString&QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-gt-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s2</i>)</h3>
<p>This function overloads operator&gt;().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically greater than <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>QLatin1StringViewconstQString& -->
<h3 class="fn" translate="no" id="operator-gt-2"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&gt;</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>This function overloads operator&gt;().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically greater than <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constchar*constQString& -->
<h3 class="fn" translate="no" id="operator-gt-11"><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically greater than <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>. Equivalent to <code translate="no">compare(s1, s2) &gt; 0</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator> -->
<!-- $$$operator>=[overload1]$$$operator>=constQString&constQString& -->
<h3 class="fn" translate="no" id="operator-gt-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if string <i translate="no">s1</i> is lexically greater than or equal to string <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constQString&QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-gt-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s1</i>, <span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s2</i>)</h3>
<p>This function overloads operator&gt;=().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically greater than or equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=QLatin1StringViewconstQString& -->
<h3 class="fn" translate="no" id="operator-gt-eq-2"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&gt;=</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>This function overloads operator&gt;=().</p>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically greater than or equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constchar*constQString& -->
<h3 class="fn" translate="no" id="operator-gt-eq-11"><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">s1</i> is lexically greater than or equal to <i translate="no">s2</i>; otherwise returns <code translate="no">false</code>. For <i translate="no">s1</i> != 0, this is equivalent to <code translate="no">compare(s1, s2) &gt;= 0</code>.</p>
<p><b>See also </b><a href="qstring.html#comparing-strings" translate="no">Comparing Strings</a>.</p>
<!-- @@@operator>= -->
<!-- $$$operator>>$$$operator>>QDataStream&QString& -->
<h3 class="fn" translate="no" id="operator-gt-gt-3"><span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>stream</i>, <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>string</i>)</h3>
<p>Reads a string from the specified <i translate="no">stream</i> into the given <i translate="no">string</i>.</p>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator>> -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QStringLiteral[overload1]$$$QStringLiteral -->
<h3 class="fn" translate="no" id="QStringLiteral"><span class="name">QStringLiteral</span>(<i>str</i>)</h3>
<p>The macro generates the data for a <a href="qstring.html" translate="no">QString</a> out of the string literal <i translate="no">str</i> at compile time. Creating a <a href="qstring.html" translate="no">QString</a> from it is free in this case, and the generated string data is stored in the read-only segment of the compiled object file.</p>
<p>If you have code that looks like this:</p>
<pre class="cpp" translate="no">
 <span class="comment">// hasAttribute takes a QString argument</span>
 <span class="keyword">if</span> (node<span class="operator">.</span>hasAttribute(<span class="string">&quot;http-contents-length&quot;</span>)) <span class="comment">//...</span>
</pre>
<p>then a temporary <a href="qstring.html" translate="no">QString</a> will be created to be passed as the <code translate="no">hasAttribute</code> function parameter. This can be quite expensive, as it involves a memory allocation and the copy/conversion of the data into <a href="qstring.html" translate="no">QString</a>'s internal encoding.</p>
<p>This cost can be avoided by using QStringLiteral instead:</p>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (node<span class="operator">.</span>hasAttribute(<span class="type">QStringLiteral</span>(u<span class="string">&quot;http-contents-length&quot;</span>))) <span class="comment">//...</span>
</pre>
<p>In this case, <a href="qstring.html" translate="no">QString</a>'s internal data will be generated at compile time; no conversion or allocation will occur at runtime.</p>
<p>Using QStringLiteral instead of a double quoted plain C++ string literal can significantly speed up creation of <a href="qstring.html" translate="no">QString</a> instances from data known at compile time.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> can still be more efficient than QStringLiteral when the string is passed to a function that has an overload taking <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> and this overload avoids conversion to <a href="qstring.html" translate="no">QString</a>. For instance, QString::operator==() can compare to a <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> directly:</p>
</div>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (attribute<span class="operator">.</span>name() <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;http-contents-length&quot;</span>_L1) <span class="comment">//...</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>Some compilers have bugs encoding strings containing characters outside the US-ASCII character set. Make sure you prefix your string with <code translate="no">u</code> in those cases. It is optional otherwise.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#QByteArrayLiteral" translate="no">QByteArrayLiteral</a>.</p>
<!-- @@@QStringLiteral -->
<!-- $$$QT_NO_CAST_FROM_ASCII[overload1]$$$QT_NO_CAST_FROM_ASCII -->
<h3 class="fn" translate="no" id="QT_NO_CAST_FROM_ASCII"><span class="name">QT_NO_CAST_FROM_ASCII</span></h3>
<p>Disables automatic conversions from 8-bit strings (<code translate="no">char *</code>) to Unicode QStrings, as well as from 8-bit <code translate="no">char</code> types (<code translate="no">char</code> and <code translate="no">unsigned char</code>) to <a href="qchar.html" translate="no">QChar</a>.</p>
<p><b>See also </b><a href="qstring.html#QT_NO_CAST_TO_ASCII" translate="no">QT_NO_CAST_TO_ASCII</a>, <a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII" translate="no">QT_RESTRICTED_CAST_FROM_ASCII</a>, and <a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY" translate="no">QT_NO_CAST_FROM_BYTEARRAY</a>.</p>
<!-- @@@QT_NO_CAST_FROM_ASCII -->
<!-- $$$QT_NO_CAST_TO_ASCII[overload1]$$$QT_NO_CAST_TO_ASCII -->
<h3 class="fn" translate="no" id="QT_NO_CAST_TO_ASCII"><span class="name">QT_NO_CAST_TO_ASCII</span></h3>
<p>Disables automatic conversion from <a href="qstring.html" translate="no">QString</a> to 8-bit strings (<code translate="no">char *</code>).</p>
<p><b>See also </b><a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a>, <a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII" translate="no">QT_RESTRICTED_CAST_FROM_ASCII</a>, and <a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY" translate="no">QT_NO_CAST_FROM_BYTEARRAY</a>.</p>
<!-- @@@QT_NO_CAST_TO_ASCII -->
<!-- $$$QT_RESTRICTED_CAST_FROM_ASCII[overload1]$$$QT_RESTRICTED_CAST_FROM_ASCII -->
<h3 class="fn" translate="no" id="QT_RESTRICTED_CAST_FROM_ASCII"><span class="name">QT_RESTRICTED_CAST_FROM_ASCII</span></h3>
<p>Disables most automatic conversions from source literals and 8-bit data to unicode QStrings, but allows the use of the <code translate="no">QChar(char)</code> and <code translate="no">QString(const char (&amp;ch)[N]</code> constructors, and the <code translate="no">QString::operator=(const char (&amp;ch)[N])</code> assignment operator. This gives most of the type-safety benefits of <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> but does not require user code to wrap character and string literals with <a href="qlatin1char.html" translate="no">QLatin1Char</a>, <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> or similar.</p>
<p>Using this macro together with source strings outside the 7-bit range, non-literals, or literals with embedded NUL characters is undefined.</p>
<p><b>See also </b><a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a> and <a href="qstring.html#QT_NO_CAST_TO_ASCII" translate="no">QT_NO_CAST_TO_ASCII</a>.</p>
<!-- @@@QT_RESTRICTED_CAST_FROM_ASCII -->
<!-- $$$qPrintable[overload1]$$$qPrintableconstQString& -->
<h3 class="fn" translate="no" id="qPrintable">const <span class="type">char</span> *<span class="name">qPrintable</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>)</h3>
<p>Returns <i translate="no">str</i> as a <code translate="no">const char *</code>. This is equivalent to <i translate="no">str</i>.<a href="qstring.html#toLocal8Bit" translate="no">toLocal8Bit</a>().<a href="qstring.html#constData" translate="no">constData</a>().</p>
<p>The char pointer will be invalid after the statement in which qPrintable() is used. This is because the array returned by <a href="qstring.html#toLocal8Bit" translate="no">QString::toLocal8Bit</a>() will fall out of scope.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qtlogging.html#qDebug" translate="no">qDebug</a>(), <a href="qtlogging.html#qInfo" translate="no">qInfo</a>(), <a href="qtlogging.html#qWarning" translate="no">qWarning</a>(), <a href="qtlogging.html#qCritical" translate="no">qCritical</a>(), <a href="qtlogging.html#qFatal" translate="no">qFatal</a>() expect %s arguments to be UTF-8 encoded, while qPrintable() converts to local 8-bit encoding. Therefore <a href="qstring.html#qUtf8Printable" translate="no">qUtf8Printable</a>() should be used for logging strings instead of qPrintable().</p>
</div>
<p><b>See also </b><a href="qstring.html#qUtf8Printable" translate="no">qUtf8Printable</a>().</p>
<!-- @@@qPrintable -->
<!-- $$$qUtf16Printable[overload1]$$$qUtf16PrintableconstQString& -->
<h3 class="fn" translate="no" id="qUtf16Printable">const <span class="type">wchar_t</span> *<span class="name">qUtf16Printable</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>)</h3>
<p>Returns <i translate="no">str</i> as a <code translate="no">const ushort *</code>, but cast to a <code translate="no">const wchar_t *</code> to avoid warnings. This is equivalent to <i translate="no">str</i>.<a href="qstring.html#utf16" translate="no">utf16</a>() plus some casting.</p>
<p>The only useful thing you can do with the return value of this macro is to pass it to <a href="qstring.html#asprintf" translate="no">QString::asprintf</a>() for use in a <code translate="no">%ls</code> conversion. In particular, the return value is <i>not</i> a valid <code translate="no">const wchar_t*</code>!</p>
<p>In general, the pointer will be invalid after the statement in which qUtf16Printable() is used. This is because the pointer may have been obtained from a temporary expression, which will fall out of scope.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <a href="qtlogging.html#qWarning" translate="no">qWarning</a>(<span class="string">&quot;%ls: %ls&quot;</span><span class="operator">,</span> qUtf16Printable(key)<span class="operator">,</span> qUtf16Printable(value));
</pre>
<p><b>See also </b><a href="qstring.html#qPrintable" translate="no">qPrintable</a>(), <a href="qtlogging.html#qDebug" translate="no">qDebug</a>(), <a href="qtlogging.html#qInfo" translate="no">qInfo</a>(), <a href="qtlogging.html#qWarning" translate="no">qWarning</a>(), <a href="qtlogging.html#qCritical" translate="no">qCritical</a>(), and <a href="qtlogging.html#qFatal" translate="no">qFatal</a>().</p>
<!-- @@@qUtf16Printable -->
<!-- $$$qUtf8Printable[overload1]$$$qUtf8PrintableconstQString& -->
<h3 class="fn" translate="no" id="qUtf8Printable">const <span class="type">char</span> *<span class="name">qUtf8Printable</span>(const <span class="type"><a href="qstring.html#QString" translate="no">QString</a></span> &amp;<i>str</i>)</h3>
<p>Returns <i translate="no">str</i> as a <code translate="no">const char *</code>. This is equivalent to <i translate="no">str</i>.<a href="qstring.html#toUtf8" translate="no">toUtf8</a>().<a href="qstring.html#constData" translate="no">constData</a>().</p>
<p>The char pointer will be invalid after the statement in which qUtf8Printable() is used. This is because the array returned by <a href="qstring.html#toUtf8" translate="no">QString::toUtf8</a>() will fall out of scope.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <a href="qtlogging.html#qWarning" translate="no">qWarning</a>(<span class="string">&quot;%s: %s&quot;</span><span class="operator">,</span> qUtf8Printable(key)<span class="operator">,</span> qUtf8Printable(value));
</pre>
<p><b>See also </b><a href="qstring.html#qPrintable" translate="no">qPrintable</a>(), <a href="qtlogging.html#qDebug" translate="no">qDebug</a>(), <a href="qtlogging.html#qInfo" translate="no">qInfo</a>(), <a href="qtlogging.html#qWarning" translate="no">qWarning</a>(), <a href="qtlogging.html#qCritical" translate="no">qCritical</a>(), and <a href="qtlogging.html#qFatal" translate="no">qFatal</a>().</p>
<!-- @@@qUtf8Printable -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
