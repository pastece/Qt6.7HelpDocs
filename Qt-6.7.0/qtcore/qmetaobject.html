<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qmetaobject.cpp -->
  <meta name="description" content="The QMetaObject class contains meta-information about Qt objects.">
  <title>QMetaObject Struct | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QMetaObject</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QMetaObject Struct</h1>
<!-- $$$QMetaObject-brief -->
<p>The QMetaObject class contains meta-information about Qt objects. <a href="#details">More...</a></p>
<!-- @@@QMetaObject -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QMetaObject&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qmetaobject-members.html">List of all members, including inherited members</a></li>
<li><a href="qmetaobject-obsolete.html">Deprecated members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject-connection.html" translate="no">Connection</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QMetaClassInfo </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#classInfo" translate="no">classInfo</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#classInfoCount" translate="no">classInfoCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#classInfoOffset" translate="no">classInfoOffset</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#className" translate="no">className</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaMethod </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#constructor" translate="no">constructor</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#constructorCount" translate="no">constructorCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaEnum </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#enumerator" translate="no">enumerator</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#enumeratorCount" translate="no">enumeratorCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#enumeratorOffset" translate="no">enumeratorOffset</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#indexOfClassInfo" translate="no">indexOfClassInfo</a></b>(const char *<i>name</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#indexOfConstructor" translate="no">indexOfConstructor</a></b>(const char *<i>constructor</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#indexOfEnumerator" translate="no">indexOfEnumerator</a></b>(const char *<i>name</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a></b>(const char *<i>method</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#indexOfProperty" translate="no">indexOfProperty</a></b>(const char *<i>name</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#indexOfSignal" translate="no">indexOfSignal</a></b>(const char *<i>signal</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#indexOfSlot" translate="no">indexOfSlot</a></b>(const char *<i>slot</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#inherits" translate="no">inherits</a></b>(const QMetaObject *<i>metaObject</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> QMetaType </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#metaType" translate="no">metaType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaMethod </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#method" translate="no">method</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#methodCount" translate="no">methodCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#methodOffset" translate="no">methodOffset</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QObject *</td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#newInstance-1" translate="no">newInstance</a></b>(Args &amp;&amp;... <i>arguments</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaProperty </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#property" translate="no">property</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#propertyCount" translate="no">propertyCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#propertyOffset" translate="no">propertyOffset</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject *</td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#superClass" translate="no">superClass</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaProperty </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#userProperty" translate="no">userProperty</a></b>() const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#checkConnectArgs" translate="no">checkConnectArgs</a></b>(const char *<i>signal</i>, const char *<i>method</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#checkConnectArgs-1" translate="no">checkConnectArgs</a></b>(const QMetaMethod &amp;<i>signal</i>, const QMetaMethod &amp;<i>method</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#connectSlotsByName" translate="no">connectSlotsByName</a></b>(QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod" translate="no">invokeMethod</a></b>(QObject *<i>obj</i>, const char *<i>member</i>, Qt::ConnectionType <i>type</i>, QTemplatedMetaMethodReturnArgument&lt;ReturnArg&gt; <i>ret</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod-5" translate="no">invokeMethod</a></b>(QObject *<i>obj</i>, const char *<i>member</i>, Qt::ConnectionType <i>type</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod-6" translate="no">invokeMethod</a></b>(QObject *<i>obj</i>, const char *<i>member</i>, QTemplatedMetaMethodReturnArgument&lt;ReturnArg&gt; <i>ret</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod-7" translate="no">invokeMethod</a></b>(QObject *<i>obj</i>, const char *<i>member</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod-8" translate="no">invokeMethod</a></b>(QObject *<i>context</i>, Functor &amp;&amp;<i>function</i>, Qt::ConnectionType <i>type</i> = Qt::AutoConnection, FunctorReturnType *<i>ret</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod-9" translate="no">invokeMethod</a></b>(QObject *<i>context</i>, Functor &amp;&amp;<i>function</i>, FunctorReturnType *<i>ret</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod-10" translate="no">invokeMethod</a></b>(QObject *<i>context</i>, Functor &amp;&amp;<i>function</i>, Qt::ConnectionType <i>type</i>, QTemplatedMetaMethodReturnArgument&lt;FunctorReturnType&gt; <i>ret</i>, Args &amp;&amp;... <i>arguments</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod-11" translate="no">invokeMethod</a></b>(QObject *<i>context</i>, Functor &amp;&amp;<i>function</i>, QTemplatedMetaMethodReturnArgument&lt;FunctorReturnType&gt; <i>ret</i>, Args &amp;&amp;... <i>arguments</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod-12" translate="no">invokeMethod</a></b>(QObject *<i>context</i>, Functor &amp;&amp;<i>function</i>, Qt::ConnectionType <i>type</i>, Args &amp;&amp;... <i>arguments</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#invokeMethod-13" translate="no">invokeMethod</a></b>(QObject *<i>context</i>, Functor &amp;&amp;<i>function</i>, Args &amp;&amp;... <i>arguments</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#normalizedSignature" translate="no">normalizedSignature</a></b>(const char *<i>method</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#normalizedType" translate="no">normalizedType</a></b>(const char *<i>type</i>)</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QMetaMethodArgument </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#Q_ARG" translate="no">Q_ARG</a></b>(<i>Type</i>, const Type &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaMethodReturnArgument </td><td class="memItemRight bottomAlign"><b><a href="qmetaobject.html#Q_RETURN_ARG" translate="no">Q_RETURN_ARG</a></b>(<i>Type</i>, Type &amp;<i>value</i>)</td></tr>
</table></div>
<!-- $$$QMetaObject-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The Qt <a href="metaobjects.html" translate="no">Meta-Object System</a> in Qt is responsible for the signals and slots inter-object communication mechanism, runtime type information, and the Qt property system. A single QMetaObject instance is created for each <a href="qobject.html" translate="no">QObject</a> subclass that is used in an application, and this instance stores all the meta-information for the <a href="qobject.html" translate="no">QObject</a> subclass. This object is available as <a href="qobject.html#metaObject" translate="no">QObject::metaObject</a>().</p>
<p>This class is not normally required for application programming, but it is useful if you write meta-applications, such as scripting engines or GUI builders.</p>
<p>The functions you are most likely to find useful are these:</p>
<ul>
<li><a href="qmetaobject.html#className" translate="no">className</a>() returns the name of a class.</li>
<li><a href="qmetaobject.html#superClass" translate="no">superClass</a>() returns the superclass's meta-object.</li>
<li><a href="qmetaobject.html#method" translate="no">method</a>() and <a href="qmetaobject.html#methodCount" translate="no">methodCount</a>() provide information about a class's meta-methods (signals, slots and other <a href="qobject.html#Q_INVOKABLE" translate="no">invokable</a> member functions).</li>
<li><a href="qmetaobject.html#enumerator" translate="no">enumerator</a>() and <a href="qmetaobject.html#enumeratorCount" translate="no">enumeratorCount</a>() and provide information about a class's enumerators.</li>
<li><a href="qmetaobject.html#propertyCount" translate="no">propertyCount</a>() and <a href="qmetaobject.html#property" translate="no">property</a>() provide information about a class's properties.</li>
<li><a href="qmetaobject.html#constructor" translate="no">constructor</a>() and <a href="qmetaobject.html#constructorCount" translate="no">constructorCount</a>() provide information about a class's meta-constructors.</li>
</ul>
<p>The index functions <a href="qmetaobject.html#indexOfConstructor" translate="no">indexOfConstructor</a>(), <a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a>(), <a href="qmetaobject.html#indexOfEnumerator" translate="no">indexOfEnumerator</a>(), and <a href="qmetaobject.html#indexOfProperty" translate="no">indexOfProperty</a>() map names of constructors, member functions, enumerators, or properties to indexes in the meta-object. For example, Qt uses <a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a>() internally when you connect a signal to a slot.</p>
<p>Classes can also have a list of <i>name</i>&ndash;<i>value</i> pairs of additional class information, stored in <a href="qmetaclassinfo.html" translate="no">QMetaClassInfo</a> objects. The number of pairs is returned by <a href="qmetaobject.html#classInfoCount" translate="no">classInfoCount</a>(), single pairs are returned by <a href="qmetaobject.html#classInfo" translate="no">classInfo</a>(), and you can search for pairs with <a href="qmetaobject.html#indexOfClassInfo" translate="no">indexOfClassInfo</a>().</p>
<div class="admonition note">
<p><b>Note: </b>Operations that use the meta object system are generally thread- safe, as QMetaObjects are typically static read-only instances generated at compile time. However, if meta objects are dynamically modified by the application (for instance, when using <a href="../qtqml/qqmlpropertymap.html" translate="no">QQmlPropertyMap</a>), then the application has to explicitly synchronize access to the respective meta object.</p>
</div>
</div>
<p><b>See also </b><a href="qmetaclassinfo.html" translate="no">QMetaClassInfo</a>, <a href="qmetaenum.html" translate="no">QMetaEnum</a>, <a href="qmetamethod.html" translate="no">QMetaMethod</a>, <a href="qmetaproperty.html" translate="no">QMetaProperty</a>, <a href="qmetatype.html" translate="no">QMetaType</a>, and <a href="metaobjects.html" translate="no">Meta-Object System</a>.</p>
<!-- @@@QMetaObject -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="invokeMethod-7"><code class="details extra" translate="no">[static, since 6.5]</code> template &lt;typename... Args&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>obj</i>, const <span class="type">char</span> *<i>member</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3><h3 class="fn fngroupitem" translate="no" id="invokeMethod-6"><code class="details extra" translate="no">[static, since 6.5]</code> template &lt;typename ReturnArg, typename... Args&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>obj</i>, const <span class="type">char</span> *<i>member</i>, <span class="type">QTemplatedMetaMethodReturnArgument</span>&lt;<span class="type">ReturnArg</span>&gt; <i>ret</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3><h3 class="fn fngroupitem" translate="no" id="invokeMethod-5"><code class="details extra" translate="no">[static, since 6.5]</code> template &lt;typename... Args&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>obj</i>, const <span class="type">char</span> *<i>member</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3><h3 class="fn fngroupitem" translate="no" id="invokeMethod"><code class="details extra" translate="no">[static, since 6.5]</code> template &lt;typename ReturnArg, typename... Args&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>obj</i>, const <span class="type">char</span> *<i>member</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i>, <span class="type">QTemplatedMetaMethodReturnArgument</span>&lt;<span class="type">ReturnArg</span>&gt; <i>ret</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3></div>
<p>Invokes the <i translate="no">member</i> (a signal or a slot name) on the object <i translate="no">obj</i>. Returns <code translate="no">true</code> if the member could be invoked. Returns <code translate="no">false</code> if there is no such member or the parameters did not match.</p>
<p>For the overloads with a QTemplatedMetaMethodReturnArgument parameter, the return value of the <i translate="no">member</i> function call is placed in <i translate="no">ret</i>. For the overloads without such a member, the return value of the called function (if any) will be discarded. QTemplatedMetaMethodReturnArgument is an internal type you should not use directly. Instead, use the qReturnArg() function.</p>
<p>The overloads with a <a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a> <i translate="no">type</i> parameter allow explicitly selecting whether the invocation will be synchronous or not:</p>
<ul>
<li>If <i translate="no">type</i> is <a href="qt.html#ConnectionType-enum" translate="no">Qt::DirectConnection</a>, the member will be invoked immediately in the current thread.</li>
<li>If <i translate="no">type</i> is <a href="qt.html#ConnectionType-enum" translate="no">Qt::QueuedConnection</a>, a <a href="qevent.html" translate="no">QEvent</a> will be sent and the member is invoked as soon as the application enters the event loop in the thread that the <i translate="no">obj</i> was created in or was moved to.</li>
<li>If <i translate="no">type</i> is <a href="qt.html#ConnectionType-enum" translate="no">Qt::BlockingQueuedConnection</a>, the method will be invoked in the same way as for <a href="qt.html#ConnectionType-enum" translate="no">Qt::QueuedConnection</a>, except that the current thread will block until the event is delivered. Using this connection type to communicate between objects in the same thread will lead to deadlocks.</li>
<li>If <i translate="no">type</i> is <a href="qt.html#ConnectionType-enum" translate="no">Qt::AutoConnection</a>, the member is invoked synchronously if <i translate="no">obj</i> lives in the same thread as the caller; otherwise it will invoke the member asynchronously. This is the behavior of the overloads that do not have the <i translate="no">type</i> parameter.</li>
</ul>
<p>You only need to pass the name of the signal or slot to this function, not the entire signature. For example, to asynchronously invoke the <a href="qthread.html#quit" translate="no">quit</a>() slot on a <a href="qthread.html" translate="no">QThread</a>, use the following code:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span><span class="operator">::</span>invokeMethod(thread<span class="operator">,</span> <span class="string">&quot;quit&quot;</span><span class="operator">,</span>
                           <span class="type">Qt</span><span class="operator">::</span>QueuedConnection);
</pre>
<p>With asynchronous method invocations, the parameters must be copyable types, because Qt needs to copy the arguments to store them in an event behind the scenes. Since Qt 6.5, this function automatically registers the types being used; however, as a side-effect, it is not possible to make calls using types that are only forward-declared. Additionally, it is not possible to make asynchronous calls that use references to non-const-qualified types as parameters either.</p>
<p>To synchronously invoke the <code translate="no">compute(QString, int, double)</code> slot on some arbitrary object <code translate="no">obj</code> retrieve its return value:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html" translate="no">QString</a></span> retVal;
 <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span><span class="operator">::</span>invokeMethod(obj<span class="operator">,</span> <span class="string">&quot;compute&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>DirectConnection<span class="operator">,</span>
                          qReturnArg(retVal)<span class="operator">,</span>
                          <span class="type"><a href="qstring.html" translate="no">QString</a></span>(<span class="string">&quot;sqrt&quot;</span>)<span class="operator">,</span> <span class="number">42</span><span class="operator">,</span> <span class="number">9.7</span>);
</pre>
<p>If the &quot;compute&quot; slot does not take exactly one <a href="qstring.html" translate="no">QString</a>, one <code translate="no">int</code>, and one <code translate="no">double</code> in the specified order, the call will fail. Note how it was necessary to be explicit about the type of the <a href="qstring.html" translate="no">QString</a>, as the character literal is not exactly the right type to match. If the method instead took a <a href="qstringview.html" translate="no">QStringView</a>, a <a href="qttypes.html#qsizetype-typedef" translate="no">qsizetype</a>, and a <code translate="no">float</code>, the call would need to be written as:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html" translate="no">QString</a></span> retVal;
 <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span><span class="operator">::</span>invokeMethod(obj<span class="operator">,</span> <span class="string">&quot;compute&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>DirectConnection<span class="operator">,</span>
                          qReturnArg(retVal)<span class="operator">,</span>
                          <span class="type"><a href="qstringview.html" translate="no">QStringView</a></span>(<span class="string">&quot;sqrt&quot;</span>)<span class="operator">,</span> qsizetype(<span class="number">42</span>)<span class="operator">,</span> <span class="number">9.7f</span>);
</pre>
<p>The same call can be executed using the <a href="qmetaobject.html#Q_ARG" translate="no">Q_ARG</a>() and <a href="qmetaobject.html#Q_RETURN_ARG" translate="no">Q_RETURN_ARG</a>() macros, as in:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qstring.html" translate="no">QString</a></span> retVal;
 <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span><span class="operator">::</span>invokeMethod(obj<span class="operator">,</span> <span class="string">&quot;compute&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>DirectConnection<span class="operator">,</span>
                           Q_RETURN_ARG(<span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> retVal)<span class="operator">,</span>
                           Q_ARG(<span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="string">&quot;sqrt&quot;</span>)<span class="operator">,</span>
                           Q_ARG(<span class="type">int</span><span class="operator">,</span> <span class="number">42</span>)<span class="operator">,</span>
                           Q_ARG(<span class="type">double</span><span class="operator">,</span> <span class="number">9.7</span>));
</pre>
<p>The macros are kept for compatibility with Qt 6.4 and earlier versions, and can be freely mixed with parameters that do not use the macro. They may be necessary in rare situations when calling a method that used a typedef to forward-declared type as a parameter or the return type.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qmetaobject.html#Q_ARG" translate="no">Q_ARG</a>(), <a href="qmetaobject.html#Q_RETURN_ARG" translate="no">Q_RETURN_ARG</a>(), and <a href="qmetamethod-obsolete.html#invoke" translate="no">QMetaMethod::invoke</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="invokeMethod-9"><code class="details extra" translate="no">[static]</code> template &lt;typename Functor, typename FunctorReturnType&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>function</i>, <span class="type">FunctorReturnType</span> *<i>ret</i>)</h3><h3 class="fn fngroupitem" translate="no" id="invokeMethod-8"><code class="details extra" translate="no">[static]</code> template &lt;typename Functor, typename FunctorReturnType&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>function</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i> = Qt::AutoConnection, <span class="type">FunctorReturnType</span> *<i>ret</i> = nullptr)</h3></div>
<p>Invokes the <i translate="no">function</i> in the event loop of <i translate="no">context</i>. <i translate="no">function</i> can be a functor or a pointer to a member function. Returns <code translate="no">true</code> if the function could be invoked. Returns <code translate="no">false</code> if there is no such function or the parameters did not match. The return value of the function call is placed in <i translate="no">ret</i>.</p>
<p>If <i translate="no">type</i> is set, then the function is invoked using that connection type. Otherwise, <a href="qt.html#ConnectionType-enum" translate="no">Qt::AutoConnection</a> will be used.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="invokeMethod-13"><code class="details extra" translate="no">[static, since 6.7]</code> template &lt;typename Functor, typename... Args&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>function</i>, <span class="type">Args</span> &amp;&amp;... <i>arguments</i>)</h3><h3 class="fn fngroupitem" translate="no" id="invokeMethod-11"><code class="details extra" translate="no">[static, since 6.7]</code> template &lt;typename Functor, typename FunctorReturnType, typename... Args&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>function</i>, <span class="type">QTemplatedMetaMethodReturnArgument</span>&lt;<span class="type">FunctorReturnType</span>&gt; <i>ret</i>, <span class="type">Args</span> &amp;&amp;... <i>arguments</i>)</h3><h3 class="fn fngroupitem" translate="no" id="invokeMethod-12"><code class="details extra" translate="no">[static, since 6.7]</code> template &lt;typename Functor, typename... Args&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>function</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i>, <span class="type">Args</span> &amp;&amp;... <i>arguments</i>)</h3><h3 class="fn fngroupitem" translate="no" id="invokeMethod-10"><code class="details extra" translate="no">[static, since 6.7]</code> template &lt;typename Functor, typename FunctorReturnType, typename... Args&gt; <span class="type">bool</span> QMetaObject::<span class="name">invokeMethod</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>function</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i>, <span class="type">QTemplatedMetaMethodReturnArgument</span>&lt;<span class="type">FunctorReturnType</span>&gt; <i>ret</i>, <span class="type">Args</span> &amp;&amp;... <i>arguments</i>)</h3></div>
<p>Invokes the <i translate="no">function</i> with <i translate="no">arguments</i> in the event loop of <i translate="no">context</i>. <i translate="no">function</i> can be a functor or a pointer to a member function. Returns <code translate="no">true</code> if the function could be invoked. The return value of the function call is placed in <i translate="no">ret</i>. The object used for the <i translate="no">ret</i> argument should be obtained by passing your object to qReturnArg(). For example:</p>
<pre class="cpp plain" translate="no">
 MyClass *obj = ...;
 int result = 0;
 QMetaObject::invokeMethod(obj, &amp;MyClass::myMethod, qReturnArg(result), parameter);
</pre>
<p>If <i translate="no">type</i> is set, then the function is invoked using that connection type. Otherwise, <a href="qt.html#ConnectionType-enum" translate="no">Qt::AutoConnection</a> will be used.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@ -->
<!-- $$$checkConnectArgs[overload1]$$$checkConnectArgsconstchar*constchar* -->
<h3 class="fn" translate="no" id="checkConnectArgs"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QMetaObject::<span class="name">checkConnectArgs</span>(const <span class="type">char</span> *<i>signal</i>, const <span class="type">char</span> *<i>method</i>)</h3>
<p>Returns <code translate="no">true</code> if the <i translate="no">signal</i> and <i translate="no">method</i> arguments are compatible; otherwise returns <code translate="no">false</code>.</p>
<p>Both <i translate="no">signal</i> and <i translate="no">method</i> are expected to be normalized.</p>
<p><b>See also </b><a href="qmetaobject.html#normalizedSignature" translate="no">normalizedSignature</a>().</p>
<!-- @@@checkConnectArgs -->
<!-- $$$checkConnectArgs$$$checkConnectArgsconstQMetaMethod&constQMetaMethod& -->
<h3 class="fn" translate="no" id="checkConnectArgs-1"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QMetaObject::<span class="name">checkConnectArgs</span>(const <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> &amp;<i>signal</i>, const <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> &amp;<i>method</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if the <i translate="no">signal</i> and <i translate="no">method</i> arguments are compatible; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@checkConnectArgs -->
<!-- $$$classInfo[overload1]$$$classInfoint -->
<h3 class="fn" translate="no" id="classInfo"><span class="type"><a href="qmetaclassinfo.html" translate="no">QMetaClassInfo</a></span> QMetaObject::<span class="name">classInfo</span>(<span class="type">int</span> <i>index</i>) const</h3>
<p>Returns the meta-data for the item of class information with the given <i translate="no">index</i>.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_CLASSINFO(<span class="string">&quot;author&quot;</span><span class="operator">,</span> <span class="string">&quot;Sabrina Schweinsteiger&quot;</span>)
     Q_CLASSINFO(<span class="string">&quot;url&quot;</span><span class="operator">,</span> <span class="string">&quot;http://doc.moosesoft.co.uk/1.0/&quot;</span>)

 <span class="keyword">public</span>:
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 };
</pre>
<p><b>See also </b><a href="qmetaobject.html#classInfoCount" translate="no">classInfoCount</a>(), <a href="qmetaobject.html#classInfoOffset" translate="no">classInfoOffset</a>(), and <a href="qmetaobject.html#indexOfClassInfo" translate="no">indexOfClassInfo</a>().</p>
<!-- @@@classInfo -->
<!-- $$$classInfoCount[overload1]$$$classInfoCount -->
<h3 class="fn" translate="no" id="classInfoCount"><span class="type">int</span> QMetaObject::<span class="name">classInfoCount</span>() const</h3>
<p>Returns the number of items of class information in this class.</p>
<p><b>See also </b><a href="qmetaobject.html#classInfo" translate="no">classInfo</a>(), <a href="qmetaobject.html#classInfoOffset" translate="no">classInfoOffset</a>(), and <a href="qmetaobject.html#indexOfClassInfo" translate="no">indexOfClassInfo</a>().</p>
<!-- @@@classInfoCount -->
<!-- $$$classInfoOffset[overload1]$$$classInfoOffset -->
<h3 class="fn" translate="no" id="classInfoOffset"><span class="type">int</span> QMetaObject::<span class="name">classInfoOffset</span>() const</h3>
<p>Returns the class information offset for this class; i.e. the index position of this class's first class information item.</p>
<p>If the class has no superclasses with class information, the offset is 0; otherwise the offset is the sum of all the class information items in the class's superclasses.</p>
<p><b>See also </b><a href="qmetaobject.html#classInfo" translate="no">classInfo</a>(), <a href="qmetaobject.html#classInfoCount" translate="no">classInfoCount</a>(), and <a href="qmetaobject.html#indexOfClassInfo" translate="no">indexOfClassInfo</a>().</p>
<!-- @@@classInfoOffset -->
<!-- $$$className[overload1]$$$className -->
<h3 class="fn" translate="no" id="className">const <span class="type">char</span> *QMetaObject::<span class="name">className</span>() const</h3>
<p>Returns the class name.</p>
<p><b>See also </b><a href="qmetaobject.html#superClass" translate="no">superClass</a>().</p>
<!-- @@@className -->
<!-- $$$connectSlotsByName[overload1]$$$connectSlotsByNameQObject* -->
<h3 class="fn" translate="no" id="connectSlotsByName"><code class="details extra" translate="no">[static]</code> <span class="type">void</span> QMetaObject::<span class="name">connectSlotsByName</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>object</i>)</h3>
<p>Searches recursively for all child objects of the given <i translate="no">object</i>, and connects matching signals from them to slots of <i translate="no">object</i> that follow the following form:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> on_<span class="operator">&lt;</span>object name<span class="operator">&gt;</span>_<span class="operator">&lt;</span>signal name<span class="operator">&gt;</span>(<span class="operator">&lt;</span>signal parameters<span class="operator">&gt;</span>);
</pre>
<p>Let's assume our object has a child object of type <code translate="no">QPushButton</code> with the <a href="qobject.html#objectName-prop" translate="no">object name</a> <code translate="no">button1</code>. The slot to catch the button's <code translate="no">clicked()</code> signal would be:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> on_button1_clicked();
</pre>
<p>If <i translate="no">object</i> itself has a properly set object name, its own signals are also connected to its respective slots.</p>
<p><b>See also </b><a href="qobject.html#setObjectName" translate="no">QObject::setObjectName</a>().</p>
<!-- @@@connectSlotsByName -->
<!-- $$$constructor[overload1]$$$constructorint -->
<h3 class="fn" translate="no" id="constructor"><span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> QMetaObject::<span class="name">constructor</span>(<span class="type">int</span> <i>index</i>) const</h3>
<p>Returns the meta-data for the constructor with the given <i translate="no">index</i>.</p>
<p><b>See also </b><a href="qmetaobject.html#constructorCount" translate="no">constructorCount</a>() and <a href="qmetaobject-obsolete.html#newInstance" translate="no">newInstance</a>().</p>
<!-- @@@constructor -->
<!-- $$$constructorCount[overload1]$$$constructorCount -->
<h3 class="fn" translate="no" id="constructorCount"><span class="type">int</span> QMetaObject::<span class="name">constructorCount</span>() const</h3>
<p>Returns the number of constructors in this class.</p>
<p><b>See also </b><a href="qmetaobject.html#constructor" translate="no">constructor</a>() and <a href="qmetaobject.html#indexOfConstructor" translate="no">indexOfConstructor</a>().</p>
<!-- @@@constructorCount -->
<!-- $$$enumerator[overload1]$$$enumeratorint -->
<h3 class="fn" translate="no" id="enumerator"><span class="type"><a href="qmetaenum.html" translate="no">QMetaEnum</a></span> QMetaObject::<span class="name">enumerator</span>(<span class="type">int</span> <i>index</i>) const</h3>
<p>Returns the meta-data for the enumerator with the given <i translate="no">index</i>.</p>
<p><b>See also </b><a href="qmetaobject.html#enumeratorCount" translate="no">enumeratorCount</a>(), <a href="qmetaobject.html#enumeratorOffset" translate="no">enumeratorOffset</a>(), and <a href="qmetaobject.html#indexOfEnumerator" translate="no">indexOfEnumerator</a>().</p>
<!-- @@@enumerator -->
<!-- $$$enumeratorCount[overload1]$$$enumeratorCount -->
<h3 class="fn" translate="no" id="enumeratorCount"><span class="type">int</span> QMetaObject::<span class="name">enumeratorCount</span>() const</h3>
<p>Returns the number of enumerators in this class.</p>
<p><b>See also </b><a href="qmetaobject.html#enumerator" translate="no">enumerator</a>(), <a href="qmetaobject.html#enumeratorOffset" translate="no">enumeratorOffset</a>(), and <a href="qmetaobject.html#indexOfEnumerator" translate="no">indexOfEnumerator</a>().</p>
<!-- @@@enumeratorCount -->
<!-- $$$enumeratorOffset[overload1]$$$enumeratorOffset -->
<h3 class="fn" translate="no" id="enumeratorOffset"><span class="type">int</span> QMetaObject::<span class="name">enumeratorOffset</span>() const</h3>
<p>Returns the enumerator offset for this class; i.e. the index position of this class's first enumerator.</p>
<p>If the class has no superclasses with enumerators, the offset is 0; otherwise the offset is the sum of all the enumerators in the class's superclasses.</p>
<p><b>See also </b><a href="qmetaobject.html#enumerator" translate="no">enumerator</a>(), <a href="qmetaobject.html#enumeratorCount" translate="no">enumeratorCount</a>(), and <a href="qmetaobject.html#indexOfEnumerator" translate="no">indexOfEnumerator</a>().</p>
<!-- @@@enumeratorOffset -->
<!-- $$$indexOfClassInfo[overload1]$$$indexOfClassInfoconstchar* -->
<h3 class="fn" translate="no" id="indexOfClassInfo"><span class="type">int</span> QMetaObject::<span class="name">indexOfClassInfo</span>(const <span class="type">char</span> *<i>name</i>) const</h3>
<p>Finds class information item <i translate="no">name</i> and returns its index; otherwise returns -1.</p>
<p><b>See also </b><a href="qmetaobject.html#classInfo" translate="no">classInfo</a>(), <a href="qmetaobject.html#classInfoCount" translate="no">classInfoCount</a>(), and <a href="qmetaobject.html#classInfoOffset" translate="no">classInfoOffset</a>().</p>
<!-- @@@indexOfClassInfo -->
<!-- $$$indexOfConstructor[overload1]$$$indexOfConstructorconstchar* -->
<h3 class="fn" translate="no" id="indexOfConstructor"><span class="type">int</span> QMetaObject::<span class="name">indexOfConstructor</span>(const <span class="type">char</span> *<i>constructor</i>) const</h3>
<p>Finds <i translate="no">constructor</i> and returns its index; otherwise returns -1.</p>
<p>Note that the <i translate="no">constructor</i> has to be in normalized form, as returned by <a href="qmetaobject.html#normalizedSignature" translate="no">normalizedSignature</a>().</p>
<p><b>See also </b><a href="qmetaobject.html#constructor" translate="no">constructor</a>(), <a href="qmetaobject.html#constructorCount" translate="no">constructorCount</a>(), and <a href="qmetaobject.html#normalizedSignature" translate="no">normalizedSignature</a>().</p>
<!-- @@@indexOfConstructor -->
<!-- $$$indexOfEnumerator[overload1]$$$indexOfEnumeratorconstchar* -->
<h3 class="fn" translate="no" id="indexOfEnumerator"><span class="type">int</span> QMetaObject::<span class="name">indexOfEnumerator</span>(const <span class="type">char</span> *<i>name</i>) const</h3>
<p>Finds enumerator <i translate="no">name</i> and returns its index; otherwise returns -1.</p>
<p><b>See also </b><a href="qmetaobject.html#enumerator" translate="no">enumerator</a>(), <a href="qmetaobject.html#enumeratorCount" translate="no">enumeratorCount</a>(), and <a href="qmetaobject.html#enumeratorOffset" translate="no">enumeratorOffset</a>().</p>
<!-- @@@indexOfEnumerator -->
<!-- $$$indexOfMethod[overload1]$$$indexOfMethodconstchar* -->
<h3 class="fn" translate="no" id="indexOfMethod"><span class="type">int</span> QMetaObject::<span class="name">indexOfMethod</span>(const <span class="type">char</span> *<i>method</i>) const</h3>
<p>Finds <i translate="no">method</i> and returns its index; otherwise returns -1.</p>
<p>Note that the <i translate="no">method</i> has to be in normalized form, as returned by <a href="qmetaobject.html#normalizedSignature" translate="no">normalizedSignature</a>().</p>
<p><b>See also </b><a href="qmetaobject.html#method" translate="no">method</a>(), <a href="qmetaobject.html#methodCount" translate="no">methodCount</a>(), <a href="qmetaobject.html#methodOffset" translate="no">methodOffset</a>(), and <a href="qmetaobject.html#normalizedSignature" translate="no">normalizedSignature</a>().</p>
<!-- @@@indexOfMethod -->
<!-- $$$indexOfProperty[overload1]$$$indexOfPropertyconstchar* -->
<h3 class="fn" translate="no" id="indexOfProperty"><span class="type">int</span> QMetaObject::<span class="name">indexOfProperty</span>(const <span class="type">char</span> *<i>name</i>) const</h3>
<p>Finds property <i translate="no">name</i> and returns its index; otherwise returns -1.</p>
<p><b>See also </b><a href="qmetaobject.html#property" translate="no">property</a>(), <a href="qmetaobject.html#propertyCount" translate="no">propertyCount</a>(), and <a href="qmetaobject.html#propertyOffset" translate="no">propertyOffset</a>().</p>
<!-- @@@indexOfProperty -->
<!-- $$$indexOfSignal[overload1]$$$indexOfSignalconstchar* -->
<h3 class="fn" translate="no" id="indexOfSignal"><span class="type">int</span> QMetaObject::<span class="name">indexOfSignal</span>(const <span class="type">char</span> *<i>signal</i>) const</h3>
<p>Finds <i translate="no">signal</i> and returns its index; otherwise returns -1.</p>
<p>This is the same as <a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a>(), except that it will return -1 if the method exists but isn't a signal.</p>
<p>Note that the <i translate="no">signal</i> has to be in normalized form, as returned by <a href="qmetaobject.html#normalizedSignature" translate="no">normalizedSignature</a>().</p>
<p><b>See also </b><a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a>(), <a href="qmetaobject.html#normalizedSignature" translate="no">normalizedSignature</a>(), <a href="qmetaobject.html#method" translate="no">method</a>(), <a href="qmetaobject.html#methodCount" translate="no">methodCount</a>(), and <a href="qmetaobject.html#methodOffset" translate="no">methodOffset</a>().</p>
<!-- @@@indexOfSignal -->
<!-- $$$indexOfSlot[overload1]$$$indexOfSlotconstchar* -->
<h3 class="fn" translate="no" id="indexOfSlot"><span class="type">int</span> QMetaObject::<span class="name">indexOfSlot</span>(const <span class="type">char</span> *<i>slot</i>) const</h3>
<p>Finds <i translate="no">slot</i> and returns its index; otherwise returns -1.</p>
<p>This is the same as <a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a>(), except that it will return -1 if the method exists but isn't a slot.</p>
<p><b>See also </b><a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a>(), <a href="qmetaobject.html#method" translate="no">method</a>(), <a href="qmetaobject.html#methodCount" translate="no">methodCount</a>(), and <a href="qmetaobject.html#methodOffset" translate="no">methodOffset</a>().</p>
<!-- @@@indexOfSlot -->
<!-- $$$inherits[overload1]$$$inheritsconstQMetaObject* -->
<h3 class="fn" translate="no" id="inherits"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QMetaObject::<span class="name">inherits</span>(const <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span> *<i>metaObject</i>) const</h3>
<p>Returns <code translate="no">true</code> if the class described by this <a href="qmetaobject.html" translate="no">QMetaObject</a> inherits the type described by <i translate="no">metaObject</i>; otherwise returns false.</p>
<p>A type is considered to inherit itself.</p>
<!-- @@@inherits -->
<!-- $$$metaType[overload1]$$$metaType -->
<h3 class="fn" translate="no" id="metaType"><code class="details extra" translate="no">[since 6.2]</code> <span class="type"><a href="qmetatype.html" translate="no">QMetaType</a></span> QMetaObject::<span class="name">metaType</span>() const</h3>
<p>Returns the metatype corresponding to this metaobject. If the metaobject originates from a namespace, an invalid metatype is returned.</p>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@metaType -->
<!-- $$$method[overload1]$$$methodint -->
<h3 class="fn" translate="no" id="method"><span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> QMetaObject::<span class="name">method</span>(<span class="type">int</span> <i>index</i>) const</h3>
<p>Returns the meta-data for the method with the given <i translate="no">index</i>.</p>
<p><b>See also </b><a href="qmetaobject.html#methodCount" translate="no">methodCount</a>(), <a href="qmetaobject.html#methodOffset" translate="no">methodOffset</a>(), and <a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a>().</p>
<!-- @@@method -->
<!-- $$$methodCount[overload1]$$$methodCount -->
<h3 class="fn" translate="no" id="methodCount"><span class="type">int</span> QMetaObject::<span class="name">methodCount</span>() const</h3>
<p>Returns the number of methods in this class, including the number of methods provided by each base class. These include signals and slots as well as normal member functions.</p>
<p>Use code like the following to obtain a <a href="qstringlist.html" translate="no">QStringList</a> containing the methods specific to a given class:</p>
<pre class="cpp" translate="no">
 <span class="keyword">const</span> <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span><span class="operator">*</span> metaObject <span class="operator">=</span> obj<span class="operator">-</span><span class="operator">&gt;</span>metaObject();
 <span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> methods;
 <span class="keyword">for</span>(<span class="type">int</span> i <span class="operator">=</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>methodOffset(); i <span class="operator">&lt;</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>methodCount(); <span class="operator">+</span><span class="operator">+</span>i)
     methods <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">::</span>fromLatin1(metaObject<span class="operator">-</span><span class="operator">&gt;</span>method(i)<span class="operator">.</span>methodSignature());
</pre>
<p><b>See also </b><a href="qmetaobject.html#method" translate="no">method</a>(), <a href="qmetaobject.html#methodOffset" translate="no">methodOffset</a>(), and <a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a>().</p>
<!-- @@@methodCount -->
<!-- $$$methodOffset[overload1]$$$methodOffset -->
<h3 class="fn" translate="no" id="methodOffset"><span class="type">int</span> QMetaObject::<span class="name">methodOffset</span>() const</h3>
<p>Returns the method offset for this class; i.e. the index position of this class's first member function.</p>
<p>The offset is the sum of all the methods in the class's superclasses (which is always positive since <a href="qobject.html" translate="no">QObject</a> has the deleteLater() slot and a destroyed() signal).</p>
<p><b>See also </b><a href="qmetaobject.html#method" translate="no">method</a>(), <a href="qmetaobject.html#methodCount" translate="no">methodCount</a>(), and <a href="qmetaobject.html#indexOfMethod" translate="no">indexOfMethod</a>().</p>
<!-- @@@methodOffset -->
<!-- $$$newInstance$$$newInstanceArgs&&... -->
<h3 class="fn" translate="no" id="newInstance-1"><code class="details extra" translate="no">[since 6.5]</code> template &lt;typename... Args&gt; <span class="type"><a href="qobject.html" translate="no">QObject</a></span> *QMetaObject::<span class="name">newInstance</span>(<span class="type">Args</span> &amp;&amp;... <i>arguments</i>) const</h3>
<p>Constructs a new instance of this class and returns the new object, or <code translate="no">nullptr</code> if no suitable constructor is available. The types of the arguments <i translate="no">arguments</i> will be used to find a matching constructor, and then forwarded to it the same way signal-slot connections do.</p>
<p>Note that only constructors that are declared with the <a href="qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> modifier are made available through the meta-object system.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qmetaobject.html#constructor" translate="no">constructor</a>().</p>
<!-- @@@newInstance -->
<!-- $$$normalizedSignature[overload1]$$$normalizedSignatureconstchar* -->
<h3 class="fn" translate="no" id="normalizedSignature"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> QMetaObject::<span class="name">normalizedSignature</span>(const <span class="type">char</span> *<i>method</i>)</h3>
<p>Normalizes the signature of the given <i translate="no">method</i>.</p>
<p>Qt uses normalized signatures to decide whether two given signals and slots are compatible. Normalization reduces whitespace to a minimum, moves 'const' to the front where appropriate, removes 'const' from value types and replaces const references with values.</p>
<p><b>See also </b><a href="qmetaobject.html#checkConnectArgs" translate="no">checkConnectArgs</a>() and <a href="qmetaobject.html#normalizedType" translate="no">normalizedType</a>().</p>
<!-- @@@normalizedSignature -->
<!-- $$$normalizedType[overload1]$$$normalizedTypeconstchar* -->
<h3 class="fn" translate="no" id="normalizedType"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> QMetaObject::<span class="name">normalizedType</span>(const <span class="type">char</span> *<i>type</i>)</h3>
<p>Normalizes a <i translate="no">type</i>.</p>
<p>See <a href="qmetaobject.html#normalizedSignature" translate="no">QMetaObject::normalizedSignature</a>() for a description on how Qt normalizes.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> normType <span class="operator">=</span> <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span><span class="operator">::</span>normalizedType(<span class="string">&quot; int    const  *&quot;</span>);
 <span class="comment">// normType is now &quot;const int*&quot;</span>
</pre>
<p><b>See also </b><a href="qmetaobject.html#normalizedSignature" translate="no">normalizedSignature</a>().</p>
<!-- @@@normalizedType -->
<!-- $$$property[overload1]$$$propertyint -->
<h3 class="fn" translate="no" id="property"><span class="type"><a href="qmetaproperty.html" translate="no">QMetaProperty</a></span> QMetaObject::<span class="name">property</span>(<span class="type">int</span> <i>index</i>) const</h3>
<p>Returns the meta-data for the property with the given <i translate="no">index</i>. If no such property exists, a null <a href="qmetaproperty.html" translate="no">QMetaProperty</a> is returned.</p>
<p><b>See also </b><a href="qmetaobject.html#propertyCount" translate="no">propertyCount</a>(), <a href="qmetaobject.html#propertyOffset" translate="no">propertyOffset</a>(), and <a href="qmetaobject.html#indexOfProperty" translate="no">indexOfProperty</a>().</p>
<!-- @@@property -->
<!-- $$$propertyCount[overload1]$$$propertyCount -->
<h3 class="fn" translate="no" id="propertyCount"><span class="type">int</span> QMetaObject::<span class="name">propertyCount</span>() const</h3>
<p>Returns the number of properties in this class, including the number of properties provided by each base class.</p>
<p>Use code like the following to obtain a <a href="qstringlist.html" translate="no">QStringList</a> containing the properties specific to a given class:</p>
<pre class="cpp" translate="no">
 <span class="keyword">const</span> <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span><span class="operator">*</span> metaObject <span class="operator">=</span> obj<span class="operator">-</span><span class="operator">&gt;</span>metaObject();
 <span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> properties;
 <span class="keyword">for</span>(<span class="type">int</span> i <span class="operator">=</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>propertyOffset(); i <span class="operator">&lt;</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>propertyCount(); <span class="operator">+</span><span class="operator">+</span>i)
     properties <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">::</span>fromLatin1(metaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i)<span class="operator">.</span>name());
</pre>
<p><b>See also </b><a href="qmetaobject.html#property" translate="no">property</a>(), <a href="qmetaobject.html#propertyOffset" translate="no">propertyOffset</a>(), and <a href="qmetaobject.html#indexOfProperty" translate="no">indexOfProperty</a>().</p>
<!-- @@@propertyCount -->
<!-- $$$propertyOffset[overload1]$$$propertyOffset -->
<h3 class="fn" translate="no" id="propertyOffset"><span class="type">int</span> QMetaObject::<span class="name">propertyOffset</span>() const</h3>
<p>Returns the property offset for this class; i.e. the index position of this class's first property.</p>
<p>The offset is the sum of all the properties in the class's superclasses (which is always positive since <a href="qobject.html" translate="no">QObject</a> has the name() property).</p>
<p><b>See also </b><a href="qmetaobject.html#property" translate="no">property</a>(), <a href="qmetaobject.html#propertyCount" translate="no">propertyCount</a>(), and <a href="qmetaobject.html#indexOfProperty" translate="no">indexOfProperty</a>().</p>
<!-- @@@propertyOffset -->
<!-- $$$superClass[overload1]$$$superClass -->
<h3 class="fn" translate="no" id="superClass">const <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span> *QMetaObject::<span class="name">superClass</span>() const</h3>
<p>Returns the meta-object of the superclass, or <code translate="no">nullptr</code> if there is no such object.</p>
<p><b>See also </b><a href="qmetaobject.html#className" translate="no">className</a>().</p>
<!-- @@@superClass -->
<!-- $$$userProperty[overload1]$$$userProperty -->
<h3 class="fn" translate="no" id="userProperty"><span class="type"><a href="qmetaproperty.html" translate="no">QMetaProperty</a></span> QMetaObject::<span class="name">userProperty</span>() const</h3>
<p>Returns the property that has the <code translate="no">USER</code> flag set to true.</p>
<p><b>See also </b><a href="qmetaproperty.html#isUser" translate="no">QMetaProperty::isUser</a>().</p>
<!-- @@@userProperty -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$Q_ARG[overload1]$$$Q_ARGconstType& -->
<h3 class="fn" translate="no" id="Q_ARG"><span class="type">QMetaMethodArgument</span> <span class="name">Q_ARG</span>(<i>Type</i>, const <span class="type">Type</span> &amp;<i>value</i>)</h3>
<p>This macro takes a <i translate="no">Type</i> and a <i translate="no">value</i> of that type and returns a QMetaMethodArgument, which can be passed to the template <a href="qmetaobject.html#invokeMethod" translate="no">QMetaObject::invokeMethod</a>() with the <code translate="no">Args &amp;&amp;...</code> arguments.</p>
<p><b>See also </b><a href="qmetaobject.html#Q_RETURN_ARG" translate="no">Q_RETURN_ARG</a>().</p>
<!-- @@@Q_ARG -->
<!-- $$$Q_RETURN_ARG[overload1]$$$Q_RETURN_ARGType& -->
<h3 class="fn" translate="no" id="Q_RETURN_ARG"><span class="type">QMetaMethodReturnArgument</span> <span class="name">Q_RETURN_ARG</span>(<i>Type</i>, <span class="type">Type</span> &amp;<i>value</i>)</h3>
<p>This macro takes a <i translate="no">Type</i> and a non-const reference to a <i translate="no">value</i> of that type and returns a QMetaMethodReturnArgument, which can be passed to the template <a href="qmetaobject.html#invokeMethod" translate="no">QMetaObject::invokeMethod</a>() with the <code translate="no">Args &amp;&amp;...</code> arguments.</p>
<p><b>See also </b><a href="qmetaobject.html#Q_ARG" translate="no">Q_ARG</a>().</p>
<!-- @@@Q_RETURN_ARG -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
