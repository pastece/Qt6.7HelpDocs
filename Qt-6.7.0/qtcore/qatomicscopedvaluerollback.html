<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qatomicscopedvaluerollback.qdoc -->
  <meta name="description" content="Provides a QScopedValueRollback for atomic variables.">
  <title>QAtomicScopedValueRollback Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QAtomicScopedValueRollback</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QAtomicScopedValueRollback Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QAtomicScopedValueRollback</span>
<!-- $$$QAtomicScopedValueRollback-brief -->
<p>Provides a <a href="qscopedvaluerollback.html" translate="no">QScopedValueRollback</a> for atomic variables. <a href="#details">More...</a></p>
<!-- @@@QAtomicScopedValueRollback -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QAtomicScopedValueRollback&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.7</td></tr>
</table></div>
<ul>
<li><a href="qatomicscopedvaluerollback-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicscopedvaluerollback.html#QAtomicScopedValueRollback-2" translate="no">QAtomicScopedValueRollback</a></b>(std::atomic&lt;T&gt; &amp;<i>var</i>, std::memory_order <i>mo</i> = std::memory_order_seq_cst)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicscopedvaluerollback.html#QAtomicScopedValueRollback-3" translate="no">QAtomicScopedValueRollback</a></b>(std::atomic&lt;T&gt; &amp;<i>var</i>, T <i>value</i>, std::memory_order <i>mo</i> = std::memory_order_seq_cst)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicscopedvaluerollback.html#QAtomicScopedValueRollback-4" translate="no">QAtomicScopedValueRollback</a></b>(QBasicAtomicInteger&lt;T&gt; &amp;<i>var</i>, std::memory_order <i>mo</i> = std::memory_order_seq_cst)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicscopedvaluerollback.html#QAtomicScopedValueRollback-5" translate="no">QAtomicScopedValueRollback</a></b>(QBasicAtomicInteger&lt;T&gt; &amp;<i>var</i>, T <i>value</i>, std::memory_order <i>mo</i> = std::memory_order_seq_cst)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicscopedvaluerollback.html#QAtomicScopedValueRollback-6" translate="no">QAtomicScopedValueRollback</a></b>(QBasicAtomicPointer&lt;std::remove_pointer_t&lt;T&gt;&gt; &amp;<i>var</i>, std::memory_order <i>mo</i> = std::memory_order_seq_cst)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicscopedvaluerollback.html#QAtomicScopedValueRollback-7" translate="no">QAtomicScopedValueRollback</a></b>(QBasicAtomicPointer&lt;std::remove_pointer_t&lt;T&gt;&gt; &amp;<i>var</i>, T <i>value</i>, std::memory_order <i>mo</i> = std::memory_order_seq_cst)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicscopedvaluerollback.html#dtor.QAtomicScopedValueRollback" translate="no">~QAtomicScopedValueRollback</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qatomicscopedvaluerollback.html#commit" translate="no">commit</a></b>()</td></tr>
</table></div>
<!-- $$$QAtomicScopedValueRollback-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QAtomicScopedValueRollback class resets an atomic variable to its prior value on destruction. It can be used to revert state when an exception is thrown without the need to write try-catch blocks.</p>
<p>It can also be used to manage variables that are temporarily set, such as reentrancy guards. By using this class, the variable will be reset whether the function is exited normally, exited early by a return statement, or exited by an exception.</p>
<p>The class works on std::atomic and the Qt atomic classes: QBasicAtomicInteger, <a href="qatomicinteger.html" translate="no">QAtomicInteger</a>, <a href="qatomicint.html" translate="no">QAtomicInt</a>, QBasicAtomicPointer and <a href="qatomicpointer.html" translate="no">QAtomicPointer</a>.</p>
<span id="memory-order"></span><p>The memory accesses to the atomic variable <i translate="no">var</i> are specified using the value of <code translate="no">mo</code>. The memory order follows this mapping: <br />
</p>
<ul>
<li>When writing to the atomic variable:<ul>
<li>An acquire ordering performs a relaxed operation instead.</li>
<li>A hybrid acquire-release ordering performs a release operation instead.</li>
</ul>
</li>
<li>When reading from the atomic variable:<ul>
<li>A release ordering performs a relaxed operation instead.</li>
<li>A consume ordering performs a consume operation.</li>
<li>A hybrid acquire-release ordering performs an acquire operation instead.</li>
</ul>
</li>
</ul>
<p><br />
Otherwise, the default memory order is sequential consistent ordering.</p>
<div class="admonition note">
<p><b>Note: </b>You should never name the template arguments explicitly, but exclusively use Class Template Argument Deduction (CTAD) and let the compiler pick the template argument.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>There is a chance that other threads modify the variable too, which means you may lose updates performed by other threads between the call to the QAtomicScopedValueRollback constructor and <a href="qatomicscopedvaluerollback.html#commit" translate="no">commit</a>() or between <a href="qatomicscopedvaluerollback.html#commit" translate="no">commit</a>() and the destructor.</p>
</div>
</div>
<p><b>See also </b><a href="qscopedvaluerollback.html" translate="no">QScopedValueRollback</a>.</p>
<!-- @@@QAtomicScopedValueRollback -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="QAtomicScopedValueRollback-4"><code class="details extra" translate="no">[explicit constexpr]</code> QAtomicScopedValueRollback::<span class="name">QAtomicScopedValueRollback</span>(<span class="type">QBasicAtomicInteger</span>&lt;<span class="type">T</span>&gt; &amp;<i>var</i>, <span class="type">std::memory_order</span> <i>mo</i> = std::memory_order_seq_cst)</h3><h3 class="fn fngroupitem" translate="no" id="QAtomicScopedValueRollback-6"><code class="details extra" translate="no">[explicit constexpr]</code> QAtomicScopedValueRollback::<span class="name">QAtomicScopedValueRollback</span>(<span class="type">QBasicAtomicPointer</span>&lt;<span class="type">std::remove_pointer_t</span>&lt;<span class="type">T</span>&gt;&gt; &amp;<i>var</i>, <span class="type">std::memory_order</span> <i>mo</i> = std::memory_order_seq_cst)</h3><h3 class="fn fngroupitem" translate="no" id="QAtomicScopedValueRollback-2"><code class="details extra" translate="no">[explicit constexpr]</code> QAtomicScopedValueRollback::<span class="name">QAtomicScopedValueRollback</span>(<span class="type">std::atomic</span>&lt;<span class="type">T</span>&gt; &amp;<i>var</i>, <span class="type">std::memory_order</span> <i>mo</i> = std::memory_order_seq_cst)</h3></div>
<p>Records the value of <i translate="no">var</i> in order to restore it on destruction.</p>
<p>This is equivalent to:</p>
<pre class="cpp" translate="no">
 T old_value <span class="operator">=</span> var<span class="operator">.</span>load(mo);
 <span class="comment">// And in the destructor: var.store(old_value, mo);</span>
</pre>
<p>The <code translate="no">mo</code> adjustment for the load is described in the <a href="qatomicscopedvaluerollback.html#memory-order" translate="no">Memory Order</a> section.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="QAtomicScopedValueRollback-5"><code class="details extra" translate="no">[explicit constexpr]</code> QAtomicScopedValueRollback::<span class="name">QAtomicScopedValueRollback</span>(<span class="type">QBasicAtomicInteger</span>&lt;<span class="type">T</span>&gt; &amp;<i>var</i>, <span class="type">T</span> <i>value</i>, <span class="type">std::memory_order</span> <i>mo</i> = std::memory_order_seq_cst)</h3><h3 class="fn fngroupitem" translate="no" id="QAtomicScopedValueRollback-7"><code class="details extra" translate="no">[explicit constexpr]</code> QAtomicScopedValueRollback::<span class="name">QAtomicScopedValueRollback</span>(<span class="type">QBasicAtomicPointer</span>&lt;<span class="type">std::remove_pointer_t</span>&lt;<span class="type">T</span>&gt;&gt; &amp;<i>var</i>, <span class="type">T</span> <i>value</i>, <span class="type">std::memory_order</span> <i>mo</i> = std::memory_order_seq_cst)</h3><h3 class="fn fngroupitem" translate="no" id="QAtomicScopedValueRollback-3"><code class="details extra" translate="no">[explicit constexpr]</code> QAtomicScopedValueRollback::<span class="name">QAtomicScopedValueRollback</span>(<span class="type">std::atomic</span>&lt;<span class="type">T</span>&gt; &amp;<i>var</i>, <span class="type">T</span> <i>value</i>, <span class="type">std::memory_order</span> <i>mo</i> = std::memory_order_seq_cst)</h3></div>
<p>Assigns <i translate="no">value</i> to <i translate="no">var</i> and stores the prior value of <i translate="no">var</i> internally for reverting on destruction.</p>
<p>This is equivalent to:</p>
<pre class="cpp" translate="no">
 T old_value <span class="operator">=</span> var<span class="operator">.</span>exchange(new_value<span class="operator">,</span> mo);
 <span class="comment">// And in the destructor: var.store(old_value, mo);</span>
</pre>
<!-- @@@ -->
<!-- $$$~QAtomicScopedValueRollback[overload1]$$$~QAtomicScopedValueRollback -->
<h3 class="fn" translate="no" id="dtor.QAtomicScopedValueRollback">QAtomicScopedValueRollback::<span class="name">~QAtomicScopedValueRollback</span>()</h3>
<p>Restores the stored value that was current at construction time, or at the last call to <a href="qatomicscopedvaluerollback.html#commit" translate="no">commit</a>(), to the managed variable.</p>
<p>This is equivalent to:</p>
<pre class="cpp" translate="no">
 <span class="comment">// In the constructor: T old_value = var.load(mo);</span>
 <span class="comment">// or: T old_value = exchange(new_value, mo);</span>
 var<span class="operator">.</span>store(old_value<span class="operator">,</span> mo);
</pre>
<p>Where <code translate="no">mo</code> is the same as the one initially passed to the constructor. See <a href="qatomicscopedvaluerollback.html#memory-order" translate="no">Memory Order</a> for the meaning of <code translate="no">mo</code>.</p>
<!-- @@@~QAtomicScopedValueRollback -->
<!-- $$$commit[overload1]$$$commit -->
<h3 class="fn" translate="no" id="commit"><code class="details extra" translate="no">[constexpr]</code> <span class="type">void</span> QAtomicScopedValueRollback::<span class="name">commit</span>()</h3>
<p>Updates the stored value to the managed variable's current value, loaded with the same memory order as on construction.</p>
<p>This updated value will be restored on destruction, instead of the original prior value.</p>
<p>This is equivalent to:</p>
<pre class="cpp" translate="no">
 <span class="comment">// Given constructor: T old_value = var.load(mo);</span>
 old_value <span class="operator">=</span> var<span class="operator">.</span>load(mo);  <span class="comment">// referesh it</span>
 <span class="comment">// And, in the destructor: var.store(old_value, mo);</span>
</pre>
<p>Where <code translate="no">mo</code> is the same as the one initially passed to the constructor. See <a href="qatomicscopedvaluerollback.html#memory-order" translate="no">Memory Order</a> for the meaning of <code translate="no">mo</code>.</p>
<!-- @@@commit -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
