<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qnumeric.cpp -->
  <meta name="description" content="The &lt;QtNumeric&gt; header file provides common numeric functions.">
  <title>&lt;QtNumeric&gt; - Qt Numeric Functions | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li>&lt;QtNumeric&gt; - Qt Numeric Functions</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">&lt;QtNumeric&gt; - Qt Numeric Functions</h1>
<!-- $$$<QtNumeric>-brief -->
<p>The &lt;QtNumeric&gt; header file provides common numeric functions. <a href="#details">More...</a></p>
<!-- @@@<QtNumeric> -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QtNumeric&gt;</span></td></tr>
</table></div>
<h2 id="functions">Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qAbs" translate="no">qAbs</a></b>(const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> typename std::enable_if_t&lt;std::is_unsigned_v&lt;T&gt; || std::is_signed_v&lt;T&gt;, bool&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qAddOverflow" translate="no">qAddOverflow</a></b>(T <i>v1</i>, T <i>v2</i>, T *<i>result</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint32 </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qFloatDistance" translate="no">qFloatDistance</a></b>(float <i>a</i>, float <i>b</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qFloatDistance-1" translate="no">qFloatDistance</a></b>(double <i>a</i>, double <i>b</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qFpClassify" translate="no">qFpClassify</a></b>(double <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qFpClassify-2" translate="no">qFpClassify</a></b>(float <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qFuzzyCompare" translate="no">qFuzzyCompare</a></b>(double <i>p1</i>, double <i>p2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qFuzzyCompare-2" translate="no">qFuzzyCompare</a></b>(float <i>p1</i>, float <i>p2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qFuzzyIsNull" translate="no">qFuzzyIsNull</a></b>(double <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qFuzzyIsNull-1" translate="no">qFuzzyIsNull</a></b>(float <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qInf" translate="no">qInf</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qIsFinite" translate="no">qIsFinite</a></b>(double <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qIsFinite-1" translate="no">qIsFinite</a></b>(float <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qIsInf" translate="no">qIsInf</a></b>(double <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qIsInf-1" translate="no">qIsInf</a></b>(float <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qIsNaN" translate="no">qIsNaN</a></b>(double <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qIsNaN-1" translate="no">qIsNaN</a></b>(float <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> typename std::enable_if_t&lt;std::is_unsigned_v&lt;T&gt; || std::is_signed_v&lt;T&gt;, bool&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qMulOverflow" translate="no">qMulOverflow</a></b>(T <i>v1</i>, T <i>v2</i>, T *<i>result</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qQNaN" translate="no">qQNaN</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qRound64" translate="no">qRound64</a></b>(double <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qRound64-2" translate="no">qRound64</a></b>(float <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qRound" translate="no">qRound</a></b>(double <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qRound-2" translate="no">qRound</a></b>(float <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qSNaN" translate="no">qSNaN</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> typename std::enable_if_t&lt;std::is_unsigned_v&lt;T&gt; || std::is_signed_v&lt;T&gt;, bool&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtnumeric.html#qSubOverflow" translate="no">qSubOverflow</a></b>(T <i>v1</i>, T <i>v2</i>, T *<i>result</i>)</td></tr>
</table></div>
<!-- $$$<QtNumeric>-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The &lt;QtNumeric&gt; header file contains various numeric functions for comparing and adjusting a numeric value.</p>
</div>
<!-- @@@<QtNumeric> -->
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="qFpClassify"><span class="type">int</span> <span class="name">qFpClassify</span>(<span class="type">double</span> <i>val</i>)</h3><h3 class="fn fngroupitem" translate="no" id="qFpClassify-2"><span class="type">int</span> <span class="name">qFpClassify</span>(<span class="type">float</span> <i>val</i>)</h3></div>
<p>Classifies a floating-point value.</p>
<p>The return values are defined in <code translate="no">&lt;cmath&gt;</code>: returns one of the following, determined by the floating-point class of <i translate="no">val</i>:</p>
<ul>
<li>FP_NAN not a number</li>
<li>FP_INFINITE infinities (positive or negative)</li>
<li>FP_ZERO zero (positive or negative)</li>
<li>FP_NORMAL finite with a full mantissa</li>
<li>FP_SUBNORMAL finite with a reduced mantissa</li>
</ul>
<!-- @@@ -->
<!-- $$$qAbs[overload1]$$$qAbsconstT& -->
<h3 class="fn" translate="no" id="qAbs"><code class="details extra" translate="no">[constexpr]</code> template &lt;typename T&gt; <span class="type">T</span> <span class="name">qAbs</span>(const <span class="type">T</span> &amp;<i>t</i>)</h3>
<p>Compares <i translate="no">t</i> to the 0 of type T and returns the absolute value. Thus if T is <i>double</i>, then <i translate="no">t</i> is compared to <i>(double) 0</i>.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> absoluteValue;
 <span class="type">int</span> myValue <span class="operator">=</span> <span class="operator">-</span><span class="number">4</span>;

 absoluteValue <span class="operator">=</span> qAbs(myValue);
 <span class="comment">// absoluteValue == 4</span>
</pre>
<!-- @@@qAbs -->
<!-- $$$qAddOverflow[overload1]$$$qAddOverflowTTT* -->
<h3 class="fn" translate="no" id="qAddOverflow"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename T&gt; <span class="type">typename</span> <span class="type">std::enable_if_t</span>&lt;<span class="type">std::is_unsigned_v</span>&lt;<span class="type">T</span>&gt; || <span class="type">std::is_signed_v</span>&lt;<span class="type">T</span>&gt;, <span class="type">bool</span>&gt; <span class="name">qAddOverflow</span>(<span class="type">T</span> <i>v1</i>, <span class="type">T</span> <i>v2</i>, <span class="type">T</span> *<i>result</i>)</h3>
<p>Adds two values <i translate="no">v1</i> and <i translate="no">v2</i>, of a numeric type <code translate="no">T</code> and records the value in <i translate="no">result</i>. If the addition overflows the valid range for type <code translate="no">T</code>, returns <code translate="no">true</code>, otherwise returns <code translate="no">false</code>.</p>
<p>An implementation is guaranteed to be available for 8-, 16-, and 32-bit integer types, as well as integer types of the size of a pointer. Overflow math for other types, if available, is considered private API.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@qAddOverflow -->
<!-- $$$qFloatDistance[overload1]$$$qFloatDistancefloatfloat -->
<h3 class="fn" translate="no" id="qFloatDistance"><span class="type"><a href="qttypes.html#quint32-typedef" translate="no">quint32</a></span> <span class="name">qFloatDistance</span>(<span class="type">float</span> <i>a</i>, <span class="type">float</span> <i>b</i>)</h3>
<p>Returns the number of representable floating-point numbers between <i translate="no">a</i> and <i translate="no">b</i>.</p>
<p>This function provides an alternative way of doing approximated comparisons of floating-point numbers similar to <a href="qtnumeric.html#qFuzzyCompare" translate="no">qFuzzyCompare</a>(). However, it returns the distance between two numbers, which gives the caller a possibility to choose the accepted error. Errors are relative, so for instance the distance between 1.0E-5 and 1.00001E-5 will give 110, while the distance between 1.0E36 and 1.00001E36 will give 127.</p>
<p>This function is useful if a floating point comparison requires a certain precision. Therefore, if <i translate="no">a</i> and <i translate="no">b</i> are equal it will return 0. The maximum value it will return for 32-bit floating point numbers is 4,278,190,078. This is the distance between <code translate="no">-FLT_MAX</code> and <code translate="no">+FLT_MAX</code>.</p>
<p>The function does not give meaningful results if any of the arguments are <code translate="no">Infinite</code> or <code translate="no">NaN</code>. You can check for this by calling <a href="qtnumeric.html#qIsFinite" translate="no">qIsFinite</a>().</p>
<p>The return value can be considered as the &quot;error&quot;, so if you for instance want to compare two 32-bit floating point numbers and all you need is an approximated 24-bit precision, you can use this function like this:</p>
<pre class="cpp" translate="no">
     <span class="keyword">if</span> (qFloatDistance(a<span class="operator">,</span> b) <span class="operator">&lt;</span> (<span class="number">1</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">7</span>)) {   <span class="comment">// The last 7 bits are not</span>
                                             <span class="comment">// significant</span>
         <span class="comment">// precise enough</span>
     }
</pre>
<p><b>See also </b><a href="qtnumeric.html#qFuzzyCompare" translate="no">qFuzzyCompare</a>().</p>
<!-- @@@qFloatDistance -->
<!-- $$$qFloatDistance$$$qFloatDistancedoubledouble -->
<h3 class="fn" translate="no" id="qFloatDistance-1"><span class="type"><a href="qttypes.html#quint64-typedef" translate="no">quint64</a></span> <span class="name">qFloatDistance</span>(<span class="type">double</span> <i>a</i>, <span class="type">double</span> <i>b</i>)</h3>
<p>Returns the number of representable floating-point numbers between <i translate="no">a</i> and <i translate="no">b</i>.</p>
<p>This function serves the same purpose as <code translate="no">qFloatDistance(float, float)</code>, but returns the distance between two <code translate="no">double</code> numbers. Since the range is larger than for two <code translate="no">float</code> numbers (<code translate="no">[-DBL_MAX,DBL_MAX]</code>), the return type is quint64.</p>
<p><b>See also </b><a href="qtnumeric.html#qFuzzyCompare" translate="no">qFuzzyCompare</a>().</p>
<!-- @@@qFloatDistance -->
<!-- $$$qFpClassify[overload1]$$$qFpClassifydouble -->
<h3 class="fn" translate="no" id="qFpClassify"><span class="type">int</span> <span class="name">qFpClassify</span>(<span class="type">double</span> <i>val</i>)</h3>
<!-- @@@qFpClassify -->
<!-- $$$qFpClassify$$$qFpClassifyfloat -->
<h3 class="fn" translate="no" id="qFpClassify-2"><span class="type">int</span> <span class="name">qFpClassify</span>(<span class="type">float</span> <i>val</i>)</h3>
<!-- @@@qFpClassify -->
<!-- $$$qFuzzyCompare[overload1]$$$qFuzzyComparedoubledouble -->
<h3 class="fn" translate="no" id="qFuzzyCompare"><code class="details extra" translate="no">[constexpr]</code> <span class="type">bool</span> <span class="name">qFuzzyCompare</span>(<span class="type">double</span> <i>p1</i>, <span class="type">double</span> <i>p2</i>)</h3>
<p>Compares the floating point value <i translate="no">p1</i> and <i translate="no">p2</i> and returns <code translate="no">true</code> if they are considered equal, otherwise <code translate="no">false</code>.</p>
<p>Note that comparing values where either <i translate="no">p1</i> or <i translate="no">p2</i> is 0.0 will not work, nor does comparing values where one of the values is NaN or infinity. If one of the values is always 0.0, use <a href="qtnumeric.html#qFuzzyIsNull" translate="no">qFuzzyIsNull</a> instead. If one of the values is likely to be 0.0, one solution is to add 1.0 to both values.</p>
<pre class="cpp" translate="no">
 <span class="comment">// Instead of comparing with 0.0</span>
 qFuzzyCompare(<span class="number">0.0</span><span class="operator">,</span> <span class="number">1.0e</span><span class="operator">-</span><span class="number">200</span>); <span class="comment">// This will return false</span>
 <span class="comment">// Compare adding 1 to both values will fix the problem</span>
 qFuzzyCompare(<span class="number">1</span> <span class="operator">+</span> <span class="number">0.0</span><span class="operator">,</span> <span class="number">1</span> <span class="operator">+</span> <span class="number">1.0e</span><span class="operator">-</span><span class="number">200</span>); <span class="comment">// This will return true</span>
</pre>
<p>The two numbers are compared in a relative way, where the exactness is stronger the smaller the numbers are.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@qFuzzyCompare -->
<!-- $$$qFuzzyCompare$$$qFuzzyComparefloatfloat -->
<h3 class="fn" translate="no" id="qFuzzyCompare-2"><code class="details extra" translate="no">[constexpr]</code> <span class="type">bool</span> <span class="name">qFuzzyCompare</span>(<span class="type">float</span> <i>p1</i>, <span class="type">float</span> <i>p2</i>)</h3>
<p>Compares the floating point value <i translate="no">p1</i> and <i translate="no">p2</i> and returns <code translate="no">true</code> if they are considered equal, otherwise <code translate="no">false</code>.</p>
<p>The two numbers are compared in a relative way, where the exactness is stronger the smaller the numbers are.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@qFuzzyCompare -->
<!-- $$$qFuzzyIsNull[overload1]$$$qFuzzyIsNulldouble -->
<h3 class="fn" translate="no" id="qFuzzyIsNull"><code class="details extra" translate="no">[constexpr]</code> <span class="type">bool</span> <span class="name">qFuzzyIsNull</span>(<span class="type">double</span> <i>d</i>)</h3>
<p>Returns true if the absolute value of <i translate="no">d</i> is within 0.000000000001 of 0.0.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@qFuzzyIsNull -->
<!-- $$$qFuzzyIsNull$$$qFuzzyIsNullfloat -->
<h3 class="fn" translate="no" id="qFuzzyIsNull-1"><code class="details extra" translate="no">[constexpr]</code> <span class="type">bool</span> <span class="name">qFuzzyIsNull</span>(<span class="type">float</span> <i>f</i>)</h3>
<p>Returns true if the absolute value of <i translate="no">f</i> is within 0.00001f of 0.0.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@qFuzzyIsNull -->
<!-- $$$qInf[overload1]$$$qInf -->
<h3 class="fn" translate="no" id="qInf"><span class="type">double</span> <span class="name">qInf</span>()</h3>
<p>Returns the bit pattern for an infinite number as a double.</p>
<p><b>See also </b><a href="qtnumeric.html#qIsInf" translate="no">qIsInf</a>().</p>
<!-- @@@qInf -->
<!-- $$$qIsFinite[overload1]$$$qIsFinitedouble -->
<h3 class="fn" translate="no" id="qIsFinite"><span class="type">bool</span> <span class="name">qIsFinite</span>(<span class="type">double</span> <i>d</i>)</h3>
<p>Returns <code translate="no">true</code> if the double <i translate="no">d</i> is a finite number.</p>
<!-- @@@qIsFinite -->
<!-- $$$qIsFinite$$$qIsFinitefloat -->
<h3 class="fn" translate="no" id="qIsFinite-1"><span class="type">bool</span> <span class="name">qIsFinite</span>(<span class="type">float</span> <i>f</i>)</h3>
<p>Returns <code translate="no">true</code> if the float <i translate="no">f</i> is a finite number.</p>
<!-- @@@qIsFinite -->
<!-- $$$qIsInf[overload1]$$$qIsInfdouble -->
<h3 class="fn" translate="no" id="qIsInf"><span class="type">bool</span> <span class="name">qIsInf</span>(<span class="type">double</span> <i>d</i>)</h3>
<p>Returns <code translate="no">true</code> if the double <i translate="no">d</i> is equivalent to infinity.</p>
<p><b>See also </b><a href="qtnumeric.html#qInf" translate="no">qInf</a>().</p>
<!-- @@@qIsInf -->
<!-- $$$qIsInf$$$qIsInffloat -->
<h3 class="fn" translate="no" id="qIsInf-1"><span class="type">bool</span> <span class="name">qIsInf</span>(<span class="type">float</span> <i>f</i>)</h3>
<p>Returns <code translate="no">true</code> if the float <i translate="no">f</i> is equivalent to infinity.</p>
<p><b>See also </b><a href="qtnumeric.html#qInf" translate="no">qInf</a>().</p>
<!-- @@@qIsInf -->
<!-- $$$qIsNaN[overload1]$$$qIsNaNdouble -->
<h3 class="fn" translate="no" id="qIsNaN"><span class="type">bool</span> <span class="name">qIsNaN</span>(<span class="type">double</span> <i>d</i>)</h3>
<p>Returns <code translate="no">true</code> if the double <i translate="no">d</i> is not a number (NaN).</p>
<!-- @@@qIsNaN -->
<!-- $$$qIsNaN$$$qIsNaNfloat -->
<h3 class="fn" translate="no" id="qIsNaN-1"><span class="type">bool</span> <span class="name">qIsNaN</span>(<span class="type">float</span> <i>f</i>)</h3>
<p>Returns <code translate="no">true</code> if the float <i translate="no">f</i> is not a number (NaN).</p>
<!-- @@@qIsNaN -->
<!-- $$$qMulOverflow[overload1]$$$qMulOverflowTTT* -->
<h3 class="fn" translate="no" id="qMulOverflow"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename T&gt; <span class="type">typename</span> <span class="type">std::enable_if_t</span>&lt;<span class="type">std::is_unsigned_v</span>&lt;<span class="type">T</span>&gt; || <span class="type">std::is_signed_v</span>&lt;<span class="type">T</span>&gt;, <span class="type">bool</span>&gt; <span class="name">qMulOverflow</span>(<span class="type">T</span> <i>v1</i>, <span class="type">T</span> <i>v2</i>, <span class="type">T</span> *<i>result</i>)</h3>
<p>Multiplies <i translate="no">v1</i> and <i translate="no">v2</i>, and records the resulting value in <i translate="no">result</i>. If the multiplication overflows the valid range for type <code translate="no">T</code>, returns <code translate="no">true</code>, otherwise returns <code translate="no">false</code>.</p>
<p>An implementation is guaranteed to be available for 8-, 16-, and 32-bit integer types, as well as integer types of the size of a pointer. Overflow math for other types, if available, is considered private API.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@qMulOverflow -->
<!-- $$$qQNaN[overload1]$$$qQNaN -->
<h3 class="fn" translate="no" id="qQNaN"><span class="type">double</span> <span class="name">qQNaN</span>()</h3>
<p>Returns the bit pattern of a quiet NaN as a double.</p>
<p><b>See also </b><a href="qtnumeric.html#qIsNaN" translate="no">qIsNaN</a>().</p>
<!-- @@@qQNaN -->
<!-- $$$qRound64[overload1]$$$qRound64double -->
<h3 class="fn" translate="no" id="qRound64"><code class="details extra" translate="no">[constexpr]</code> <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <span class="name">qRound64</span>(<span class="type">double</span> <i>d</i>)</h3>
<p>Rounds <i translate="no">d</i> to the nearest 64-bit integer.</p>
<p>Rounds half away from zero (e.g. 0.5 -&gt; 1, -0.5 -&gt; -1).</p>
<div class="admonition note">
<p><b>Note: </b>This function does not guarantee correctness for high precisions.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">double</span> valueA <span class="operator">=</span> <span class="number">42949672960.3</span>;
 <span class="type">double</span> valueB <span class="operator">=</span> <span class="number">42949672960.7</span>;

 <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> roundedValueA <span class="operator">=</span> qRound64(valueA);
 <span class="comment">// roundedValueA = 42949672960</span>
 <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> roundedValueB <span class="operator">=</span> qRound64(valueB);
 <span class="comment">// roundedValueB = 42949672961</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>If the value <i translate="no">d</i> is outside the range of <code translate="no">qint64</code>, the behavior is undefined.</p>
</div>
<!-- @@@qRound64 -->
<!-- $$$qRound64$$$qRound64float -->
<h3 class="fn" translate="no" id="qRound64-2"><code class="details extra" translate="no">[constexpr]</code> <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <span class="name">qRound64</span>(<span class="type">float</span> <i>d</i>)</h3>
<p>Rounds <i translate="no">d</i> to the nearest 64-bit integer.</p>
<p>Rounds half away from zero (e.g. 0.5f -&gt; 1, -0.5f -&gt; -1).</p>
<div class="admonition note">
<p><b>Note: </b>This function does not guarantee correctness for high precisions.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">float</span> valueA <span class="operator">=</span> <span class="number">42949672960.3</span>;
 <span class="type">float</span> valueB <span class="operator">=</span> <span class="number">42949672960.7</span>;

 <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> roundedValueA <span class="operator">=</span> qRound64(valueA);
 <span class="comment">// roundedValueA = 42949672960</span>
 <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> roundedValueB <span class="operator">=</span> qRound64(valueB);
 <span class="comment">// roundedValueB = 42949672961</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>If the value <i translate="no">d</i> is outside the range of <code translate="no">qint64</code>, the behavior is undefined.</p>
</div>
<!-- @@@qRound64 -->
<!-- $$$qRound[overload1]$$$qRounddouble -->
<h3 class="fn" translate="no" id="qRound"><code class="details extra" translate="no">[constexpr]</code> <span class="type">int</span> <span class="name">qRound</span>(<span class="type">double</span> <i>d</i>)</h3>
<p>Rounds <i translate="no">d</i> to the nearest integer.</p>
<p>Rounds half away from zero (e.g. 0.5 -&gt; 1, -0.5 -&gt; -1).</p>
<div class="admonition note">
<p><b>Note: </b>This function does not guarantee correctness for high precisions.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">double</span> valueA <span class="operator">=</span> <span class="number">2.3</span>;
 <span class="type">double</span> valueB <span class="operator">=</span> <span class="number">2.7</span>;

 <span class="type">int</span> roundedValueA <span class="operator">=</span> qRound(valueA);
 <span class="comment">// roundedValueA = 2</span>
 <span class="type">int</span> roundedValueB <span class="operator">=</span> qRound(valueB);
 <span class="comment">// roundedValueB = 3</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>If the value <i translate="no">d</i> is outside the range of <code translate="no">int</code>, the behavior is undefined.</p>
</div>
<!-- @@@qRound -->
<!-- $$$qRound$$$qRoundfloat -->
<h3 class="fn" translate="no" id="qRound-2"><code class="details extra" translate="no">[constexpr]</code> <span class="type">int</span> <span class="name">qRound</span>(<span class="type">float</span> <i>d</i>)</h3>
<p>Rounds <i translate="no">d</i> to the nearest integer.</p>
<p>Rounds half away from zero (e.g. 0.5f -&gt; 1, -0.5f -&gt; -1).</p>
<div class="admonition note">
<p><b>Note: </b>This function does not guarantee correctness for high precisions.</p>
</div>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">float</span> valueA <span class="operator">=</span> <span class="number">2.3</span>;
 <span class="type">float</span> valueB <span class="operator">=</span> <span class="number">2.7</span>;

 <span class="type">int</span> roundedValueA <span class="operator">=</span> <a href="qtnumeric.html#qRound" translate="no">qRound</a>(valueA);
 <span class="comment">// roundedValueA = 2</span>
 <span class="type">int</span> roundedValueB <span class="operator">=</span> <a href="qtnumeric.html#qRound" translate="no">qRound</a>(valueB);
 <span class="comment">// roundedValueB = 3</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>If the value <i translate="no">d</i> is outside the range of <code translate="no">int</code>, the behavior is undefined.</p>
</div>
<!-- @@@qRound -->
<!-- $$$qSNaN[overload1]$$$qSNaN -->
<h3 class="fn" translate="no" id="qSNaN"><span class="type">double</span> <span class="name">qSNaN</span>()</h3>
<p>Returns the bit pattern of a signalling NaN as a double.</p>
<!-- @@@qSNaN -->
<!-- $$$qSubOverflow[overload1]$$$qSubOverflowTTT* -->
<h3 class="fn" translate="no" id="qSubOverflow"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename T&gt; <span class="type">typename</span> <span class="type">std::enable_if_t</span>&lt;<span class="type">std::is_unsigned_v</span>&lt;<span class="type">T</span>&gt; || <span class="type">std::is_signed_v</span>&lt;<span class="type">T</span>&gt;, <span class="type">bool</span>&gt; <span class="name">qSubOverflow</span>(<span class="type">T</span> <i>v1</i>, <span class="type">T</span> <i>v2</i>, <span class="type">T</span> *<i>result</i>)</h3>
<p>Subtracts <i translate="no">v2</i> from <i translate="no">v1</i> and records the resulting value in <i translate="no">result</i>. If the subtraction overflows the valid range for type <code translate="no">T</code>, returns <code translate="no">true</code>, otherwise returns <code translate="no">false</code>.</p>
<p>An implementation is guaranteed to be available for 8-, 16-, and 32-bit integer types, as well as integer types of the size of a pointer. Overflow math for other types, if available, is considered private API.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@qSubOverflow -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
