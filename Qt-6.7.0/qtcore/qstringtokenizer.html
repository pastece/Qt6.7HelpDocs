<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qstringtokenizer.cpp -->
  <meta name="description" content="The QStringTokenizer class splits strings into tokens along given separators.">
  <title>QStringTokenizer Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QStringTokenizer</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#lazy-sequences">Lazy Sequences</a></li>
<li class="level2"><a href="#end-sentinel">End Sentinel</a></li>
<li class="level2"><a href="#temporaries">Temporaries</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QStringTokenizer Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename Haystack, typename Needle&gt; class QStringTokenizer</span>
<!-- $$$QStringTokenizer-brief -->
<p>The QStringTokenizer class splits strings into tokens along given separators. <a href="#details">More...</a></p>
<!-- @@@QStringTokenizer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QStringTokenizer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> QtPrivate::Tok::HaystackPinning (private), QtPrivate::Tok::NeedlePinning (private), and </td></tr>
</table></div>
<ul>
<li><a href="qstringtokenizer-members.html">List of all members, including inherited members</a></li>
<li>QStringTokenizer is part of <a href="../qtdoc/string-processing.html">Classes for String Data</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#const_iterator-typedef" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#const_pointer-typedef" translate="no">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#const_reference-typedef" translate="no">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#iterator-typedef" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#pointer-typedef" translate="no">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#reference-typedef" translate="no">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#sentinel-typedef" translate="no">sentinel</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#value_type-typedef" translate="no">value_type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></b>(Haystack <i>haystack</i>, Needle <i>needle</i>, Qt::CaseSensitivity <i>cs</i>, Qt::SplitBehavior <i>sb</i> = Qt::KeepEmptyParts)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#QStringTokenizer-1" translate="no">QStringTokenizer</a></b>(Haystack <i>haystack</i>, Needle <i>needle</i>, Qt::SplitBehavior <i>sb</i> = Qt::KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringTokenizer&lt;Haystack, Needle&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#begin" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringTokenizer&lt;Haystack, Needle&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringTokenizer&lt;Haystack, Needle&gt;::sentinel </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringTokenizer&lt;Haystack, Needle&gt;::sentinel </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#end" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> LContainer </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#toContainer" translate="no">toContainer</a></b>(LContainer &amp;&amp;<i>c</i> = {}) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> RContainer </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#toContainer-1" translate="no">toContainer</a></b>(RContainer &amp;&amp;<i>c</i> = {}) const &&</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> decltype(QtPrivate::Tok::TokenizerResult&lt;Haystack, Needle&gt;{std::forward&lt;Haystack&gt;(h), std::forward&lt;Needle&gt;(n), flags...}) </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#qTokenize" translate="no">qTokenize</a></b>(Haystack &amp;&amp;<i>haystack</i>, Needle &amp;&amp;<i>needle</i>, Flags... <i>flags</i>)</td></tr>
</table></div>
<!-- $$$QStringTokenizer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Splits a string into substrings wherever a given separator occurs, returning a (lazily constructed) list of those strings. If the separator does not match anywhere in the string, produces a single-element list containing this string. If the separator is empty, QStringTokenizer produces an empty string, followed by each of the string's characters, followed by another empty string. The two enumerations <a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SplitBehavior</a> and <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a> further control the output.</p>
<p>QStringTokenizer drives <a href="qstringview.html#tokenize" translate="no">QStringView::tokenize</a>(), but, at least with a recent compiler, you can use it directly, too:</p>
<pre class="cpp" translate="no">
 <span class="keyword">for</span> (<span class="keyword">auto</span> it : <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>{string<span class="operator">,</span> separator})
     use(<span class="operator">*</span>it);
</pre>
<div class="admonition note">
<p><b>Note: </b>You should never, ever, name the template arguments of a QStringTokenizer explicitly. If you can use C++17 Class Template Argument Deduction (CTAD), you may write <code translate="no">QStringTokenizer{string, separator}</code> (without template arguments). If you can't use C++17 CTAD, you must use the <a href="qstringview.html#split" translate="no">QStringView::split</a>() or QLatin1StringView::split() member functions and store the return value only in <code translate="no">auto</code> variables:</p>
</div>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> result <span class="operator">=</span> string<span class="operator">.</span>split(sep);
</pre>
<p>This is because the template arguments of QStringTokenizer have a very subtle dependency on the specific string and separator types from with which they are constructed, and they don't usually correspond to the actual types passed.</p>
<h3 id="lazy-sequences">Lazy Sequences</h3>
<p>QStringTokenizer acts as a so-called lazy sequence, that is, each next element is only computed once you ask for it. Lazy sequences have the advantage that they only require O(1) memory. They have the disadvantage that, at least for QStringTokenizer, they only allow forward, not random-access, iteration.</p>
<p>The intended use-case is that you just plug it into a ranged for loop:</p>
<pre class="cpp" translate="no">
 <span class="keyword">for</span> (<span class="keyword">auto</span> it : <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>{string<span class="operator">,</span> separator})
     use(<span class="operator">*</span>it);
</pre>
<p>or a C++20 ranged algorithm:</p>
<pre class="cpp" translate="no">
 std<span class="operator">::</span>ranges<span class="operator">::</span>for_each(<span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>{string<span class="operator">,</span> separator}<span class="operator">,</span>
                       <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">auto</span> token) { use(token); });
</pre>
<h3 id="end-sentinel">End Sentinel</h3>
<p>The QStringTokenizer iterators cannot be used with classical STL algorithms, because those require iterator/iterator pairs, while QStringTokenizer uses sentinels. That is, it uses a different type, <a href="qstringtokenizer.html#sentinel-typedef" translate="no">QStringTokenizer::sentinel</a>, to mark the end of the range. This improves performance, because the sentinel is an empty type. Sentinels are supported from C++17 (for ranged for) and C++20 (for algorithms using the new ranges library).</p>
<h3 id="temporaries">Temporaries</h3>
<p>QStringTokenizer is very carefully designed to avoid dangling references. If you construct a tokenizer from a temporary string (an rvalue), that argument is stored internally, so the referenced data isn't deleted before it is tokenized:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> tok <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>{widget<span class="operator">.</span>text()<span class="operator">,</span> u<span class="char">','</span>};
 <span class="comment">// return value of `widget.text()` is destroyed, but content was moved into `tok`</span>
 <span class="keyword">for</span> (<span class="keyword">auto</span> e : tok)
    use(e);
</pre>
<p>If you pass named objects (lvalues), then QStringTokenizer does not store a copy. You are responsible to keep the named object's data around for longer than the tokenizer operates on it:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> text <span class="operator">=</span> widget<span class="operator">.</span>text();
 <span class="keyword">auto</span> tok <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>{text<span class="operator">,</span> u<span class="char">','</span>};
 text<span class="operator">.</span>clear();      <span class="comment">// destroy content of `text`</span>
 <span class="keyword">for</span> (<span class="keyword">auto</span> e : tok) <span class="comment">// ERROR: `tok` references deleted data!</span>
     use(e);
</pre>
</div>
<p><b>See also </b><a href="qstringview.html#split" translate="no">QStringView::split</a>(), <a href="qstring.html#split" translate="no">QString::split</a>(), and <a href="qregularexpression.html" translate="no">QRegularExpression</a>.</p>
<!-- @@@QStringTokenizer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$const_iterator -->
<h3 class="fn" translate="no" id="const_iterator-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">const_iterator</span></h3>
<p>This typedef provides an STL-style const iterator for <a href="qstringtokenizer.html" translate="no">QStringTokenizer</a>.</p>
<p><b>See also </b><a href="qstringtokenizer.html#iterator-typedef" translate="no">iterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" translate="no" id="const_pointer-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">const_pointer</span></h3>
<p>Alias for <code translate="no">value_type *</code>.</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" translate="no" id="const_reference-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">const_reference</span></h3>
<p>Alias for <code translate="no">value_type &amp;</code>.</p>
<!-- @@@const_reference -->
<!-- $$$difference_type -->
<h3 class="fn" translate="no" id="difference_type-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">difference_type</span></h3>
<p>Alias for qsizetype.</p>
<!-- @@@difference_type -->
<!-- $$$iterator -->
<h3 class="fn" translate="no" id="iterator-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">iterator</span></h3>
<p>This typedef provides an STL-style const iterator for <a href="qstringtokenizer.html" translate="no">QStringTokenizer</a>.</p>
<p><a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> does not support mutable iterators, so this is the same as <a href="qstringtokenizer.html#const_iterator-typedef" translate="no">const_iterator</a>.</p>
<p><b>See also </b><a href="qstringtokenizer.html#const_iterator-typedef" translate="no">const_iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$pointer -->
<h3 class="fn" translate="no" id="pointer-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">pointer</span></h3>
<p>Alias for <code translate="no">value_type *</code>.</p>
<p><a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> does not support mutable iterators, so this is the same as <a href="qstringtokenizer.html#const_pointer-typedef" translate="no">const_pointer</a>.</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" translate="no" id="reference-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">reference</span></h3>
<p>Alias for <code translate="no">value_type &amp;</code>.</p>
<p><a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> does not support mutable references, so this is the same as <a href="qstringtokenizer.html#const_reference-typedef" translate="no">const_reference</a>.</p>
<!-- @@@reference -->
<!-- $$$sentinel -->
<h3 class="fn" translate="no" id="sentinel-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">sentinel</span></h3>
<p>This typedef provides an STL-style sentinel for <a href="qstringtokenizer.html#iterator-typedef" translate="no">QStringTokenizer::iterator</a> and <a href="qstringtokenizer.html#const_iterator-typedef" translate="no">QStringTokenizer::const_iterator</a>.</p>
<p><b>See also </b><a href="qstringtokenizer.html#const_iterator-typedef" translate="no">const_iterator</a>.</p>
<!-- @@@sentinel -->
<!-- $$$size_type -->
<h3 class="fn" translate="no" id="size_type-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">size_type</span></h3>
<p>Alias for qsizetype.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" translate="no" id="value_type-typedef"><code class="details extra" translate="no">[alias]</code> QStringTokenizer::<span class="name">value_type</span></h3>
<p>Alias for <code translate="no">const QStringView</code> or <code translate="no">const QLatin1StringView</code>, depending on the tokenizer's <code translate="no">Haystack</code> template argument.</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="QStringTokenizer"><code class="details extra" translate="no">[explicit constexpr noexcept(...)]</code> QStringTokenizer::<span class="name">QStringTokenizer</span>(<span class="type">Haystack</span> <i>haystack</i>, <span class="type">Needle</span> <i>needle</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i>, <span class="type"><a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SplitBehavior</a></span> <i>sb</i> = Qt::KeepEmptyParts)</h3><h3 class="fn fngroupitem" translate="no" id="QStringTokenizer-1"><code class="details extra" translate="no">[explicit constexpr noexcept(...)]</code> QStringTokenizer::<span class="name">QStringTokenizer</span>(<span class="type">Haystack</span> <i>haystack</i>, <span class="type">Needle</span> <i>needle</i>, <span class="type"><a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SplitBehavior</a></span> <i>sb</i> = Qt::KeepEmptyParts, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3></div>
<p>Constructs a string tokenizer that splits the string <i translate="no">haystack</i> into substrings wherever <i translate="no">needle</i> occurs, and allows iteration over those strings as they are found. If <i translate="no">needle</i> does not match anywhere in <i translate="no">haystack</i>, a single element containing <i translate="no">haystack</i> is produced.</p>
<p><i translate="no">cs</i> specifies whether <i translate="no">needle</i> should be matched case sensitively or case insensitively.</p>
<p>If <i translate="no">sb</i> is <a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SkipEmptyParts</a>, empty entries don't appear in the result. By default, empty entries are included.</p>
<div class="admonition note">
<p><b>Note: </b> (1) does not throw any exception when &quot;std::is_nothrow_copy_constructible&lt;QStringTokenizer&gt;::value&quot; is true.</p>
</div>
<div class="admonition note">
<p><b>Note: </b> (2) does not throw any exception when &quot;std::is_nothrow_copy_constructible&lt;QStringTokenizer&gt;::value&quot; is true.</p>
</div>
<p><b>See also </b><a href="qstringview.html#split" translate="no">QStringView::split</a>(), <a href="qstring.html#split" translate="no">QString::split</a>(), <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a>, and <a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SplitBehavior</a>.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="begin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>&lt;<span class="type">Haystack</span>, <span class="type">Needle</span>&gt;<span class="type">::iterator</span> QStringTokenizer::<span class="name">begin</span>() const</h3><h3 class="fn fngroupitem" translate="no" id="cbegin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>&lt;<span class="type">Haystack</span>, <span class="type">Needle</span>&gt;<span class="type">::iterator</span> QStringTokenizer::<span class="name">cbegin</span>() const</h3></div>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first token in the list.</p>
<p><b>See also </b><a href="qstringtokenizer.html#end" translate="no">end</a>() and <a href="qstringtokenizer.html#cend" translate="no">cend</a>().</p>
<!-- @@@ -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" translate="no" id="cend"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>&lt;<span class="type">Haystack</span>, <span class="type">Needle</span>&gt;<span class="type">::sentinel</span> QStringTokenizer::<span class="name">cend</span>() const</h3>
<p>Same as <a href="qstringtokenizer.html#end" translate="no">end</a>().</p>
<p><b>See also </b><a href="qstringtokenizer.html#cbegin" translate="no">cbegin</a>() and <a href="qstringtokenizer.html#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>&lt;<span class="type">Haystack</span>, <span class="type">Needle</span>&gt;<span class="type">::sentinel</span> QStringTokenizer::<span class="name">end</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style sentinel</a> pointing to the imaginary token after the last token in the list.</p>
<p><b>See also </b><a href="qstringtokenizer.html#begin" translate="no">begin</a>() and <a href="qstringtokenizer.html#cend" translate="no">cend</a>().</p>
<!-- @@@end -->
<!-- $$$toContainer[overload1]$$$toContainerLContainer&& -->
<h3 class="fn" translate="no" id="toContainer">template &lt;typename LContainer&gt; <span class="type">LContainer</span> QStringTokenizer::<span class="name">toContainer</span>(<span class="type">LContainer</span> &amp;&amp;<i>c</i> = {}) const &</h3>
<p>Converts the lazy sequence into a (typically) random-access container of type <code translate="no">LContainer</code>.</p>
<p>This function is only available if <code translate="no">Container</code> has a <code translate="no">value_type</code> matching this tokenizer's <a href="qstringtokenizer.html#value_type-typedef" translate="no">value_type</a>.</p>
<p>If you pass in a named container (an lvalue) for <i translate="no">c</i>, then that container is filled, and a reference to it is returned. If you pass in a temporary container (an rvalue, incl. the default argument), then that container is filled, and returned by value.</p>
<pre class="cpp" translate="no">
 <span class="comment">// assuming tok's value_type is QStringView, then...</span>
 <span class="keyword">auto</span> tok <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>{<span class="operator">~</span><span class="operator">~</span><span class="operator">~</span>};
 <span class="comment">// ... rac1 is a QList:</span>
 <span class="keyword">auto</span> rac1 <span class="operator">=</span> tok<span class="operator">.</span>toContainer();
 <span class="comment">// ... rac2 is std::pmr::vector&lt;QStringView&gt;:</span>
 <span class="keyword">auto</span> rac2 <span class="operator">=</span> tok<span class="operator">.</span>toContainer<span class="operator">&lt;</span>std<span class="operator">::</span>pmr<span class="operator">::</span>vector<span class="operator">&lt;</span><span class="type"><a href="qstringview.html" translate="no">QStringView</a></span><span class="operator">&gt;</span><span class="operator">&gt;</span>();
 <span class="keyword">auto</span> rac3 <span class="operator">=</span> <span class="type"><a href="qvarlengtharray.html" translate="no">QVarLengthArray</a></span><span class="operator">&lt;</span><span class="type"><a href="qstringview.html" translate="no">QStringView</a></span><span class="operator">,</span> <span class="number">12</span><span class="operator">&gt;</span>{};
 <span class="comment">// appends the token sequence produced by tok to rac3</span>
 <span class="comment">//  and returns a reference to rac3 (which we ignore here):</span>
 tok<span class="operator">.</span>toContainer(rac3);
</pre>
<p>This gives you maximum flexibility in how you want the sequence to be stored.</p>
<!-- @@@toContainer -->
<!-- $$$toContainer$$$toContainerRContainer&& -->
<h3 class="fn" translate="no" id="toContainer-1">template &lt;typename RContainer&gt; <span class="type">RContainer</span> QStringTokenizer::<span class="name">toContainer</span>(<span class="type">RContainer</span> &amp;&amp;<i>c</i> = {}) const &&</h3>
<p>This is an overloaded function.</p>
<p>Converts the lazy sequence into a (typically) random-access container of type <code translate="no">RContainer</code>.</p>
<p>In addition to the constraints on the lvalue-this overload, this rvalue-this overload is only available when this <a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> does not store the haystack internally, as this could create a container full of dangling references:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> tokens <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>{widget<span class="operator">.</span>text()<span class="operator">,</span> u<span class="char">','</span>}<span class="operator">.</span>toContainer();
 <span class="comment">// ERROR: cannot call toContainer() on rvalue</span>
 <span class="comment">// 'tokens' references the data of the copy of widget.text()</span>
 <span class="comment">// stored inside the QStringTokenizer, which has since been deleted</span>
</pre>
<p>To fix, store the <a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> in a temporary:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> tokenizer <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>{widget<span class="operator">.</span>text90<span class="operator">,</span> u<span class="char">','</span>};
 <span class="keyword">auto</span> tokens <span class="operator">=</span> tokenizer<span class="operator">.</span>toContainer();
 <span class="comment">// OK: the copy of widget.text() stored in 'tokenizer' keeps the data</span>
 <span class="comment">// referenced by 'tokens' alive.</span>
</pre>
<p>You can force this function into existence by passing a view instead:</p>
<pre class="cpp" translate="no">
 func(<span class="type"><a href="qstringtokenizer.html#QStringTokenizer" translate="no">QStringTokenizer</a></span>{<span class="type"><a href="qstringview.html" translate="no">QStringView</a></span>{widget<span class="operator">.</span>text()}<span class="operator">,</span> u<span class="char">','</span>}<span class="operator">.</span>toContainer());
 <span class="comment">// OK: compiler keeps widget.text() around until after func() has executed</span>
</pre>
<p>If you pass in a named container (an lvalue)for <i translate="no">c</i>, then that container is filled, and a reference to it is returned. If you pass in a temporary container (an rvalue, incl. the default argument), then that container is filled, and returned by value.</p>
<!-- @@@toContainer -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qTokenize[overload1]$$$qTokenizeHaystack&&Needle&&Flags... -->
<h3 class="fn" translate="no" id="qTokenize"><code class="details extra" translate="no">[constexpr noexcept(...), since 6.0]</code> template &lt;typename Haystack, typename Needle, typename... Flags&gt; <span class="type">decltype</span>(<span class="type">QtPrivate::Tok::TokenizerResult</span>&lt;<span class="type">Haystack</span>, <span class="type">Needle</span>&gt;{<span class="type">std::forward</span>&lt;<span class="type">Haystack</span>&gt;(<span class="type">h</span>), <span class="type">std::forward</span>&lt;<span class="type">Needle</span>&gt;(<span class="type">n</span>), <span class="type">flags</span>...}) <span class="name">qTokenize</span>(<span class="type">Haystack</span> &amp;&amp;<i>haystack</i>, <span class="type">Needle</span> &amp;&amp;<i>needle</i>, <span class="type">Flags</span>... <i>flags</i>)</h3>
<p>Factory function for a <a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> that splits the string <i translate="no">haystack</i> into substrings wherever <i translate="no">needle</i> occurs, and allows iteration over those strings as they are found. If <i translate="no">needle</i> does not match anywhere in <i translate="no">haystack</i>, a single element containing <i translate="no">haystack</i> is produced.</p>
<p>Pass values from <a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a> and <a href="qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SplitBehavior</a> enumerators as <i translate="no">flags</i> to modify the behavior of the tokenizer.</p>
<p>You can use this function if your compiler doesn't, yet, support C++17 Class Template Argument Deduction (CTAD). We recommend direct use of <a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> with CTAD instead.</p>
<p>This function was introduced in Qt 6.0.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;QtPrivate::Tok::is_nothrow_constructible_from&lt;Haystack, Needle&gt;::value&quot; is true.</p>
</div>
<!-- @@@qTokenize -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
