<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qelapsedtimer.cpp -->
  <meta name="description" content="The QElapsedTimer class provides a fast way to calculate elapsed times.">
  <title>QElapsedTimer Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QElapsedTimer</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#reference-clocks">Reference Clocks</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QElapsedTimer Class</h1>
<!-- $$$QElapsedTimer-brief -->
<p>The QElapsedTimer class provides a fast way to calculate elapsed times. <a href="#details">More...</a></p>
<!-- @@@QElapsedTimer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QElapsedTimer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qelapsedtimer-members.html">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#ClockType-enum" translate="no">ClockType</a></b> { SystemTime, MonotonicClock, TickCounter, MachAbsoluteTime, PerformanceCounter }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#Duration-typedef" translate="no">Duration</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#TimePoint-typedef" translate="no">TimePoint</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QElapsedTimer::Duration </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#durationElapsed" translate="no">durationElapsed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QElapsedTimer::Duration </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#durationTo" translate="no">durationTo</a></b>(const QElapsedTimer &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#hasExpired" translate="no">hasExpired</a></b>(qint64 <i>timeout</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#invalidate" translate="no">invalidate</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#msecsSinceReference" translate="no">msecsSinceReference</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#msecsTo" translate="no">msecsTo</a></b>(const QElapsedTimer &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#nsecsElapsed" translate="no">nsecsElapsed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#restart" translate="no">restart</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#secsTo" translate="no">secsTo</a></b>(const QElapsedTimer &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#start" translate="no">start</a></b>()</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QElapsedTimer::ClockType </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#clockType" translate="no">clockType</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#isMonotonic" translate="no">isMonotonic</a></b>()</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#operator-not-eq" translate="no">operator!=</a></b>(const QElapsedTimer &amp;<i>lhs</i>, const QElapsedTimer &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qelapsedtimer.html#operator-eq-eq" translate="no">operator==</a></b>(const QElapsedTimer &amp;<i>lhs</i>, const QElapsedTimer &amp;<i>rhs</i>)</td></tr>
</table></div>
<!-- $$$QElapsedTimer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QElapsedTimer class is usually used to quickly calculate how much time has elapsed between two events. Its API is similar to that of <a href="qtime.html" translate="no">QTime</a>, so code that was using that can be ported quickly to the new class.</p>
<p>However, unlike <a href="qtime.html" translate="no">QTime</a>, QElapsedTimer tries to use monotonic clocks if possible. This means it's not possible to convert QElapsedTimer objects to a human-readable time.</p>
<p>The typical use-case for the class is to determine how much time was spent in a slow operation. The simplest example of such a case is for debugging purposes, as in the following example:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> timer;
     timer<span class="operator">.</span>start();

     slowOperation1();

     <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;The slow operation took&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> timer<span class="operator">.</span>elapsed() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;milliseconds&quot;</span>;
</pre>
<p>In this example, the timer is started by a call to <a href="qelapsedtimer.html#start" translate="no">start</a>() and the elapsed time is calculated by the <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>() function.</p>
<p>The time elapsed can also be used to recalculate the time available for another operation, after the first one is complete. This is useful when the execution must complete within a certain time period, but several steps are needed. The <code translate="no">waitFor</code>-type functions in <a href="qiodevice.html" translate="no">QIODevice</a> and its subclasses are good examples of such need. In that case, the code could be as follows:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> executeSlowOperations(<span class="type">int</span> timeout)
 {
     <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> timer;
     timer<span class="operator">.</span>start();
     slowOperation1();

     <span class="type">int</span> remainingTime <span class="operator">=</span> timeout <span class="operator">-</span> timer<span class="operator">.</span>elapsed();
     <span class="keyword">if</span> (remainingTime <span class="operator">&gt;</span> <span class="number">0</span>)
         slowOperation2(remainingTime);
 }
</pre>
<p>Another use-case is to execute a certain operation for a specific timeslice. For this, QElapsedTimer provides the <a href="qelapsedtimer.html#hasExpired" translate="no">hasExpired</a>() convenience function, which can be used to determine if a certain number of milliseconds has already elapsed:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> executeOperationsForTime(<span class="type">int</span> ms)
 {
     <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> timer;
     timer<span class="operator">.</span>start();

     <span class="keyword">while</span> (<span class="operator">!</span>timer<span class="operator">.</span>hasExpired(ms))
         slowOperation1();
 }
</pre>
<p>It is often more convenient to use <a href="qdeadlinetimer.html" translate="no">QDeadlineTimer</a> in this case, which counts towards a timeout in the future instead of tracking elapsed time.</p>
<h3 id="reference-clocks">Reference Clocks</h3>
<p>QElapsedTimer will use the platform's monotonic reference clock in all platforms that support it (see <a href="qelapsedtimer.html#isMonotonic" translate="no">QElapsedTimer::isMonotonic</a>()). This has the added benefit that QElapsedTimer is immune to time adjustments, such as the user correcting the time. Also unlike <a href="qtime.html" translate="no">QTime</a>, QElapsedTimer is immune to changes in the timezone settings, such as daylight-saving periods.</p>
<p>On the other hand, this means QElapsedTimer values can only be compared with other values that use the same reference. This is especially true if the time since the reference is extracted from the QElapsedTimer object (<a href="qelapsedtimer.html#msecsSinceReference" translate="no">QElapsedTimer::msecsSinceReference</a>()) and serialised. These values should never be exchanged across the network or saved to disk, since there's no telling whether the computer node receiving the data is the same as the one originating it or if it has rebooted since.</p>
<p>It is, however, possible to exchange the value with other processes running on the same machine, provided that they also use the same reference clock. QElapsedTimer will always use the same clock, so it's safe to compare with the value coming from another process in the same machine. If comparing to values produced by other APIs, you should check that the clock used is the same as QElapsedTimer (see <a href="qelapsedtimer.html#clockType" translate="no">QElapsedTimer::clockType</a>()).</p>
</div>
<p><b>See also </b><a href="qtime.html" translate="no">QTime</a>, <a href="qtimer.html" translate="no">QTimer</a>, and <a href="qdeadlinetimer.html" translate="no">QDeadlineTimer</a>.</p>
<!-- @@@QElapsedTimer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ClockType$$$SystemTime$$$MonotonicClock$$$TickCounter$$$MachAbsoluteTime$$$PerformanceCounter -->
<h3 class="fn" translate="no" id="ClockType-enum">enum QElapsedTimer::<span class="name">ClockType</span></h3>
<p>This enum contains the different clock types that <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> may use.</p>
<p><a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> will always use the same clock type in a particular machine, so this value will not change during the lifetime of a program. It is provided so that <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> can be used with other non-Qt implementations, to guarantee that the same reference clock is being used.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QElapsedTimer::SystemTime</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The human-readable system time. This clock is not monotonic.</td></tr>
<tr><td class="topAlign"><code translate="no">QElapsedTimer::MonotonicClock</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The system's monotonic clock, usually found in Unix systems. This clock is monotonic.</td></tr>
<tr><td class="topAlign"><code translate="no">QElapsedTimer::TickCounter</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Not used anymore.</td></tr>
<tr><td class="topAlign"><code translate="no">QElapsedTimer::MachAbsoluteTime</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The Mach kernel's absolute time (macOS and iOS). This clock is monotonic.</td></tr>
<tr><td class="topAlign"><code translate="no">QElapsedTimer::PerformanceCounter</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The performance counter provided by Windows. This clock is monotonic.</td></tr>
</table></div>
<h5 id="systemtime">SystemTime</h5>
<p>The system time clock is purely the real time, expressed in milliseconds since Jan 1, 1970 at 0:00 UTC. It's equivalent to the value returned by the C and POSIX <code translate="no">time</code> function, with the milliseconds added. This clock type is currently only used on Unix systems that do not support monotonic clocks (see below).</p>
<p>This is the only non-monotonic clock that <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> may use.</p>
<h5 id="monotonicclock">MonotonicClock</h5>
<p>This is the system's monotonic clock, expressed in milliseconds since an arbitrary point in the past. This clock type is used on Unix systems which support POSIX monotonic clocks (<code translate="no">_POSIX_MONOTONIC_CLOCK</code>).</p>
<h5 id="machabsolutetime">MachAbsoluteTime</h5>
<p>This clock type is based on the absolute time presented by Mach kernels, such as that found on macOS. This clock type is presented separately from MonotonicClock since macOS and iOS are also Unix systems and may support a POSIX monotonic clock with values differing from the Mach absolute time.</p>
<p>This clock is monotonic.</p>
<h5 id="performancecounter">PerformanceCounter</h5>
<p>This clock uses the Windows functions <code translate="no">QueryPerformanceCounter</code> and <code translate="no">QueryPerformanceFrequency</code> to access the system's performance counter.</p>
<p>This clock is monotonic.</p>
<p><b>See also </b><a href="qelapsedtimer.html#clockType" translate="no">clockType</a>() and <a href="qelapsedtimer.html#isMonotonic" translate="no">isMonotonic</a>().</p>
<!-- @@@ClockType -->
<!-- $$$Duration -->
<h3 class="fn" translate="no" id="Duration-typedef"><code class="details extra" translate="no">[alias]</code> QElapsedTimer::<span class="name">Duration</span></h3>
<p>Synonym for <code translate="no">std::chrono::nanoseconds</code>.</p>
<!-- @@@Duration -->
<!-- $$$TimePoint -->
<h3 class="fn" translate="no" id="TimePoint-typedef"><code class="details extra" translate="no">[alias]</code> QElapsedTimer::<span class="name">TimePoint</span></h3>
<p>Synonym for <code translate="no">std::chrono::time_point&lt;std::chrono::steady_clock, Duration&gt;</code>.</p>
<!-- @@@TimePoint -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QElapsedTimer[overload1]$$$QElapsedTimer -->
<h3 class="fn" translate="no" id="QElapsedTimer"><code class="details extra" translate="no">[constexpr noexcept]</code> QElapsedTimer::<span class="name">QElapsedTimer</span>()</h3>
<p>Constructs an invalid QElapsedTimer. A timer becomes valid once it has been started.</p>
<p><b>See also </b><a href="qelapsedtimer.html#isValid" translate="no">isValid</a>() and <a href="qelapsedtimer.html#start" translate="no">start</a>().</p>
<!-- @@@QElapsedTimer -->
<!-- $$$clockType[overload1]$$$clockType -->
<h3 class="fn" translate="no" id="clockType"><code class="details extra" translate="no">[static noexcept]</code> <span class="type"><a href="qelapsedtimer.html#ClockType-enum" translate="no">QElapsedTimer::ClockType</a></span> QElapsedTimer::<span class="name">clockType</span>()</h3>
<p>Returns the clock type that this <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> implementation uses.</p>
<p>Since Qt 6.6, <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> uses <code translate="no">std::chrono::steady_clock</code>, so the clock type is always <a href="qelapsedtimer.html#ClockType-enum" translate="no">MonotonicClock</a>.</p>
<p><b>See also </b><a href="qelapsedtimer.html#isMonotonic" translate="no">isMonotonic</a>().</p>
<!-- @@@clockType -->
<!-- $$$durationElapsed[overload1]$$$durationElapsed -->
<h3 class="fn" translate="no" id="durationElapsed"><code class="details extra" translate="no">[noexcept, since 6.6]</code> <span class="type"><a href="qelapsedtimer.html#Duration-typedef" translate="no">QElapsedTimer::Duration</a></span> QElapsedTimer::<span class="name">durationElapsed</span>() const</h3>
<p>Returns a <code translate="no">std::chrono::nanoseconds</code> with the time since this <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> was last started.</p>
<p>Calling this function on a <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> that is invalid results in undefined behavior.</p>
<p>On platforms that do not provide nanosecond resolution, the value returned will be the best estimate available.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qelapsedtimer.html#start" translate="no">start</a>(), <a href="qelapsedtimer.html#restart" translate="no">restart</a>(), <a href="qelapsedtimer.html#hasExpired" translate="no">hasExpired</a>(), and <a href="qelapsedtimer.html#invalidate" translate="no">invalidate</a>().</p>
<!-- @@@durationElapsed -->
<!-- $$$durationTo[overload1]$$$durationToconstQElapsedTimer& -->
<h3 class="fn" translate="no" id="durationTo"><code class="details extra" translate="no">[noexcept, since 6.6]</code> <span class="type"><a href="qelapsedtimer.html#Duration-typedef" translate="no">QElapsedTimer::Duration</a></span> QElapsedTimer::<span class="name">durationTo</span>(const <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> &amp;<i>other</i>) const</h3>
<p>Returns the time difference between this <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> and <i translate="no">other</i> as a <code translate="no">std::chrono::nanoseconds</code>. If <i translate="no">other</i> was started before this object, the returned value will be negative. If it was started later, the returned value will be positive.</p>
<p>The return value is undefined if this object or <i translate="no">other</i> were invalidated.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qelapsedtimer.html#secsTo" translate="no">secsTo</a>() and <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>().</p>
<!-- @@@durationTo -->
<!-- $$$elapsed[overload1]$$$elapsed -->
<h3 class="fn" translate="no" id="elapsed"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> QElapsedTimer::<span class="name">elapsed</span>() const</h3>
<p>Returns the number of milliseconds since this <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> was last started.</p>
<p>Calling this function on a <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> that is invalid results in undefined behavior.</p>
<p><b>See also </b><a href="qelapsedtimer.html#start" translate="no">start</a>(), <a href="qelapsedtimer.html#restart" translate="no">restart</a>(), <a href="qelapsedtimer.html#hasExpired" translate="no">hasExpired</a>(), <a href="qelapsedtimer.html#isValid" translate="no">isValid</a>(), and <a href="qelapsedtimer.html#invalidate" translate="no">invalidate</a>().</p>
<!-- @@@elapsed -->
<!-- $$$hasExpired[overload1]$$$hasExpiredqint64 -->
<h3 class="fn" translate="no" id="hasExpired"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QElapsedTimer::<span class="name">hasExpired</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>timeout</i>) const</h3>
<p>Returns <code translate="no">true</code> if <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>() exceeds the given <i translate="no">timeout</i>, otherwise <code translate="no">false</code>.</p>
<p>A negative <i translate="no">timeout</i> is interpreted as infinite, so <code translate="no">false</code> is returned in this case. Otherwise, this is equivalent to <code translate="no">elapsed() &gt; timeout</code>. You can do the same for a duration by comparing <a href="qelapsedtimer.html#durationElapsed" translate="no">durationElapsed</a>() to a duration timeout.</p>
<p><b>See also </b><a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>() and <a href="qdeadlinetimer.html" translate="no">QDeadlineTimer</a>.</p>
<!-- @@@hasExpired -->
<!-- $$$invalidate[overload1]$$$invalidate -->
<h3 class="fn" translate="no" id="invalidate"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QElapsedTimer::<span class="name">invalidate</span>()</h3>
<p>Marks this <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> object as invalid.</p>
<p>An invalid object can be checked with <a href="qelapsedtimer.html#isValid" translate="no">isValid</a>(). Calculations of timer elapsed since invalid data are undefined and will likely produce bizarre results.</p>
<p><b>See also </b><a href="qelapsedtimer.html#isValid" translate="no">isValid</a>(), <a href="qelapsedtimer.html#start" translate="no">start</a>(), and <a href="qelapsedtimer.html#restart" translate="no">restart</a>().</p>
<!-- @@@invalidate -->
<!-- $$$isMonotonic[overload1]$$$isMonotonic -->
<h3 class="fn" translate="no" id="isMonotonic"><code class="details extra" translate="no">[static noexcept]</code> <span class="type">bool</span> QElapsedTimer::<span class="name">isMonotonic</span>()</h3>
<p>Returns <code translate="no">true</code> if this is a monotonic clock, false otherwise. See the information on the different clock types to understand which ones are monotonic.</p>
<p>Since Qt 6.6, <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> uses <code translate="no">std::chrono::steady_clock</code>, so this function now always returns true.</p>
<p><b>See also </b><a href="qelapsedtimer.html#clockType" translate="no">clockType</a>() and <a href="qelapsedtimer.html#ClockType-enum" translate="no">QElapsedTimer::ClockType</a>.</p>
<!-- @@@isMonotonic -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QElapsedTimer::<span class="name">isValid</span>() const</h3>
<p>Returns <code translate="no">false</code> if the timer has never been started or invalidated by a call to <a href="qelapsedtimer.html#invalidate" translate="no">invalidate</a>().</p>
<p><b>See also </b><a href="qelapsedtimer.html#invalidate" translate="no">invalidate</a>(), <a href="qelapsedtimer.html#start" translate="no">start</a>(), and <a href="qelapsedtimer.html#restart" translate="no">restart</a>().</p>
<!-- @@@isValid -->
<!-- $$$msecsSinceReference[overload1]$$$msecsSinceReference -->
<h3 class="fn" translate="no" id="msecsSinceReference"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> QElapsedTimer::<span class="name">msecsSinceReference</span>() const</h3>
<p>Returns the number of milliseconds between last time this <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> object was started and its reference clock's start.</p>
<p>This number is usually arbitrary for all clocks except the <a href="qelapsedtimer.html#ClockType-enum" translate="no">QElapsedTimer::SystemTime</a> clock. For that clock type, this number is the number of milliseconds since January 1st, 1970 at 0:00 UTC (that is, it is the Unix time expressed in milliseconds).</p>
<p>On Linux, Windows and Apple platforms, this value is usually the time since the system boot, though it usually does not include the time the system has spent in sleep states.</p>
<p><b>See also </b><a href="qelapsedtimer.html#clockType" translate="no">clockType</a>() and <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>().</p>
<!-- @@@msecsSinceReference -->
<!-- $$$msecsTo[overload1]$$$msecsToconstQElapsedTimer& -->
<h3 class="fn" translate="no" id="msecsTo"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> QElapsedTimer::<span class="name">msecsTo</span>(const <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> &amp;<i>other</i>) const</h3>
<p>Returns the number of milliseconds between this <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> and <i translate="no">other</i>. If <i translate="no">other</i> was started before this object, the returned value will be negative. If it was started later, the returned value will be positive.</p>
<p>The return value is undefined if this object or <i translate="no">other</i> were invalidated.</p>
<p><b>See also </b><a href="qelapsedtimer.html#secsTo" translate="no">secsTo</a>() and <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>().</p>
<!-- @@@msecsTo -->
<!-- $$$nsecsElapsed[overload1]$$$nsecsElapsed -->
<h3 class="fn" translate="no" id="nsecsElapsed"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> QElapsedTimer::<span class="name">nsecsElapsed</span>() const</h3>
<p>Returns the number of nanoseconds since this <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> was last started.</p>
<p>Calling this function on a <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> that is invalid results in undefined behavior.</p>
<p>On platforms that do not provide nanosecond resolution, the value returned will be the best estimate available.</p>
<p><b>See also </b><a href="qelapsedtimer.html#start" translate="no">start</a>(), <a href="qelapsedtimer.html#restart" translate="no">restart</a>(), <a href="qelapsedtimer.html#hasExpired" translate="no">hasExpired</a>(), and <a href="qelapsedtimer.html#invalidate" translate="no">invalidate</a>().</p>
<!-- @@@nsecsElapsed -->
<!-- $$$restart[overload1]$$$restart -->
<h3 class="fn" translate="no" id="restart"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> QElapsedTimer::<span class="name">restart</span>()</h3>
<p>Restarts the timer and returns the number of milliseconds elapsed since the previous start. This function is equivalent to obtaining the elapsed time with <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>() and then starting the timer again with <a href="qelapsedtimer.html#start" translate="no">start</a>(), but it does so in one single operation, avoiding the need to obtain the clock value twice.</p>
<p>Calling this function on a <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> that is invalid results in undefined behavior.</p>
<p>The following example illustrates how to use this function to calibrate a parameter to a slow operation (for example, an iteration count) so that this operation takes at least 250 milliseconds:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> timer;

     <span class="type">int</span> count <span class="operator">=</span> <span class="number">1</span>;
     timer<span class="operator">.</span>start();
     <span class="keyword">do</span> {
         count <span class="operator">*</span><span class="operator">=</span> <span class="number">2</span>;
         slowOperation2(count);
     } <span class="keyword">while</span> (timer<span class="operator">.</span>restart() <span class="operator">&lt;</span> <span class="number">250</span>);

     <span class="keyword">return</span> count;
</pre>
<p><b>See also </b><a href="qelapsedtimer.html#start" translate="no">start</a>(), <a href="qelapsedtimer.html#invalidate" translate="no">invalidate</a>(), <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>(), and <a href="qelapsedtimer.html#isValid" translate="no">isValid</a>().</p>
<!-- @@@restart -->
<!-- $$$secsTo[overload1]$$$secsToconstQElapsedTimer& -->
<h3 class="fn" translate="no" id="secsTo"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> QElapsedTimer::<span class="name">secsTo</span>(const <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> &amp;<i>other</i>) const</h3>
<p>Returns the number of seconds between this <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> and <i translate="no">other</i>. If <i translate="no">other</i> was started before this object, the returned value will be negative. If it was started later, the returned value will be positive.</p>
<p>Calling this function on or with a <a href="qelapsedtimer.html" translate="no">QElapsedTimer</a> that is invalid results in undefined behavior.</p>
<p><b>See also </b><a href="qelapsedtimer.html#msecsTo" translate="no">msecsTo</a>() and <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>().</p>
<!-- @@@secsTo -->
<!-- $$$start[overload1]$$$start -->
<h3 class="fn" translate="no" id="start"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QElapsedTimer::<span class="name">start</span>()</h3>
<p>Starts this timer. Once started, a timer value can be checked with <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>() or <a href="qelapsedtimer.html#msecsSinceReference" translate="no">msecsSinceReference</a>().</p>
<p>Normally, a timer is started just before a lengthy operation, such as:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> timer;
     timer<span class="operator">.</span>start();

     slowOperation1();

     <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;The slow operation took&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> timer<span class="operator">.</span>elapsed() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;milliseconds&quot;</span>;
</pre>
<p>Also, starting a timer makes it valid again.</p>
<p><b>See also </b><a href="qelapsedtimer.html#restart" translate="no">restart</a>(), <a href="qelapsedtimer.html#invalidate" translate="no">invalidate</a>(), and <a href="qelapsedtimer.html#elapsed" translate="no">elapsed</a>().</p>
<!-- @@@start -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$operator!=[overload1]$$$operator!=constQElapsedTimer&constQElapsedTimer& -->
<h3 class="fn" translate="no" id="operator-not-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> &amp;<i>lhs</i>, const <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">lhs</i> and <i translate="no">rhs</i> contain different times, false otherwise.</p>
<!-- @@@operator!= -->
<!-- $$$operator==[overload1]$$$operator==constQElapsedTimer&constQElapsedTimer& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> &amp;<i>lhs</i>, const <span class="type"><a href="qelapsedtimer.html#QElapsedTimer" translate="no">QElapsedTimer</a></span> &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">lhs</i> and <i translate="no">rhs</i> contain the same time, false otherwise.</p>
<!-- @@@operator== -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
