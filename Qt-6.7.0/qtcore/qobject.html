<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qobject.cpp -->
  <meta name="description" content="The QObject class is the base class of all Qt objects.">
  <title>QObject Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QObject</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#thread-affinity">Thread Affinity</a></li>
<li class="level2"><a href="#no-copy-constructor-or-assignment-operator">No Copy Constructor or Assignment Operator</a></li>
<li class="level2"><a href="#auto-connection">Auto-Connection</a></li>
<li class="level2"><a href="#dynamic-properties">Dynamic Properties</a></li>
<li class="level2"><a href="#internationalization-i18n">Internationalization (I18n)</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QObject Class</h1>
<!-- $$$QObject-brief -->
<p>The QObject class is the base class of all Qt objects. <a href="#details">More...</a></p>
<!-- @@@QObject -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QObject&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="../qtdatavis3d/q3dobject.html" translate="no">Q3DObject</a>, <a href="../qtgraphs/q3dscene.html" translate="no">Q3DScene</a>, <a href="../qtgraphs/q3dtheme.html" translate="no">Q3DTheme</a>, <a href="../qtgraphs/qabstract3daxis.html" translate="no">QAbstract3DAxis</a>, <a href="../qtgraphs/qabstract3dinputhandler.html" translate="no">QAbstract3DInputHandler</a>, <a href="../qtgraphs/qabstract3dseries.html" translate="no">QAbstract3DSeries</a>, <a href="qabstractanimation.html" translate="no">QAbstractAnimation</a>, <a href="../qtgraphs/qabstractaxis.html" translate="no">QAbstractAxis</a>, <a href="../qtgraphs/qabstractdataproxy.html" translate="no">QAbstractDataProxy</a>, <a href="qabstracteventdispatcher.html" translate="no">QAbstractEventDispatcher</a>, <a href="../qtgrpc/qabstractgrpcclient.html" translate="no">QAbstractGrpcClient</a>, <a href="../qthttpserver/qabstracthttpserver.html" translate="no">QAbstractHttpServer</a>, <a href="../qtwidgets/qabstractitemdelegate.html" translate="no">QAbstractItemDelegate</a>, <a href="qabstractitemmodel.html" translate="no">QAbstractItemModel</a>, <a href="../qttestlib/qabstractitemmodeltester.html" translate="no">QAbstractItemModelTester</a>, <a href="../qtnetwork/qabstractnetworkcache.html" translate="no">QAbstractNetworkCache</a>, <a href="../qtnetworkauth/qabstractoauth.html" translate="no">QAbstractOAuth</a>, <a href="../qtnetworkauth/qabstractoauthreplyhandler.html" translate="no">QAbstractOAuthReplyHandler</a>, <a href="../qtgraphs/qabstractseries.html" translate="no">QAbstractSeries</a>, <a href="../qtstatemachine/qabstractstate.html" translate="no">QAbstractState</a>, <a href="../qtgui/qabstracttextdocumentlayout.html" translate="no">QAbstractTextDocumentLayout</a>, <a href="../qtstatemachine/qabstracttransition.html" translate="no">QAbstractTransition</a>, <a href="../qtgui/qaccessibleplugin.html" translate="no">QAccessiblePlugin</a>, <a href="../qtgui/qaction.html" translate="no">QAction</a>, <a href="../qtgui/qactiongroup.html" translate="no">QActionGroup</a>, <a href="../qtspatialaudio/qambientsound.html" translate="no">QAmbientSound</a>, <a href="../qtmultimedia/qaudiodecoder.html" translate="no">QAudioDecoder</a>, <a href="../qtspatialaudio/qaudioengine.html" translate="no">QAudioEngine</a>, <a href="../qtmultimedia/qaudioinput.html" translate="no">QAudioInput</a>, <a href="../qtspatialaudio/qaudiolistener.html" translate="no">QAudioListener</a>, <a href="../qtmultimedia/qaudiooutput.html" translate="no">QAudioOutput</a>, <a href="../qtspatialaudio/qaudioroom.html" translate="no">QAudioRoom</a>, <a href="../qtmultimedia/qaudiosink.html" translate="no">QAudioSink</a>, <a href="../qtmultimedia/qaudiosource.html" translate="no">QAudioSource</a>, <a href="../activeqt/qaxbaseobject.html" translate="no">QAxBaseObject</a>, <a href="../activeqt/qaxfactory.html" translate="no">QAxFactory</a>, <a href="../activeqt/qaxscript.html" translate="no">QAxScript</a>, <a href="../activeqt/qaxscriptmanager.html" translate="no">QAxScriptManager</a>, <a href="../qtgraphs/qbarset.html" translate="no">QBarSet</a>, <a href="../qtbluetooth/qbluetoothdevicediscoveryagent.html" translate="no">QBluetoothDeviceDiscoveryAgent</a>, <a href="../qtbluetooth/qbluetoothlocaldevice.html" translate="no">QBluetoothLocalDevice</a>, <a href="../qtbluetooth/qbluetoothserver.html" translate="no">QBluetoothServer</a>, <a href="../qtbluetooth/qbluetoothservicediscoveryagent.html" translate="no">QBluetoothServiceDiscoveryAgent</a>, <a href="../qtcharts/qboxset.html" translate="no">QBoxSet</a>, <a href="../qtwidgets/qbuttongroup.html" translate="no">QButtonGroup</a>, <a href="../qtmultimedia/qcamera.html" translate="no">QCamera</a>, <a href="../qtserialbus/qcanbus.html" translate="no">QCanBus</a>, <a href="../qtserialbus/qcanbusdevice.html" translate="no">QCanBusDevice</a>, <a href="../qtcharts/qcandlestickmodelmapper.html" translate="no">QCandlestickModelMapper</a>, <a href="../qtcharts/qcandlestickset.html" translate="no">QCandlestickSet</a>, <a href="../qtgui/qclipboard.html" translate="no">QClipboard</a>, <a href="../qtcoap/qcoapclient.html" translate="no">QCoapClient</a>, <a href="../qtwidgets/qcompleter.html" translate="no">QCompleter</a>, <a href="qcoreapplication.html" translate="no">QCoreApplication</a>, <a href="../qtgraphs/qcustom3ditem.html" translate="no">QCustom3DItem</a>, <a href="../qtwidgets/qdatawidgetmapper.html" translate="no">QDataWidgetMapper</a>, <a href="../qtdbus/qdbusabstractadaptor.html" translate="no">QDBusAbstractAdaptor</a>, <a href="../qtdbus/qdbusabstractinterface.html" translate="no">QDBusAbstractInterface</a>, <a href="../qtdbus/qdbuspendingcallwatcher.html" translate="no">QDBusPendingCallWatcher</a>, <a href="../qtdbus/qdbusserver.html" translate="no">QDBusServer</a>, <a href="../qtdbus/qdbusservicewatcher.html" translate="no">QDBusServiceWatcher</a>, <a href="../qtdbus/qdbusvirtualobject.html" translate="no">QDBusVirtualObject</a>, <a href="../qtdesigner/qdesignerformeditorinterface.html" translate="no">QDesignerFormEditorInterface</a>, <a href="../qtdesigner/qdesignerformwindowmanagerinterface.html" translate="no">QDesignerFormWindowManagerInterface</a>, <a href="../qtnetwork/qdnslookup.html" translate="no">QDnsLookup</a>, <a href="../qtgui/qdrag.html" translate="no">QDrag</a>, <a href="../qtnetwork/qdtls.html" translate="no">QDtls</a>, <a href="../qtnetwork/qdtlsclientverifier.html" translate="no">QDtlsClientVerifier</a>, <a href="qeventloop.html" translate="no">QEventLoop</a>, <a href="../qtdesigner/qextensionfactory.html" translate="no">QExtensionFactory</a>, <a href="../qtdesigner/qextensionmanager.html" translate="no">QExtensionManager</a>, <a href="qfileselector.html" translate="no">QFileSelector</a>, <a href="qfilesystemwatcher.html" translate="no">QFileSystemWatcher</a>, <a href="qfuturewatcher.html" translate="no">QFutureWatcher</a>, <a href="../qtgui/qgenericplugin.html" translate="no">QGenericPlugin</a>, <a href="../qtpositioning/qgeoareamonitorsource.html" translate="no">QGeoAreaMonitorSource</a>, <a href="../qtlocation/qgeocodereply.html" translate="no">QGeoCodeReply</a>, <a href="../qtlocation/qgeocodingmanager.html" translate="no">QGeoCodingManager</a>, <a href="../qtlocation/qgeocodingmanagerengine.html" translate="no">QGeoCodingManagerEngine</a>, <a href="../qtpositioning/qgeopositioninfosource.html" translate="no">QGeoPositionInfoSource</a>, <a href="../qtlocation/qgeoroutereply.html" translate="no">QGeoRouteReply</a>, <a href="../qtlocation/qgeoroutingmanager.html" translate="no">QGeoRoutingManager</a>, <a href="../qtlocation/qgeoroutingmanagerengine.html" translate="no">QGeoRoutingManagerEngine</a>, <a href="../qtpositioning/qgeosatelliteinfosource.html" translate="no">QGeoSatelliteInfoSource</a>, <a href="../qtlocation/qgeoserviceprovider.html" translate="no">QGeoServiceProvider</a>, <a href="../qtwidgets/qgesture.html" translate="no">QGesture</a>, <a href="../qtwidgets/qgraphicsanchor.html" translate="no">QGraphicsAnchor</a>, <a href="../qtwidgets/qgraphicseffect.html" translate="no">QGraphicsEffect</a>, <a href="../qtwidgets/qgraphicsitemanimation.html" class="obsolete" translate="no">QGraphicsItemAnimation</a>, <a href="../qtwidgets/qgraphicsobject.html" translate="no">QGraphicsObject</a>, <a href="../qtwidgets/qgraphicsscene.html" translate="no">QGraphicsScene</a>, <a href="../qtwidgets/qgraphicstransform.html" translate="no">QGraphicsTransform</a>, <a href="../qtgraphs/qgraphtheme.html" translate="no">QGraphTheme</a>, <a href="../qtgrpc/qgrpcchanneloperation.html" translate="no">QGrpcChannelOperation</a>, <a href="../qtgrpc/qgrpcoperation.html" translate="no">QGrpcOperation</a>, <a href="../qthelp/qhelpenginecore.html" translate="no">QHelpEngineCore</a>, <a href="../qthelp/qhelpfilterengine.html" translate="no">QHelpFilterEngine</a>, <a href="../qthelp/qhelpsearchengine.html" translate="no">QHelpSearchEngine</a>, <a href="../qtnetwork/qhttpmultipart.html" translate="no">QHttpMultiPart</a>, <a href="../qtgui/qiconengineplugin.html" translate="no">QIconEnginePlugin</a>, <a href="../qtmultimedia/qimagecapture.html" translate="no">QImageCapture</a>, <a href="../qtgui/qimageioplugin.html" translate="no">QImageIOPlugin</a>, <a href="../qtgui/qinputdevice.html" translate="no">QInputDevice</a>, <a href="../qtgui/qinputmethod.html" translate="no">QInputMethod</a>, <a href="qiodevice.html" translate="no">QIODevice</a>, <a href="qitemselectionmodel.html" translate="no">QItemSelectionModel</a>, <a href="../qtqml/qjsengine.html" translate="no">QJSEngine</a>, <a href="../qtwidgets/qlayout.html" translate="no">QLayout</a>, <a href="../qtcharts/qlegendmarker.html" translate="no">QLegendMarker</a>, <a href="qlibrary.html" translate="no">QLibrary</a>, <a href="../qtnetwork/qlocalserver.html" translate="no">QLocalServer</a>, <a href="../qtbluetooth/qlowenergycontroller.html" translate="no">QLowEnergyController</a>, <a href="../qtbluetooth/qlowenergyservice.html" translate="no">QLowEnergyService</a>, <a href="../qtwebsockets/qmaskgenerator.html" translate="no">QMaskGenerator</a>, <a href="../qtmultimedia/qmediacapturesession.html" translate="no">QMediaCaptureSession</a>, <a href="../qtmultimedia/qmediadevices.html" translate="no">QMediaDevices</a>, <a href="../qtmultimedia/qmediaplayer.html" translate="no">QMediaPlayer</a>, <a href="../qtmultimedia/qmediarecorder.html" translate="no">QMediaRecorder</a>, <a href="qmimedata.html" translate="no">QMimeData</a>, <a href="../qtserialbus/qmodbusdevice.html" translate="no">QModbusDevice</a>, <a href="../qtserialbus/qmodbusreply.html" translate="no">QModbusReply</a>, <a href="../qtgui/qmovie.html" translate="no">QMovie</a>, <a href="../qtmqtt/qmqttclient.html" translate="no">QMqttClient</a>, <a href="../qtmqtt/qmqttsubscription.html" translate="no">QMqttSubscription</a>, <a href="../qtnfc/qnearfieldmanager.html" translate="no">QNearFieldManager</a>, <a href="../qtnfc/qnearfieldtarget.html" translate="no">QNearFieldTarget</a>, <a href="../qtnetwork/qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a>, <a href="../qtnetwork/qnetworkcookiejar.html" translate="no">QNetworkCookieJar</a>, <a href="../qtnetwork/qnetworkinformation.html" translate="no">QNetworkInformation</a>, <a href="qobjectcleanuphandler.html" translate="no">QObjectCleanupHandler</a>, <a href="../qtgui/qoffscreensurface.html" translate="no">QOffscreenSurface</a>, <a href="../qtopcua/qopcuaclient.html" translate="no">QOpcUaClient</a>, <a href="../qtopcua/qopcuagdsclient.html" translate="no">QOpcUaGdsClient</a>, <a href="../qtopcua/qopcuagenericstructhandler.html" translate="no">QOpcUaGenericStructHandler</a>, <a href="../qtopcua/qopcuahistoryreadresponse.html" translate="no">QOpcUaHistoryReadResponse</a>, <a href="../qtopcua/qopcuakeypair.html" translate="no">QOpcUaKeyPair</a>, <a href="../qtopcua/qopcuanode.html" translate="no">QOpcUaNode</a>, <a href="../qtopcua/qopcuaprovider.html" translate="no">QOpcUaProvider</a>, <a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a>, <a href="../qtgui/qopenglcontextgroup.html" translate="no">QOpenGLContextGroup</a>, <a href="../qtopengl/qopengldebuglogger.html" translate="no">QOpenGLDebugLogger</a>, <a href="../qtopengl/qopenglshader.html" translate="no">QOpenGLShader</a>, <a href="../qtopengl/qopenglshaderprogram.html" translate="no">QOpenGLShaderProgram</a>, <a href="../qtopengl/qopengltimemonitor.html" translate="no">QOpenGLTimeMonitor</a>, <a href="../qtopengl/qopengltimerquery.html" translate="no">QOpenGLTimerQuery</a>, <a href="../qtopengl/qopenglvertexarrayobject.html" translate="no">QOpenGLVertexArrayObject</a>, <a href="../qtpdf/qpdfdocument.html" translate="no">QPdfDocument</a>, <a href="../qtpdf/qpdfpagenavigator.html" translate="no">QPdfPageNavigator</a>, <a href="../qtpdf/qpdfpagerenderer.html" translate="no">QPdfPageRenderer</a>, <a href="../qtgui/qpdfwriter.html" translate="no">QPdfWriter</a>, <a href="../qtcharts/qpieslice.html" translate="no">QPieSlice</a>, <a href="../qtlocation/qplacemanager.html" translate="no">QPlaceManager</a>, <a href="../qtlocation/qplacemanagerengine.html" translate="no">QPlaceManagerEngine</a>, <a href="../qtlocation/qplacereply.html" translate="no">QPlaceReply</a>, <a href="qpluginloader.html" translate="no">QPluginLoader</a>, <a href="../qtqml/qqmlcomponent.html" translate="no">QQmlComponent</a>, <a href="../qtqml/qqmlcontext.html" translate="no">QQmlContext</a>, <a href="../qtqml/qqmlengineextensionplugin.html" translate="no">QQmlEngineExtensionPlugin</a>, <a href="../qtqml/qqmlexpression.html" translate="no">QQmlExpression</a>, <a href="../qtqml/qqmlextensionplugin.html" translate="no">QQmlExtensionPlugin</a>, <a href="../qtqml/qqmlfileselector.html" translate="no">QQmlFileSelector</a>, <a href="../qtqml/qqmlimageproviderbase.html" translate="no">QQmlImageProviderBase</a>, <a href="../qtqml/qqmlpropertymap.html" translate="no">QQmlPropertyMap</a>, <a href="../qtquick3d/qquick3dobject.html" translate="no">QQuick3DObject</a>, <a href="../qtquickcontrols/qquickattachedpropertypropagator.html" translate="no">QQuickAttachedPropertyPropagator</a>, <a href="../qtquick/qquickimageresponse.html" translate="no">QQuickImageResponse</a>, <a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a>, <a href="../qtquick/qquickitemgrabresult.html" translate="no">QQuickItemGrabResult</a>, <a href="../qtquick/qquickrendercontrol.html" translate="no">QQuickRenderControl</a>, <a href="../qtquick/qquicktextdocument.html" translate="no">QQuickTextDocument</a>, <a href="../qtquick/qquicktexturefactory.html" translate="no">QQuickTextureFactory</a>, <a href="../qtwebengine/qquickwebengineprofile.html" translate="no">QQuickWebEngineProfile</a>, <a href="../qtremoteobjects/qremoteobjectabstractpersistedstore.html" translate="no">QRemoteObjectAbstractPersistedStore</a>, <a href="../qtremoteobjects/qremoteobjectnode.html" translate="no">QRemoteObjectNode</a>, <a href="../qtremoteobjects/qremoteobjectpendingcallwatcher.html" translate="no">QRemoteObjectPendingCallWatcher</a>, <a href="../qtremoteobjects/qremoteobjectreplica.html" translate="no">QRemoteObjectReplica</a>, <a href="../qtnetwork/qrestaccessmanager.html" translate="no">QRestAccessManager</a>, <a href="../qtgui/qscreen.html" translate="no">QScreen</a>, <a href="../qtmultimedia/qscreencapture.html" translate="no">QScreenCapture</a>, <a href="../qtwidgets/qscroller.html" translate="no">QScroller</a>, <a href="../qtscxml/qscxmldatamodel.html" translate="no">QScxmlDataModel</a>, <a href="../qtscxml/qscxmlinvokableservice.html" translate="no">QScxmlInvokableService</a>, <a href="../qtscxml/qscxmlinvokableservicefactory.html" translate="no">QScxmlInvokableServiceFactory</a>, <a href="../qtscxml/qscxmlstatemachine.html" translate="no">QScxmlStateMachine</a>, <a href="../qtsensors/qsensor.html" translate="no">QSensor</a>, <a href="../qtsensors/qsensorbackend.html" translate="no">QSensorBackend</a>, <a href="../qtsensors/qsensorreading.html" translate="no">QSensorReading</a>, <a href="../qtgraphs/qseriestheme.html" translate="no">QSeriesTheme</a>, <a href="../qtgui/qsessionmanager.html" translate="no">QSessionManager</a>, <a href="qsettings.html" translate="no">QSettings</a>, <a href="../qtquick/qsgtexture.html" translate="no">QSGTexture</a>, <a href="../qtquick/qsgtextureprovider.html" translate="no">QSGTextureProvider</a>, <a href="qsharedmemory.html" translate="no">QSharedMemory</a>, <a href="../qtgui/qshortcut.html" translate="no">QShortcut</a>, <a href="qsignalmapper.html" translate="no">QSignalMapper</a>, <a href="../qttestlib/qsignalspy.html" translate="no">QSignalSpy</a>, <a href="qsocketnotifier.html" translate="no">QSocketNotifier</a>, <a href="../qtmultimedia/qsoundeffect.html" translate="no">QSoundEffect</a>, <a href="../qtspatialaudio/qspatialsound.html" translate="no">QSpatialSound</a>, <a href="../qtsql/qsqldriver.html" translate="no">QSqlDriver</a>, <a href="../qtsql/qsqldriverplugin.html" translate="no">QSqlDriverPlugin</a>, <a href="../qtwidgets/qstyle.html" translate="no">QStyle</a>, <a href="../qtgui/qstylehints.html" translate="no">QStyleHints</a>, <a href="../qtwidgets/qstyleplugin.html" translate="no">QStylePlugin</a>, <a href="../qtsvg/qsvgrenderer.html" translate="no">QSvgRenderer</a>, <a href="../qtgui/qsyntaxhighlighter.html" translate="no">QSyntaxHighlighter</a>, <a href="../qtwidgets/qsystemtrayicon.html" translate="no">QSystemTrayIcon</a>, <a href="../qt3d/qt3danimation-qabstractanimation.html" translate="no">Qt3DAnimation::QAbstractAnimation</a>, <a href="../qt3d/qt3danimation-qanimationcontroller.html" translate="no">Qt3DAnimation::QAnimationController</a>, <a href="../qt3d/qt3danimation-qanimationgroup.html" translate="no">Qt3DAnimation::QAnimationGroup</a>, <a href="../qt3d/qt3danimation-qmorphtarget.html" translate="no">Qt3DAnimation::QMorphTarget</a>, <a href="../qt3d/qt3dcore-qabstractaspect.html" translate="no">Qt3DCore::QAbstractAspect</a>, <a href="../qt3d/qt3dcore-qaspectengine.html" translate="no">Qt3DCore::QAspectEngine</a>, <a href="../qt3d/qt3dcore-qnode.html" translate="no">Qt3DCore::QNode</a>, <a href="../qt3d/qt3dcore-quick-qqmlaspectengine.html" translate="no">Qt3DCore::Quick::QQmlAspectEngine</a>, <a href="../qt3d/qt3dinput-qinputdeviceintegration.html" translate="no">Qt3DInput::QInputDeviceIntegration</a>, <a href="../qt3d/qt3dinput-qkeyevent.html" translate="no">Qt3DInput::QKeyEvent</a>, <a href="../qt3d/qt3dinput-qmouseevent.html" translate="no">Qt3DInput::QMouseEvent</a>, <a href="../qt3d/qt3dinput-qwheelevent.html" translate="no">Qt3DInput::QWheelEvent</a>, <a href="../qt3d/qt3drender-qgraphicsapifilter.html" translate="no">Qt3DRender::QGraphicsApiFilter</a>, <a href="../qt3d/qt3drender-qpickevent.html" translate="no">Qt3DRender::QPickEvent</a>, <a href="../qt3d/qt3drender-qrendercapabilities.html" translate="no">Qt3DRender::QRenderCapabilities</a>, <a href="../qt3d/qt3drender-qrendercapturereply.html" translate="no">Qt3DRender::QRenderCaptureReply</a>, <a href="../qt3d/qt3drender-qstenciloperationarguments.html" translate="no">Qt3DRender::QStencilOperationArguments</a>, <a href="../qt3d/qt3drender-qstenciltestarguments.html" translate="no">Qt3DRender::QStencilTestArguments</a>, <a href="../qt3d/qt3drender-qtexturewrapmode.html" translate="no">Qt3DRender::QTextureWrapMode</a>, <a href="../qtnetwork/qtcpserver.html" translate="no">QTcpServer</a>, <a href="../qtgui/qtextdocument.html" translate="no">QTextDocument</a>, <a href="../qtgui/qtextobject.html" translate="no">QTextObject</a>, <a href="../qttexttospeech/qtexttospeech.html" translate="no">QTextToSpeech</a>, <a href="qthread.html" translate="no">QThread</a>, <a href="qthreadpool.html" translate="no">QThreadPool</a>, <a href="qtimeline.html" translate="no">QTimeLine</a>, <a href="qtimer.html" translate="no">QTimer</a>, <a href="qtranslator.html" translate="no">QTranslator</a>, <a href="../qtuitools/quiloader.html" translate="no">QUiLoader</a>, <a href="../qtgui/qundogroup.html" translate="no">QUndoGroup</a>, <a href="../qtgui/qundostack.html" translate="no">QUndoStack</a>, <a href="../qtgui/qvalidator.html" translate="no">QValidator</a>, <a href="../qtgraphs/qvalue3daxisformatter.html" translate="no">QValue3DAxisFormatter</a>, <a href="../qtmultimedia/qvideosink.html" translate="no">QVideoSink</a>, <a href="../qtvirtualkeyboard/qvirtualkeyboardabstractinputmethod.html" translate="no">QVirtualKeyboardAbstractInputMethod</a>, <a href="../qtvirtualkeyboard/qvirtualkeyboarddictionary.html" translate="no">QVirtualKeyboardDictionary</a>, <a href="../qtvirtualkeyboard/qvirtualkeyboarddictionarymanager.html" translate="no">QVirtualKeyboardDictionaryManager</a>, <a href="../qtvirtualkeyboard/qvirtualkeyboardinputcontext.html" translate="no">QVirtualKeyboardInputContext</a>, <a href="../qtvirtualkeyboard/qvirtualkeyboardinputengine.html" translate="no">QVirtualKeyboardInputEngine</a>, <a href="../qtvirtualkeyboard/qvirtualkeyboardobserver.html" translate="no">QVirtualKeyboardObserver</a>, <a href="../qtvirtualkeyboard/qvirtualkeyboardtrace.html" translate="no">QVirtualKeyboardTrace</a>, <a href="../qtwaylandcompositor/qwaylandclient.html" translate="no">QWaylandClient</a>, <a href="../qtwaylandcompositor/qwaylandobject.html" translate="no">QWaylandObject</a>, <a href="../qtwaylandcompositor/qwaylandquickshellintegration.html" translate="no">QWaylandQuickShellIntegration</a>, <a href="../qtwaylandcompositor/qwaylandsurfacegrabber.html" translate="no">QWaylandSurfaceGrabber</a>, <a href="../qtwaylandcompositor/qwaylandview.html" translate="no">QWaylandView</a>, <a href="../qtwaylandcompositor/qwaylandxdgpopup.html" translate="no">QWaylandXdgPopup</a>, <a href="../qtwaylandcompositor/qwaylandxdgtoplevel.html" translate="no">QWaylandXdgToplevel</a>, <a href="../qtwebchannel/qwebchannel.html" translate="no">QWebChannel</a>, <a href="../qtwebchannel/qwebchannelabstracttransport.html" translate="no">QWebChannelAbstractTransport</a>, <a href="../qtwebengine/qwebenginecontextmenurequest.html" translate="no">QWebEngineContextMenuRequest</a>, <a href="../qtwebengine/qwebenginecookiestore.html" translate="no">QWebEngineCookieStore</a>, <a href="../qtwebengine/qwebenginedownloadrequest.html" translate="no">QWebEngineDownloadRequest</a>, <a href="../qtwebengine/qwebenginehistory.html" translate="no">QWebEngineHistory</a>, <a href="../qtwebengine/qwebenginenavigationrequest.html" translate="no">QWebEngineNavigationRequest</a>, <a href="../qtwebengine/qwebenginenewwindowrequest.html" translate="no">QWebEngineNewWindowRequest</a>, <a href="../qtwebengine/qwebenginenotification.html" translate="no">QWebEngineNotification</a>, <a href="../qtwebengine/qwebenginepage.html" translate="no">QWebEnginePage</a>, <a href="../qtwebengine/qwebengineprofile.html" translate="no">QWebEngineProfile</a>, <a href="../qtwebengine/qwebengineurlrequestinterceptor.html" translate="no">QWebEngineUrlRequestInterceptor</a>, <a href="../qtwebengine/qwebengineurlrequestjob.html" translate="no">QWebEngineUrlRequestJob</a>, <a href="../qtwebengine/qwebengineurlschemehandler.html" translate="no">QWebEngineUrlSchemeHandler</a>, <a href="../qtwebengine/qwebenginewebauthuxrequest.html" translate="no">QWebEngineWebAuthUxRequest</a>, <a href="../qtwebsockets/qwebsocket.html" translate="no">QWebSocket</a>, <a href="../qtwebsockets/qwebsocketserver.html" translate="no">QWebSocketServer</a>, <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>, <a href="../qtgui/qwindow.html" translate="no">QWindow</a>, <a href="../qtmultimedia/qwindowcapture.html" translate="no">QWindowCapture</a>, and <a href="qwineventnotifier.html" translate="no">QWinEventNotifier</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qobject-members.html">List of all members, including inherited members</a></li>
<li><a href="qobject-obsolete.html">Deprecated members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<p><b>Note:</b> These functions are also <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>:</p>
<ul>
<li><a href="qobject.html#connect" translate="no">connect</a>(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)</li>
<li><a href="qobject.html#connect-2" translate="no">connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type) const</a></li>
<li><a href="qobject.html#connect-3" translate="no">connect</a>(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)</li>
<li><a href="qobject.html#connect-4" translate="no">connect</a>(const QObject *sender, PointerToMemberFunction signal, Functor functor)</li>
<li><a href="qobject.html#connect-5" translate="no">connect</a>(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type)</li>
<li><a href="qobject.html#disconnect" translate="no">disconnect</a>(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</li>
<li><a href="qobject.html#disconnect-2" translate="no">disconnect(const char *signal, const QObject *receiver, const char *method) const</a></li>
<li><a href="qobject.html#disconnect-5" translate="no">disconnect</a>(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)</li>
<li><a href="qobject.html#deleteLater" translate="no">deleteLater</a>()</li>
</ul>
<h2 id="properties">Properties</h2>
<ul>
<li class="fn" translate="no"><b><a href="qobject.html#objectName-prop" translate="no">objectName</a></b> : QString</li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#QObject" translate="no">QObject</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#dtor.QObject" translate="no">~QObject</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;QString&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#objectName-prop" translate="no">bindableObjectName</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#blockSignals" translate="no">blockSignals</a></b>(bool <i>block</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QObjectList &amp;</td><td class="memItemRight bottomAlign"><b><a href="qobject.html#children" translate="no">children</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaObject::Connection </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#connect-2" translate="no">connect</a></b>(const QObject *<i>sender</i>, const char *<i>signal</i>, const char *<i>method</i>, Qt::ConnectionType <i>type</i> = Qt::AutoConnection) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#disconnect-2" translate="no">disconnect</a></b>(const char *<i>signal</i> = nullptr, const QObject *<i>receiver</i> = nullptr, const char *<i>method</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#disconnect-3" translate="no">disconnect</a></b>(const QObject *<i>receiver</i>, const char *<i>method</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#dumpObjectInfo" translate="no">dumpObjectInfo</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#dumpObjectTree" translate="no">dumpObjectTree</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#dynamicPropertyNames" translate="no">dynamicPropertyNames</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#event" translate="no">event</a></b>(QEvent *<i>e</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#eventFilter" translate="no">eventFilter</a></b>(QObject *<i>watched</i>, QEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#findChild" translate="no">findChild</a></b>(QAnyStringView <i>name</i>, Qt::FindChildOptions <i>options</i> = Qt::FindChildrenRecursively) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> T </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#findChild-1" translate="no">findChild</a></b>(Qt::FindChildOptions <i>options</i> = Qt::FindChildrenRecursively) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#findChildren" translate="no">findChildren</a></b>(QAnyStringView <i>name</i>, Qt::FindChildOptions <i>options</i> = Qt::FindChildrenRecursively) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#findChildren-1" translate="no">findChildren</a></b>(Qt::FindChildOptions <i>options</i> = Qt::FindChildrenRecursively) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#findChildren-2" translate="no">findChildren</a></b>(const QRegularExpression &amp;<i>re</i>, Qt::FindChildOptions <i>options</i> = Qt::FindChildrenRecursively) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#inherits" translate="no">inherits</a></b>(const char *<i>className</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#installEventFilter" translate="no">installEventFilter</a></b>(QObject *<i>filterObj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#isQuickItemType" translate="no">isQuickItemType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#isWidgetType" translate="no">isWidgetType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#isWindowType" translate="no">isWindowType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#killTimer" translate="no">killTimer</a></b>(int <i>id</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual const QMetaObject *</td><td class="memItemRight bottomAlign"><b><a href="qobject.html#metaObject" translate="no">metaObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#moveToThread" translate="no">moveToThread</a></b>(QThread *<i>targetThread</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#objectName-prop" translate="no">objectName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="qobject.html#parent" translate="no">parent</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#property" translate="no">property</a></b>(const char *<i>name</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#removeEventFilter" translate="no">removeEventFilter</a></b>(QObject *<i>obj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#setObjectName" translate="no">setObjectName</a></b>(const QString &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#setObjectName-1" translate="no">setObjectName</a></b>(QAnyStringView <i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#setParent" translate="no">setParent</a></b>(QObject *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#setProperty" translate="no">setProperty</a></b>(const char *<i>name</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#setProperty-1" translate="no">setProperty</a></b>(const char *<i>name</i>, QVariant &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#signalsBlocked" translate="no">signalsBlocked</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#startTimer" translate="no">startTimer</a></b>(int <i>interval</i>, Qt::TimerType <i>timerType</i> = Qt::CoarseTimer)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#startTimer-1" translate="no">startTimer</a></b>(std::chrono::milliseconds <i>interval</i>, Qt::TimerType <i>timerType</i> = Qt::CoarseTimer)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QThread *</td><td class="memItemRight bottomAlign"><b><a href="qobject.html#thread" translate="no">thread</a></b>() const</td></tr>
</table></div>
<h2 id="public-slots">Public Slots</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#deleteLater" translate="no">deleteLater</a></b>()</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#destroyed" translate="no">destroyed</a></b>(QObject *<i>obj</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#objectNameChanged" translate="no">objectNameChanged</a></b>(const QString &amp;<i>objectName</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QMetaObject::Connection </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#connect" translate="no">connect</a></b>(const QObject *<i>sender</i>, const char *<i>signal</i>, const QObject *<i>receiver</i>, const char *<i>method</i>, Qt::ConnectionType <i>type</i> = Qt::AutoConnection)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaObject::Connection </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#connect-1" translate="no">connect</a></b>(const QObject *<i>sender</i>, const QMetaMethod &amp;<i>signal</i>, const QObject *<i>receiver</i>, const QMetaMethod &amp;<i>method</i>, Qt::ConnectionType <i>type</i> = Qt::AutoConnection)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaObject::Connection </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#connect-3" translate="no">connect</a></b>(const QObject *<i>sender</i>, PointerToMemberFunction <i>signal</i>, const QObject *<i>receiver</i>, PointerToMemberFunction <i>method</i>, Qt::ConnectionType <i>type</i> = Qt::AutoConnection)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaObject::Connection </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#connect-4" translate="no">connect</a></b>(const QObject *<i>sender</i>, PointerToMemberFunction <i>signal</i>, Functor <i>functor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaObject::Connection </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#connect-5" translate="no">connect</a></b>(const QObject *<i>sender</i>, PointerToMemberFunction <i>signal</i>, const QObject *<i>context</i>, Functor <i>functor</i>, Qt::ConnectionType <i>type</i> = Qt::AutoConnection)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#disconnect" translate="no">disconnect</a></b>(const QObject *<i>sender</i>, const char *<i>signal</i>, const QObject *<i>receiver</i>, const char *<i>method</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#disconnect-1" translate="no">disconnect</a></b>(const QObject *<i>sender</i>, const QMetaMethod &amp;<i>signal</i>, const QObject *<i>receiver</i>, const QMetaMethod &amp;<i>method</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#disconnect-4" translate="no">disconnect</a></b>(const QMetaObject::Connection &amp;<i>connection</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#disconnect-5" translate="no">disconnect</a></b>(const QObject *<i>sender</i>, PointerToMemberFunction <i>signal</i>, const QObject *<i>receiver</i>, PointerToMemberFunction <i>method</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#staticMetaObject-var" translate="no">staticMetaObject</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#tr" translate="no">tr</a></b>(const char *<i>sourceText</i>, const char *<i>disambiguation</i> = nullptr, int <i>n</i> = -1)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#childEvent" translate="no">childEvent</a></b>(QChildEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#connectNotify" translate="no">connectNotify</a></b>(const QMetaMethod &amp;<i>signal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#customEvent" translate="no">customEvent</a></b>(QEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#disconnectNotify" translate="no">disconnectNotify</a></b>(const QMetaMethod &amp;<i>signal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#isSignalConnected" translate="no">isSignalConnected</a></b>(const QMetaMethod &amp;<i>signal</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#receivers" translate="no">receivers</a></b>(const char *<i>signal</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="qobject.html#sender" translate="no">sender</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#senderSignalIndex" translate="no">senderSignalIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#timerEvent" translate="no">timerEvent</a></b>(QTimerEvent *<i>event</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#QObjectList-typedef" translate="no">QObjectList</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#qobject_cast" translate="no">qobject_cast</a></b>(QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#qobject_cast-1" translate="no">qobject_cast</a></b>(const QObject *<i>object</i>)</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#QT_NO_CONTEXTLESS_CONNECT" translate="no">QT_NO_CONTEXTLESS_CONNECT</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#QT_NO_NARROWING_CONVERSIONS_IN_CONNECT" translate="no">QT_NO_NARROWING_CONVERSIONS_IN_CONNECT</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_CLASSINFO" translate="no">Q_CLASSINFO</a></b>(<i>Name</i>, <i>Value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_EMIT" translate="no">Q_EMIT</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_ENUM" translate="no">Q_ENUM</a></b>(...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_ENUM_NS" translate="no">Q_ENUM_NS</a></b>(...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_FLAG" translate="no">Q_FLAG</a></b>(...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_FLAG_NS" translate="no">Q_FLAG_NS</a></b>(...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_GADGET" translate="no">Q_GADGET</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_GADGET_EXPORT" translate="no">Q_GADGET_EXPORT</a></b>(<i>EXPORT_MACRO</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_INTERFACES" translate="no">Q_INTERFACES</a></b>(...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_MOC_INCLUDE" translate="no">Q_MOC_INCLUDE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_NAMESPACE_EXPORT" translate="no">Q_NAMESPACE_EXPORT</a></b>(<i>EXPORT_MACRO</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a></b>(...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_REVISION" translate="no">Q_REVISION</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_SET_OBJECT_NAME" translate="no">Q_SET_OBJECT_NAME</a></b>(<i>Object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_SIGNAL" translate="no">Q_SIGNAL</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_SIGNALS" translate="no">Q_SIGNALS</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_SLOT" translate="no">Q_SLOT</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobject.html#Q_SLOTS" translate="no">Q_SLOTS</a></b></td></tr>
</table></div>
<!-- $$$QObject-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QObject is the heart of the Qt <a href="object.html" translate="no">Object Model</a>. The central feature in this model is a very powerful mechanism for seamless object communication called <a href="signalsandslots.html" translate="no">signals and slots</a>. You can connect a signal to a slot with <a href="qobject.html#connect" translate="no">connect</a>() and destroy the connection with <a href="qobject.html#disconnect" translate="no">disconnect</a>(). To avoid never ending notification loops you can temporarily block signals with <a href="qobject.html#blockSignals" translate="no">blockSignals</a>(). The protected functions <a href="qobject.html#connectNotify" translate="no">connectNotify</a>() and <a href="qobject.html#disconnectNotify" translate="no">disconnectNotify</a>() make it possible to track connections.</p>
<p>QObjects organize themselves in <a href="objecttrees.html" translate="no">object trees</a>. When you create a QObject with another object as parent, the object will automatically add itself to the parent's <a href="qobject.html#children" translate="no">children</a>() list. The parent takes ownership of the object; i.e., it will automatically delete its children in its destructor. You can look for an object by name and optionally type using <a href="qobject.html#findChild" translate="no">findChild</a>() or <a href="qobject.html#findChildren" translate="no">findChildren</a>().</p>
<p>Every object has an <a href="qobject.html#objectName-prop" translate="no">objectName</a>() and its class name can be found via the corresponding <a href="qobject.html#metaObject" translate="no">metaObject</a>() (see <a href="qmetaobject.html#className" translate="no">QMetaObject::className</a>()). You can determine whether the object's class inherits another class in the QObject inheritance hierarchy by using the <a href="qobject.html#inherits" translate="no">inherits</a>() function.</p>
<p>When an object is deleted, it emits a <a href="qobject.html#destroyed" translate="no">destroyed</a>() signal. You can catch this signal to avoid dangling references to QObjects.</p>
<p>QObjects can receive events through <a href="qobject.html#event" translate="no">event</a>() and filter the events of other objects. See <a href="qobject.html#installEventFilter" translate="no">installEventFilter</a>() and <a href="qobject.html#eventFilter" translate="no">eventFilter</a>() for details. A convenience handler, <a href="qobject.html#childEvent" translate="no">childEvent</a>(), can be reimplemented to catch child events.</p>
<p>Last but not least, QObject provides the basic timer support in Qt; see <a href="qtimer.html" translate="no">QTimer</a> for high-level support for timers.</p>
<p>Notice that the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro is mandatory for any object that implements signals, slots or properties. You also need to run the <a href="../qtdoc/moc.html" translate="no">Meta Object Compiler</a> on the source file. We strongly recommend the use of this macro in all subclasses of QObject regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.</p>
<p>All Qt widgets inherit QObject. The convenience function <a href="qobject.html#isWidgetType" translate="no">isWidgetType</a>() returns whether an object is actually a widget. It is much faster than <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>&lt;<a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> *&gt;(<i>obj</i>) or <i>obj</i>-&gt;<a href="qobject.html#inherits" translate="no">inherits</a>(&quot;<a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>&quot;).</p>
<p>Some QObject functions, e.g. <a href="qobject.html#children" translate="no">children</a>(), return a <a href="qobject.html#QObjectList-typedef" translate="no">QObjectList</a>. <a href="qobject.html#QObjectList-typedef" translate="no">QObjectList</a> is a typedef for <a href="qlist.html" translate="no">QList</a>&lt;QObject *&gt;.</p>
<h3 id="thread-affinity">Thread Affinity</h3>
<p>A QObject instance is said to have a <i>thread affinity</i>, or that it <i>lives</i> in a certain thread. When a QObject receives a <a href="qt.html#ConnectionType-enum" translate="no">queued signal</a> or a <a href="eventsandfilters.html#sending-events" translate="no">posted event</a>, the slot or event handler will run in the thread that the object lives in.</p>
<div class="admonition note">
<p><b>Note: </b>If a QObject has no thread affinity (that is, if <a href="qobject.html#thread" translate="no">thread</a>() returns zero), or if it lives in a thread that has no running event loop, then it cannot receive queued signals or posted events.</p>
</div>
<p>By default, a QObject lives in the thread in which it is created. An object's thread affinity can be queried using <a href="qobject.html#thread" translate="no">thread</a>() and changed using <a href="qobject.html#moveToThread" translate="no">moveToThread</a>().</p>
<p>All QObjects must live in the same thread as their parent. Consequently:</p>
<ul>
<li><a href="qobject.html#setParent" translate="no">setParent</a>() will fail if the two QObjects involved live in different threads.</li>
<li>When a QObject is moved to another thread, all its children will be automatically moved too.</li>
<li><a href="qobject.html#moveToThread" translate="no">moveToThread</a>() will fail if the QObject has a parent.</li>
<li>If QObjects are created within <a href="qthread.html#run" translate="no">QThread::run</a>(), they cannot become children of the <a href="qthread.html" translate="no">QThread</a> object because the <a href="qthread.html" translate="no">QThread</a> does not live in the thread that calls <a href="qthread.html#run" translate="no">QThread::run</a>().</li>
</ul>
<div class="admonition note">
<p><b>Note: </b>A QObject's member variables <i>do not</i> automatically become its children. The parent-child relationship must be set by either passing a pointer to the child's <a href="qobject.html#QObject" translate="no">constructor</a>, or by calling <a href="qobject.html#setParent" translate="no">setParent</a>(). Without this step, the object's member variables will remain in the old thread when <a href="qobject.html#moveToThread" translate="no">moveToThread</a>() is called.</p>
</div>
<span id="no-copy-constructor"></span><h3 id="no-copy-constructor-or-assignment-operator">No Copy Constructor or Assignment Operator</h3>
<p>QObject has neither a copy constructor nor an assignment operator. This is by design. Actually, they are declared, but in a <code translate="no">private</code> section with the macro <a href="qtclasshelpermacros-qtcore-proxy.html#Q_DISABLE_COPY" translate="no">Q_DISABLE_COPY</a>(). In fact, all Qt classes derived from QObject (direct or indirect) use this macro to declare their copy constructor and assignment operator to be private. The reasoning is found in the discussion on <a href="object.html#identity-vs-value" translate="no">Identity vs Value</a> on the Qt <a href="object.html" translate="no">Object Model</a> page.</p>
<p>The main consequence is that you should use pointers to QObject (or to your QObject subclass) where you might otherwise be tempted to use your QObject subclass as a value. For example, without a copy constructor, you can't use a subclass of QObject as the value to be stored in one of the container classes. You must store pointers.</p>
<h3 id="auto-connection">Auto-Connection</h3>
<p>Qt's meta-object system provides a mechanism to automatically connect signals and slots between QObject subclasses and their children. As long as objects are defined with suitable object names, and slots follow a simple naming convention, this connection can be performed at run-time by the <a href="qmetaobject.html#connectSlotsByName" translate="no">QMetaObject::connectSlotsByName</a>() function.</p>
<p><a href="../qtdoc/uic.html" translate="no">uic</a> generates code that invokes this function to enable auto-connection to be performed between widgets on forms created with <i>Qt Designer</i>. More information about using auto-connection with <i>Qt Designer</i> is given in the <a href="../qtdesigner/designer-using-a-ui-file.html" translate="no">Using a Designer UI File in Your Application</a> section of the <i>Qt Designer</i> manual.</p>
<h3 id="dynamic-properties">Dynamic Properties</h3>
<p>Dynamic properties can be added to and removed from QObject instances at run-time. Dynamic properties do not need to be declared at compile-time, yet they provide the same advantages as static properties and are manipulated using the same API - using <a href="qobject.html#property" translate="no">property</a>() to read them and <a href="qobject.html#setProperty" translate="no">setProperty</a>() to write them.</p>
<p>Dynamic properties are supported by <a href="../qtdesigner/designer-widget-mode.html#the-property-editor" translate="no">Qt Designer</a>, and both standard Qt widgets and user-created forms can be given dynamic properties.</p>
<h3 id="internationalization-i18n">Internationalization (I18n)</h3>
<p>All QObject subclasses support Qt's translation features, making it possible to translate an application's user interface into different languages.</p>
<p>To make user-visible text translatable, it must be wrapped in calls to the <a href="qobject.html#tr" translate="no">tr</a>() function. This is explained in detail in the <a href="../qtdoc/i18n-source-translation.html" translate="no">Writing Source Code for Translation</a> document.</p>
</div>
<p><b>See also </b><a href="qmetaobject.html" translate="no">QMetaObject</a>, <a href="qpointer.html" translate="no">QPointer</a>, <a href="qobjectcleanuphandler.html" translate="no">QObjectCleanupHandler</a>, <a href="qtclasshelpermacros-qtcore-proxy.html#Q_DISABLE_COPY" translate="no">Q_DISABLE_COPY</a>(), and <a href="objecttrees.html" translate="no">Object Trees &amp; Ownership</a>.</p>
<!-- @@@QObject -->
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$objectName-prop$$$objectName$$$setObjectNameconstQString&$$$setObjectNameQAnyStringView$$$objectNameChangedconstQString&$$$bindableObjectName -->
<h3 class="fn" translate="no" id="objectName-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">objectName</span> : <span class="type"><a href="qstring.html" translate="no">QString</a></span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds the name of this object</p>
<p>You can find an object by name (and type) using <a href="qobject.html#findChild" translate="no">findChild</a>(). You can find a set of objects with <a href="qobject.html#findChildren" translate="no">findChildren</a>().</p>
<pre class="cpp" translate="no">
 <a href="qtlogging.html#qDebug" translate="no">qDebug</a>(<span class="string">&quot;MyClass::setPrecision(): (%s) invalid precision %f&quot;</span><span class="operator">,</span>
        <a href="qstring.html#qPrintable" translate="no">qPrintable</a>(objectName())<span class="operator">,</span> newPrecision);
</pre>
<p>By default, this property contains an empty string.</p>
<p><b>See also </b><a href="qobject.html#metaObject" translate="no">metaObject</a>() and <a href="qmetaobject.html#className" translate="no">QMetaObject::className</a>().</p>
<!-- @@@objectName -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QObject[overload1]$$$QObjectQObject* -->
<h3 class="fn" translate="no" id="QObject"><code class="details extra" translate="no">[explicit invokable]</code> QObject::<span class="name">QObject</span>(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs an object with parent object <i translate="no">parent</i>.</p>
<p>The parent of an object may be viewed as the object's owner. For instance, a <a href="../qtwidgets/qdialog.html" translate="no">dialog box</a> is the parent of the <b translate="no">OK</b> and <b translate="no">Cancel</b> buttons it contains.</p>
<p>The destructor of a parent object destroys all child objects.</p>
<p>Setting <i translate="no">parent</i> to <code translate="no">nullptr</code> constructs an object with no parent. If the object is a widget, it will become a top-level window.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p><b>See also </b><a href="qobject.html#parent" translate="no">parent</a>(), <a href="qobject.html#findChild" translate="no">findChild</a>(), and <a href="qobject.html#findChildren" translate="no">findChildren</a>().</p>
<!-- @@@QObject -->
<!-- $$$~QObject[overload1]$$$~QObject -->
<h3 class="fn" translate="no" id="dtor.QObject"><code class="details extra" translate="no">[virtual noexcept]</code> QObject::<span class="name">~QObject</span>()</h3>
<p>Destroys the object, deleting all its child objects.</p>
<p>All signals to and from the object are automatically disconnected, and any pending posted events for the object are removed from the event queue. However, it is often safer to use <a href="qobject.html#deleteLater" translate="no">deleteLater</a>() rather than deleting a <a href="qobject.html" translate="no">QObject</a> subclass directly.</p>
<div class="admonition warning">
<p><b>Warning: </b>All child objects are deleted. If any of these objects are on the stack or global, sooner or later your program will crash. We do not recommend holding pointers to child objects from outside the parent. If you still do, the <a href="qobject.html#destroyed" translate="no">destroyed</a>() signal gives you an opportunity to detect when an object is destroyed.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>Deleting a <a href="qobject.html" translate="no">QObject</a> while pending events are waiting to be delivered can cause a crash. You must not delete the <a href="qobject.html" translate="no">QObject</a> directly if it exists in a different thread than the one currently executing. Use <a href="qobject.html#deleteLater" translate="no">deleteLater</a>() instead, which will cause the event loop to delete the object after all pending events have been delivered to it.</p>
</div>
<p><b>See also </b><a href="qobject.html#deleteLater" translate="no">deleteLater</a>().</p>
<!-- @@@~QObject -->
<!-- $$$blockSignals[overload1]$$$blockSignalsbool -->
<h3 class="fn" translate="no" id="blockSignals"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QObject::<span class="name">blockSignals</span>(<span class="type">bool</span> <i>block</i>)</h3>
<p>If <i translate="no">block</i> is true, signals emitted by this object are blocked (i.e., emitting a signal will not invoke anything connected to it). If <i translate="no">block</i> is false, no such blocking will occur.</p>
<p>The return value is the previous value of <a href="qobject.html#signalsBlocked" translate="no">signalsBlocked</a>().</p>
<p>Note that the <a href="qobject.html#destroyed" translate="no">destroyed</a>() signal will be emitted even if the signals for this object have been blocked.</p>
<p>Signals emitted while being blocked are not buffered.</p>
<p><b>See also </b><a href="qobject.html#signalsBlocked" translate="no">signalsBlocked</a>() and <a href="qsignalblocker.html" translate="no">QSignalBlocker</a>.</p>
<!-- @@@blockSignals -->
<!-- $$$childEvent[overload1]$$$childEventQChildEvent* -->
<h3 class="fn" translate="no" id="childEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QObject::<span class="name">childEvent</span>(<span class="type"><a href="qchildevent.html" translate="no">QChildEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive child events. The event is passed in the <i translate="no">event</i> parameter.</p>
<p><a href="qevent.html#Type-enum" translate="no">QEvent::ChildAdded</a> and <a href="qevent.html#Type-enum" translate="no">QEvent::ChildRemoved</a> events are sent to objects when children are added or removed. In both cases you can only rely on the child being a <a href="qobject.html" translate="no">QObject</a>, or if <a href="qobject.html#isWidgetType" translate="no">isWidgetType</a>() returns <code translate="no">true</code>, a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a>. (This is because, in the <a href="qevent.html#Type-enum" translate="no">ChildAdded</a> case, the child is not yet fully constructed, and in the <a href="qevent.html#Type-enum" translate="no">ChildRemoved</a> case it might have been destructed already).</p>
<p><a href="qevent.html#Type-enum" translate="no">QEvent::ChildPolished</a> events are sent to widgets when children are polished, or when polished children are added. If you receive a child polished event, the child's construction is usually completed. However, this is not guaranteed, and multiple polish events may be delivered during the execution of a widget's constructor.</p>
<p>For every child widget, you receive one <a href="qevent.html#Type-enum" translate="no">ChildAdded</a> event, zero or more <a href="qevent.html#Type-enum" translate="no">ChildPolished</a> events, and one <a href="qevent.html#Type-enum" translate="no">ChildRemoved</a> event.</p>
<p>The <a href="qevent.html#Type-enum" translate="no">ChildPolished</a> event is omitted if a child is removed immediately after it is added. If a child is polished several times during construction and destruction, you may receive several child polished events for the same child, each time with a different virtual table.</p>
<p><b>See also </b><a href="qobject.html#event" translate="no">event</a>().</p>
<!-- @@@childEvent -->
<!-- $$$children[overload1]$$$children -->
<h3 class="fn" translate="no" id="children">const <span class="type"><a href="qobject.html#QObjectList-typedef" translate="no">QObjectList</a></span> &amp;QObject::<span class="name">children</span>() const</h3>
<p>Returns a list of child objects. The <a href="qobject.html#QObjectList-typedef" translate="no">QObjectList</a> class is defined in the <code translate="no">&lt;QObject&gt;</code> header file as the following:</p>
<pre class="cpp" translate="no">
 <span class="keyword">typedef</span> <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">*</span><span class="operator">&gt;</span> <span class="type"><a href="qobject.html#QObjectList-typedef" translate="no">QObjectList</a></span>;
</pre>
<p>The first child added is the <a href="qlist.html#first" translate="no">first</a> object in the list and the last child added is the <a href="qlist.html#last" translate="no">last</a> object in the list, i.e. new children are appended at the end.</p>
<p>Note that the list order changes when <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> children are <a href="../qtwidgets/qwidget.html#raise" translate="no">raised</a> or <a href="../qtwidgets/qwidget.html#lower" translate="no">lowered</a>. A widget that is raised becomes the last object in the list, and a widget that is lowered becomes the first object in the list.</p>
<p><b>See also </b><a href="qobject.html#findChild" translate="no">findChild</a>(), <a href="qobject.html#findChildren" translate="no">findChildren</a>(), <a href="qobject.html#parent" translate="no">parent</a>(), and <a href="qobject.html#setParent" translate="no">setParent</a>().</p>
<!-- @@@children -->
<!-- $$$connect[overload1]$$$connectconstQObject*constchar*constQObject*constchar*Qt::ConnectionType -->
<h3 class="fn" translate="no" id="connect"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a></span> QObject::<span class="name">connect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>sender</i>, const <span class="type">char</span> *<i>signal</i>, const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i>, const <span class="type">char</span> *<i>method</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i> = Qt::AutoConnection)</h3>
<p>Creates a connection of the given <i translate="no">type</i> from the <i translate="no">signal</i> in the <i translate="no">sender</i> object to the <i translate="no">method</i> in the <i translate="no">receiver</i> object. Returns a handle to the connection that can be used to disconnect it later.</p>
<p>You must use the <code translate="no">SIGNAL()</code> and <code translate="no">SLOT()</code> macros when specifying the <i translate="no">signal</i> and the <i translate="no">method</i>, for example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span> <span class="operator">*</span>label <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span>;
 <span class="type"><a href="../qtwidgets/qscrollbar.html" translate="no">QScrollBar</a></span> <span class="operator">*</span>scrollBar <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qscrollbar.html" translate="no">QScrollBar</a></span>;
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(scrollBar<span class="operator">,</span> SIGNAL(valueChanged(<span class="type">int</span>))<span class="operator">,</span>
                  label<span class="operator">,</span>  SLOT(setNum(<span class="type">int</span>)));
</pre>
<p>This example ensures that the label always displays the current scroll bar value. Note that the signal and slots parameters must not contain any variable names, only the type. E.g. the following would not work and return false:</p>
<pre class="cpp" translate="no">
 <span class="comment">// WRONG</span>
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(scrollBar<span class="operator">,</span> SIGNAL(valueChanged(<span class="type">int</span> value))<span class="operator">,</span>
                  label<span class="operator">,</span> SLOT(setNum(<span class="type">int</span> value)));
</pre>
<p>A signal can also be connected to another signal:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyWidget : <span class="keyword">public</span> <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     MyWidget();

 <span class="keyword">signals</span>:
     <span class="type">void</span> buttonClicked();

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span>myButton;
 };

 MyWidget<span class="operator">::</span>MyWidget()
 {
     myButton <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span>(<span class="keyword">this</span>);
     connect(myButton<span class="operator">,</span> SIGNAL(clicked())<span class="operator">,</span>
             <span class="keyword">this</span><span class="operator">,</span> SIGNAL(buttonClicked()));
 }
</pre>
<p>In this example, the <code translate="no">MyWidget</code> constructor relays a signal from a private member variable, and makes it available under a name that relates to <code translate="no">MyWidget</code>.</p>
<p>A signal can be connected to many slots and signals. Many signals can be connected to one slot.</p>
<p>If a signal is connected to several slots, the slots are activated in the same order in which the connections were made, when the signal is emitted.</p>
<p>The function returns a <a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a> that represents a handle to a connection if it successfully connects the signal to the slot. The connection handle will be invalid if it cannot create the connection, for example, if <a href="qobject.html" translate="no">QObject</a> is unable to verify the existence of either <i translate="no">signal</i> or <i translate="no">method</i>, or if their signatures aren't compatible. You can check if the handle is valid by casting it to a bool.</p>
<p>By default, a signal is emitted for every connection you make; two signals are emitted for duplicate connections. You can break all of these connections with a single <a href="qobject.html#disconnect" translate="no">disconnect</a>() call. If you pass the <a href="qt.html#ConnectionType-enum" translate="no">Qt::UniqueConnection</a> <i translate="no">type</i>, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return an invalid <a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a>.</p>
<div class="admonition note">
<p><b>Note: </b>Qt::UniqueConnections do not work for lambdas, non-member functions and functors; they only apply to connecting to member functions.</p>
</div>
<p>The optional <i translate="no">type</i> parameter describes the type of connection to establish. In particular, it determines whether a particular signal is delivered to a slot immediately or queued for delivery at a later time. If the signal is queued, the parameters must be of types that are known to Qt's meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect: Cannot queue arguments of type <span class="char">'MyType'</span>
 (Make sure <span class="char">'MyType'</span> is registered <span class="keyword">using</span> <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>()<span class="operator">.</span>)
</pre>
<p>call <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>() to register the data type before you establish the connection.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="qobject.html#disconnect" translate="no">disconnect</a>(), <a href="qobject.html#sender" translate="no">sender</a>(), <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>(), <a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>(), and <a href="../qtdoc/signalsandslots-syntaxes.html" translate="no">Differences between String-Based and Functor-Based Connections</a>.</p>
<!-- @@@connect -->
<!-- $$$connect$$$connectconstQObject*constQMetaMethod&constQObject*constQMetaMethod&Qt::ConnectionType -->
<h3 class="fn" translate="no" id="connect-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a></span> QObject::<span class="name">connect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>sender</i>, const <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> &amp;<i>signal</i>, const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i>, const <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> &amp;<i>method</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i> = Qt::AutoConnection)</h3>
<p>Creates a connection of the given <i translate="no">type</i> from the <i translate="no">signal</i> in the <i translate="no">sender</i> object to the <i translate="no">method</i> in the <i translate="no">receiver</i> object. Returns a handle to the connection that can be used to disconnect it later.</p>
<p>The Connection handle will be invalid if it cannot create the connection, for example, the parameters were invalid. You can check if the <a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a> is valid by casting it to a bool.</p>
<p>This function works in the same way as <code translate="no">connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)</code> but it uses <a href="qmetamethod.html" translate="no">QMetaMethod</a> to specify signal and method.</p>
<p><b>See also </b><a href="qobject.html#connect" translate="no">connect</a>(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type).</p>
<!-- @@@connect -->
<!-- $$$connect$$$connectconstQObject*constchar*constchar*Qt::ConnectionType -->
<h3 class="fn" translate="no" id="connect-2"><span class="type"><a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a></span> QObject::<span class="name">connect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>sender</i>, const <span class="type">char</span> *<i>signal</i>, const <span class="type">char</span> *<i>method</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i> = Qt::AutoConnection) const</h3>
<p>This function overloads connect().</p>
<p>Connects <i translate="no">signal</i> from the <i translate="no">sender</i> object to this object's <i translate="no">method</i>.</p>
<p>Equivalent to connect(<i translate="no">sender</i>, <i translate="no">signal</i>, <code translate="no">this</code>, <i translate="no">method</i>, <i translate="no">type</i>).</p>
<p>Every connection you make emits a signal, so duplicate connections emit two signals. You can break a connection using <a href="qobject.html#disconnect" translate="no">disconnect</a>().</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="qobject.html#disconnect" translate="no">disconnect</a>().</p>
<!-- @@@connect -->
<!-- $$$connect$$$connectconstQObject*PointerToMemberFunctionconstQObject*PointerToMemberFunctionQt::ConnectionType -->
<h3 class="fn" translate="no" id="connect-3"><code class="details extra" translate="no">[static]</code> template &lt;typename PointerToMemberFunction&gt; <span class="type"><a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a></span> QObject::<span class="name">connect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>sender</i>, <span class="type">PointerToMemberFunction</span> <i>signal</i>, const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i>, <span class="type">PointerToMemberFunction</span> <i>method</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i> = Qt::AutoConnection)</h3>
<p>This function overloads connect().</p>
<p>Creates a connection of the given <i translate="no">type</i> from the <i translate="no">signal</i> in the <i translate="no">sender</i> object to the <i translate="no">method</i> in the <i translate="no">receiver</i> object. Returns a handle to the connection that can be used to disconnect it later.</p>
<p>The signal must be a function declared as a signal in the header. The slot function can be any member function that can be connected to the signal. A slot can be connected to a given signal if the signal has at least as many arguments as the slot, and there is an implicit conversion between the types of the corresponding arguments in the signal and the slot.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span> <span class="operator">*</span>label <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span>;
 <span class="type"><a href="../qtwidgets/qlineedit.html" translate="no">QLineEdit</a></span> <span class="operator">*</span>lineEdit <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qlineedit.html" translate="no">QLineEdit</a></span>;
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(lineEdit<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtwidgets/qlineedit.html" translate="no">QLineEdit</a></span><span class="operator">::</span>textChanged<span class="operator">,</span>
                  label<span class="operator">,</span>  <span class="operator">&amp;</span><span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span><span class="operator">::</span>setText);
</pre>
<p>This example ensures that the label always displays the current line edit text.</p>
<p>A signal can be connected to many slots and signals. Many signals can be connected to one slot.</p>
<p>If a signal is connected to several slots, the slots are activated in the same order as the order the connection was made, when the signal is emitted</p>
<p>The function returns an handle to a connection if it successfully connects the signal to the slot. The Connection handle will be invalid if it cannot create the connection, for example, if <a href="qobject.html" translate="no">QObject</a> is unable to verify the existence of <i translate="no">signal</i> (if it was not declared as a signal) You can check if the <a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a> is valid by casting it to a bool.</p>
<p>By default, a signal is emitted for every connection you make; two signals are emitted for duplicate connections. You can break all of these connections with a single <a href="qobject.html#disconnect" translate="no">disconnect</a>() call. If you pass the <a href="qt.html#ConnectionType-enum" translate="no">Qt::UniqueConnection</a> <i translate="no">type</i>, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return an invalid <a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a>.</p>
<p>The optional <i translate="no">type</i> parameter describes the type of connection to establish. In particular, it determines whether a particular signal is delivered to a slot immediately or queued for delivery at a later time. If the signal is queued, the parameters must be of types that are known to Qt's meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect: Cannot queue arguments of type <span class="char">'MyType'</span>
 (Make sure <span class="char">'MyType'</span> is registered <span class="keyword">using</span> <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>()<span class="operator">.</span>)
</pre>
<p>make sure to declare the argument type with <a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a></p>
<p>Overloaded functions can be resolved with help of <a href="qoverload-qtcore-proxy.html#qOverload" translate="no">qOverload</a>.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="../qtdoc/signalsandslots-syntaxes.html" translate="no">Differences between String-Based and Functor-Based Connections</a>.</p>
<!-- @@@connect -->
<!-- $$$connect$$$connectconstQObject*PointerToMemberFunctionFunctor -->
<h3 class="fn" translate="no" id="connect-4"><code class="details extra" translate="no">[static]</code> template &lt;typename PointerToMemberFunction, typename Functor&gt; <span class="type"><a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a></span> QObject::<span class="name">connect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>sender</i>, <span class="type">PointerToMemberFunction</span> <i>signal</i>, <span class="type">Functor</span> <i>functor</i>)</h3>
<p>This function overloads connect().</p>
<p>Creates a connection from <i translate="no">signal</i> in <i translate="no">sender</i> object to <i translate="no">functor</i>, and returns a handle to the connection</p>
<p>The signal must be a function declared as a signal in the header. The slot function can be any function or functor that can be connected to the signal. A slot function can be connected to a given signal if the signal has at least as many arguments as the slot function. There must exist implicit conversion between the types of the corresponding arguments in the signal and the slot.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> someFunction();
 <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span>button <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span>;
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(button<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span><span class="operator">::</span>clicked<span class="operator">,</span> someFunction);
</pre>
<p>Lambda expressions can also be used:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> page <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="type"><a href="../qtnetwork/qtcpsocket.html" translate="no">QTcpSocket</a></span> <span class="operator">*</span>socket <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtnetwork/qtcpsocket.html" translate="no">QTcpSocket</a></span>;
 socket<span class="operator">-</span><span class="operator">&gt;</span>connectToHost(<span class="string">&quot;qt-project.org&quot;</span><span class="operator">,</span> <span class="number">80</span>);
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(socket<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtnetwork/qtcpsocket.html" translate="no">QTcpSocket</a></span><span class="operator">::</span>connected<span class="operator">,</span> <span class="operator">[</span><span class="operator">=</span><span class="operator">]</span> () {
         socket<span class="operator">-</span><span class="operator">&gt;</span>write(<span class="string">&quot;GET &quot;</span> <span class="operator">+</span> page <span class="operator">+</span> <span class="string">&quot;\r\n&quot;</span>);
     });
</pre>
<p>The connection will automatically disconnect if the sender is destroyed. However, you should take care that any objects used within the functor are still alive when the signal is emitted.</p>
<p>For this reason, it is recommended to use the overload of connect() that also takes a <a href="qobject.html" translate="no">QObject</a> as a receiver/context. It is possible to disable the usage of the context-less overload by defining the <code translate="no">QT_NO_CONTEXTLESS_CONNECT</code> macro.</p>
<p>Overloaded functions can be resolved with help of <a href="qoverload-qtcore-proxy.html#qOverload" translate="no">qOverload</a>.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@connect -->
<!-- $$$connect$$$connectconstQObject*PointerToMemberFunctionconstQObject*FunctorQt::ConnectionType -->
<h3 class="fn" translate="no" id="connect-5"><code class="details extra" translate="no">[static]</code> template &lt;typename PointerToMemberFunction, typename Functor&gt; <span class="type"><a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a></span> QObject::<span class="name">connect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>sender</i>, <span class="type">PointerToMemberFunction</span> <i>signal</i>, const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> <i>functor</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>type</i> = Qt::AutoConnection)</h3>
<p>This function overloads connect().</p>
<p>Creates a connection of a given <i translate="no">type</i> from <i translate="no">signal</i> in <i translate="no">sender</i> object to <i translate="no">functor</i> to be placed in a specific event loop of <i translate="no">context</i>, and returns a handle to the connection.</p>
<div class="admonition note">
<p><b>Note: </b>Qt::UniqueConnections do not work for lambdas, non-member functions and functors; they only apply to connecting to member functions.</p>
</div>
<p>The signal must be a function declared as a signal in the header. The slot function can be any function or functor that can be connected to the signal. A slot function can be connected to a given signal if the signal has at least as many arguments as the slot function. There must exist implicit conversion between the types of the corresponding arguments in the signal and the slot.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> someFunction();
 <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span>button <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span>;
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(button<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span><span class="operator">::</span>clicked<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> someFunction<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>QueuedConnection);
</pre>
<p>Lambda expressions can also be used:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> page <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="type"><a href="../qtnetwork/qtcpsocket.html" translate="no">QTcpSocket</a></span> <span class="operator">*</span>socket <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtnetwork/qtcpsocket.html" translate="no">QTcpSocket</a></span>;
 socket<span class="operator">-</span><span class="operator">&gt;</span>connectToHost(<span class="string">&quot;qt-project.org&quot;</span><span class="operator">,</span> <span class="number">80</span>);
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(socket<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtnetwork/qtcpsocket.html" translate="no">QTcpSocket</a></span><span class="operator">::</span>connected<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">=</span><span class="operator">]</span> () {
         socket<span class="operator">-</span><span class="operator">&gt;</span>write(<span class="string">&quot;GET &quot;</span> <span class="operator">+</span> page <span class="operator">+</span> <span class="string">&quot;\r\n&quot;</span>);
     }<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>AutoConnection);
</pre>
<p>The connection will automatically disconnect if the sender or the context is destroyed. However, you should take care that any objects used within the functor are still alive when the signal is emitted.</p>
<p>Overloaded functions can be resolved with help of <a href="qoverload-qtcore-proxy.html#qOverload" translate="no">qOverload</a>.</p>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@connect -->
<!-- $$$connectNotify[overload1]$$$connectNotifyconstQMetaMethod& -->
<h3 class="fn" translate="no" id="connectNotify"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QObject::<span class="name">connectNotify</span>(const <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> &amp;<i>signal</i>)</h3>
<p>This virtual function is called when something has been connected to <i translate="no">signal</i> in this object.</p>
<p>If you want to compare <i translate="no">signal</i> with a specific signal, you can use <a href="qmetamethod.html#fromSignal" translate="no">QMetaMethod::fromSignal</a>() as follows:</p>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (signal <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span><span class="operator">::</span>fromSignal(<span class="operator">&amp;</span>MyObject<span class="operator">::</span>valueChanged)) {
     <span class="comment">// signal is valueChanged</span>
 }
</pre>
<div class="admonition warning">
<p><b>Warning: </b>This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function is called from the thread which performs the connection, which may be a different thread from the thread in which this object lives. This function may also be called with a <a href="qobject.html" translate="no">QObject</a> internal mutex locked. It is therefore not allowed to re-enter any <a href="qobject.html" translate="no">QObject</a> functions, including <a href="qobject.html#isSignalConnected" translate="no">isSignalConnected</a>(), from your reimplementation. If you lock a mutex in your reimplementation, make sure that you don't call <a href="qobject.html" translate="no">QObject</a> functions with that mutex held in other places or it will result in a deadlock.</p>
</div>
<p><b>See also </b><a href="qobject.html#connect" translate="no">connect</a>() and <a href="qobject.html#disconnectNotify" translate="no">disconnectNotify</a>().</p>
<!-- @@@connectNotify -->
<!-- $$$customEvent[overload1]$$$customEventQEvent* -->
<h3 class="fn" translate="no" id="customEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QObject::<span class="name">customEvent</span>(<span class="type"><a href="qevent.html" translate="no">QEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive custom events. Custom events are user-defined events with a type value at least as large as the <a href="qevent.html#Type-enum" translate="no">QEvent::User</a> item of the <a href="qevent.html#Type-enum" translate="no">QEvent::Type</a> enum, and is typically a <a href="qevent.html" translate="no">QEvent</a> subclass. The event is passed in the <i translate="no">event</i> parameter.</p>
<p><b>See also </b><a href="qobject.html#event" translate="no">event</a>() and <a href="qevent.html" translate="no">QEvent</a>.</p>
<!-- @@@customEvent -->
<!-- $$$deleteLater[overload1]$$$deleteLater -->
<h3 class="fn" translate="no" id="deleteLater"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QObject::<span class="name">deleteLater</span>()</h3>
<p>Schedules this object for deletion.</p>
<p>The object will be deleted when control returns to the event loop. If the event loop is not running when this function is called (e.g. deleteLater() is called on an object before <a href="qcoreapplication.html#exec" translate="no">QCoreApplication::exec</a>()), the object will be deleted once the event loop is started. If deleteLater() is called after the main event loop has stopped, the object will not be deleted. If deleteLater() is called on an object that lives in a thread with no running event loop, the object will be destroyed when the thread finishes.</p>
<p>Note that entering and leaving a new event loop (e.g., by opening a modal dialog) will <i>not</i> perform the deferred deletion; for the object to be deleted, the control must return to the event loop from which deleteLater() was called. This does not apply to objects deleted while a previous, nested event loop was still running: the Qt event loop will delete those objects as soon as the new nested event loop starts.</p>
<p>In situations where Qt is not driving the event dispatcher via e.g. <a href="qcoreapplication.html#exec" translate="no">QCoreApplication::exec</a>() or <a href="qeventloop.html#exec" translate="no">QEventLoop::exec</a>(), deferred deletes will not be processed automatically. To ensure deferred deletion in this scenario, the following workaround can be used:</p>
<pre class="cpp" translate="no">
 <span class="keyword">const</span> <span class="keyword">auto</span> <span class="operator">*</span>eventDispatcher <span class="operator">=</span> <span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">::</span>currentThread()<span class="operator">-</span><span class="operator">&gt;</span>eventDispatcher();
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(eventDispatcher<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qabstracteventdispatcher.html" translate="no">QAbstractEventDispatcher</a></span><span class="operator">::</span>aboutToBlock<span class="operator">,</span>
     <span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">::</span>currentThread()<span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>{
         <span class="keyword">if</span> (<span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">::</span>currentThread()<span class="operator">-</span><span class="operator">&gt;</span>loopLevel() <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>)
             <span class="type"><a href="qcoreapplication.html" translate="no">QCoreApplication</a></span><span class="operator">::</span>sendPostedEvents(nullptr<span class="operator">,</span> <span class="type"><a href="qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>DeferredDelete);
     }
 );
</pre>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="qobject.html#destroyed" translate="no">destroyed</a>() and <a href="qpointer.html" translate="no">QPointer</a>.</p>
<!-- @@@deleteLater -->
<!-- $$$destroyed[overload1]$$$destroyedQObject* -->
<h3 class="fn" translate="no" id="destroyed"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QObject::<span class="name">destroyed</span>(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>obj</i> = nullptr)</h3>
<p>This signal is emitted immediately before the object <i translate="no">obj</i> is destroyed, after any instances of <a href="qpointer.html" translate="no">QPointer</a> have been notified, and cannot be blocked.</p>
<p>All the objects's children are destroyed immediately after this signal is emitted.</p>
<p><b>See also </b><a href="qobject.html#deleteLater" translate="no">deleteLater</a>() and <a href="qpointer.html" translate="no">QPointer</a>.</p>
<!-- @@@destroyed -->
<!-- $$$disconnect[overload1]$$$disconnectconstQObject*constchar*constQObject*constchar* -->
<h3 class="fn" translate="no" id="disconnect"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QObject::<span class="name">disconnect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>sender</i>, const <span class="type">char</span> *<i>signal</i>, const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i>, const <span class="type">char</span> *<i>method</i>)</h3>
<p>Disconnects <i translate="no">signal</i> in object <i translate="no">sender</i> from <i translate="no">method</i> in object <i translate="no">receiver</i>. Returns <code translate="no">true</code> if the connection is successfully broken; otherwise returns <code translate="no">false</code>.</p>
<p>A signal-slot connection is removed when either of the objects involved are destroyed.</p>
<p>disconnect() is typically used in three ways, as the following examples demonstrate.</p>
<ol class="1" type="1"><li>Disconnect everything connected to an object's signals:<pre class="cpp" translate="no">
 disconnect(myObject<span class="operator">,</span> nullptr<span class="operator">,</span> nullptr<span class="operator">,</span> nullptr);
</pre>
<p>equivalent to the non-static overloaded function</p>
<pre class="cpp" translate="no">
 myObject<span class="operator">-</span><span class="operator">&gt;</span>disconnect();
</pre>
</li>
<li>Disconnect everything connected to a specific signal:<pre class="cpp" translate="no">
 disconnect(myObject<span class="operator">,</span> SIGNAL(mySignal())<span class="operator">,</span> nullptr<span class="operator">,</span> nullptr);
</pre>
<p>equivalent to the non-static overloaded function</p>
<pre class="cpp" translate="no">
 myObject<span class="operator">-</span><span class="operator">&gt;</span>disconnect(SIGNAL(mySignal()));
</pre>
</li>
<li>Disconnect a specific receiver:<pre class="cpp" translate="no">
 disconnect(myObject<span class="operator">,</span> nullptr<span class="operator">,</span> myReceiver<span class="operator">,</span> nullptr);
</pre>
<p>equivalent to the non-static overloaded function</p>
<pre class="cpp" translate="no">
 myObject<span class="operator">-</span><span class="operator">&gt;</span>disconnect(myReceiver);
</pre>
</li>
</ol>
<p><code translate="no">nullptr</code> may be used as a wildcard, meaning &quot;any signal&quot;, &quot;any receiving object&quot;, or &quot;any slot in the receiving object&quot;, respectively.</p>
<p>The <i translate="no">sender</i> may never be <code translate="no">nullptr</code>. (You cannot disconnect signals from more than one object in a single call.)</p>
<p>If <i translate="no">signal</i> is <code translate="no">nullptr</code>, it disconnects <i translate="no">receiver</i> and <i translate="no">method</i> from any signal. If not, only the specified signal is disconnected.</p>
<p>If <i translate="no">receiver</i> is <code translate="no">nullptr</code>, it disconnects anything connected to <i translate="no">signal</i>. If not, slots in objects other than <i translate="no">receiver</i> are not disconnected.</p>
<p>If <i translate="no">method</i> is <code translate="no">nullptr</code>, it disconnects anything that is connected to <i translate="no">receiver</i>. If not, only slots named <i translate="no">method</i> will be disconnected, and all other slots are left alone. The <i translate="no">method</i> must be <code translate="no">nullptr</code> if <i translate="no">receiver</i> is left out, so you cannot disconnect a specifically-named slot on all objects.</p>
<div class="admonition note">
<p><b>Note: </b>Disconnecting all signal-slot connections will also disconnect the <a href="qobject.html#destroyed" translate="no">QObject::destroyed</a>() signal if it is connected. Doing so can adversely affect classes that rely on this signal for cleaning up resources. It is recommended to disconnect only the specific signals that were connected by application code.</p>
</div>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="qobject.html#connect" translate="no">connect</a>().</p>
<!-- @@@disconnect -->
<!-- $$$disconnect$$$disconnectconstQObject*constQMetaMethod&constQObject*constQMetaMethod& -->
<h3 class="fn" translate="no" id="disconnect-1"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QObject::<span class="name">disconnect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>sender</i>, const <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> &amp;<i>signal</i>, const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i>, const <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> &amp;<i>method</i>)</h3>
<p>Disconnects <i translate="no">signal</i> in object <i translate="no">sender</i> from <i translate="no">method</i> in object <i translate="no">receiver</i>. Returns <code translate="no">true</code> if the connection is successfully broken; otherwise returns <code translate="no">false</code>.</p>
<p>This function provides the same possibilities like <code translate="no">disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</code> but uses <a href="qmetamethod.html" translate="no">QMetaMethod</a> to represent the signal and the method to be disconnected.</p>
<p>Additionally this function returns false and no signals and slots disconnected if:</p>
<ol class="1" type="1"><li><i translate="no">signal</i> is not a member of sender class or one of its parent classes.</li>
<li><i translate="no">method</i> is not a member of receiver class or one of its parent classes.</li>
<li><i translate="no">signal</i> instance represents not a signal.</li>
</ol>
<p>QMetaMethod() may be used as wildcard in the meaning &quot;any signal&quot; or &quot;any slot in receiving object&quot;. In the same way <code translate="no">nullptr</code> can be used for <i translate="no">receiver</i> in the meaning &quot;any receiving object&quot;. In this case method should also be QMetaMethod(). <i translate="no">sender</i> parameter should be never <code translate="no">nullptr</code>.</p>
<div class="admonition note">
<p><b>Note: </b>Disconnecting all signal-slot connections will also disconnect the <a href="qobject.html#destroyed" translate="no">QObject::destroyed</a>() signal if it is connected. Doing so can adversely affect classes that rely on this signal for cleaning up resources. It is recommended to disconnect only the specific signals that were connected by application code.</p>
</div>
<p><b>See also </b><a href="qobject.html#disconnect" translate="no">disconnect</a>(const QObject *sender, const char *signal, const QObject *receiver, const char *method).</p>
<!-- @@@disconnect -->
<!-- $$$disconnect$$$disconnectconstchar*constQObject*constchar* -->
<h3 class="fn" translate="no" id="disconnect-2"><span class="type">bool</span> QObject::<span class="name">disconnect</span>(const <span class="type">char</span> *<i>signal</i> = nullptr, const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i> = nullptr, const <span class="type">char</span> *<i>method</i> = nullptr) const</h3>
<p>This function overloads disconnect().</p>
<p>Disconnects <i translate="no">signal</i> from <i translate="no">method</i> of <i translate="no">receiver</i>.</p>
<p>A signal-slot connection is removed when either of the objects involved are destroyed.</p>
<div class="admonition note">
<p><b>Note: </b>Disconnecting all signal-slot connections will also disconnect the <a href="qobject.html#destroyed" translate="no">QObject::destroyed</a>() signal if it is connected. Doing so can adversely affect classes that rely on this signal for cleaning up resources. It is recommended to disconnect only the specific signals that were connected by application code.</p>
</div>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<!-- @@@disconnect -->
<!-- $$$disconnect$$$disconnectconstQObject*constchar* -->
<h3 class="fn" translate="no" id="disconnect-3"><span class="type">bool</span> QObject::<span class="name">disconnect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i>, const <span class="type">char</span> *<i>method</i> = nullptr) const</h3>
<p>This function overloads disconnect().</p>
<p>Disconnects all signals in this object from <i translate="no">receiver</i>'s <i translate="no">method</i>.</p>
<p>A signal-slot connection is removed when either of the objects involved are destroyed.</p>
<!-- @@@disconnect -->
<!-- $$$disconnect$$$disconnectconstQMetaObject::Connection& -->
<h3 class="fn" translate="no" id="disconnect-4"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QObject::<span class="name">disconnect</span>(const <span class="type"><a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a></span> &amp;<i>connection</i>)</h3>
<p>Disconnect a connection.</p>
<p>If the <i translate="no">connection</i> is invalid or has already been disconnected, do nothing and return false.</p>
<p><b>See also </b><a href="qobject.html#connect" translate="no">connect</a>().</p>
<!-- @@@disconnect -->
<!-- $$$disconnect$$$disconnectconstQObject*PointerToMemberFunctionconstQObject*PointerToMemberFunction -->
<h3 class="fn" translate="no" id="disconnect-5"><code class="details extra" translate="no">[static]</code> template &lt;typename PointerToMemberFunction&gt; <span class="type">bool</span> QObject::<span class="name">disconnect</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>sender</i>, <span class="type">PointerToMemberFunction</span> <i>signal</i>, const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>receiver</i>, <span class="type">PointerToMemberFunction</span> <i>method</i>)</h3>
<p>This function overloads disconnect().</p>
<p>Disconnects <i translate="no">signal</i> in object <i translate="no">sender</i> from <i translate="no">method</i> in object <i translate="no">receiver</i>. Returns <code translate="no">true</code> if the connection is successfully broken; otherwise returns <code translate="no">false</code>.</p>
<p>A signal-slot connection is removed when either of the objects involved are destroyed.</p>
<p>disconnect() is typically used in three ways, as the following examples demonstrate.</p>
<ol class="1" type="1"><li>Disconnect everything connected to an object's signals:<pre class="cpp" translate="no">
 disconnect(myObject<span class="operator">,</span> nullptr<span class="operator">,</span> nullptr<span class="operator">,</span> nullptr);
</pre>
</li>
<li>Disconnect everything connected to a specific signal:<pre class="cpp" translate="no">
 disconnect(myObject<span class="operator">,</span> <span class="operator">&amp;</span>MyObject<span class="operator">::</span>mySignal()<span class="operator">,</span> nullptr<span class="operator">,</span> nullptr);
</pre>
</li>
<li>Disconnect a specific receiver:<pre class="cpp" translate="no">
 disconnect(myObject<span class="operator">,</span> nullptr<span class="operator">,</span> myReceiver<span class="operator">,</span> nullptr);
</pre>
</li>
<li>Disconnect a connection from one specific signal to a specific slot:<pre class="cpp" translate="no">
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>disconnect(lineEdit<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtwidgets/qlineedit.html" translate="no">QLineEdit</a></span><span class="operator">::</span>textChanged<span class="operator">,</span>
                  label<span class="operator">,</span>  <span class="operator">&amp;</span><span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span><span class="operator">::</span>setText);
</pre>
</li>
</ol>
<p><code translate="no">nullptr</code> may be used as a wildcard, meaning &quot;any signal&quot;, &quot;any receiving object&quot;, or &quot;any slot in the receiving object&quot;, respectively.</p>
<p>The <i translate="no">sender</i> may never be <code translate="no">nullptr</code>. (You cannot disconnect signals from more than one object in a single call.)</p>
<p>If <i translate="no">signal</i> is <code translate="no">nullptr</code>, it disconnects <i translate="no">receiver</i> and <i translate="no">method</i> from any signal. If not, only the specified signal is disconnected.</p>
<p>If <i translate="no">receiver</i> is <code translate="no">nullptr</code>, it disconnects anything connected to <i translate="no">signal</i>. If not, only slots in the specified receiver are disconnected. disconnect() with a non-null <i translate="no">receiver</i> also disconnects slot functions that were connected with <i translate="no">receiver</i> as their context object.</p>
<p>If <i translate="no">method</i> is <code translate="no">nullptr</code>, it disconnects anything that is connected to <i translate="no">receiver</i>. If not, only slots named <i translate="no">method</i> will be disconnected, and all other slots are left alone. The <i translate="no">method</i> must be <code translate="no">nullptr</code> if <i translate="no">receiver</i> is left out, so you cannot disconnect a specifically-named slot on all objects.</p>
<div class="admonition note">
<p><b>Note: </b>It is not possible to use this overload to disconnect signals connected to functors or lambda expressions. That is because it is not possible to compare them. Instead, use the overload that takes a <a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a></p>
</div>
<p><b>Note:</b> This function is <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="qobject.html#connect" translate="no">connect</a>().</p>
<!-- @@@disconnect -->
<!-- $$$disconnectNotify[overload1]$$$disconnectNotifyconstQMetaMethod& -->
<h3 class="fn" translate="no" id="disconnectNotify"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QObject::<span class="name">disconnectNotify</span>(const <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> &amp;<i>signal</i>)</h3>
<p>This virtual function is called when something has been disconnected from <i translate="no">signal</i> in this object.</p>
<p>See <a href="qobject.html#connectNotify" translate="no">connectNotify</a>() for an example of how to compare <i translate="no">signal</i> with a specific signal.</p>
<p>If all signals were disconnected from this object (e.g., the signal argument to <a href="qobject.html#disconnect" translate="no">disconnect</a>() was <code translate="no">nullptr</code>), disconnectNotify() is only called once, and the <i translate="no">signal</i> will be an invalid <a href="qmetamethod.html" translate="no">QMetaMethod</a> (<a href="qmetamethod.html#isValid" translate="no">QMetaMethod::isValid</a>() returns <code translate="no">false</code>).</p>
<div class="admonition warning">
<p><b>Warning: </b>This function violates the object-oriented principle of modularity. However, it might be useful for optimizing access to expensive resources.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function is called from the thread which performs the disconnection, which may be a different thread from the thread in which this object lives. This function may also be called with a <a href="qobject.html" translate="no">QObject</a> internal mutex locked. It is therefore not allowed to re-enter any <a href="qobject.html" translate="no">QObject</a> functions, including <a href="qobject.html#isSignalConnected" translate="no">isSignalConnected</a>(), from your reimplementation. If you lock a mutex in your reimplementation, make sure that you don't call <a href="qobject.html" translate="no">QObject</a> functions with that mutex held in other places or it will result in a deadlock.</p>
</div>
<p><b>See also </b><a href="qobject.html#disconnect" translate="no">disconnect</a>() and <a href="qobject.html#connectNotify" translate="no">connectNotify</a>().</p>
<!-- @@@disconnectNotify -->
<!-- $$$dumpObjectInfo[overload1]$$$dumpObjectInfo -->
<h3 class="fn" translate="no" id="dumpObjectInfo"><span class="type">void</span> QObject::<span class="name">dumpObjectInfo</span>() const</h3>
<p>Dumps information about signal connections, etc. for this object to the debug output.</p>
<div class="admonition note">
<p><b>Note: </b>Before Qt 5.9, this function was not const.</p>
</div>
<p><b>See also </b><a href="qobject.html#dumpObjectTree" translate="no">dumpObjectTree</a>().</p>
<!-- @@@dumpObjectInfo -->
<!-- $$$dumpObjectTree[overload1]$$$dumpObjectTree -->
<h3 class="fn" translate="no" id="dumpObjectTree"><span class="type">void</span> QObject::<span class="name">dumpObjectTree</span>() const</h3>
<p>Dumps a tree of children to the debug output.</p>
<div class="admonition note">
<p><b>Note: </b>Before Qt 5.9, this function was not const.</p>
</div>
<p><b>See also </b><a href="qobject.html#dumpObjectInfo" translate="no">dumpObjectInfo</a>().</p>
<!-- @@@dumpObjectTree -->
<!-- $$$dynamicPropertyNames[overload1]$$$dynamicPropertyNames -->
<h3 class="fn" translate="no" id="dynamicPropertyNames"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span>&gt; QObject::<span class="name">dynamicPropertyNames</span>() const</h3>
<p>Returns the names of all properties that were dynamically added to the object using <a href="qobject.html#setProperty" translate="no">setProperty</a>().</p>
<!-- @@@dynamicPropertyNames -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" translate="no" id="event"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QObject::<span class="name">event</span>(<span class="type"><a href="qevent.html" translate="no">QEvent</a></span> *<i>e</i>)</h3>
<p>This virtual function receives events to an object and should return true if the event <i translate="no">e</i> was recognized and processed.</p>
<p>The event() function can be reimplemented to customize the behavior of an object.</p>
<p>Make sure you call the parent event class implementation for all the events you did not handle.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     MyClass(<span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);
     <span class="operator">~</span>MyClass();

     <span class="type">bool</span> event(<span class="type"><a href="qevent.html" translate="no">QEvent</a></span><span class="operator">*</span> ev) override
     {
         <span class="keyword">if</span> (ev<span class="operator">-</span><span class="operator">&gt;</span>type() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>PolishRequest) {
             <span class="comment">// overwrite handling of PolishRequest if any</span>
             doThings();
             <span class="keyword">return</span> <span class="keyword">true</span>;
         } <span class="keyword">else</span>  <span class="keyword">if</span> (ev<span class="operator">-</span><span class="operator">&gt;</span>type() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>Show) {
             <span class="comment">// complement handling of Show if any</span>
             doThings2();
             <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span><span class="operator">::</span>event(ev);
             <span class="keyword">return</span> <span class="keyword">true</span>;
         }
         <span class="comment">// Make sure the rest of events are handled</span>
         <span class="keyword">return</span> <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span><span class="operator">::</span>event(ev);
     }
 };
</pre>
<p><b>See also </b><a href="qobject.html#installEventFilter" translate="no">installEventFilter</a>(), <a href="qobject.html#timerEvent" translate="no">timerEvent</a>(), <a href="qcoreapplication.html#sendEvent" translate="no">QCoreApplication::sendEvent</a>(), and <a href="qcoreapplication.html#postEvent" translate="no">QCoreApplication::postEvent</a>().</p>
<!-- @@@event -->
<!-- $$$eventFilter[overload1]$$$eventFilterQObject*QEvent* -->
<h3 class="fn" translate="no" id="eventFilter"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QObject::<span class="name">eventFilter</span>(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>watched</i>, <span class="type"><a href="qevent.html" translate="no">QEvent</a></span> *<i>event</i>)</h3>
<p>Filters events if this object has been installed as an event filter for the <i translate="no">watched</i> object.</p>
<p>In your reimplementation of this function, if you want to filter the <i translate="no">event</i> out, i.e. stop it being handled further, return true; otherwise return false.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MainWindow : <span class="keyword">public</span> <span class="type"><a href="../qtwidgets/qmainwindow.html" translate="no">QMainWindow</a></span>
 {
 <span class="keyword">public</span>:
     MainWindow();

 <span class="keyword">protected</span>:
     <span class="type">bool</span> eventFilter(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>obj<span class="operator">,</span> <span class="type"><a href="qevent.html" translate="no">QEvent</a></span> <span class="operator">*</span>ev) override;

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtwidgets/qtextedit.html" translate="no">QTextEdit</a></span> <span class="operator">*</span>textEdit;
 };

 MainWindow<span class="operator">::</span>MainWindow()
 {
     textEdit <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qtextedit.html" translate="no">QTextEdit</a></span>;
     setCentralWidget(textEdit);

     textEdit<span class="operator">-</span><span class="operator">&gt;</span>installEventFilter(<span class="keyword">this</span>);
 }

 <span class="type">bool</span> MainWindow<span class="operator">::</span>eventFilter(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>obj<span class="operator">,</span> <span class="type"><a href="qevent.html" translate="no">QEvent</a></span> <span class="operator">*</span>event)
 {
     <span class="keyword">if</span> (obj <span class="operator">=</span><span class="operator">=</span> textEdit) {
         <span class="keyword">if</span> (event<span class="operator">-</span><span class="operator">&gt;</span>type() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>KeyPress) {
             <span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> <span class="operator">*</span>keyEvent <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span><span class="operator">*</span><span class="operator">&gt;</span>(event);
             <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Ate key press&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> keyEvent<span class="operator">-</span><span class="operator">&gt;</span>key();
             <span class="keyword">return</span> <span class="keyword">true</span>;
         } <span class="keyword">else</span> {
             <span class="keyword">return</span> <span class="keyword">false</span>;
         }
     } <span class="keyword">else</span> {
         <span class="comment">// pass the event on to the parent class</span>
         <span class="keyword">return</span> <span class="type"><a href="../qtwidgets/qmainwindow.html" translate="no">QMainWindow</a></span><span class="operator">::</span>eventFilter(obj<span class="operator">,</span> event);
     }
 }
</pre>
<p>Notice in the example above that unhandled events are passed to the base class's eventFilter() function, since the base class might have reimplemented eventFilter() for its own internal purposes.</p>
<p>Some events, such as <a href="qevent.html#Type-enum" translate="no">QEvent::ShortcutOverride</a> must be explicitly accepted (by calling <a href="qevent.html#accept" translate="no">accept</a>() on them) in order to prevent propagation.</p>
<div class="admonition warning">
<p><b>Warning: </b>If you delete the receiver object in this function, be sure to return true. Otherwise, Qt will forward the event to the deleted object and the program might crash.</p>
</div>
<p><b>See also </b><a href="qobject.html#installEventFilter" translate="no">installEventFilter</a>().</p>
<!-- @@@eventFilter -->
<!-- $$$findChild[overload1]$$$findChildQAnyStringViewQt::FindChildOptions -->
<h3 class="fn" translate="no" id="findChild">template &lt;typename T&gt; <span class="type">T</span> QObject::<span class="name">findChild</span>(<span class="type"><a href="qanystringview.html" translate="no">QAnyStringView</a></span> <i>name</i>, <span class="type"><a href="qt.html#FindChildOption-enum" translate="no">Qt::FindChildOptions</a></span> <i>options</i> = Qt::FindChildrenRecursively) const</h3>
<p>Returns the child of this object that can be cast into type T and that is called <i translate="no">name</i>, or <code translate="no">nullptr</code> if there is no such object. A null <i translate="no">name</i> argument causes all objects to be matched. An empty, non-null <i translate="no">name</i> matches only objects whose <a href="qobject.html#objectName-prop" translate="no">objectName</a> is empty. The search is performed recursively, unless <i translate="no">options</i> specifies the option FindDirectChildrenOnly.</p>
<p>If there is more than one child matching the search, the most-direct ancestor is returned. If there are several most-direct ancestors, the first child in <a href="qobject.html#children" translate="no">children</a>() will be returned. In that case, it's better to use <a href="qobject.html#findChildren" translate="no">findChildren</a>() to get the complete list of all children.</p>
<p>This example returns a child <code translate="no">QPushButton</code> of <code translate="no">parentWidget</code> named <code translate="no">&quot;button1&quot;</code>, even if the button isn't a direct child of the parent:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span>button <span class="operator">=</span> parentWidget<span class="operator">-</span><span class="operator">&gt;</span>findChild<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(<span class="string">&quot;button1&quot;</span>);
</pre>
<p>This example returns a <code translate="no">QListWidget</code> child of <code translate="no">parentWidget</code>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtwidgets/qlistwidget.html" translate="no">QListWidget</a></span> <span class="operator">*</span>list <span class="operator">=</span> parentWidget<span class="operator">-</span><span class="operator">&gt;</span>findChild<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qlistwidget.html" translate="no">QListWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span>();
</pre>
<p>This example returns a child <code translate="no">QPushButton</code> of <code translate="no">parentWidget</code> (its direct parent) named <code translate="no">&quot;button1&quot;</code>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span>button <span class="operator">=</span> parentWidget<span class="operator">-</span><span class="operator">&gt;</span>findChild<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(<span class="string">&quot;button1&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>FindDirectChildrenOnly);
</pre>
<p>This example returns a <code translate="no">QListWidget</code> child of <code translate="no">parentWidget</code>, its direct parent:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtwidgets/qlistwidget.html" translate="no">QListWidget</a></span> <span class="operator">*</span>list <span class="operator">=</span> parentWidget<span class="operator">-</span><span class="operator">&gt;</span>findChild<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qlistwidget.html" translate="no">QListWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(<span class="type">Qt</span><span class="operator">::</span>FindDirectChildrenOnly);
</pre>
<div class="admonition note">
<p><b>Note: </b>In Qt versions prior to 6.7, this function took <i translate="no">name</i> as <code translate="no">QString</code>, not <code translate="no">QAnyStringView</code>.</p>
</div>
<p><b>See also </b><a href="qobject.html#findChildren" translate="no">findChildren</a>().</p>
<!-- @@@findChild -->
<!-- $$$findChild$$$findChildQt::FindChildOptions -->
<h3 class="fn" translate="no" id="findChild-1"><code class="details extra" translate="no">[since 6.7]</code> template &lt;typename T&gt; <span class="type">T</span> QObject::<span class="name">findChild</span>(<span class="type"><a href="qt.html#FindChildOption-enum" translate="no">Qt::FindChildOptions</a></span> <i>options</i> = Qt::FindChildrenRecursively) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the child of this object that can be cast into type T, or <code translate="no">nullptr</code> if there is no such object. The search is performed recursively, unless <i translate="no">options</i> specifies the option FindDirectChildrenOnly.</p>
<p>If there is more than one child matching the search, the most-direct ancestor is returned. If there are several most-direct ancestors, the first child in <a href="qobject.html#children" translate="no">children</a>() will be returned. In that case, it's better to use <a href="qobject.html#findChildren" translate="no">findChildren</a>() to get the complete list of all children.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qobject.html#findChildren" translate="no">findChildren</a>().</p>
<!-- @@@findChild -->
<!-- $$$findChildren[overload1]$$$findChildrenQAnyStringViewQt::FindChildOptions -->
<h3 class="fn" translate="no" id="findChildren">template &lt;typename T&gt; <span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QObject::<span class="name">findChildren</span>(<span class="type"><a href="qanystringview.html" translate="no">QAnyStringView</a></span> <i>name</i>, <span class="type"><a href="qt.html#FindChildOption-enum" translate="no">Qt::FindChildOptions</a></span> <i>options</i> = Qt::FindChildrenRecursively) const</h3>
<p>Returns all children of this object with the given <i translate="no">name</i> that can be cast to type T, or an empty list if there are no such objects. A null <i translate="no">name</i> argument causes all objects to be matched, an empty one only those whose <a href="qobject.html#objectName-prop" translate="no">objectName</a> is empty. The search is performed recursively, unless <i translate="no">options</i> specifies the option FindDirectChildrenOnly.</p>
<p>The following example shows how to find a list of child <code translate="no">QWidget</code>s of the specified <code translate="no">parentWidget</code> named <code translate="no">widgetname</code>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span> widgets <span class="operator">=</span> parentWidget<span class="operator">.</span>findChildren<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(<span class="string">&quot;widgetname&quot;</span>);
</pre>
<p>This example returns all <code translate="no">QPushButton</code>s that are children of <code translate="no">parentWidget</code>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span> allPButtons <span class="operator">=</span> parentWidget<span class="operator">.</span>findChildren<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>();
</pre>
<p>This example returns all <code translate="no">QPushButton</code>s that are immediate children of <code translate="no">parentWidget</code>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span> childButtons <span class="operator">=</span> parentWidget<span class="operator">.</span>findChildren<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(<span class="type">Qt</span><span class="operator">::</span>FindDirectChildrenOnly);
</pre>
<div class="admonition note">
<p><b>Note: </b>In Qt versions prior to 6.7, this function took <i translate="no">name</i> as <code translate="no">QString</code>, not <code translate="no">QAnyStringView</code>.</p>
</div>
<p><b>See also </b><a href="qobject.html#findChild" translate="no">findChild</a>().</p>
<!-- @@@findChildren -->
<!-- $$$findChildren$$$findChildrenQt::FindChildOptions -->
<h3 class="fn" translate="no" id="findChildren-1"><code class="details extra" translate="no">[since 6.3]</code> template &lt;typename T&gt; <span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QObject::<span class="name">findChildren</span>(<span class="type"><a href="qt.html#FindChildOption-enum" translate="no">Qt::FindChildOptions</a></span> <i>options</i> = Qt::FindChildrenRecursively) const</h3>
<p>This is an overloaded function.</p>
<p>Returns all children of this object that can be cast to type T, or an empty list if there are no such objects. The search is performed recursively, unless <i translate="no">options</i> specifies the option FindDirectChildrenOnly.</p>
<p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qobject.html#findChild" translate="no">findChild</a>().</p>
<!-- @@@findChildren -->
<!-- $$$findChildren$$$findChildrenconstQRegularExpression&Qt::FindChildOptions -->
<h3 class="fn" translate="no" id="findChildren-2">template &lt;typename T&gt; <span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QObject::<span class="name">findChildren</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type"><a href="qt.html#FindChildOption-enum" translate="no">Qt::FindChildOptions</a></span> <i>options</i> = Qt::FindChildrenRecursively) const</h3>
<p>This function overloads findChildren().</p>
<p>Returns the children of this object that can be cast to type T and that have names matching the regular expression <i translate="no">re</i>, or an empty list if there are no such objects. The search is performed recursively, unless <i translate="no">options</i> specifies the option FindDirectChildrenOnly.</p>
<!-- @@@findChildren -->
<!-- $$$inherits[overload1]$$$inheritsconstchar* -->
<h3 class="fn" translate="no" id="inherits"><span class="type">bool</span> QObject::<span class="name">inherits</span>(const <span class="type">char</span> *<i>className</i>) const</h3>
<p>Returns <code translate="no">true</code> if this object is an instance of a class that inherits <i translate="no">className</i> or a <a href="qobject.html" translate="no">QObject</a> subclass that inherits <i translate="no">className</i>; otherwise returns <code translate="no">false</code>.</p>
<p>A class is considered to inherit itself.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qtimer.html" translate="no">QTimer</a></span> <span class="operator">*</span>timer <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtimer.html" translate="no">QTimer</a></span>;         <span class="comment">// QTimer inherits QObject</span>
 timer<span class="operator">-</span><span class="operator">&gt;</span>inherits(<span class="string">&quot;QTimer&quot;</span>);          <span class="comment">// returns true</span>
 timer<span class="operator">-</span><span class="operator">&gt;</span>inherits(<span class="string">&quot;QObject&quot;</span>);         <span class="comment">// returns true</span>
 timer<span class="operator">-</span><span class="operator">&gt;</span>inherits(<span class="string">&quot;QAbstractButton&quot;</span>); <span class="comment">// returns false</span>

 <span class="comment">// QVBoxLayout inherits QObject and QLayoutItem</span>
 <span class="type"><a href="../qtwidgets/qvboxlayout.html" translate="no">QVBoxLayout</a></span> <span class="operator">*</span>layout <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qvboxlayout.html" translate="no">QVBoxLayout</a></span>;
 layout<span class="operator">-</span><span class="operator">&gt;</span>inherits(<span class="string">&quot;QObject&quot;</span>);        <span class="comment">// returns true</span>
 layout<span class="operator">-</span><span class="operator">&gt;</span>inherits(<span class="string">&quot;QLayoutItem&quot;</span>);    <span class="comment">// returns true (even though QLayoutItem is not a QObject)</span>
</pre>
<p>If you need to determine whether an object is an instance of a particular class for the purpose of casting it, consider using <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>&lt;Type *&gt;(object) instead.</p>
<p><b>See also </b><a href="qobject.html#metaObject" translate="no">metaObject</a>() and <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>().</p>
<!-- @@@inherits -->
<!-- $$$installEventFilter[overload1]$$$installEventFilterQObject* -->
<h3 class="fn" translate="no" id="installEventFilter"><span class="type">void</span> QObject::<span class="name">installEventFilter</span>(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>filterObj</i>)</h3>
<p>Installs an event filter <i translate="no">filterObj</i> on this object. For example:</p>
<pre class="cpp" translate="no">
 monitoredObj<span class="operator">-</span><span class="operator">&gt;</span>installEventFilter(filterObj);
</pre>
<p>An event filter is an object that receives all events that are sent to this object. The filter can either stop the event or forward it to this object. The event filter <i translate="no">filterObj</i> receives events via its <a href="qobject.html#eventFilter" translate="no">eventFilter</a>() function. The <a href="qobject.html#eventFilter" translate="no">eventFilter</a>() function must return true if the event should be filtered, (i.e. stopped); otherwise it must return false.</p>
<p>If multiple event filters are installed on a single object, the filter that was installed last is activated first.</p>
<p>If <i translate="no">filterObj</i> has already been installed for this object, this function moves it so it acts as if it was installed last.</p>
<p>Here's a <code translate="no">KeyPressEater</code> class that eats the key presses of its monitored objects:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> KeyPressEater : <span class="keyword">public</span> <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span>
 {
     Q_OBJECT
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

 <span class="keyword">protected</span>:
     <span class="type">bool</span> eventFilter(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>obj<span class="operator">,</span> <span class="type"><a href="qevent.html" translate="no">QEvent</a></span> <span class="operator">*</span>event) override;
 };

 <span class="type">bool</span> KeyPressEater<span class="operator">::</span>eventFilter(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>obj<span class="operator">,</span> <span class="type"><a href="qevent.html" translate="no">QEvent</a></span> <span class="operator">*</span>event)
 {
     <span class="keyword">if</span> (event<span class="operator">-</span><span class="operator">&gt;</span>type() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>KeyPress) {
         <span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> <span class="operator">*</span>keyEvent <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(event);
         <a href="qtlogging.html#qDebug" translate="no">qDebug</a>(<span class="string">&quot;Ate key press %d&quot;</span><span class="operator">,</span> keyEvent<span class="operator">-</span><span class="operator">&gt;</span>key());
         <span class="keyword">return</span> <span class="keyword">true</span>;
     } <span class="keyword">else</span> {
         <span class="comment">// standard event processing</span>
         <span class="keyword">return</span> <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>eventFilter(obj<span class="operator">,</span> event);
     }
 }
</pre>
<p>And here's how to install it on two widgets:</p>
<pre class="cpp" translate="no">
 KeyPressEater <span class="operator">*</span>keyPressEater <span class="operator">=</span> <span class="keyword">new</span> KeyPressEater(<span class="keyword">this</span>);
 <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span> <span class="operator">*</span>pushButton <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span>(<span class="keyword">this</span>);
 <span class="type"><a href="../qtwidgets/qlistview.html" translate="no">QListView</a></span> <span class="operator">*</span>listView <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qlistview.html" translate="no">QListView</a></span>(<span class="keyword">this</span>);

 pushButton<span class="operator">-</span><span class="operator">&gt;</span>installEventFilter(keyPressEater);
 listView<span class="operator">-</span><span class="operator">&gt;</span>installEventFilter(keyPressEater);
</pre>
<p>The <a href="../qtgui/qshortcut.html" translate="no">QShortcut</a> class, for example, uses this technique to intercept shortcut key presses.</p>
<div class="admonition warning">
<p><b>Warning: </b>If you delete the receiver object in your <a href="qobject.html#eventFilter" translate="no">eventFilter</a>() function, be sure to return true. If you return false, Qt sends the event to the deleted object and the program will crash.</p>
</div>
<p>Note that the filtering object must be in the same thread as this object. If <i translate="no">filterObj</i> is in a different thread, this function does nothing. If either <i translate="no">filterObj</i> or this object are moved to a different thread after calling this function, the event filter will not be called until both objects have the same thread affinity again (it is <i>not</i> removed).</p>
<p><b>See also </b><a href="qobject.html#removeEventFilter" translate="no">removeEventFilter</a>(), <a href="qobject.html#eventFilter" translate="no">eventFilter</a>(), and <a href="qobject.html#event" translate="no">event</a>().</p>
<!-- @@@installEventFilter -->
<!-- $$$isQuickItemType[overload1]$$$isQuickItemType -->
<h3 class="fn" translate="no" id="isQuickItemType"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">bool</span> QObject::<span class="name">isQuickItemType</span>() const</h3>
<p>Returns <code translate="no">true</code> if the object is a <a href="../qtquick/qquickitem.html" translate="no">QQuickItem</a>; otherwise returns <code translate="no">false</code>.</p>
<p>Calling this function is equivalent to calling <code translate="no">inherits(&quot;QQuickItem&quot;)</code>, except that it is much faster.</p>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@isQuickItemType -->
<!-- $$$isSignalConnected[overload1]$$$isSignalConnectedconstQMetaMethod& -->
<h3 class="fn" translate="no" id="isSignalConnected"><code class="details extra" translate="no">[protected]</code> <span class="type">bool</span> QObject::<span class="name">isSignalConnected</span>(const <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> &amp;<i>signal</i>) const</h3>
<p>Returns <code translate="no">true</code> if the <i translate="no">signal</i> is connected to at least one receiver, otherwise returns <code translate="no">false</code>.</p>
<p><i translate="no">signal</i> must be a signal member of this object, otherwise the behaviour is undefined.</p>
<pre class="cpp" translate="no">
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span> valueChangedSignal <span class="operator">=</span> <span class="type"><a href="qmetamethod.html" translate="no">QMetaMethod</a></span><span class="operator">::</span>fromSignal(<span class="operator">&amp;</span>MyObject<span class="operator">::</span>valueChanged);
 <span class="keyword">if</span> (isSignalConnected(valueChangedSignal)) {
     <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> data;
     data <span class="operator">=</span> get_the_value();       <span class="comment">// expensive operation</span>
     <span class="keyword">emit</span> valueChanged(data);
 }
</pre>
<p>As the code snippet above illustrates, you can use this function to avoid expensive initialization or emitting a signal that nobody listens to. However, in a multithreaded application, connections might change after this function returns and before the signal gets emitted.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function violates the object-oriented principle of modularity. In particular, this function must not be called from an override of <a href="qobject.html#connectNotify" translate="no">connectNotify</a>() or <a href="qobject.html#disconnectNotify" translate="no">disconnectNotify</a>(), as those might get called from any thread.</p>
</div>
<!-- @@@isSignalConnected -->
<!-- $$$isWidgetType[overload1]$$$isWidgetType -->
<h3 class="fn" translate="no" id="isWidgetType"><span class="type">bool</span> QObject::<span class="name">isWidgetType</span>() const</h3>
<p>Returns <code translate="no">true</code> if the object is a widget; otherwise returns <code translate="no">false</code>.</p>
<p>Calling this function is equivalent to calling <code translate="no">inherits(&quot;QWidget&quot;)</code>, except that it is much faster.</p>
<!-- @@@isWidgetType -->
<!-- $$$isWindowType[overload1]$$$isWindowType -->
<h3 class="fn" translate="no" id="isWindowType"><span class="type">bool</span> QObject::<span class="name">isWindowType</span>() const</h3>
<p>Returns <code translate="no">true</code> if the object is a window; otherwise returns <code translate="no">false</code>.</p>
<p>Calling this function is equivalent to calling <code translate="no">inherits(&quot;QWindow&quot;)</code>, except that it is much faster.</p>
<!-- @@@isWindowType -->
<!-- $$$killTimer[overload1]$$$killTimerint -->
<h3 class="fn" translate="no" id="killTimer"><span class="type">void</span> QObject::<span class="name">killTimer</span>(<span class="type">int</span> <i>id</i>)</h3>
<p>Kills the timer with timer identifier, <i translate="no">id</i>.</p>
<p>The timer identifier is returned by <a href="qobject.html#startTimer" translate="no">startTimer</a>() when a timer event is started.</p>
<p><b>See also </b><a href="qobject.html#timerEvent" translate="no">timerEvent</a>() and <a href="qobject.html#startTimer" translate="no">startTimer</a>().</p>
<!-- @@@killTimer -->
<!-- $$$metaObject[overload1]$$$metaObject -->
<h3 class="fn" translate="no" id="metaObject"><code class="details extra" translate="no">[virtual]</code> const <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span> *QObject::<span class="name">metaObject</span>() const</h3>
<p>Returns a pointer to the meta-object of this object.</p>
<p>A meta-object contains information about a class that inherits <a href="qobject.html" translate="no">QObject</a>, e.g. class name, superclass name, properties, signals and slots. Every <a href="qobject.html" translate="no">QObject</a> subclass that contains the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro will have a meta-object.</p>
<p>The meta-object information is required by the signal/slot connection mechanism and the property system. The <a href="qobject.html#inherits" translate="no">inherits</a>() function also makes use of the meta-object.</p>
<p>If you have no pointer to an actual object instance but still want to access the meta-object of a class, you can use <a href="qobject.html#staticMetaObject-var" translate="no">staticMetaObject</a>.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>obj <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span>;
 obj<span class="operator">-</span><span class="operator">&gt;</span>metaObject()<span class="operator">-</span><span class="operator">&gt;</span>className();             <span class="comment">// returns &quot;QPushButton&quot;</span>

 <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span><span class="operator">::</span>staticMetaObject<span class="operator">.</span>className();  <span class="comment">// returns &quot;QPushButton&quot;</span>
</pre>
<p><b>See also </b><a href="qobject.html#staticMetaObject-var" translate="no">staticMetaObject</a>.</p>
<!-- @@@metaObject -->
<!-- $$$moveToThread[overload1]$$$moveToThreadQThread* -->
<h3 class="fn" translate="no" id="moveToThread"><span class="type">bool</span> QObject::<span class="name">moveToThread</span>(<span class="type"><a href="qthread.html" translate="no">QThread</a></span> *<i>targetThread</i>)</h3>
<p>Changes the thread affinity for this object and its children and returns <code translate="no">true</code> on success. The object cannot be moved if it has a parent. Event processing will continue in the <i translate="no">targetThread</i>.</p>
<p>To move an object to the main thread, use <a href="qcoreapplication.html#instance" translate="no">QApplication::instance</a>() to retrieve a pointer to the current application, and then use <a href="qobject.html#thread" translate="no">QApplication::thread</a>() to retrieve the thread in which the application lives. For example:</p>
<pre class="cpp" translate="no">
 myObject<span class="operator">-</span><span class="operator">&gt;</span>moveToThread(<span class="type"><a href="../qtwidgets/qapplication.html" translate="no">QApplication</a></span><span class="operator">::</span>instance()<span class="operator">-</span><span class="operator">&gt;</span>thread());
</pre>
<p>If <i translate="no">targetThread</i> is <code translate="no">nullptr</code>, all event processing for this object and its children stops, as they are no longer associated with any thread.</p>
<p>Note that all active timers for the object will be reset. The timers are first stopped in the current thread and restarted (with the same interval) in the <i translate="no">targetThread</i>. As a result, constantly moving an object between threads can postpone timer events indefinitely.</p>
<p>A <a href="qevent.html#Type-enum" translate="no">QEvent::ThreadChange</a> event is sent to this object just before the thread affinity is changed. You can handle this event to perform any special processing. Note that any new events that are posted to this object will be handled in the <i translate="no">targetThread</i>, provided it is not <code translate="no">nullptr</code>: when it is <code translate="no">nullptr</code>, no event processing for this object or its children can happen, as they are no longer associated with any thread.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function is <i>not</i> thread-safe; the current thread must be same as the current thread affinity. In other words, this function can only &quot;push&quot; an object from the current thread to another thread, it cannot &quot;pull&quot; an object from any arbitrary thread to the current thread. There is one exception to this rule however: objects with no thread affinity can be &quot;pulled&quot; to the current thread.</p>
</div>
<p><b>See also </b><a href="qobject.html#thread" translate="no">thread</a>().</p>
<!-- @@@moveToThread -->
<!-- $$$objectNameChanged -->
<h3 class="fn" translate="no" id="objectNameChanged"><code class="details extra" translate="no">[private signal]</code> <span class="type">void</span> QObject::<span class="name">objectNameChanged</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>objectName</i>)</h3>
<p>This signal is emitted after the object's name has been changed. The new object name is passed as <i translate="no">objectName</i>.</p>
<div class="admonition note"><p><b>Note: </b>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</p>
</div><div class="admonition note"><p><b>Note: </b>Notifier signal for property <a href="qobject.html#objectName-prop" translate="no">objectName</a>. </p>
</div><p><b>See also </b><a href="qobject.html#objectName-prop" translate="no">QObject::objectName</a>.</p>
<!-- @@@objectNameChanged -->
<!-- $$$parent[overload1]$$$parent -->
<h3 class="fn" translate="no" id="parent"><span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *QObject::<span class="name">parent</span>() const</h3>
<p>Returns a pointer to the parent object.</p>
<p><b>See also </b><a href="qobject.html#setParent" translate="no">setParent</a>() and <a href="qobject.html#children" translate="no">children</a>().</p>
<!-- @@@parent -->
<!-- $$$property[overload1]$$$propertyconstchar* -->
<h3 class="fn" translate="no" id="property"><span class="type"><a href="qvariant.html" translate="no">QVariant</a></span> QObject::<span class="name">property</span>(const <span class="type">char</span> *<i>name</i>) const</h3>
<p>Returns the value of the object's <i translate="no">name</i> property.</p>
<p>If no such property exists, the returned variant is invalid.</p>
<p>Information about all available properties is provided through the <a href="qobject.html#metaObject" translate="no">metaObject</a>() and <a href="qobject.html#dynamicPropertyNames" translate="no">dynamicPropertyNames</a>().</p>
<p><b>See also </b><a href="qobject.html#setProperty" translate="no">setProperty</a>(), <a href="qvariant.html#isValid" translate="no">QVariant::isValid</a>(), <a href="qobject.html#metaObject" translate="no">metaObject</a>(), and <a href="qobject.html#dynamicPropertyNames" translate="no">dynamicPropertyNames</a>().</p>
<!-- @@@property -->
<!-- $$$receivers[overload1]$$$receiversconstchar* -->
<h3 class="fn" translate="no" id="receivers"><code class="details extra" translate="no">[protected]</code> <span class="type">int</span> QObject::<span class="name">receivers</span>(const <span class="type">char</span> *<i>signal</i>) const</h3>
<p>Returns the number of receivers connected to the <i translate="no">signal</i>.</p>
<p>Since both slots and signals can be used as receivers for signals, and the same connections can be made many times, the number of receivers is the same as the number of connections made from this signal.</p>
<p>When calling this function, you can use the <code translate="no">SIGNAL()</code> macro to pass a specific signal:</p>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (receivers(SIGNAL(valueChanged(<span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span>))) <span class="operator">&gt;</span> <span class="number">0</span>) {
     <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> data;
     get_the_value(<span class="operator">&amp;</span>data);       <span class="comment">// expensive operation</span>
     <span class="keyword">emit</span> valueChanged(data);
 }
</pre>
<div class="admonition warning">
<p><b>Warning: </b>This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</p>
</div>
<p><b>See also </b><a href="qobject.html#isSignalConnected" translate="no">isSignalConnected</a>().</p>
<!-- @@@receivers -->
<!-- $$$removeEventFilter[overload1]$$$removeEventFilterQObject* -->
<h3 class="fn" translate="no" id="removeEventFilter"><span class="type">void</span> QObject::<span class="name">removeEventFilter</span>(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>obj</i>)</h3>
<p>Removes an event filter object <i translate="no">obj</i> from this object. The request is ignored if such an event filter has not been installed.</p>
<p>All event filters for this object are automatically removed when this object is destroyed.</p>
<p>It is always safe to remove an event filter, even during event filter activation (i.e. from the <a href="qobject.html#eventFilter" translate="no">eventFilter</a>() function).</p>
<p><b>See also </b><a href="qobject.html#installEventFilter" translate="no">installEventFilter</a>(), <a href="qobject.html#eventFilter" translate="no">eventFilter</a>(), and <a href="qobject.html#event" translate="no">event</a>().</p>
<!-- @@@removeEventFilter -->
<!-- $$$sender[overload1]$$$sender -->
<h3 class="fn" translate="no" id="sender"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *QObject::<span class="name">sender</span>() const</h3>
<p>Returns a pointer to the object that sent the signal, if called in a slot activated by a signal; otherwise it returns <code translate="no">nullptr</code>. The pointer is valid only during the execution of the slot that calls this function from this object's thread context.</p>
<p>The pointer returned by this function becomes invalid if the sender is destroyed, or if the slot is disconnected from the sender's signal.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function violates the object-oriented principle of modularity. However, getting access to the sender might be useful when many signals are connected to a single slot.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>As mentioned above, the return value of this function is not valid when the slot is called via a <a href="qt.html#ConnectionType-enum" translate="no">Qt::DirectConnection</a> from a thread different from this object's thread. Do not use this function in this type of scenario.</p>
</div>
<p><b>See also </b><a href="qobject.html#senderSignalIndex" translate="no">senderSignalIndex</a>().</p>
<!-- @@@sender -->
<!-- $$$senderSignalIndex[overload1]$$$senderSignalIndex -->
<h3 class="fn" translate="no" id="senderSignalIndex"><code class="details extra" translate="no">[protected]</code> <span class="type">int</span> QObject::<span class="name">senderSignalIndex</span>() const</h3>
<p>Returns the meta-method index of the signal that called the currently executing slot, which is a member of the class returned by <a href="qobject.html#sender" translate="no">sender</a>(). If called outside of a slot activated by a signal, -1 is returned.</p>
<p>For signals with default parameters, this function will always return the index with all parameters, regardless of which was used with <a href="qobject.html#connect" translate="no">connect</a>(). For example, the signal <code translate="no">destroyed(QObject *obj = \nullptr)</code> will have two different indexes (with and without the parameter), but this function will always return the index with a parameter. This does not apply when overloading signals with different parameters.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function violates the object-oriented principle of modularity. However, getting access to the signal index might be useful when many signals are connected to a single slot.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>The return value of this function is not valid when the slot is called via a <a href="qt.html#ConnectionType-enum" translate="no">Qt::DirectConnection</a> from a thread different from this object's thread. Do not use this function in this type of scenario.</p>
</div>
<p><b>See also </b><a href="qobject.html#sender" translate="no">sender</a>(), <a href="qmetaobject.html#indexOfSignal" translate="no">QMetaObject::indexOfSignal</a>(), and <a href="qmetaobject.html#method" translate="no">QMetaObject::method</a>().</p>
<!-- @@@senderSignalIndex -->
<!-- $$$setObjectName -->
<h3 class="fn" translate="no" id="setObjectName"><span class="type">void</span> QObject::<span class="name">setObjectName</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>name</i>)</h3>
<p>Sets the object's name to <i translate="no">name</i>.</p>
<div class="admonition note"><p><b>Note: </b>Setter function for property <a href="qobject.html#objectName-prop" translate="no">objectName</a>. </p>
</div><p><b>See also </b><a href="qobject.html#objectName-prop" translate="no">objectName</a>().</p>
<!-- @@@setObjectName -->
<!-- $$$setObjectName -->
<h3 class="fn" translate="no" id="setObjectName-1"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">void</span> QObject::<span class="name">setObjectName</span>(<span class="type"><a href="qanystringview.html" translate="no">QAnyStringView</a></span> <i>name</i>)</h3>
<p>This is an overloaded function.</p>
<div class="admonition note"><p><b>Note: </b>Setter function for property <a href="qobject.html#objectName-prop" translate="no">objectName</a>. </p>
</div><p>This function was introduced in Qt 6.4.</p>
<!-- @@@setObjectName -->
<!-- $$$setParent[overload1]$$$setParentQObject* -->
<h3 class="fn" translate="no" id="setParent"><span class="type">void</span> QObject::<span class="name">setParent</span>(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i>)</h3>
<p>Makes the object a child of <i translate="no">parent</i>.</p>
<p><b>See also </b><a href="qobject.html#parent" translate="no">parent</a>() and <a href="qobject.html#children" translate="no">children</a>().</p>
<!-- @@@setParent -->
<!-- $$$setProperty[overload1]$$$setPropertyconstchar*constQVariant& -->
<h3 class="fn" translate="no" id="setProperty"><span class="type">bool</span> QObject::<span class="name">setProperty</span>(const <span class="type">char</span> *<i>name</i>, const <span class="type"><a href="qvariant.html" translate="no">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Sets the value of the object's <i translate="no">name</i> property to <i translate="no">value</i>.</p>
<p>If the property is defined in the class using <a href="qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a> then true is returned on success and false otherwise. If the property is not defined using <a href="qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a>, and therefore not listed in the meta-object, it is added as a dynamic property and false is returned.</p>
<p>Information about all available properties is provided through the <a href="qobject.html#metaObject" translate="no">metaObject</a>() and <a href="qobject.html#dynamicPropertyNames" translate="no">dynamicPropertyNames</a>().</p>
<p>Dynamic properties can be queried again using <a href="qobject.html#property" translate="no">property</a>() and can be removed by setting the property value to an invalid <a href="qvariant.html" translate="no">QVariant</a>. Changing the value of a dynamic property causes a <a href="qdynamicpropertychangeevent.html" translate="no">QDynamicPropertyChangeEvent</a> to be sent to the object.</p>
<p><b>Note:</b> Dynamic properties starting with &quot;_q_&quot; are reserved for internal purposes.</p>
<p><b>See also </b><a href="qobject.html#property" translate="no">property</a>(), <a href="qobject.html#metaObject" translate="no">metaObject</a>(), <a href="qobject.html#dynamicPropertyNames" translate="no">dynamicPropertyNames</a>(), and <a href="qmetaproperty.html#write" translate="no">QMetaProperty::write</a>().</p>
<!-- @@@setProperty -->
<!-- $$$setProperty$$$setPropertyconstchar*QVariant&& -->
<h3 class="fn" translate="no" id="setProperty-1"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">bool</span> QObject::<span class="name">setProperty</span>(const <span class="type">char</span> *<i>name</i>, <span class="type"><a href="qvariant.html" translate="no">QVariant</a></span> &amp;&amp;<i>value</i>)</h3>
<p>This function overloads setProperty.</p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@setProperty -->
<!-- $$$signalsBlocked[overload1]$$$signalsBlocked -->
<h3 class="fn" translate="no" id="signalsBlocked"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QObject::<span class="name">signalsBlocked</span>() const</h3>
<p>Returns <code translate="no">true</code> if signals are blocked; otherwise returns <code translate="no">false</code>.</p>
<p>Signals are not blocked by default.</p>
<p><b>See also </b><a href="qobject.html#blockSignals" translate="no">blockSignals</a>() and <a href="qsignalblocker.html" translate="no">QSignalBlocker</a>.</p>
<!-- @@@signalsBlocked -->
<!-- $$$startTimer[overload1]$$$startTimerintQt::TimerType -->
<h3 class="fn" translate="no" id="startTimer"><span class="type">int</span> QObject::<span class="name">startTimer</span>(<span class="type">int</span> <i>interval</i>, <span class="type"><a href="qt.html#TimerType-enum" translate="no">Qt::TimerType</a></span> <i>timerType</i> = Qt::CoarseTimer)</h3>
<p>This is an overloaded function that will start a timer of type <i translate="no">timerType</i> and a timeout of <i translate="no">interval</i> milliseconds. This is equivalent to calling:</p>
<pre class="cpp" translate="no">
 startTimer(std<span class="operator">::</span>chrono<span class="operator">::</span>milliseconds{interval}<span class="operator">,</span> timerType);
</pre>
<p><b>See also </b><a href="qobject.html#timerEvent" translate="no">timerEvent</a>(), <a href="qobject.html#killTimer" translate="no">killTimer</a>(), and <a href="qtimer.html#singleShot" translate="no">QTimer::singleShot</a>().</p>
<!-- @@@startTimer -->
<!-- $$$startTimer$$$startTimerstd::chrono::millisecondsQt::TimerType -->
<h3 class="fn" translate="no" id="startTimer-1"><span class="type">int</span> QObject::<span class="name">startTimer</span>(<span class="type">std::chrono::milliseconds</span> <i>interval</i>, <span class="type"><a href="qt.html#TimerType-enum" translate="no">Qt::TimerType</a></span> <i>timerType</i> = Qt::CoarseTimer)</h3>
<p>This is an overloaded function.</p>
<p>Starts a timer and returns a timer identifier, or returns zero if it could not start a timer.</p>
<p>A timer event will occur every <i translate="no">interval</i> until <a href="qobject.html#killTimer" translate="no">killTimer</a>() is called. If <i translate="no">interval</i> is equal to <code translate="no">std::chrono::duration::zero()</code>, then the timer event occurs once every time there are no more window system events to process.</p>
<p>The virtual <a href="qobject.html#timerEvent" translate="no">timerEvent</a>() function is called with the <a href="qtimerevent.html" translate="no">QTimerEvent</a> event parameter class when a timer event occurs. Reimplement this function to get timer events.</p>
<p>If multiple timers are running, the <a href="qtimerevent.html#timerId" translate="no">QTimerEvent::timerId</a>() can be used to find out which timer was activated.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyObject : <span class="keyword">public</span> <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     MyObject(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);

 <span class="keyword">protected</span>:
     <span class="type">void</span> timerEvent(<span class="type"><a href="qtimerevent.html" translate="no">QTimerEvent</a></span> <span class="operator">*</span>event) override;
 };

 MyObject<span class="operator">::</span>MyObject(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>parent)
     : <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span>(parent)
 {
     startTimer(<span class="number">50</span>);     <span class="comment">// 50-millisecond timer</span>
     startTimer(<span class="number">1000</span>);   <span class="comment">// 1-second timer</span>
     startTimer(<span class="number">60000</span>);  <span class="comment">// 1-minute timer</span>

     <span class="keyword">using</span> <span class="keyword">namespace</span> std<span class="operator">::</span>chrono;
     startTimer(milliseconds(<span class="number">50</span>));
     startTimer(seconds(<span class="number">1</span>));
     startTimer(minutes(<span class="number">1</span>));

     <span class="comment">// since C++14 we can use std::chrono::duration literals, e.g.:</span>
     startTimer(<span class="number">100ms</span>);
     startTimer(<span class="number">5s</span>);
     startTimer(<span class="number">2min</span>);
     startTimer(<span class="number">1h</span>);
 }

 <span class="type">void</span> MyObject<span class="operator">::</span>timerEvent(<span class="type"><a href="qtimerevent.html" translate="no">QTimerEvent</a></span> <span class="operator">*</span>event)
 {
     <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Timer ID:&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> event<span class="operator">-</span><span class="operator">&gt;</span>timerId();
 }
</pre>
<p>Note that <a href="qtimer.html" translate="no">QTimer</a>'s accuracy depends on the underlying operating system and hardware. The <i translate="no">timerType</i> argument allows you to customize the accuracy of the timer. See <a href="qt.html#TimerType-enum" translate="no">Qt::TimerType</a> for information on the different timer types. Most platforms support an accuracy of 20 milliseconds; some provide more. If Qt is unable to deliver the requested number of timer events, it will silently discard some.</p>
<p>The <a href="qtimer.html" translate="no">QTimer</a> class provides a high-level programming interface with single-shot timers and timer signals instead of events. There is also a <a href="qbasictimer.html" translate="no">QBasicTimer</a> class that is more lightweight than <a href="qtimer.html" translate="no">QTimer</a> and less clumsy than using timer IDs directly.</p>
<p><b>See also </b><a href="qobject.html#timerEvent" translate="no">timerEvent</a>(), <a href="qobject.html#killTimer" translate="no">killTimer</a>(), and <a href="qtimer.html#singleShot" translate="no">QTimer::singleShot</a>().</p>
<!-- @@@startTimer -->
<!-- $$$thread[overload1]$$$thread -->
<h3 class="fn" translate="no" id="thread"><span class="type"><a href="qthread.html" translate="no">QThread</a></span> *QObject::<span class="name">thread</span>() const</h3>
<p>Returns the thread in which the object lives.</p>
<p><b>See also </b><a href="qobject.html#moveToThread" translate="no">moveToThread</a>().</p>
<!-- @@@thread -->
<!-- $$$timerEvent[overload1]$$$timerEventQTimerEvent* -->
<h3 class="fn" translate="no" id="timerEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QObject::<span class="name">timerEvent</span>(<span class="type"><a href="qtimerevent.html" translate="no">QTimerEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive timer events for the object.</p>
<p><a href="qtimer.html" translate="no">QTimer</a> provides a higher-level interface to the timer functionality, and also more general information about timers. The timer event is passed in the <i translate="no">event</i> parameter.</p>
<p><b>See also </b><a href="qobject.html#startTimer" translate="no">startTimer</a>(), <a href="qobject.html#killTimer" translate="no">killTimer</a>(), and <a href="qobject.html#event" translate="no">event</a>().</p>
<!-- @@@timerEvent -->
<!-- $$$tr[overload1]$$$trconstchar*constchar*int -->
<h3 class="fn" translate="no" id="tr"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qstring.html" translate="no">QString</a></span> QObject::<span class="name">tr</span>(const <span class="type">char</span> *<i>sourceText</i>, const <span class="type">char</span> *<i>disambiguation</i> = nullptr, <span class="type">int</span> <i>n</i> = -1)</h3>
<p>Returns a translated version of <i translate="no">sourceText</i>, optionally based on a <i translate="no">disambiguation</i> string and value of <i translate="no">n</i> for strings containing plurals; otherwise returns <a href="qstring.html#fromUtf8" translate="no">QString::fromUtf8</a>(<i translate="no">sourceText</i>) if no appropriate translated string is available.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> SpreadSheet<span class="operator">::</span>setupMenuBar()
 {
     <span class="type"><a href="../qtwidgets/qmenu.html" translate="no">QMenu</a></span> <span class="operator">*</span>fileMenu <span class="operator">=</span> menuBar()<span class="operator">-</span><span class="operator">&gt;</span>addMenu(tr(<span class="string">&quot;&amp;File&quot;</span>));
     ...
</pre>
<p>If the same <i translate="no">sourceText</i> is used in different roles within the same context, an additional identifying string may be passed in <i translate="no">disambiguation</i> (<code translate="no">nullptr</code> by default).</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 MyWindow<span class="operator">::</span>MyWindow()
 {
     <span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span> <span class="operator">*</span>senderLabel <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span>(tr(<span class="string">&quot;Name:&quot;</span>));
     <span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span> <span class="operator">*</span>recipientLabel <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qlabel.html" translate="no">QLabel</a></span>(tr(<span class="string">&quot;Name:&quot;</span><span class="operator">,</span> <span class="string">&quot;recipient&quot;</span>));
     ...
</pre>
<p>See <a href="../qtdoc/i18n-source-translation.html" translate="no">Writing Source Code for Translation</a> for a detailed description of Qt's translation mechanisms in general, and the <a href="../qtdoc/i18n-source-translation.html#disambiguate-identical-text" translate="no">Disambiguate Identical Text</a> section for information on disambiguation.</p>
<div class="admonition warning">
<p><b>Warning: </b>This method is reentrant only if all translators are installed <i>before</i> calling this method. Installing or removing translators while performing translations is not supported. Doing so will probably result in crashes or other undesirable behavior.</p>
</div>
<p><b>See also </b><a href="qcoreapplication.html#translate" translate="no">QCoreApplication::translate</a>() and <a href="../qtdoc/internationalization.html" translate="no">Internationalization with Qt</a>.</p>
<!-- @@@tr -->
</div>
<div class="vars">
<h2>Member Variable Documentation</h2>
<!-- $$$staticMetaObject -->
<h3 class="fn" translate="no" id="staticMetaObject-var">const <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span> QObject::<span class="name">staticMetaObject</span></h3>
<p>This variable stores the meta-object for the class.</p>
<p>A meta-object contains information about a class that inherits <a href="qobject.html" translate="no">QObject</a>, e.g. class name, superclass name, properties, signals and slots. Every class that contains the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro will also have a meta-object.</p>
<p>The meta-object information is required by the signal/slot connection mechanism and the property system. The <a href="qobject.html#inherits" translate="no">inherits</a>() function also makes use of the meta-object.</p>
<p>If you have a pointer to an object, you can use <a href="qobject.html#metaObject" translate="no">metaObject</a>() to retrieve the meta-object associated with that object.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span><span class="operator">::</span>staticMetaObject<span class="operator">.</span>className();  <span class="comment">// returns &quot;QPushButton&quot;</span>

 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>obj <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span>;
 obj<span class="operator">-</span><span class="operator">&gt;</span>metaObject()<span class="operator">-</span><span class="operator">&gt;</span>className();             <span class="comment">// returns &quot;QPushButton&quot;</span>
</pre>
<p><b>See also </b><a href="qobject.html#metaObject" translate="no">metaObject</a>().</p>
<!-- @@@staticMetaObject -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="qobject_cast">template &lt;typename T&gt; <span class="type">T</span> <span class="name">qobject_cast</span>(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>)</h3><h3 class="fn fngroupitem" translate="no" id="qobject_cast-1">template &lt;typename T&gt; <span class="type">T</span> <span class="name">qobject_cast</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>)</h3></div>
<p>Returns the given <i translate="no">object</i> cast to type T if the object is of type T (or of a subclass); otherwise returns <code translate="no">nullptr</code>. If <i translate="no">object</i> is <code translate="no">nullptr</code> then it will also return <code translate="no">nullptr</code>.</p>
<p>The class T must inherit (directly or indirectly) <a href="qobject.html" translate="no">QObject</a> and be declared with the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro.</p>
<p>A class is considered to inherit itself.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>obj <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtimer.html" translate="no">QTimer</a></span>;          <span class="comment">// QTimer inherits QObject</span>

 <span class="type"><a href="qtimer.html" translate="no">QTimer</a></span> <span class="operator">*</span>timer <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="qtimer.html" translate="no">QTimer</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj);
 <span class="comment">// timer == (QObject *)obj</span>

 <span class="type"><a href="../qtwidgets/qabstractbutton.html" translate="no">QAbstractButton</a></span> <span class="operator">*</span>button <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qabstractbutton.html" translate="no">QAbstractButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj);
 <span class="comment">// button == nullptr</span>
</pre>
<p>The <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>() function behaves similarly to the standard C++ <code translate="no">dynamic_cast()</code>, with the advantages that it doesn't require RTTI support and it works across dynamic library boundaries.</p>
<p><a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>() can also be used in conjunction with interfaces.</p>
<div class="admonition warning">
<p><b>Warning: </b>If T isn't declared with the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro, this function's return value is undefined.</p>
</div>
<p><b>See also </b><a href="qobject.html#inherits" translate="no">QObject::inherits</a>().</p>
<!-- @@@ -->
<!-- $$$QObjectList -->
<h3 class="fn" translate="no" id="QObjectList-typedef"><span class="name">QObjectList</span></h3>
<p>Synonym for <a href="qlist.html" translate="no">QList</a>&lt;<a href="qobject.html" translate="no">QObject</a> *&gt;.</p>
<!-- @@@QObjectList -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QT_NO_CONTEXTLESS_CONNECT[overload1]$$$QT_NO_CONTEXTLESS_CONNECT -->
<h3 class="fn" translate="no" id="QT_NO_CONTEXTLESS_CONNECT"><code class="details extra" translate="no">[since 6.7]</code> <span class="name">QT_NO_CONTEXTLESS_CONNECT</span></h3>
<p>Defining this macro will disable the overload of <a href="qobject.html#connect" translate="no">QObject::connect</a>() that connects a signal to a functor, without also specifying a <a href="qobject.html" translate="no">QObject</a> as a receiver/context object (that is, the 3-arguments overload of <a href="qobject.html#connect" translate="no">QObject::connect</a>()).</p>
<p>Using the context-less overload is error prone, because it is easy to connect to functors that depend on some local state of the receiving end. If such local state gets destroyed, the connection does not get automatically disconnected.</p>
<p>Moreover, such connections are always direct connections, which may cause issues in multithreaded scenarios (for instance, if the signal is emitted from another thread).</p>
<p>This macro was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qobject.html#connect" translate="no">QObject::connect</a> and <a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a>.</p>
<!-- @@@QT_NO_CONTEXTLESS_CONNECT -->
<!-- $$$QT_NO_NARROWING_CONVERSIONS_IN_CONNECT[overload1]$$$QT_NO_NARROWING_CONVERSIONS_IN_CONNECT -->
<h3 class="fn" translate="no" id="QT_NO_NARROWING_CONVERSIONS_IN_CONNECT"><span class="name">QT_NO_NARROWING_CONVERSIONS_IN_CONNECT</span></h3>
<p>Defining this macro will disable narrowing and floating-point-to-integral conversions between the arguments carried by a signal and the arguments accepted by a slot, when the signal and the slot are connected using the PMF-based syntax.</p>
<p><b>See also </b><a href="qobject.html#connect" translate="no">QObject::connect</a>.</p>
<!-- @@@QT_NO_NARROWING_CONVERSIONS_IN_CONNECT -->
<!-- $$$Q_CLASSINFO[overload1]$$$Q_CLASSINFO -->
<h3 class="fn" translate="no" id="Q_CLASSINFO"><span class="name">Q_CLASSINFO</span>(<i>Name</i>, <i>Value</i>)</h3>
<p>This macro associates extra information to the class, which is available using <a href="qobject.html#metaObject" translate="no">QObject::metaObject</a>(). The extra information takes the form of a <i translate="no">Name</i> string and a <i translate="no">Value</i> literal string.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_CLASSINFO(<span class="string">&quot;Author&quot;</span><span class="operator">,</span> <span class="string">&quot;Pierre Gendron&quot;</span>)
     Q_CLASSINFO(<span class="string">&quot;URL&quot;</span><span class="operator">,</span> <span class="string">&quot;http://www.my-organization.qc.ca&quot;</span>)

 <span class="keyword">public</span>:
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 };
</pre>
<p>Qt makes use of the macro in <a href="../qtdbus/qtdbus-index.html" translate="no">Qt D-Bus</a> and <a href="../qtqml/qtqml-index.html" translate="no">Qt Qml</a> modules. For instance, when defining <a href="../qtqml/qtqml-typesystem-objecttypes.html" translate="no">QML Object Types</a> in C++, you can designate a property as the <i>default</i> one:</p>
<pre class="cpp" translate="no">
 Q_CLASSINFO(<span class="string">&quot;DefaultProperty&quot;</span><span class="operator">,</span> <span class="string">&quot;content&quot;</span>)
</pre>
<p><b>See also </b><a href="qmetaobject.html#classInfo" translate="no">QMetaObject::classInfo</a>(), <a href="../qtdbus/usingadaptors.html" translate="no">Using Qt D-Bus Adaptors</a>, and <a href="../qtqml/qtqml-cppintegration-definetypes.html" translate="no">Defining QML Types from C++</a>.</p>
<!-- @@@Q_CLASSINFO -->
<!-- $$$Q_EMIT[overload1]$$$Q_EMIT -->
<h3 class="fn" translate="no" id="Q_EMIT"><span class="name">Q_EMIT</span></h3>
<p>Use this macro to replace the <code translate="no">emit</code> keyword for emitting signals, when you want to use Qt Signals and Slots with a <a href="signalsandslots.html#3rd-party-signals-and-slots" translate="no">3rd party signal/slot mechanism</a>.</p>
<p>The macro is normally used when <code translate="no">no_keywords</code> is specified with the <code translate="no">CONFIG</code> variable in the <code translate="no">.pro</code> file, but it can be used even when <code translate="no">no_keywords</code> is <i>not</i> specified.</p>
<!-- @@@Q_EMIT -->
<!-- $$$Q_ENUM[overload1]$$$Q_ENUM... -->
<h3 class="fn" translate="no" id="Q_ENUM"><span class="name">Q_ENUM</span>(...)</h3>
<p>This macro registers an enum type with the meta-object system. It must be placed after the enum declaration in a class that has the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a>, <a href="qobject.html#Q_GADGET" translate="no">Q_GADGET</a> or <a href="qobject.html#Q_GADGET_EXPORT" translate="no">Q_GADGET_EXPORT</a> macro. For namespaces use <a href="qobject.html#Q_ENUM_NS" translate="no">Q_ENUM_NS</a>() instead.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     MyClass(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);
     <span class="operator">~</span>MyClass();

     <span class="keyword">enum</span> Priority { High<span class="operator">,</span> Low<span class="operator">,</span> VeryHigh<span class="operator">,</span> VeryLow };
     Q_ENUM(Priority)
     <span class="type">void</span> setPriority(Priority priority);
     Priority priority() <span class="keyword">const</span>;
 };
</pre>
<p>Enumerations that are declared with Q_ENUM have their <a href="qmetaenum.html" translate="no">QMetaEnum</a> registered in the enclosing <a href="qmetaobject.html" translate="no">QMetaObject</a>. You can also use <a href="qmetaenum.html#fromType" translate="no">QMetaEnum::fromType</a>() to get the <a href="qmetaenum.html" translate="no">QMetaEnum</a>.</p>
<p>Registered enumerations are automatically registered also to the Qt meta type system, making them known to <a href="qmetatype.html" translate="no">QMetaType</a> without the need to use <a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>(). This will enable useful features; for example, if used in a <a href="qvariant.html" translate="no">QVariant</a>, you can convert them to strings. Likewise, passing them to <a href="qdebug.html" translate="no">QDebug</a> will print out their names.</p>
<p>Mind that the enum values are stored as signed <code translate="no">int</code> in the meta object system. Registering enumerations with values outside the range of values valid for <code translate="no">int</code> will lead to overflows and potentially undefined behavior when accessing them through the meta object system. QML, for example, does access registered enumerations through the meta object system.</p>
<p><b>See also </b><a href="properties.html" translate="no">Qt's Property System</a>.</p>
<!-- @@@Q_ENUM -->
<!-- $$$Q_ENUM_NS[overload1]$$$Q_ENUM_NS... -->
<h3 class="fn" translate="no" id="Q_ENUM_NS"><span class="name">Q_ENUM_NS</span>(...)</h3>
<p>This macro registers an enum type with the meta-object system. It must be placed after the enum declaration in a namespace that has the <a href="qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> macro. It is the same as <a href="qobject.html#Q_ENUM" translate="no">Q_ENUM</a> but in a namespace.</p>
<p>Enumerations that are declared with Q_ENUM_NS have their <a href="qmetaenum.html" translate="no">QMetaEnum</a> registered in the enclosing <a href="qmetaobject.html" translate="no">QMetaObject</a>. You can also use <a href="qmetaenum.html#fromType" translate="no">QMetaEnum::fromType</a>() to get the <a href="qmetaenum.html" translate="no">QMetaEnum</a>.</p>
<p>Registered enumerations are automatically registered also to the Qt meta type system, making them known to <a href="qmetatype.html" translate="no">QMetaType</a> without the need to use <a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>(). This will enable useful features; for example, if used in a <a href="qvariant.html" translate="no">QVariant</a>, you can convert them to strings. Likewise, passing them to <a href="qdebug.html" translate="no">QDebug</a> will print out their names.</p>
<p>Mind that the enum values are stored as signed <code translate="no">int</code> in the meta object system. Registering enumerations with values outside the range of values valid for <code translate="no">int</code> will lead to overflows and potentially undefined behavior when accessing them through the meta object system. QML, for example, does access registered enumerations through the meta object system.</p>
<p><b>See also </b><a href="properties.html" translate="no">Qt's Property System</a>.</p>
<!-- @@@Q_ENUM_NS -->
<!-- $$$Q_FLAG[overload1]$$$Q_FLAG... -->
<h3 class="fn" translate="no" id="Q_FLAG"><span class="name">Q_FLAG</span>(...)</h3>
<p>This macro registers a single <a href="qflags.html" translate="no">flags type</a> with the meta-object system. It is typically used in a class definition to declare that values of a given enum can be used as flags and combined using the bitwise OR operator. For namespaces use <a href="qobject.html#Q_FLAG_NS" translate="no">Q_FLAG_NS</a>() instead.</p>
<p>The macro must be placed after the enum declaration. The declaration of the flags type is done using the <a href="qflags.html#Q_DECLARE_FLAGS" translate="no">Q_DECLARE_FLAGS</a>() macro.</p>
<p>For example, in <a href="qitemselectionmodel.html" translate="no">QItemSelectionModel</a>, the <a href="qitemselectionmodel.html#SelectionFlag-enum" translate="no">SelectionFlags</a> flag is declared in the following way:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> <span class="type"><a href="qitemselectionmodel.html" translate="no">QItemSelectionModel</a></span> : <span class="keyword">public</span> <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">enum</span> SelectionFlag {
         NoUpdate       <span class="operator">=</span> <span class="number">0x0000</span><span class="operator">,</span>
         Clear          <span class="operator">=</span> <span class="number">0x0001</span><span class="operator">,</span>
         Select         <span class="operator">=</span> <span class="number">0x0002</span><span class="operator">,</span>
         Deselect       <span class="operator">=</span> <span class="number">0x0004</span><span class="operator">,</span>
         Toggle         <span class="operator">=</span> <span class="number">0x0008</span><span class="operator">,</span>
         Current        <span class="operator">=</span> <span class="number">0x0010</span><span class="operator">,</span>
         Rows           <span class="operator">=</span> <span class="number">0x0020</span><span class="operator">,</span>
         Columns        <span class="operator">=</span> <span class="number">0x0040</span><span class="operator">,</span>
         SelectCurrent  <span class="operator">=</span> Select <span class="operator">|</span> Current<span class="operator">,</span>
         ToggleCurrent  <span class="operator">=</span> Toggle <span class="operator">|</span> Current<span class="operator">,</span>
         ClearAndSelect <span class="operator">=</span> Clear <span class="operator">|</span> Select
     };

     Q_DECLARE_FLAGS(SelectionFlags<span class="operator">,</span> SelectionFlag)
     Q_FLAG(SelectionFlags)
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>The Q_FLAG macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to use <a href="qobject.html#Q_ENUM" translate="no">Q_ENUM</a>() in addition to this macro.</p>
</div>
<p><b>See also </b><a href="properties.html" translate="no">Qt's Property System</a>.</p>
<!-- @@@Q_FLAG -->
<!-- $$$Q_FLAG_NS[overload1]$$$Q_FLAG_NS... -->
<h3 class="fn" translate="no" id="Q_FLAG_NS"><span class="name">Q_FLAG_NS</span>(...)</h3>
<p>This macro registers a single <a href="qflags.html" translate="no">flags type</a> with the meta-object system. It is used in a namespace that has the <a href="qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> macro, to declare that values of a given enum can be used as flags and combined using the bitwise OR operator. It is the same as <a href="qobject.html#Q_FLAG" translate="no">Q_FLAG</a> but in a namespace.</p>
<p>The macro must be placed after the enum declaration.</p>
<div class="admonition note">
<p><b>Note: </b>The Q_FLAG_NS macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to use <a href="qobject.html#Q_ENUM_NS" translate="no">Q_ENUM_NS</a>() in addition to this macro.</p>
</div>
<p><b>See also </b><a href="properties.html" translate="no">Qt's Property System</a>.</p>
<!-- @@@Q_FLAG_NS -->
<!-- $$$Q_GADGET[overload1]$$$Q_GADGET -->
<h3 class="fn" translate="no" id="Q_GADGET"><span class="name">Q_GADGET</span></h3>
<p>The Q_GADGET macro is a lighter version of the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro for classes that do not inherit from <a href="qobject.html" translate="no">QObject</a> but still want to use some of the reflection capabilities offered by <a href="qmetaobject.html" translate="no">QMetaObject</a>. Just like the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro, it must appear in the private section of a class definition.</p>
<p>Q_GADGETs can have <a href="qobject.html#Q_ENUM" translate="no">Q_ENUM</a>, <a href="qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a> and <a href="qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>, but they cannot have signals or slots.</p>
<p>Q_GADGET makes a class member, <code translate="no">staticMetaObject</code>, available. <code translate="no">staticMetaObject</code> is of type <a href="qmetaobject.html" translate="no">QMetaObject</a> and provides access to the enums declared with <a href="qobject.html#Q_ENUM" translate="no">Q_ENUM</a>.</p>
<div class="admonition note">
<p><b>Note: </b>This macro expansion ends with a <code translate="no">private</code>: access specifier, which makes member declarations immediately after the macro private, too. If you want add public (or protected) members immediately after the macro, you need to use a <code translate="no">public</code>: (or <code translate="no">protected</code>:) access specifier.</p>
</div>
<p><b>See also </b><a href="qobject.html#Q_GADGET_EXPORT" translate="no">Q_GADGET_EXPORT</a>.</p>
<!-- @@@Q_GADGET -->
<!-- $$$Q_GADGET_EXPORT[overload1]$$$Q_GADGET_EXPORT -->
<h3 class="fn" translate="no" id="Q_GADGET_EXPORT"><code class="details extra" translate="no">[since 6.3]</code> <span class="name">Q_GADGET_EXPORT</span>(<i>EXPORT_MACRO</i>)</h3>
<p>The Q_GADGET_EXPORT macro works exactly like the <a href="qobject.html#Q_GADGET" translate="no">Q_GADGET</a> macro. However, the <code translate="no">staticMetaObject</code> variable that is made available (see <a href="qobject.html#Q_GADGET" translate="no">Q_GADGET</a>) is declared with the supplied <i translate="no">EXPORT_MACRO</i> qualifier. This is useful if the object needs to be exported from a dynamic library, but the enclosing class as a whole should not be (e.g. because it consists of mostly inline functions).</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Point {
     Q_GADGET_EXPORT(EXPORT_MACRO)
     Q_PROPERTY(<span class="type">int</span> x MEMBER x)
     Q_PROPERTY(<span class="type">int</span> y MEMBER y)
     <span class="operator">~</span><span class="operator">~</span><span class="operator">~</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>This macro expansion ends with a <code translate="no">private</code>: access specifier, which makes member declarations immediately after the macro private, too. If you want add public (or protected) members immediately after the macro, you need to use a <code translate="no">public</code>: (or <code translate="no">protected</code>:) access specifier.</p>
</div>
<p>This macro was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qobject.html#Q_GADGET" translate="no">Q_GADGET</a> and <a href="../qtdoc/sharedlibrary.html" translate="no">Creating Shared Libraries</a>.</p>
<!-- @@@Q_GADGET_EXPORT -->
<!-- $$$Q_INTERFACES[overload1]$$$Q_INTERFACES... -->
<h3 class="fn" translate="no" id="Q_INTERFACES"><span class="name">Q_INTERFACES</span>(...)</h3>
<p>This macro tells Qt which interfaces the class implements. This is used when implementing plugins.</p>
<p><b>See also </b><a href="qtplugin.html#Q_DECLARE_INTERFACE" translate="no">Q_DECLARE_INTERFACE</a>(), <a href="qtplugin.html#Q_PLUGIN_METADATA" translate="no">Q_PLUGIN_METADATA</a>(), and <a href="../qtdoc/plugins-howto.html" translate="no">How to Create Qt Plugins</a>.</p>
<!-- @@@Q_INTERFACES -->
<!-- $$$Q_INVOKABLE[overload1]$$$Q_INVOKABLE -->
<h3 class="fn" translate="no" id="Q_INVOKABLE"><span class="name">Q_INVOKABLE</span></h3>
<p>Apply this macro to declarations of member functions to allow them to be invoked via the meta-object system. The macro is written before the return type, as shown in the following example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Window : <span class="keyword">public</span> <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     Window();
     <span class="type">void</span> normalMethod();
     Q_INVOKABLE <span class="type">void</span> invokableMethod();
 };
</pre>
<p>The <code translate="no">invokableMethod()</code> function is marked up using Q_INVOKABLE, causing it to be registered with the meta-object system and enabling it to be invoked using <a href="qmetaobject.html#invokeMethod" translate="no">QMetaObject::invokeMethod</a>(). Since <code translate="no">normalMethod()</code> function is not registered in this way, it cannot be invoked using <a href="qmetaobject.html#invokeMethod" translate="no">QMetaObject::invokeMethod</a>().</p>
<p>If an invokable member function returns a pointer to a <a href="qobject.html" translate="no">QObject</a> or a subclass of <a href="qobject.html" translate="no">QObject</a> and it is invoked from QML, special ownership rules apply. See <a href="../qtqml/qtqml-cppintegration-data.html" translate="no">Data Type Conversion Between QML and C++</a> for more information.</p>
<!-- @@@Q_INVOKABLE -->
<!-- $$$Q_MOC_INCLUDE[overload1]$$$Q_MOC_INCLUDE -->
<h3 class="fn" translate="no" id="Q_MOC_INCLUDE"><code class="details extra" translate="no">[since 6.0]</code> <span class="name">Q_MOC_INCLUDE</span></h3>
<p>The Q_MOC_INCLUDE macro can be used within or outside a class, and tell the <a href="../qtdoc/moc.html" translate="no">Meta Object Compiler</a> to add an include.</p>
<pre class="cpp" translate="no">
 <span class="comment">// Put this in your code and the generated code will include this header.</span>
 Q_MOC_INCLUDE(<span class="string">&quot;myheader.h&quot;</span>)
</pre>
<p>This is useful if the types you use as properties or signal/slots arguments are forward declared.</p>
<p>This macro was introduced in Qt 6.0.</p>
<!-- @@@Q_MOC_INCLUDE -->
<!-- $$$Q_NAMESPACE[overload1]$$$Q_NAMESPACE -->
<h3 class="fn" translate="no" id="Q_NAMESPACE"><span class="name">Q_NAMESPACE</span></h3>
<p>The Q_NAMESPACE macro can be used to add <a href="qmetaobject.html" translate="no">QMetaObject</a> capabilities to a namespace.</p>
<p>Q_NAMESPACEs can have <a href="qobject.html#Q_CLASSINFO" translate="no">Q_CLASSINFO</a>, <a href="qobject.html#Q_ENUM_NS" translate="no">Q_ENUM_NS</a>, <a href="qobject.html#Q_FLAG_NS" translate="no">Q_FLAG_NS</a>, but they cannot have <a href="qobject.html#Q_ENUM" translate="no">Q_ENUM</a>, <a href="qobject.html#Q_FLAG" translate="no">Q_FLAG</a>, <a href="qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a>, <a href="qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>, signals nor slots.</p>
<p>Q_NAMESPACE makes an external variable, <code translate="no">staticMetaObject</code>, available. <code translate="no">staticMetaObject</code> is of type <a href="qmetaobject.html" translate="no">QMetaObject</a> and provides access to the enums declared with <a href="qobject.html#Q_ENUM_NS" translate="no">Q_ENUM_NS</a>/<a href="qobject.html#Q_FLAG_NS" translate="no">Q_FLAG_NS</a>.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> test {
 Q_NAMESPACE
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p><b>See also </b><a href="qobject.html#Q_NAMESPACE_EXPORT" translate="no">Q_NAMESPACE_EXPORT</a>.</p>
<!-- @@@Q_NAMESPACE -->
<!-- $$$Q_NAMESPACE_EXPORT[overload1]$$$Q_NAMESPACE_EXPORT -->
<h3 class="fn" translate="no" id="Q_NAMESPACE_EXPORT"><span class="name">Q_NAMESPACE_EXPORT</span>(<i>EXPORT_MACRO</i>)</h3>
<p>The Q_NAMESPACE_EXPORT macro can be used to add <a href="qmetaobject.html" translate="no">QMetaObject</a> capabilities to a namespace.</p>
<p>It works exactly like the <a href="qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> macro. However, the external <code translate="no">staticMetaObject</code> variable that gets defined in the namespace is declared with the supplied <i translate="no">EXPORT_MACRO</i> qualifier. This is useful if the object needs to be exported from a dynamic library.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> test {
 Q_NAMESPACE_EXPORT(EXPORT_MACRO)
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p><b>See also </b><a href="qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> and <a href="../qtdoc/sharedlibrary.html" translate="no">Creating Shared Libraries</a>.</p>
<!-- @@@Q_NAMESPACE_EXPORT -->
<!-- $$$Q_OBJECT[overload1]$$$Q_OBJECT -->
<h3 class="fn" translate="no" id="Q_OBJECT"><span class="name">Q_OBJECT</span></h3>
<p>The Q_OBJECT macro must appear in the private section of a class definition that declares its own signals and slots or that uses other services provided by Qt's meta-object system.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;QObject&gt;</span>

 <span class="keyword">class</span> Counter : <span class="keyword">public</span> <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     Counter() { m_value <span class="operator">=</span> <span class="number">0</span>; }

     <span class="type">int</span> value() <span class="keyword">const</span> { <span class="keyword">return</span> m_value; }

 <span class="keyword">public</span> <span class="keyword">slots</span>:
     <span class="type">void</span> setValue(<span class="type">int</span> value);

 <span class="keyword">signals</span>:
     <span class="type">void</span> valueChanged(<span class="type">int</span> newValue);

 <span class="keyword">private</span>:
     <span class="type">int</span> m_value;
 };
</pre>
<div class="admonition note">
<p><b>Note: </b>This macro requires the class to be a subclass of <a href="qobject.html" translate="no">QObject</a>. Use <a href="qobject.html#Q_GADGET" translate="no">Q_GADGET</a> or <a href="qobject.html#Q_GADGET_EXPORT" translate="no">Q_GADGET_EXPORT</a> instead of Q_OBJECT to enable the meta object system's support for enums in a class that is not a <a href="qobject.html" translate="no">QObject</a> subclass.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This macro expansion ends with a <code translate="no">private</code>: access specifier, which makes member declarations immediately after the macro private, too. If you want add public (or protected) members immediately after the macro, you need to use a <code translate="no">public</code>: (or <code translate="no">protected</code>:) access specifier.</p>
</div>
<p><b>See also </b><a href="metaobjects.html" translate="no">Meta-Object System</a>, <a href="signalsandslots.html" translate="no">Signals and Slots</a>, and <a href="properties.html" translate="no">Qt's Property System</a>.</p>
<!-- @@@Q_OBJECT -->
<!-- $$$Q_PROPERTY[overload1]$$$Q_PROPERTY... -->
<h3 class="fn" translate="no" id="Q_PROPERTY"><span class="name">Q_PROPERTY</span>(...)</h3>
<p>This macro is used for declaring properties in classes that inherit <a href="qobject.html" translate="no">QObject</a>. Properties behave like class data members, but they have additional features accessible through the <a href="metaobjects.html" translate="no">Meta-Object System</a>.</p>
<pre class="cpp" translate="no">
 Q_PROPERTY(type name
            (READ getFunction <span class="operator">[</span>WRITE setFunction<span class="operator">]</span> <span class="operator">|</span>
             MEMBER memberName <span class="operator">[</span>(READ getFunction <span class="operator">|</span> WRITE setFunction)<span class="operator">]</span>)
            <span class="operator">[</span>RESET resetFunction<span class="operator">]</span>
            <span class="operator">[</span>NOTIFY notifySignal<span class="operator">]</span>
            <span class="operator">[</span>REVISION <span class="type">int</span> <span class="operator">|</span> REVISION(<span class="type">int</span><span class="operator">[</span><span class="operator">,</span> <span class="type">int</span><span class="operator">]</span>)<span class="operator">]</span>
            <span class="operator">[</span>DESIGNABLE <span class="type">bool</span><span class="operator">]</span>
            <span class="operator">[</span>SCRIPTABLE <span class="type">bool</span><span class="operator">]</span>
            <span class="operator">[</span>STORED <span class="type">bool</span><span class="operator">]</span>
            <span class="operator">[</span>USER <span class="type">bool</span><span class="operator">]</span>
            <span class="operator">[</span>BINDABLE bindableProperty<span class="operator">]</span>
            <span class="operator">[</span>CONSTANT<span class="operator">]</span>
            <span class="operator">[</span>FINAL<span class="operator">]</span>
            <span class="operator">[</span>REQUIRED<span class="operator">]</span>)
</pre>
<p>The property name and type and the <code translate="no">READ</code> function are required. The type can be any type supported by <a href="qvariant.html" translate="no">QVariant</a>, or it can be a user-defined type. The other items are optional, but a <code translate="no">WRITE</code> function is common. The attributes default to true except <code translate="no">USER</code>, which defaults to false.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 Q_PROPERTY(<span class="type"><a href="qstring.html" translate="no">QString</a></span> title READ title WRITE setTitle USER <span class="keyword">true</span>)
</pre>
<p>For more details about how to use this macro, and a more detailed example of its use, see the discussion on <a href="properties.html" translate="no">Qt's Property System</a>.</p>
<p><b>See also </b><a href="properties.html" translate="no">Qt's Property System</a>.</p>
<!-- @@@Q_PROPERTY -->
<!-- $$$Q_REVISION[overload1]$$$Q_REVISION -->
<h3 class="fn" translate="no" id="Q_REVISION"><span class="name">Q_REVISION</span></h3>
<p>Apply this macro to declarations of member functions to tag them with a revision number in the meta-object system. The macro is written before the return type, as shown in the following example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Window : <span class="keyword">public</span> <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type">int</span> normalProperty READ normalProperty)
     Q_PROPERTY(<span class="type">int</span> newProperty READ newProperty REVISION(<span class="number">2</span><span class="operator">,</span> <span class="number">1</span>))

 <span class="keyword">public</span>:
     Window();
     <span class="type">int</span> normalProperty();
     <span class="type">int</span> newProperty();
 <span class="keyword">public</span> <span class="keyword">slots</span>:
     <span class="type">void</span> normalMethod();
     Q_REVISION(<span class="number">2</span><span class="operator">,</span> <span class="number">1</span>) <span class="type">void</span> newMethod();
 };
</pre>
<p>This is useful when using the meta-object system to dynamically expose objects to another API, as you can match the version expected by multiple versions of the other API. Consider the following simplified example:</p>
<pre class="cpp" translate="no">
     Window window;
     <span class="type">int</span> expectedRevision <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">const</span> <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span> <span class="operator">*</span>windowMetaObject <span class="operator">=</span> window<span class="operator">.</span>metaObject();
     <span class="keyword">for</span> (<span class="type">int</span> i<span class="operator">=</span><span class="number">0</span>; i <span class="operator">&lt;</span> windowMetaObject<span class="operator">-</span><span class="operator">&gt;</span>methodCount(); i<span class="operator">+</span><span class="operator">+</span>)
         <span class="keyword">if</span> (windowMetaObject<span class="operator">-</span><span class="operator">&gt;</span>method(i)<span class="operator">.</span>revision() <span class="operator">&lt;</span><span class="operator">=</span> expectedRevision)
             exposeMethod(windowMetaObject<span class="operator">-</span><span class="operator">&gt;</span>method(i));
     <span class="keyword">for</span> (<span class="type">int</span> i<span class="operator">=</span><span class="number">0</span>; i <span class="operator">&lt;</span> windowMetaObject<span class="operator">-</span><span class="operator">&gt;</span>propertyCount(); i<span class="operator">+</span><span class="operator">+</span>)
         <span class="keyword">if</span> (windowMetaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i)<span class="operator">.</span>revision() <span class="operator">&lt;</span><span class="operator">=</span> expectedRevision)
             exposeProperty(windowMetaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i));
</pre>
<p>Using the same Window class as the previous example, the newProperty and newMethod would only be exposed in this code when the expected version is <code translate="no">2.1</code> or greater.</p>
<p>Since all methods are considered to be in revision <code translate="no">0</code> if untagged, a tag of <code translate="no">Q_REVISION(0)</code> or <code translate="no">Q_REVISION(0, 0)</code> is invalid and ignored.</p>
<p>You can pass one or two integer parameters to <code translate="no">Q_REVISION</code>. If you pass one parameter, it denotes the minor version only. This means that the major version is unspecified. If you pass two, the first parameter is the major version and the second parameter is the minor version.</p>
<p>This tag is not used by the meta-object system itself. Currently this is only used by the <a href="../qtqml/qtqml-qmlmodule.html" translate="no">QtQml</a> module.</p>
<p>For a more generic string tag, see <a href="qmetamethod.html#tag" translate="no">QMetaMethod::tag</a>()</p>
<p><b>See also </b><a href="qmetamethod.html#revision" translate="no">QMetaMethod::revision</a>().</p>
<!-- @@@Q_REVISION -->
<!-- $$$Q_SET_OBJECT_NAME[overload1]$$$Q_SET_OBJECT_NAME -->
<h3 class="fn" translate="no" id="Q_SET_OBJECT_NAME"><span class="name">Q_SET_OBJECT_NAME</span>(<i>Object</i>)</h3>
<p>This macro assigns <i translate="no">Object</i> the <a href="qobject.html#objectName-prop" translate="no">objectName</a> &quot;Object&quot;.</p>
<p>It doesn't matter whether <i translate="no">Object</i> is a pointer or not, the macro figures that out by itself.</p>
<p><b>See also </b><a href="qobject.html#objectName-prop" translate="no">QObject::objectName</a>().</p>
<!-- @@@Q_SET_OBJECT_NAME -->
<!-- $$$Q_SIGNAL[overload1]$$$Q_SIGNAL -->
<h3 class="fn" translate="no" id="Q_SIGNAL"><span class="name">Q_SIGNAL</span></h3>
<p>This is an additional macro that allows you to mark a single function as a signal. It can be quite useful, especially when you use a 3rd-party source code parser which doesn't understand a <code translate="no">signals</code> or <code translate="no">Q_SIGNALS</code> groups.</p>
<p>Use this macro to replace the <code translate="no">signals</code> keyword in class declarations, when you want to use Qt Signals and Slots with a <a href="signalsandslots.html#3rd-party-signals-and-slots" translate="no">3rd party signal/slot mechanism</a>.</p>
<p>The macro is normally used when <code translate="no">no_keywords</code> is specified with the <code translate="no">CONFIG</code> variable in the <code translate="no">.pro</code> file, but it can be used even when <code translate="no">no_keywords</code> is <i>not</i> specified.</p>
<!-- @@@Q_SIGNAL -->
<!-- $$$Q_SIGNALS[overload1]$$$Q_SIGNALS -->
<h3 class="fn" translate="no" id="Q_SIGNALS"><span class="name">Q_SIGNALS</span></h3>
<p>Use this macro to replace the <code translate="no">signals</code> keyword in class declarations, when you want to use Qt Signals and Slots with a <a href="signalsandslots.html#3rd-party-signals-and-slots" translate="no">3rd party signal/slot mechanism</a>.</p>
<p>The macro is normally used when <code translate="no">no_keywords</code> is specified with the <code translate="no">CONFIG</code> variable in the <code translate="no">.pro</code> file, but it can be used even when <code translate="no">no_keywords</code> is <i>not</i> specified.</p>
<!-- @@@Q_SIGNALS -->
<!-- $$$Q_SLOT[overload1]$$$Q_SLOT -->
<h3 class="fn" translate="no" id="Q_SLOT"><span class="name">Q_SLOT</span></h3>
<p>This is an additional macro that allows you to mark a single function as a slot. It can be quite useful, especially when you use a 3rd-party source code parser which doesn't understand a <code translate="no">slots</code> or <code translate="no">Q_SLOTS</code> groups.</p>
<p>Use this macro to replace the <code translate="no">slots</code> keyword in class declarations, when you want to use Qt Signals and Slots with a <a href="signalsandslots.html#3rd-party-signals-and-slots" translate="no">3rd party signal/slot mechanism</a>.</p>
<p>The macro is normally used when <code translate="no">no_keywords</code> is specified with the <code translate="no">CONFIG</code> variable in the <code translate="no">.pro</code> file, but it can be used even when <code translate="no">no_keywords</code> is <i>not</i> specified.</p>
<!-- @@@Q_SLOT -->
<!-- $$$Q_SLOTS[overload1]$$$Q_SLOTS -->
<h3 class="fn" translate="no" id="Q_SLOTS"><span class="name">Q_SLOTS</span></h3>
<p>Use this macro to replace the <code translate="no">slots</code> keyword in class declarations, when you want to use Qt Signals and Slots with a <a href="signalsandslots.html#3rd-party-signals-and-slots" translate="no">3rd party signal/slot mechanism</a>.</p>
<p>The macro is normally used when <code translate="no">no_keywords</code> is specified with the <code translate="no">CONFIG</code> variable in the <code translate="no">.pro</code> file, but it can be used even when <code translate="no">no_keywords</code> is <i>not</i> specified.</p>
<!-- @@@Q_SLOTS -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
