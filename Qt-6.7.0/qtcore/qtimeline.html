<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qtimeline.cpp -->
  <meta name="description" content="The QTimeLine class provides a timeline for controlling animations.">
  <title>QTimeLine Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QTimeLine</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QTimeLine Class</h1>
<!-- $$$QTimeLine-brief -->
<p>The QTimeLine class provides a timeline for controlling animations. <a href="#details">More...</a></p>
<!-- @@@QTimeLine -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QTimeLine&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qobject.html" translate="no">QObject</a></td></tr>
</table></div>
<ul>
<li><a href="qtimeline-members.html">List of all members, including inherited members</a></li>
<li>QTimeLine is part of <a href="animation.html">Animation Framework</a>.</li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#Direction-enum" translate="no">Direction</a></b> { Forward, Backward }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#State-enum" translate="no">State</a></b> { NotRunning, Paused, Running }</td></tr>
</table></div>
<h2 id="properties">Properties</h2>
<div class="table"><table class="propsummary" translate="no">
<tr><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qtimeline.html#currentTime-prop" translate="no">currentTime</a></b> : int</li>
<li class="fn" translate="no"><b><a href="qtimeline.html#direction-prop" translate="no">direction</a></b> : Direction</li>
<li class="fn" translate="no"><b><a href="qtimeline.html#duration-prop" translate="no">duration</a></b> : int</li>
</ul></td><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qtimeline.html#easingCurve-prop" translate="no">easingCurve</a></b> : QEasingCurve</li>
<li class="fn" translate="no"><b><a href="qtimeline.html#loopCount-prop" translate="no">loopCount</a></b> : int</li>
<li class="fn" translate="no"><b><a href="qtimeline.html#updateInterval-prop" translate="no">updateInterval</a></b> : int</li>
</ul>
</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#QTimeLine" translate="no">QTimeLine</a></b>(int <i>duration</i> = 1000, QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#dtor.QTimeLine" translate="no">~QTimeLine</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;int&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#currentTime-prop" translate="no">bindableCurrentTime</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;QTimeLine::Direction&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#direction-prop" translate="no">bindableDirection</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;int&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#duration-prop" translate="no">bindableDuration</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;QEasingCurve&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#easingCurve-prop" translate="no">bindableEasingCurve</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;int&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#loopCount-prop" translate="no">bindableLoopCount</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;int&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#updateInterval-prop" translate="no">bindableUpdateInterval</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#currentFrame" translate="no">currentFrame</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#currentTime-prop" translate="no">currentTime</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#currentValue" translate="no">currentValue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTimeLine::Direction </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#direction-prop" translate="no">direction</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#duration-prop" translate="no">duration</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QEasingCurve </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#easingCurve-prop" translate="no">easingCurve</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#endFrame" translate="no">endFrame</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#frameForTime" translate="no">frameForTime</a></b>(int <i>msec</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#loopCount-prop" translate="no">loopCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#direction-prop" translate="no">setDirection</a></b>(QTimeLine::Direction <i>direction</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#duration-prop" translate="no">setDuration</a></b>(int <i>duration</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#easingCurve-prop" translate="no">setEasingCurve</a></b>(const QEasingCurve &amp;<i>curve</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#setEndFrame" translate="no">setEndFrame</a></b>(int <i>frame</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#setFrameRange" translate="no">setFrameRange</a></b>(int <i>startFrame</i>, int <i>endFrame</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#loopCount-prop" translate="no">setLoopCount</a></b>(int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#setStartFrame" translate="no">setStartFrame</a></b>(int <i>frame</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#updateInterval-prop" translate="no">setUpdateInterval</a></b>(int <i>interval</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#startFrame" translate="no">startFrame</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTimeLine::State </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#state" translate="no">state</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#updateInterval-prop" translate="no">updateInterval</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qreal </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#valueForTime" translate="no">valueForTime</a></b>(int <i>msec</i>) const</td></tr>
</table></div>
<h2 id="public-slots">Public Slots</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#resume" translate="no">resume</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#currentTime-prop" translate="no">setCurrentTime</a></b>(int <i>msec</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#setPaused" translate="no">setPaused</a></b>(bool <i>paused</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#start" translate="no">start</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#stop" translate="no">stop</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#toggleDirection" translate="no">toggleDirection</a></b>()</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#finished" translate="no">finished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#frameChanged" translate="no">frameChanged</a></b>(int <i>frame</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#stateChanged" translate="no">stateChanged</a></b>(QTimeLine::State <i>newState</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#valueChanged" translate="no">valueChanged</a></b>(qreal <i>value</i>)</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qtimeline.html#timerEvent" translate="no">timerEvent</a></b>(QTimerEvent *<i>event</i>) override</td></tr>
</table></div>
<!-- $$$QTimeLine-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>It's most commonly used to animate a GUI control by calling a slot periodically. You can construct a timeline by passing its duration in milliseconds to QTimeLine's constructor. The timeline's duration describes for how long the animation will run. Then you set a suitable frame range by calling <a href="qtimeline.html#setFrameRange" translate="no">setFrameRange</a>(). Finally connect the <a href="qtimeline.html#frameChanged" translate="no">frameChanged</a>() signal to a suitable slot in the widget you wish to animate (for example, <a href="../qtwidgets/qprogressbar.html#value-prop" translate="no">setValue</a>() in <a href="../qtwidgets/qprogressbar.html" translate="no">QProgressBar</a>). When you proceed to calling <a href="qtimeline.html#start" translate="no">start</a>(), QTimeLine will enter Running state, and start emitting <a href="qtimeline.html#frameChanged" translate="no">frameChanged</a>() at regular intervals, causing your widget's connected property's value to grow from the lower end to the upper and of your frame range, at a steady rate. You can specify the update interval by calling <a href="qtimeline.html#updateInterval-prop" translate="no">setUpdateInterval</a>(). When done, QTimeLine enters <a href="qtimeline.html#State-enum" translate="no">NotRunning</a> state, and emits <a href="qtimeline.html#finished" translate="no">finished</a>().</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 progressBar <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qprogressbar.html" translate="no">QProgressBar</a></span>(<span class="keyword">this</span>);
 progressBar<span class="operator">-</span><span class="operator">&gt;</span>setRange(<span class="number">0</span><span class="operator">,</span> <span class="number">100</span>);

 <span class="comment">// Construct a 1-second timeline with a frame range of 0 - 100</span>
 <span class="type"><a href="qtimeline.html#QTimeLine" translate="no">QTimeLine</a></span> <span class="operator">*</span>timeLine <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtimeline.html#QTimeLine" translate="no">QTimeLine</a></span>(<span class="number">1000</span><span class="operator">,</span> <span class="keyword">this</span>);
 timeLine<span class="operator">-</span><span class="operator">&gt;</span>setFrameRange(<span class="number">0</span><span class="operator">,</span> <span class="number">100</span>);
 connect(timeLine<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qtimeline.html#QTimeLine" translate="no">QTimeLine</a></span><span class="operator">::</span>frameChanged<span class="operator">,</span> progressBar<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtwidgets/qprogressbar.html" translate="no">QProgressBar</a></span><span class="operator">::</span>setValue);

 <span class="comment">// Clicking the push button will start the progress bar animation</span>
 pushButton <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span>(tr(<span class="string">&quot;Start animation&quot;</span>)<span class="operator">,</span> <span class="keyword">this</span>);
 connect(pushButton<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtwidgets/qpushbutton.html" translate="no">QPushButton</a></span><span class="operator">::</span>clicked<span class="operator">,</span> timeLine<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qtimeline.html#QTimeLine" translate="no">QTimeLine</a></span><span class="operator">::</span>start);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>By default the timeline runs once, from its beginning to its end, upon which you must call <a href="qtimeline.html#start" translate="no">start</a>() again to restart from the beginning. To make the timeline loop, you can call <a href="qtimeline.html#loopCount-prop" translate="no">setLoopCount</a>(), passing the number of times the timeline should run before finishing. The direction can also be changed, causing the timeline to run backward, by calling <a href="qtimeline.html#direction-prop" translate="no">setDirection</a>(). You can also pause and unpause the timeline while it's running by calling <a href="qtimeline.html#setPaused" translate="no">setPaused</a>(). For interactive control, the <a href="qtimeline.html#currentTime-prop" translate="no">setCurrentTime</a>() function is provided, which sets the time position of the time line directly. Although most useful in <a href="qtimeline.html#State-enum" translate="no">NotRunning</a> state (e.g., connected to a <a href="qtimeline.html#valueChanged" translate="no">valueChanged</a>() signal in a <a href="../qtwidgets/qslider.html" translate="no">QSlider</a>), this function can be called at any time.</p>
<p>The frame interface is useful for standard widgets, but QTimeLine can be used to control any type of animation. The heart of QTimeLine lies in the <a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>() function, which generates a <i>value</i> between 0 and 1 for a given time. This value is typically used to describe the steps of an animation, where 0 is the first step of an animation, and 1 is the last step. When running, QTimeLine generates values between 0 and 1 by calling <a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>() and emitting <a href="qtimeline.html#valueChanged" translate="no">valueChanged</a>(). By default, <a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>() applies an interpolation algorithm to generate these value. You can choose from a set of predefined timeline algorithms by calling <a href="qtimeline.html#easingCurve-prop" translate="no">setEasingCurve</a>().</p>
<p>Note that, by default, QTimeLine uses <a href="qeasingcurve.html#Type-enum" translate="no">QEasingCurve::InOutSine</a>, which provides a value that grows slowly, then grows steadily, and finally grows slowly. For a custom timeline, you can reimplement <a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>(), in which case QTimeLine's <a href="qtimeline.html#easingCurve-prop" translate="no">easingCurve</a> property is ignored.</p>
</div>
<p><b>See also </b><a href="../qtwidgets/qprogressbar.html" translate="no">QProgressBar</a> and <a href="../qtwidgets/qprogressdialog.html" translate="no">QProgressDialog</a>.</p>
<!-- @@@QTimeLine -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Direction$$$Forward$$$Backward -->
<h3 class="fn" translate="no" id="Direction-enum">enum QTimeLine::<span class="name">Direction</span></h3>
<p>This enum describes the direction of the timeline when in <a href="qtimeline.html#State-enum" translate="no">Running</a> state.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QTimeLine::Forward</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The current time of the timeline increases with time (i.e., moves from 0 and towards the end / duration).</td></tr>
<tr><td class="topAlign"><code translate="no">QTimeLine::Backward</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The current time of the timeline decreases with time (i.e., moves from the end / duration and towards 0).</td></tr>
</table></div>
<p><b>See also </b><a href="qtimeline.html#direction-prop" translate="no">setDirection</a>().</p>
<!-- @@@Direction -->
<!-- $$$State$$$NotRunning$$$Paused$$$Running -->
<h3 class="fn" translate="no" id="State-enum">enum QTimeLine::<span class="name">State</span></h3>
<p>This enum describes the state of the timeline.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QTimeLine::NotRunning</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The timeline is not running. This is the initial state of <a href="qtimeline.html" translate="no">QTimeLine</a>, and the state <a href="qtimeline.html" translate="no">QTimeLine</a> reenters when finished. The current time, frame and value remain unchanged until either <a href="qtimeline.html#currentTime-prop" translate="no">setCurrentTime</a>() is called, or the timeline is started by calling <a href="qtimeline.html#start" translate="no">start</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QTimeLine::Paused</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The timeline is paused (i.e., temporarily suspended). Calling <a href="qtimeline.html#setPaused" translate="no">setPaused</a>(false) will resume timeline activity.</td></tr>
<tr><td class="topAlign"><code translate="no">QTimeLine::Running</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The timeline is running. While control is in the event loop, <a href="qtimeline.html" translate="no">QTimeLine</a> will update its current time at regular intervals, emitting <a href="qtimeline.html#valueChanged" translate="no">valueChanged</a>() and <a href="qtimeline.html#frameChanged" translate="no">frameChanged</a>() when appropriate.</td></tr>
</table></div>
<p><b>See also </b><a href="qtimeline.html#state" translate="no">state</a>() and <a href="qtimeline.html#stateChanged" translate="no">stateChanged</a>().</p>
<!-- @@@State -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$currentTime-prop$$$currentTime$$$setCurrentTimeint$$$bindableCurrentTime -->
<h3 class="fn" translate="no" id="currentTime-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">currentTime</span> : <span class="type">int</span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds the current time of the time line.</p>
<p>When <a href="qtimeline.html" translate="no">QTimeLine</a> is in Running state, this value is updated continuously as a function of the duration and direction of the timeline. Otherwise, it is value that was current when <a href="qtimeline.html#stop" translate="no">stop</a>() was called last, or the value set by setCurrentTime().</p>
<div class="admonition note">
<p><b>Note: </b>You can bind other properties to currentTime, but it is not recommended setting bindings to it. As animation progresses, the currentTime is updated automatically, which cancels its bindings.</p>
</div>
<p>By default, this property contains a value of 0.</p>
<!-- @@@currentTime -->
<!-- $$$direction-prop$$$direction$$$setDirectionQTimeLine::Direction$$$bindableDirection -->
<h3 class="fn" translate="no" id="direction-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">direction</span> : <span class="type"><a href="qtimeline.html#Direction-enum" translate="no">Direction</a></span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds the direction of the timeline when <a href="qtimeline.html" translate="no">QTimeLine</a> is in <a href="qtimeline.html#State-enum" translate="no">Running</a> state.</p>
<p>This direction indicates whether the time moves from 0 towards the timeline duration, or from the value of the duration and towards 0 after <a href="qtimeline.html#start" translate="no">start</a>() has been called.</p>
<p>Any binding of direction will be removed not only by setDirection(), but also by <a href="qtimeline.html#toggleDirection" translate="no">toggleDirection</a>().</p>
<p>By default, this property is set to <a href="qtimeline.html#Direction-enum" translate="no">Forward</a>.</p>
<!-- @@@direction -->
<!-- $$$duration-prop$$$duration$$$setDurationint$$$bindableDuration -->
<h3 class="fn" translate="no" id="duration-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">duration</span> : <span class="type">int</span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds the total duration of the timeline in milliseconds.</p>
<p>By default, this value is 1000 (i.e., 1 second), but you can change this by either passing a duration to <a href="qtimeline.html" translate="no">QTimeLine</a>'s constructor, or by calling setDuration(). The duration must be larger than 0.</p>
<div class="admonition note">
<p><b>Note: </b>Changing the duration does not cause the current time to be reset to zero or the new duration. You also need to call <a href="qtimeline.html#currentTime-prop" translate="no">setCurrentTime</a>() with the desired value.</p>
</div>
<!-- @@@duration -->
<!-- $$$easingCurve-prop$$$easingCurve$$$setEasingCurveconstQEasingCurve&$$$bindableEasingCurve -->
<h3 class="fn" translate="no" id="easingCurve-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">easingCurve</span> : <span class="type"><a href="qeasingcurve.html" translate="no">QEasingCurve</a></span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>Specifies the easing curve that the timeline will use. If <a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>() is reimplemented, this value is ignored.</p>
<p><b>See also </b><a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>().</p>
<!-- @@@easingCurve -->
<!-- $$$loopCount-prop$$$loopCount$$$setLoopCountint$$$bindableLoopCount -->
<h3 class="fn" translate="no" id="loopCount-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">loopCount</span> : <span class="type">int</span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds the number of times the timeline should loop before it's finished.</p>
<p>A loop count of 0 means that the timeline will loop forever.</p>
<p>By default, this property contains a value of 1.</p>
<!-- @@@loopCount -->
<!-- $$$updateInterval-prop$$$updateInterval$$$setUpdateIntervalint$$$bindableUpdateInterval -->
<h3 class="fn" translate="no" id="updateInterval-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">updateInterval</span> : <span class="type">int</span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds the time in milliseconds between each time <a href="qtimeline.html" translate="no">QTimeLine</a> updates its current time.</p>
<p>When updating the current time, <a href="qtimeline.html" translate="no">QTimeLine</a> will emit <a href="qtimeline.html#valueChanged" translate="no">valueChanged</a>() if the current value changed, and <a href="qtimeline.html#frameChanged" translate="no">frameChanged</a>() if the frame changed.</p>
<p>By default, the interval is 40 ms, which corresponds to a rate of 25 updates per second.</p>
<!-- @@@updateInterval -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QTimeLine[overload1]$$$QTimeLineintQObject* -->
<h3 class="fn" translate="no" id="QTimeLine"><code class="details extra" translate="no">[explicit]</code> QTimeLine::<span class="name">QTimeLine</span>(<span class="type">int</span> <i>duration</i> = 1000, <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a timeline with a duration of <i translate="no">duration</i> milliseconds. <i translate="no">parent</i> is passed to <a href="qobject.html" translate="no">QObject</a>'s constructor. The default duration is 1000 milliseconds.</p>
<!-- @@@QTimeLine -->
<!-- $$$~QTimeLine[overload1]$$$~QTimeLine -->
<h3 class="fn" translate="no" id="dtor.QTimeLine"><code class="details extra" translate="no">[virtual noexcept]</code> QTimeLine::<span class="name">~QTimeLine</span>()</h3>
<p>Destroys the timeline.</p>
<!-- @@@~QTimeLine -->
<!-- $$$currentFrame[overload1]$$$currentFrame -->
<h3 class="fn" translate="no" id="currentFrame"><span class="type">int</span> QTimeLine::<span class="name">currentFrame</span>() const</h3>
<p>Returns the frame corresponding to the current time.</p>
<p><b>See also </b><a href="qtimeline.html#currentTime-prop" translate="no">currentTime</a>(), <a href="qtimeline.html#frameForTime" translate="no">frameForTime</a>(), and <a href="qtimeline.html#setFrameRange" translate="no">setFrameRange</a>().</p>
<!-- @@@currentFrame -->
<!-- $$$currentValue[overload1]$$$currentValue -->
<h3 class="fn" translate="no" id="currentValue"><span class="type"><a href="qttypes.html#qreal-typedef" translate="no">qreal</a></span> QTimeLine::<span class="name">currentValue</span>() const</h3>
<p>Returns the value corresponding to the current time.</p>
<p><b>See also </b><a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>() and <a href="qtimeline.html#currentFrame" translate="no">currentFrame</a>().</p>
<!-- @@@currentValue -->
<!-- $$$endFrame[overload1]$$$endFrame -->
<h3 class="fn" translate="no" id="endFrame"><span class="type">int</span> QTimeLine::<span class="name">endFrame</span>() const</h3>
<p>Returns the end frame, which is the frame corresponding to the end of the timeline (i.e., the frame for which the current value is 1).</p>
<p><b>See also </b><a href="qtimeline.html#setEndFrame" translate="no">setEndFrame</a>() and <a href="qtimeline.html#setFrameRange" translate="no">setFrameRange</a>().</p>
<!-- @@@endFrame -->
<!-- $$$finished[overload1]$$$finished -->
<h3 class="fn" translate="no" id="finished"><code class="details extra" translate="no">[private signal]</code> <span class="type">void</span> QTimeLine::<span class="name">finished</span>()</h3>
<p>This signal is emitted when <a href="qtimeline.html" translate="no">QTimeLine</a> finishes (i.e., reaches the end of its time line), and does not loop.</p>
<div class="admonition note"><p><b>Note: </b>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</p>
</div><!-- @@@finished -->
<!-- $$$frameChanged[overload1]$$$frameChangedint -->
<h3 class="fn" translate="no" id="frameChanged"><code class="details extra" translate="no">[private signal]</code> <span class="type">void</span> QTimeLine::<span class="name">frameChanged</span>(<span class="type">int</span> <i>frame</i>)</h3>
<p><a href="qtimeline.html" translate="no">QTimeLine</a> emits this signal at regular intervals when in <a href="qtimeline.html#State-enum" translate="no">Running</a> state, but only if the current frame changes. <i translate="no">frame</i> is the current frame number.</p>
<div class="admonition note"><p><b>Note: </b>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</p>
</div><p><b>See also </b><a href="qtimeline.html#setFrameRange" translate="no">QTimeLine::setFrameRange</a>() and <a href="qtimeline.html#updateInterval-prop" translate="no">QTimeLine::updateInterval</a>.</p>
<!-- @@@frameChanged -->
<!-- $$$frameForTime[overload1]$$$frameForTimeint -->
<h3 class="fn" translate="no" id="frameForTime"><span class="type">int</span> QTimeLine::<span class="name">frameForTime</span>(<span class="type">int</span> <i>msec</i>) const</h3>
<p>Returns the frame corresponding to the time <i translate="no">msec</i>. This value is calculated using a linear interpolation of the start and end frame, based on the value returned by <a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>().</p>
<p><b>See also </b><a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>() and <a href="qtimeline.html#setFrameRange" translate="no">setFrameRange</a>().</p>
<!-- @@@frameForTime -->
<!-- $$$resume[overload1]$$$resume -->
<h3 class="fn" translate="no" id="resume"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QTimeLine::<span class="name">resume</span>()</h3>
<p>Resumes the timeline from the current time. <a href="qtimeline.html" translate="no">QTimeLine</a> will reenter Running state, and once it enters the event loop, it will update its current time, frame and value at regular intervals.</p>
<p>In contrast to <a href="qtimeline.html#start" translate="no">start</a>(), this function does not restart the timeline before it resumes.</p>
<p><b>See also </b><a href="qtimeline.html#start" translate="no">start</a>(), <a href="qtimeline.html#updateInterval-prop" translate="no">updateInterval</a>(), <a href="qtimeline.html#frameChanged" translate="no">frameChanged</a>(), and <a href="qtimeline.html#valueChanged" translate="no">valueChanged</a>().</p>
<!-- @@@resume -->
<!-- $$$setEndFrame[overload1]$$$setEndFrameint -->
<h3 class="fn" translate="no" id="setEndFrame"><span class="type">void</span> QTimeLine::<span class="name">setEndFrame</span>(<span class="type">int</span> <i>frame</i>)</h3>
<p>Sets the end frame, which is the frame corresponding to the end of the timeline (i.e., the frame for which the current value is 1), to <i translate="no">frame</i>.</p>
<p><b>See also </b><a href="qtimeline.html#endFrame" translate="no">endFrame</a>(), <a href="qtimeline.html#startFrame" translate="no">startFrame</a>(), and <a href="qtimeline.html#setFrameRange" translate="no">setFrameRange</a>().</p>
<!-- @@@setEndFrame -->
<!-- $$$setFrameRange[overload1]$$$setFrameRangeintint -->
<h3 class="fn" translate="no" id="setFrameRange"><span class="type">void</span> QTimeLine::<span class="name">setFrameRange</span>(<span class="type">int</span> <i>startFrame</i>, <span class="type">int</span> <i>endFrame</i>)</h3>
<p>Sets the timeline's frame counter to start at <i translate="no">startFrame</i>, and end and <i translate="no">endFrame</i>. For each time value, <a href="qtimeline.html" translate="no">QTimeLine</a> will find the corresponding frame when you call <a href="qtimeline.html#currentFrame" translate="no">currentFrame</a>() or <a href="qtimeline.html#frameForTime" translate="no">frameForTime</a>() by interpolating, using the return value of <a href="qtimeline.html#valueForTime" translate="no">valueForTime</a>().</p>
<p>When in Running state, <a href="qtimeline.html" translate="no">QTimeLine</a> also emits the <a href="qtimeline.html#frameChanged" translate="no">frameChanged</a>() signal when the frame changes.</p>
<p><b>See also </b><a href="qtimeline.html#startFrame" translate="no">startFrame</a>(), <a href="qtimeline.html#endFrame" translate="no">endFrame</a>(), <a href="qtimeline.html#start" translate="no">start</a>(), and <a href="qtimeline.html#currentFrame" translate="no">currentFrame</a>().</p>
<!-- @@@setFrameRange -->
<!-- $$$setPaused[overload1]$$$setPausedbool -->
<h3 class="fn" translate="no" id="setPaused"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QTimeLine::<span class="name">setPaused</span>(<span class="type">bool</span> <i>paused</i>)</h3>
<p>If <i translate="no">paused</i> is true, the timeline is paused, causing <a href="qtimeline.html" translate="no">QTimeLine</a> to enter Paused state. No updates will be signaled until either <a href="qtimeline.html#start" translate="no">start</a>() or setPaused(false) is called. If <i translate="no">paused</i> is false, the timeline is resumed and continues where it left.</p>
<p><b>See also </b><a href="qtimeline.html#state" translate="no">state</a>() and <a href="qtimeline.html#start" translate="no">start</a>().</p>
<!-- @@@setPaused -->
<!-- $$$setStartFrame[overload1]$$$setStartFrameint -->
<h3 class="fn" translate="no" id="setStartFrame"><span class="type">void</span> QTimeLine::<span class="name">setStartFrame</span>(<span class="type">int</span> <i>frame</i>)</h3>
<p>Sets the start frame, which is the frame corresponding to the start of the timeline (i.e., the frame for which the current value is 0), to <i translate="no">frame</i>.</p>
<p><b>See also </b><a href="qtimeline.html#startFrame" translate="no">startFrame</a>(), <a href="qtimeline.html#endFrame" translate="no">endFrame</a>(), and <a href="qtimeline.html#setFrameRange" translate="no">setFrameRange</a>().</p>
<!-- @@@setStartFrame -->
<!-- $$$start[overload1]$$$start -->
<h3 class="fn" translate="no" id="start"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QTimeLine::<span class="name">start</span>()</h3>
<p>Starts the timeline. <a href="qtimeline.html" translate="no">QTimeLine</a> will enter Running state, and once it enters the event loop, it will update its current time, frame and value at regular intervals. The default interval is 40 ms (i.e., 25 times per second). You can change the update interval by calling <a href="qtimeline.html#updateInterval-prop" translate="no">setUpdateInterval</a>().</p>
<p>The timeline will start from position 0, or the end if going backward. If you want to resume a stopped timeline without restarting, you can call <a href="qtimeline.html#resume" translate="no">resume</a>() instead.</p>
<p><b>See also </b><a href="qtimeline.html#resume" translate="no">resume</a>(), <a href="qtimeline.html#updateInterval-prop" translate="no">updateInterval</a>(), <a href="qtimeline.html#frameChanged" translate="no">frameChanged</a>(), and <a href="qtimeline.html#valueChanged" translate="no">valueChanged</a>().</p>
<!-- @@@start -->
<!-- $$$startFrame[overload1]$$$startFrame -->
<h3 class="fn" translate="no" id="startFrame"><span class="type">int</span> QTimeLine::<span class="name">startFrame</span>() const</h3>
<p>Returns the start frame, which is the frame corresponding to the start of the timeline (i.e., the frame for which the current value is 0).</p>
<p><b>See also </b><a href="qtimeline.html#setStartFrame" translate="no">setStartFrame</a>() and <a href="qtimeline.html#setFrameRange" translate="no">setFrameRange</a>().</p>
<!-- @@@startFrame -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn" translate="no" id="state"><span class="type"><a href="qtimeline.html#State-enum" translate="no">QTimeLine::State</a></span> QTimeLine::<span class="name">state</span>() const</h3>
<p>Returns the state of the timeline.</p>
<p><b>See also </b><a href="qtimeline.html#start" translate="no">start</a>(), <a href="qtimeline.html#setPaused" translate="no">setPaused</a>(), and <a href="qtimeline.html#stop" translate="no">stop</a>().</p>
<!-- @@@state -->
<!-- $$$stateChanged[overload1]$$$stateChangedQTimeLine::State -->
<h3 class="fn" translate="no" id="stateChanged"><code class="details extra" translate="no">[private signal]</code> <span class="type">void</span> QTimeLine::<span class="name">stateChanged</span>(<span class="type"><a href="qtimeline.html#State-enum" translate="no">QTimeLine::State</a></span> <i>newState</i>)</h3>
<p>This signal is emitted whenever <a href="qtimeline.html" translate="no">QTimeLine</a>'s state changes. The new state is <i translate="no">newState</i>.</p>
<div class="admonition note"><p><b>Note: </b>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</p>
</div><!-- @@@stateChanged -->
<!-- $$$stop[overload1]$$$stop -->
<h3 class="fn" translate="no" id="stop"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QTimeLine::<span class="name">stop</span>()</h3>
<p>Stops the timeline, causing <a href="qtimeline.html" translate="no">QTimeLine</a> to enter <a href="qtimeline.html#State-enum" translate="no">NotRunning</a> state.</p>
<p><b>See also </b><a href="qtimeline.html#start" translate="no">start</a>().</p>
<!-- @@@stop -->
<!-- $$$timerEvent[overload1]$$$timerEventQTimerEvent* -->
<h3 class="fn" translate="no" id="timerEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QTimeLine::<span class="name">timerEvent</span>(<span class="type"><a href="qtimerevent.html" translate="no">QTimerEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="qobject.html#timerEvent" translate="no">QObject::timerEvent</a>(QTimerEvent *event).</p>
<!-- @@@timerEvent -->
<!-- $$$toggleDirection[overload1]$$$toggleDirection -->
<h3 class="fn" translate="no" id="toggleDirection"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QTimeLine::<span class="name">toggleDirection</span>()</h3>
<p>Toggles the direction of the timeline. If the direction was Forward, it becomes Backward, and vice verca.</p>
<p>Existing bindings of <a href="qtimeline.html#direction-prop" translate="no">direction</a> are removed.</p>
<p><b>See also </b><a href="qtimeline.html#direction-prop" translate="no">setDirection</a>().</p>
<!-- @@@toggleDirection -->
<!-- $$$valueChanged[overload1]$$$valueChangedqreal -->
<h3 class="fn" translate="no" id="valueChanged"><code class="details extra" translate="no">[private signal]</code> <span class="type">void</span> QTimeLine::<span class="name">valueChanged</span>(<span class="type"><a href="qttypes.html#qreal-typedef" translate="no">qreal</a></span> <i>value</i>)</h3>
<p><a href="qtimeline.html" translate="no">QTimeLine</a> emits this signal at regular intervals when in <a href="qtimeline.html#State-enum" translate="no">Running</a> state, but only if the current value changes. <i translate="no">value</i> is the current value. <i translate="no">value</i> is a number between 0.0 and 1.0</p>
<div class="admonition note"><p><b>Note: </b>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</p>
</div><p><b>See also </b><a href="qtimeline.html#duration-prop" translate="no">QTimeLine::setDuration</a>(), <a href="qtimeline.html#valueForTime" translate="no">QTimeLine::valueForTime</a>(), and <a href="qtimeline.html#updateInterval-prop" translate="no">QTimeLine::updateInterval</a>.</p>
<!-- @@@valueChanged -->
<!-- $$$valueForTime[overload1]$$$valueForTimeint -->
<h3 class="fn" translate="no" id="valueForTime"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="qttypes.html#qreal-typedef" translate="no">qreal</a></span> QTimeLine::<span class="name">valueForTime</span>(<span class="type">int</span> <i>msec</i>) const</h3>
<p>Returns the timeline value for the time <i translate="no">msec</i>. The returned value, which varies depending on the curve shape, is always between 0 and 1. If <i translate="no">msec</i> is 0, the default implementation always returns 0.</p>
<p>Reimplement this function to provide a custom curve shape for your timeline.</p>
<p><b>See also </b><a href="qtimeline.html#easingCurve-prop" translate="no">easingCurve</a> and <a href="qtimeline.html#frameForTime" translate="no">frameForTime</a>().</p>
<!-- @@@valueForTime -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
