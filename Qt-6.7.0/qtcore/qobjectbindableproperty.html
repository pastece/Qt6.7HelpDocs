<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qproperty.cpp -->
  <meta name="description" content="The QObjectBindableProperty class is a template class that enables automatic property bindings for property data stored in QObject derived classes.">
  <title>QObjectBindableProperty Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QObjectBindableProperty</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QObjectBindableProperty Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename Class, typename T, auto Offset, auto Signal = nullptr&gt; class QObjectBindableProperty</span>
<!-- $$$QObjectBindableProperty-brief -->
<p>The QObjectBindableProperty class is a template class that enables automatic property bindings for property data stored in <a href="qobject.html" translate="no">QObject</a> derived classes. <a href="#details">More...</a></p>
<!-- @@@QObjectBindableProperty -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QObjectBindableProperty&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qpropertydata.html" translate="no">QPropertyData</a></td></tr>
</table></div>
<ul>
<li><a href="qobjectbindableproperty-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#QObjectBindableProperty" translate="no">QObjectBindableProperty</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#QObjectBindableProperty-1" translate="no">QObjectBindableProperty</a></b>(const T &amp;<i>initialValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#QObjectBindableProperty-2" translate="no">QObjectBindableProperty</a></b>(T &amp;&amp;<i>initialValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#QObjectBindableProperty-4" translate="no">QObjectBindableProperty</a></b>(Functor &amp;&amp;<i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#QObjectBindableProperty-5" translate="no">QObjectBindableProperty</a></b>(Class *<i>owner</i>, const QPropertyBinding&lt;T&gt; &amp;<i>binding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#QObjectBindableProperty-6" translate="no">QObjectBindableProperty</a></b>(Class *<i>owner</i>, QPropertyBinding&lt;T&gt; &amp;&amp;<i>binding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#dtor.QObjectBindableProperty" translate="no">~QObjectBindableProperty</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyNotifier </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#addNotifier" translate="no">addNotifier</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#binding" translate="no">binding</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#hasBinding" translate="no">hasBinding</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#notify" translate="no">notify</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyChangeHandler&lt;Functor&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#onValueChanged" translate="no">onValueChanged</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#setBinding" translate="no">setBinding</a></b>(const QPropertyBinding&lt;T&gt; &amp;<i>newBinding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#setBinding-1" translate="no">setBinding</a></b>(const QUntypedPropertyBinding &amp;<i>newBinding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#setBinding-2" translate="no">setBinding</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#setValue" translate="no">setValue</a></b>(QObjectBindableProperty&lt;Class, T, Offset, Signal&gt;::parameter_type <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#setValue-1" translate="no">setValue</a></b>(QObjectBindableProperty&lt;Class, T, Offset, Signal&gt;::rvalue_ref <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyChangeHandler&lt;Functor&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#subscribe" translate="no">subscribe</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#takeBinding" translate="no">takeBinding</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QObjectBindableProperty&lt;Class, T, Offset, Signal&gt;::parameter_type </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#value" translate="no">value</a></b>() const</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY" translate="no">Q_OBJECT_BINDABLE_PROPERTY</a></b>(<i>containingClass</i>, <i>type</i>, <i>name</i>, <i>signal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> </td><td class="memItemRight bottomAlign"><b><a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS" translate="no">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a></b>(<i>containingClass</i>, <i>type</i>, <i>name</i>, <i>initialvalue</i>, <i>signal</i>)</td></tr>
</table></div>
<!-- $$$QObjectBindableProperty-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QObjectBindableProperty is a generic container that holds an instance of T and behaves mostly like <a href="qproperty.html" translate="no">QProperty</a>. It is one of the classes implementing <a href="bindableproperties.html" translate="no">Qt Bindable Properties</a>. Unlike <a href="qproperty.html" translate="no">QProperty</a>, it stores its management data structure in the surrounding <a href="qobject.html" translate="no">QObject</a>. The extra template parameters are used to identify the surrounding class and a member function of that class acting as a change handler.</p>
<p>You can use QObjectBindableProperty to add binding support to code that uses <a href="qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a>. The getter and setter methods must be adapted carefully according to the rules described in <a href="bindableproperties.html#bindable-property-getters-and-setters" translate="no">Bindable Property Getters and Setters</a>.</p>
<p>In order to invoke the change signal on property changes, use QObjectBindableProperty and pass the change signal as a callback.</p>
<p>A simple example is given in the following.</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;QObject&gt;</span>
 <span class="preprocessor">#include &lt;QProperty&gt;</span>
 <span class="preprocessor">#include &lt;QDebug&gt;</span>

 <span class="keyword">class</span> Foo : <span class="keyword">public</span> <span class="type"><a href="qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type">int</span> myVal READ myVal WRITE setMyVal BINDABLE bindableMyVal)
 <span class="keyword">public</span>:
     <span class="type">int</span> myVal() { <span class="keyword">return</span> myValMember<span class="operator">.</span>value(); }
     <span class="type">void</span> setMyVal(<span class="type">int</span> newvalue) { myValMember <span class="operator">=</span> newvalue; }
     <span class="type"><a href="qbindable.html" translate="no">QBindable</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> bindableMyVal() { <span class="keyword">return</span> <span class="operator">&amp;</span>myValMember; }
 <span class="keyword">signals</span>:
     <span class="type">void</span> myValChanged();

 <span class="keyword">private</span>:
     Q_OBJECT_BINDABLE_PROPERTY(Foo<span class="operator">,</span> <span class="type">int</span><span class="operator">,</span> myValMember<span class="operator">,</span> <span class="operator">&amp;</span>Foo<span class="operator">::</span>myValChanged);
 };

 <span class="type">int</span> main()
 {
     <span class="type">bool</span> debugout(<span class="keyword">true</span>); <span class="comment">// enable debug log</span>
     Foo myfoo;
     <span class="type"><a href="qproperty.html" translate="no">QProperty</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> prop(<span class="number">42</span>);
     <span class="type"><a href="qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(<span class="operator">&amp;</span>myfoo<span class="operator">,</span> <span class="operator">&amp;</span>Foo<span class="operator">::</span>myValChanged<span class="operator">,</span> <span class="operator">[</span><span class="operator">&amp;</span><span class="operator">]</span>() {
         <span class="keyword">if</span> (debugout)
             <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> myfoo<span class="operator">.</span>myVal();
     });
     myfoo<span class="operator">.</span>bindableMyVal()<span class="operator">.</span>setBinding(<span class="operator">[</span><span class="operator">&amp;</span><span class="operator">]</span>() { <span class="keyword">return</span> prop<span class="operator">.</span>value(); }); <span class="comment">// prints &quot;42&quot;</span>

     prop <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// prints &quot;5&quot;</span>
     debugout <span class="operator">=</span> <span class="keyword">false</span>;
     prop <span class="operator">=</span> <span class="number">6</span>; <span class="comment">// prints nothing</span>
     debugout <span class="operator">=</span> <span class="keyword">true</span>;
     prop <span class="operator">=</span> <span class="number">7</span>; <span class="comment">// prints &quot;7&quot;</span>
 }

 <span class="preprocessor">#include &quot;main.moc&quot;</span>
</pre>
<p>QObjectBindableProperty is usually not used directly, instead an instance of it is created by using the <a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY" translate="no">Q_OBJECT_BINDABLE_PROPERTY</a> macro.</p>
<p>Use the <a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY" translate="no">Q_OBJECT_BINDABLE_PROPERTY</a> macro in the class declaration to declare the property as bindable.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type">int</span> x READ x WRITE setX NOTIFY xChanged BINDABLE bindableX)
 <span class="keyword">public</span>:
     <span class="type">int</span> x() <span class="keyword">const</span> { <span class="keyword">return</span> xProp; }
     <span class="type">void</span> setX(<span class="type">int</span> x) { xProp <span class="operator">=</span> x; }
     <span class="type"><a href="qbindable.html" translate="no">QBindable</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> bindableX() { <span class="keyword">return</span> <span class="type"><a href="qbindable.html" translate="no">QBindable</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(<span class="operator">&amp;</span>xProp); }

 <span class="keyword">signals</span>:
     <span class="type">void</span> xChanged();

 <span class="keyword">private</span>:
     <span class="comment">// Declare the instance of the bindable property data.</span>
     Q_OBJECT_BINDABLE_PROPERTY(MyClass<span class="operator">,</span> <span class="type">int</span><span class="operator">,</span> xProp<span class="operator">,</span> <span class="operator">&amp;</span>MyClass<span class="operator">::</span>xChanged)
 };
</pre>
<p>If you need to directly initialize the property with some non-default value, you can use the <a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS" translate="no">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a> macro. It accepts a value for the initialization as one of its parameters.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass : <span class="keyword">public</span> <span class="type"><a href="qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type">int</span> x READ x WRITE setX NOTIFY xChanged BINDABLE bindableX)
 <span class="keyword">public</span>:
     <span class="type">int</span> x() <span class="keyword">const</span> { <span class="keyword">return</span> xProp; }
     <span class="type">void</span> setX(<span class="type">int</span> x) { xProp <span class="operator">=</span> x; }
     <span class="type"><a href="qbindable.html" translate="no">QBindable</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> bindableX() { <span class="keyword">return</span> <span class="type"><a href="qbindable.html" translate="no">QBindable</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(<span class="operator">&amp;</span>xProp); }

 <span class="keyword">signals</span>:
     <span class="type">void</span> xChanged();

 <span class="keyword">private</span>:
     <span class="comment">// Declare the instance of int bindable property data and</span>
     <span class="comment">// initialize it with the value 5.</span>
     <span class="comment">// This is similar to declaring</span>
     <span class="comment">// int xProp = 5;</span>
     <span class="comment">// without using the new QObjectBindableProperty class.</span>
     Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS(MyClass<span class="operator">,</span> <span class="type">int</span><span class="operator">,</span> xProp<span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="operator">&amp;</span>MyClass<span class="operator">::</span>xChanged)
 };
</pre>
<p><a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS" translate="no">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a> does not support multiple arguments directly. If your property requires multiple arguments for initialization, please explicitly call the specific constructor.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> CustomType
 {
 <span class="keyword">public</span>:
     CustomType(<span class="type">int</span> val<span class="operator">,</span> <span class="type">int</span> otherVal) : value(val)<span class="operator">,</span> anotherValue(otherVal) { }

 <span class="keyword">private</span>:
     <span class="type">int</span> value <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">int</span> anotherValue <span class="operator">=</span> <span class="number">0</span>;
 };

 <span class="comment">// later when using CustomType as a property</span>
 Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS(MyClass<span class="operator">,</span> CustomType xProp<span class="operator">,</span> CustomType(<span class="number">5</span><span class="operator">,</span> <span class="number">10</span>)<span class="operator">,</span>
                                      <span class="operator">&amp;</span>MyClass<span class="operator">::</span>xChanged)
</pre>
<p>The change handler can optionally accept one argument, of the same type as the property, in which case it is passed the new value of the property. Otherwise, it should take no arguments.</p>
<p>If the property does not need a changed notification, you can leave out the &quot;NOTIFY xChanged&quot; in the <a href="qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a> macro as well as the last argument of the <a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY" translate="no">Q_OBJECT_BINDABLE_PROPERTY</a> and <a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS" translate="no">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a> macros.</p>
</div>
<p><b>See also </b><a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY" translate="no">Q_OBJECT_BINDABLE_PROPERTY</a>, <a href="qobjectbindableproperty.html#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS" translate="no">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a>, <a href="qproperty.html" translate="no">QProperty</a>, <a href="qobjectcomputedproperty.html" translate="no">QObjectComputedProperty</a>, <a href="properties.html" translate="no">Qt's Property System</a>, and <a href="bindableproperties.html" translate="no">Qt Bindable Properties</a>.</p>
<!-- @@@QObjectBindableProperty -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="setValue"><span class="type">void</span> QObjectBindableProperty::<span class="name">setValue</span>(<span class="type"><a href="qobjectbindableproperty.html#QObjectBindableProperty" translate="no">QObjectBindableProperty</a></span>&lt;<span class="type">Class</span>, <span class="type">T</span>, <span class="type">Offset</span>, <span class="type">Signal</span>&gt;<span class="type">::parameter_type</span> <i>newValue</i>)</h3><h3 class="fn fngroupitem" translate="no" id="setValue-1"><span class="type">void</span> QObjectBindableProperty::<span class="name">setValue</span>(<span class="type"><a href="qobjectbindableproperty.html#QObjectBindableProperty" translate="no">QObjectBindableProperty</a></span>&lt;<span class="type">Class</span>, <span class="type">T</span>, <span class="type">Offset</span>, <span class="type">Signal</span>&gt;<span class="type">::rvalue_ref</span> <i>newValue</i>)</h3></div>
<p>Assigns <i translate="no">newValue</i> to this property and removes the property's associated binding, if present. If the property value changes as a result, calls the Callback function on <i translate="no">owner</i>.</p>
<!-- @@@ -->
<!-- $$$QObjectBindableProperty[overload1]$$$QObjectBindableProperty -->
<h3 class="fn" translate="no" id="QObjectBindableProperty">QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>()</h3>
<p>Constructs a property with a default constructed instance of T.</p>
<!-- @@@QObjectBindableProperty -->
<!-- $$$QObjectBindableProperty$$$QObjectBindablePropertyconstT& -->
<h3 class="fn" translate="no" id="QObjectBindableProperty-1"><code class="details extra" translate="no">[explicit]</code> QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(const <span class="type">T</span> &amp;<i>initialValue</i>)</h3>
<p>Constructs a property with the provided <i translate="no">initialValue</i>.</p>
<!-- @@@QObjectBindableProperty -->
<!-- $$$QObjectBindableProperty$$$QObjectBindablePropertyT&& -->
<h3 class="fn" translate="no" id="QObjectBindableProperty-2"><code class="details extra" translate="no">[explicit]</code> QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(<span class="type">T</span> &amp;&amp;<i>initialValue</i>)</h3>
<p>Move-Constructs a property with the provided <i translate="no">initialValue</i>.</p>
<!-- @@@QObjectBindableProperty -->
<!-- $$$QObjectBindableProperty$$$QObjectBindablePropertyFunctor&& -->
<h3 class="fn" translate="no" id="QObjectBindableProperty-4"><code class="details extra" translate="no">[explicit]</code> template &lt;typename Functor&gt; QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(<span class="type">Functor</span> &amp;&amp;<i>f</i>)</h3>
<p>Constructs a property that is tied to the provided binding expression <i translate="no">f</i>. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<!-- @@@QObjectBindableProperty -->
<!-- $$$QObjectBindableProperty$$$QObjectBindablePropertyClass*constQPropertyBinding<T>& -->
<h3 class="fn" translate="no" id="QObjectBindableProperty-5"><code class="details extra" translate="no">[default]</code> QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(<span class="type">Class</span> *<i>owner</i>, const <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;<i>binding</i>)</h3>
<p>Constructs a property that is tied to the provided <i translate="no">binding</i> expression. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<p>When the property value changes, <i translate="no">owner</i> is notified via the Callback function.</p>
<!-- @@@QObjectBindableProperty -->
<!-- $$$QObjectBindableProperty$$$QObjectBindablePropertyClass*QPropertyBinding<T>&& -->
<h3 class="fn" translate="no" id="QObjectBindableProperty-6"><code class="details extra" translate="no">[default]</code> QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(<span class="type">Class</span> *<i>owner</i>, <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>binding</i>)</h3>
<p>Constructs a property that is tied to the provided <i translate="no">binding</i> expression. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<p>When the property value changes, <i translate="no">owner</i> is notified via the Callback function.</p>
<!-- @@@QObjectBindableProperty -->
<!-- $$$~QObjectBindableProperty[overload1]$$$~QObjectBindableProperty -->
<h3 class="fn" translate="no" id="dtor.QObjectBindableProperty"><code class="details extra" translate="no">[default]</code> QObjectBindableProperty::<span class="name">~QObjectBindableProperty</span>()</h3>
<p>Destroys the property.</p>
<!-- @@@~QObjectBindableProperty -->
<!-- $$$addNotifier[overload1]$$$addNotifierFunctor -->
<h3 class="fn" translate="no" id="addNotifier">template &lt;typename Functor&gt; <span class="type"><a href="qpropertynotifier.html" translate="no">QPropertyNotifier</a></span> QObjectBindableProperty::<span class="name">addNotifier</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>Subscribes the given functor <i translate="no">f</i> as a callback that is called whenever the value of the property changes.</p>
<p>The callback <i translate="no">f</i> is expected to be a type that has a plain call operator <code translate="no">()</code> without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p>
<p>The returned property change handler object keeps track of the subscription. When it goes out of scope, the callback is unsubscribed.</p>
<p>This method is in some cases easier to use than <a href="qobjectbindableproperty.html#onValueChanged" translate="no">onValueChanged</a>(), as the returned object is not a template. It can therefore more easily be stored, e.g. as a member in a class.</p>
<p><b>See also </b><a href="qobjectbindableproperty.html#onValueChanged" translate="no">onValueChanged</a>() and <a href="qobjectbindableproperty.html#subscribe" translate="no">subscribe</a>().</p>
<!-- @@@addNotifier -->
<!-- $$$binding[overload1]$$$binding -->
<h3 class="fn" translate="no" id="binding"><span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QObjectBindableProperty::<span class="name">binding</span>() const</h3>
<p>Returns the binding expression that is associated with this property. A default constructed QPropertyBinding&lt;T&gt; will be returned if no such association exists.</p>
<p><b>See also </b><a href="qobjectbindableproperty.html#setBinding" translate="no">setBinding</a>().</p>
<!-- @@@binding -->
<!-- $$$hasBinding[overload1]$$$hasBinding -->
<h3 class="fn" translate="no" id="hasBinding"><span class="type">bool</span> QObjectBindableProperty::<span class="name">hasBinding</span>() const</h3>
<p>Returns true if the property is associated with a binding; false otherwise.</p>
<!-- @@@hasBinding -->
<!-- $$$notify[overload1]$$$notify -->
<h3 class="fn" translate="no" id="notify"><span class="type">void</span> QObjectBindableProperty::<span class="name">notify</span>()</h3>
<p>Programmatically signals a change of the property. Any binding which depend on it will be notified, and if the property has a signal, it will be emitted.</p>
<p>This can be useful in combination with setValueBypassingBindings to defer signalling the change until a class invariant has been restored.</p>
<div class="admonition note">
<p><b>Note: </b>If this property has a binding (i.e. <a href="qobjectbindableproperty.html#hasBinding" translate="no">hasBinding</a>() returns true), that binding is not reevaluated when notify() is called. Any binding depending on this property is still reevaluated as usual.</p>
</div>
<p><b>See also </b><a href="qproperty.html#beginPropertyUpdateGroup" translate="no">Qt::beginPropertyUpdateGroup</a>() and <a href="qpropertydata.html#setValueBypassingBindings" translate="no">setValueBypassingBindings</a>().</p>
<!-- @@@notify -->
<!-- $$$onValueChanged[overload1]$$$onValueChangedFunctor -->
<h3 class="fn" translate="no" id="onValueChanged">template &lt;typename Functor&gt; <span class="type"><a href="qpropertychangehandler.html" translate="no">QPropertyChangeHandler</a></span>&lt;<span class="type">Functor</span>&gt; QObjectBindableProperty::<span class="name">onValueChanged</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>Registers the given functor <i translate="no">f</i> as a callback that shall be called whenever the value of the property changes. On each value change, the handler is either called immediately, or deferred, depending on the context.</p>
<p>The callback <i translate="no">f</i> is expected to be a type that has a plain call operator <code translate="no">()</code> without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p>
<p>The returned property change handler object keeps track of the registration. When it goes out of scope, the callback is de-registered.</p>
<!-- @@@onValueChanged -->
<!-- $$$setBinding[overload1]$$$setBindingconstQPropertyBinding<T>& -->
<h3 class="fn" translate="no" id="setBinding"><span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QObjectBindableProperty::<span class="name">setBinding</span>(const <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;<i>newBinding</i>)</h3>
<p>Associates the value of this property with the provided <i translate="no">newBinding</i> expression and returns the previously associated binding. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly. When the property value changes, the owner is notified via the Callback function.</p>
<p><b>See also </b><a href="qobjectbindableproperty.html#binding" translate="no">binding</a>().</p>
<!-- @@@setBinding -->
<!-- $$$setBinding$$$setBindingconstQUntypedPropertyBinding& -->
<h3 class="fn" translate="no" id="setBinding-1"><span class="type">bool</span> QObjectBindableProperty::<span class="name">setBinding</span>(const <span class="type">QUntypedPropertyBinding</span> &amp;<i>newBinding</i>)</h3>
<p>This is an overloaded function.</p>
<p>Associates the value of this property with the provided <i translate="no">newBinding</i> expression. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<p>Returns <code translate="no">true</code> if the type of this property is the same as the type the binding function returns; <code translate="no">false</code> otherwise.</p>
<!-- @@@setBinding -->
<!-- $$$setBinding$$$setBindingFunctor -->
<h3 class="fn" translate="no" id="setBinding-2">template &lt;typename Functor&gt; <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QObjectBindableProperty::<span class="name">setBinding</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>This is an overloaded function.</p>
<p>Associates the value of this property with the provided functor <i translate="no">f</i> and returns the previously associated binding. The property's value is set to the result of evaluating the new binding by invoking the call operator <code translate="no">()</code> of <i translate="no">f</i>. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<p>When the property value changes, the owner is notified via the Callback function.</p>
<p><b>See also </b><a href="bindableproperties.html#formulating-a-property-binding" translate="no">Formulating a Property Binding</a>.</p>
<!-- @@@setBinding -->
<!-- $$$subscribe[overload1]$$$subscribeFunctor -->
<h3 class="fn" translate="no" id="subscribe">template &lt;typename Functor&gt; <span class="type"><a href="qpropertychangehandler.html" translate="no">QPropertyChangeHandler</a></span>&lt;<span class="type">Functor</span>&gt; QObjectBindableProperty::<span class="name">subscribe</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>Subscribes the given functor <i translate="no">f</i> as a callback that is called immediately and whenever the value of the property changes in the future. On each value change, the handler is either called immediately, or deferred, depending on the context.</p>
<p>The callback <i translate="no">f</i> is expected to be a type that has a plain call operator <code translate="no">()</code> without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p>
<p>The returned property change handler object keeps track of the subscription. When it goes out of scope, the callback is unsubscribed.</p>
<!-- @@@subscribe -->
<!-- $$$takeBinding[overload1]$$$takeBinding -->
<h3 class="fn" translate="no" id="takeBinding"><span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QObjectBindableProperty::<span class="name">takeBinding</span>()</h3>
<p>Disassociates the binding expression from this property and returns it. After calling this function, the value of the property will only change if you assign a new value to it, or when a new binding is set.</p>
<!-- @@@takeBinding -->
<!-- $$$value[overload1]$$$value -->
<h3 class="fn" translate="no" id="value"><span class="type"><a href="qobjectbindableproperty.html#QObjectBindableProperty" translate="no">QObjectBindableProperty</a></span>&lt;<span class="type">Class</span>, <span class="type">T</span>, <span class="type">Offset</span>, <span class="type">Signal</span>&gt;<span class="type">::parameter_type</span> QObjectBindableProperty::<span class="name">value</span>() const</h3>
<p>Returns the value of the property. This may evaluate a binding expression that is tied to this property, before returning the value.</p>
<p><b>See also </b><a href="qobjectbindableproperty.html#setValue" translate="no">setValue</a>().</p>
<!-- @@@value -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$Q_OBJECT_BINDABLE_PROPERTY[overload1]$$$Q_OBJECT_BINDABLE_PROPERTY -->
<h3 class="fn" translate="no" id="Q_OBJECT_BINDABLE_PROPERTY"><code class="details extra" translate="no">[since 6.0]</code> <span class="name">Q_OBJECT_BINDABLE_PROPERTY</span>(<i>containingClass</i>, <i>type</i>, <i>name</i>, <i>signal</i>)</h3>
<p>Declares a <a href="qobjectbindableproperty.html" translate="no">QObjectBindableProperty</a> inside <i translate="no">containingClass</i> of type <i translate="no">type</i> with name <i translate="no">name</i>. If the optional argument <i translate="no">signal</i> is given, this signal will be emitted when the property is marked dirty.</p>
<p>This macro was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="properties.html" translate="no">Qt's Property System</a> and <a href="bindableproperties.html" translate="no">Qt Bindable Properties</a>.</p>
<!-- @@@Q_OBJECT_BINDABLE_PROPERTY -->
<!-- $$$Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS[overload1]$$$Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS -->
<h3 class="fn" translate="no" id="Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS"><code class="details extra" translate="no">[since 6.0]</code> <span class="name">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</span>(<i>containingClass</i>, <i>type</i>, <i>name</i>, <i>initialvalue</i>, <i>signal</i>)</h3>
<p>Declares a <a href="qobjectbindableproperty.html" translate="no">QObjectBindableProperty</a> inside <i translate="no">containingClass</i> of type <i translate="no">type</i> with name <i translate="no">name</i> which is initialized to <i translate="no">initialvalue</i>. If the optional argument <i translate="no">signal</i> is given, this signal will be emitted when the property is marked dirty.</p>
<p>This macro was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="properties.html" translate="no">Qt's Property System</a> and <a href="bindableproperties.html" translate="no">Qt Bindable Properties</a>.</p>
<!-- @@@Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
