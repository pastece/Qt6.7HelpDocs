<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qfuture.qdoc -->
  <meta name="description" content="Contains miscellaneous identifiers used by the QFuture class.">
  <title>QtFuture Namespace | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li>QtFuture Namespace</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#classes">Classes</a></li>
<li class="level1"><a href="#types">Types</a></li>
<li class="level1"><a href="#functions">Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QtFuture Namespace</h1>
<!-- $$$QtFuture-brief -->
<p>Contains miscellaneous identifiers used by the <a href="qfuture.html" translate="no">QFuture</a> class. <a href="#details">More...</a></p>
<!-- @@@QtFuture -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;<a href="qfuture.html" translate="no">QFuture</a>&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qtfuture-obsolete.html">Deprecated members</a></li>
</ul>
<h2 id="classes">Classes</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> struct </td><td class="memItemRight bottomAlign"><b><a href="qtfuture-whenanyresult.html" translate="no">WhenAnyResult</a></b></td></tr>
</table></div>
<h2 id="types">Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> enum class </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#Launch-enum" translate="no">Launch</a></b> { Sync, Async, Inherit }</td></tr>
</table></div>
<h2 id="functions">Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;QtFuture::ArgsType&lt;Signal&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#connect" translate="no">connect</a></b>(Sender *<i>sender</i>, Signal <i>signal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeExceptionalFuture" translate="no">makeExceptionalFuture</a></b>(const QException &amp;<i>exception</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeExceptionalFuture-1" translate="no">makeExceptionalFuture</a></b>(std::__exception_ptr::exception_ptr <i>exception</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QFuture&lt;QtFuture::ContainedType&lt;Container&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeReadyRangeFuture" translate="no">makeReadyRangeFuture</a></b>(Container &amp;&amp;<i>container</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QFuture&lt;ValueType&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeReadyRangeFuture-1" translate="no">makeReadyRangeFuture</a></b>(std::initializer_list&lt;ValueType&gt; <i>values</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QFuture&lt;std::decay_t&lt;T&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeReadyValueFuture" translate="no">makeReadyValueFuture</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QFuture&lt;void&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeReadyVoidFuture" translate="no">makeReadyVoidFuture</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> QFuture&lt;OutputSequence&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#whenAll" translate="no">whenAll</a></b>(InputIt <i>first</i>, InputIt <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> QFuture&lt;OutputSequence&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#whenAll-1" translate="no">whenAll</a></b>(Futures &amp;&amp;... <i>futures</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> QFuture&lt;QtFuture::WhenAnyResult&lt;T&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#whenAny" translate="no">whenAny</a></b>(InputIt <i>first</i>, InputIt <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> QFuture&lt;std::variant&lt;std::decay_t&lt;Futures&gt;...&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#whenAny-1" translate="no">whenAny</a></b>(Futures &amp;&amp;... <i>futures</i>)</td></tr>
</table></div>
<!-- $$$QtFuture-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
</div>
<!-- @@@QtFuture -->
<div class="classes">
<h2>Classes</h2>
<h3> class <a href="qtfuture-whenanyresult.html">WhenAnyResult</a></h3><!-- $$$WhenAnyResult-brief -->
<p><a href="qtfuture-whenanyresult.html" translate="no">QtFuture::WhenAnyResult</a> is used to represent the result of <a href="qtfuture.html#whenAny" translate="no">QtFuture::whenAny</a>(). <a href="qtfuture-whenanyresult.html#details">More...</a></p>
<!-- @@@WhenAnyResult -->
</div>
<div class="types">
<h2>Type Documentation</h2>
<!-- $$$Launch$$$Sync$$$Async$$$Inherit -->
<h3 class="fn" translate="no" id="Launch-enum"><code class="details extra" translate="no">[since 6.0]</code> enum class QtFuture::<span class="name">Launch</span></h3>
<p>Represents execution policies for running a <a href="qfuture.html" translate="no">QFuture</a> continuation.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QtFuture::Launch::Sync</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The continuation will be launched in the same thread that fulfills the promise associated with the future to which the continuation was attached, or if it has already finished, the continuation will be invoked immediately, in the thread that executes <code translate="no">then()</code>.</td></tr>
<tr><td class="topAlign"><code translate="no">QtFuture::Launch::Async</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The continuation will be launched in a separate thread taken from the global <a href="qthreadpool.html" translate="no">QThreadPool</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QtFuture::Launch::Inherit</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The continuation will inherit the launch policy or thread pool of the future to which it is attached.</td></tr>
</table></div>
<p><code translate="no">Sync</code> is used as a default launch policy.</p>
<p>This enum was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#then" translate="no">QFuture::then</a>() and <a href="qthreadpool.html#globalInstance" translate="no">QThreadPool::globalInstance</a>().</p>
<!-- @@@Launch -->
</div>
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$connect[overload1]$$$connectSender*Signal -->
<h3 class="fn" translate="no" id="connect">template &lt;typename Sender, typename Signal, typename = QtPrivate::EnableIfInvocable&lt;Sender, Signal&gt;> <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">QtFuture::ArgsType</span>&lt;<span class="type">Signal</span>&gt;&gt; QtFuture::<span class="name">connect</span>(<span class="type">Sender</span> *<i>sender</i>, <span class="type">Signal</span> <i>signal</i>)</h3>
<p>Creates and returns a <a href="qfuture.html" translate="no">QFuture</a> which will become available when the <i translate="no">sender</i> emits the <i translate="no">signal</i>. If the <i translate="no">signal</i> takes no arguments, a <a href="qfuture.html" translate="no">QFuture</a>&lt;void&gt; is returned. If the <i translate="no">signal</i> takes a single argument, the resulted <a href="qfuture.html" translate="no">QFuture</a> will be filled with the signal's argument value. If the <i translate="no">signal</i> takes multiple arguments, the resulted <a href="qfuture.html" translate="no">QFuture</a> is filled with std::tuple storing the values of signal's arguments. If the <i translate="no">sender</i> is destroyed before the <i translate="no">signal</i> is emitted, the resulted <a href="qfuture.html" translate="no">QFuture</a> will be canceled.</p>
<p>For example, let's say we have the following object:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Object : <span class="keyword">public</span> <span class="type"><a href="qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">signals</span>:
     <span class="type">void</span> noArgSignal();
     <span class="type">void</span> singleArgSignal(<span class="type">int</span> value);
     <span class="type">void</span> multipleArgs(<span class="type">int</span> value1<span class="operator">,</span> <span class="type">double</span> value2<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>value3);
 };
</pre>
<p>We can connect its signals to <a href="qfuture.html" translate="no">QFuture</a> objects in the following way:</p>
<pre class="cpp" translate="no">
 Object object;
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span> voidFuture <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>noArgSignal);
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> intFuture <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>singleArgSignal);

 <span class="keyword">using</span> Args <span class="operator">=</span> std<span class="operator">::</span>tuple<span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type">double</span><span class="operator">,</span> <span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span>;
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span>Args<span class="operator">&gt;</span> tupleFuture <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>multipleArgs)
</pre>
<p>We can also chain continuations to be run when a signal is emitted:</p>
<pre class="cpp" translate="no">
 <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>singleArgSignal)<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> value) {
     <span class="comment">// do something with the value</span>
 });
</pre>
<p>You can also start the continuation in a new thread or a custom thread pool using <a href="qtfuture.html#Launch-enum" translate="no">QtFuture::Launch</a> policies. For example:</p>
<pre class="cpp" translate="no">
 <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>singleArgSignal)<span class="operator">.</span>then(<span class="type">QtFuture</span><span class="operator">::</span>Launch<span class="operator">::</span>Async<span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> value) {
     <span class="comment">// this will run in a new thread</span>
 });
</pre>
<p>Throwing an exception from a slot invoked by Qt's signal-slot connection is considered to be an undefined behavior, if it is not handled within the slot. But with QFuture::connect(), you can throw and handle exceptions from the continuations:</p>
<pre class="cpp" translate="no">
 <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>singleArgSignal)<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> value) {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">throw</span> std<span class="operator">::</span>exception();
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> std<span class="operator">::</span>exception <span class="operator">&amp;</span>e) {
     <span class="comment">// handle the exception</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// handle other exceptions</span>
 });
</pre>
<div class="admonition note">
<p><b>Note: </b>The connected future will be fulfilled only once, when the signal is emitted for the first time.</p>
</div>
<p><b>See also </b><a href="qfuture.html" translate="no">QFuture</a> and <a href="qfuture.html#then" translate="no">QFuture::then</a>().</p>
<!-- @@@connect -->
<!-- $$$makeExceptionalFuture[overload1]$$$makeExceptionalFutureconstQException& -->
<h3 class="fn" translate="no" id="makeExceptionalFuture"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename T = void&gt; <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtFuture::<span class="name">makeExceptionalFuture</span>(const <span class="type"><a href="qexception.html" translate="no">QException</a></span> &amp;<i>exception</i>)</h3>
<p>Creates and returns a <a href="qfuture.html" translate="no">QFuture</a> which already has an exception <i translate="no">exception</i>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qexception.html" translate="no">QException</a></span> e;
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeExceptionalFuture<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(e);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">try</span> {
     f<span class="operator">.</span>result(); <span class="comment">// throws QException</span>
 } <span class="keyword">catch</span> (<span class="type"><a href="qexception.html" translate="no">QException</a></span> <span class="operator">&amp;</span>) {
     <span class="comment">// handle exception here</span>
 }
</pre>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html" translate="no">QFuture</a>, <a href="qexception.html" translate="no">QException</a>, <a href="qtfuture.html#makeReadyVoidFuture" translate="no">QtFuture::makeReadyVoidFuture</a>(), and <a href="qtfuture.html#makeReadyValueFuture" translate="no">QtFuture::makeReadyValueFuture</a>().</p>
<!-- @@@makeExceptionalFuture -->
<!-- $$$makeExceptionalFuture$$$makeExceptionalFuturestd::__exception_ptr::exception_ptr -->
<h3 class="fn" translate="no" id="makeExceptionalFuture-1"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename T = void&gt; <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtFuture::<span class="name">makeExceptionalFuture</span>(<span class="type">std::__exception_ptr::exception_ptr</span> <i>exception</i>)</h3>
<p>This is an overloaded function.</p>
<p>Creates and returns a <a href="qfuture.html" translate="no">QFuture</a> which already has an exception <i translate="no">exception</i>.</p>
<pre class="cpp" translate="no">
 <span class="keyword">struct</span> TestException
 {
 };
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">auto</span> exception <span class="operator">=</span> std<span class="operator">::</span>make_exception_ptr(TestException());
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeExceptionalFuture<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(exception);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">try</span> {
     f<span class="operator">.</span>result(); <span class="comment">// throws TestException</span>
 } <span class="keyword">catch</span> (TestException <span class="operator">&amp;</span>) {
     <span class="comment">// handle exception here</span>
 }
</pre>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html" translate="no">QFuture</a>, <a href="qexception.html" translate="no">QException</a>, <a href="qtfuture.html#makeReadyVoidFuture" translate="no">QtFuture::makeReadyVoidFuture</a>(), and <a href="qtfuture.html#makeReadyValueFuture" translate="no">QtFuture::makeReadyValueFuture</a>().</p>
<!-- @@@makeExceptionalFuture -->
<!-- $$$makeReadyRangeFuture[overload1]$$$makeReadyRangeFutureContainer&& -->
<h3 class="fn" translate="no" id="makeReadyRangeFuture"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename Container, QtFuture::if_container_with_input_iterators&lt;Container&gt; = true> <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">QtFuture::ContainedType</span>&lt;<span class="type">Container</span>&gt;&gt; QtFuture::<span class="name">makeReadyRangeFuture</span>(<span class="type">Container</span> &amp;&amp;<i>container</i>)</h3>
<p>This is an overloaded function.</p>
<p>Takes an input container <i translate="no">container</i> and returns a <a href="qfuture.html" translate="no">QFuture</a> with multiple results of type <code translate="no">ContainedType</code> initialized from the values of the <i translate="no">container</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This overload only participates in overload resolution if the <code translate="no">Container</code> has input iterators.</p>
</div>
<pre class="cpp" translate="no">
 <span class="keyword">const</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> values{<span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span>};
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeReadyRangeFuture(values);
     ...
 <span class="keyword">const</span> <span class="type">int</span> count <span class="operator">=</span> f<span class="operator">.</span>resultCount(); <span class="comment">// count == 3</span>
 <span class="keyword">const</span> <span class="keyword">auto</span> results <span class="operator">=</span> f<span class="operator">.</span>results(); <span class="comment">// results == { 1, 2, 3 }</span>
</pre>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qfuture.html" translate="no">QFuture</a>, <a href="qtfuture.html#makeReadyVoidFuture" translate="no">QtFuture::makeReadyVoidFuture</a>(), <a href="qtfuture.html#makeReadyValueFuture" translate="no">QtFuture::makeReadyValueFuture</a>(), and <a href="qtfuture.html#makeExceptionalFuture" translate="no">QtFuture::makeExceptionalFuture</a>().</p>
<!-- @@@makeReadyRangeFuture -->
<!-- $$$makeReadyRangeFuture$$$makeReadyRangeFuturestd::initializer_list<ValueType> -->
<h3 class="fn" translate="no" id="makeReadyRangeFuture-1"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename ValueType&gt; <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">ValueType</span>&gt; QtFuture::<span class="name">makeReadyRangeFuture</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">ValueType</span>&gt; <i>values</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="qfuture.html" translate="no">QFuture</a> with multiple results of type <code translate="no">ValueType</code> initialized from the input initializer list <i translate="no">values</i>.</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeReadyRangeFuture({<span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span>});
     ...
 <span class="keyword">const</span> <span class="type">int</span> count <span class="operator">=</span> f<span class="operator">.</span>resultCount(); <span class="comment">// count == 3</span>
 <span class="keyword">const</span> <span class="keyword">auto</span> results <span class="operator">=</span> f<span class="operator">.</span>results(); <span class="comment">// results == { 1, 2, 3 }</span>
</pre>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qfuture.html" translate="no">QFuture</a>, <a href="qtfuture.html#makeReadyVoidFuture" translate="no">QtFuture::makeReadyVoidFuture</a>(), <a href="qtfuture.html#makeReadyValueFuture" translate="no">QtFuture::makeReadyValueFuture</a>(), and <a href="qtfuture.html#makeExceptionalFuture" translate="no">QtFuture::makeExceptionalFuture</a>().</p>
<!-- @@@makeReadyRangeFuture -->
<!-- $$$makeReadyValueFuture[overload1]$$$makeReadyValueFutureT&& -->
<h3 class="fn" translate="no" id="makeReadyValueFuture"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename T&gt; <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">std::decay_t</span>&lt;<span class="type">T</span>&gt;&gt; QtFuture::<span class="name">makeReadyValueFuture</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>Creates and returns a <a href="qfuture.html" translate="no">QFuture</a> which already has a result <i translate="no">value</i>. The returned <a href="qfuture.html" translate="no">QFuture</a> has a type of std::decay_t&lt;T&gt;, where T is not void. The returned <a href="qfuture.html" translate="no">QFuture</a> will already be in the finished state.</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeReadyValueFuture(std<span class="operator">::</span>make_unique<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(<span class="number">42</span>));
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">const</span> <span class="type">int</span> result <span class="operator">=</span> <span class="operator">*</span>f<span class="operator">.</span>takeResult(); <span class="comment">// result == 42</span>
</pre>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qfuture.html" translate="no">QFuture</a>, <a href="qtfuture.html#makeReadyRangeFuture" translate="no">QtFuture::makeReadyRangeFuture</a>(), <a href="qtfuture.html#makeReadyVoidFuture" translate="no">QtFuture::makeReadyVoidFuture</a>(), and <a href="qtfuture.html#makeExceptionalFuture" translate="no">QtFuture::makeExceptionalFuture</a>().</p>
<!-- @@@makeReadyValueFuture -->
<!-- $$$makeReadyVoidFuture[overload1]$$$makeReadyVoidFuture -->
<h3 class="fn" translate="no" id="makeReadyVoidFuture"><code class="details extra" translate="no">[since 6.6]</code> <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">void</span>&gt; QtFuture::<span class="name">makeReadyVoidFuture</span>()</h3>
<p>Creates and returns a void <a href="qfuture.html" translate="no">QFuture</a>. Such <a href="qfuture.html" translate="no">QFuture</a> can't store any result. One can use it to query the state of the computation. The returned <a href="qfuture.html" translate="no">QFuture</a> will already be in the finished state.</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeReadyVoidFuture();
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">const</span> <span class="type">bool</span> started <span class="operator">=</span> f<span class="operator">.</span>isStarted(); <span class="comment">// started == true</span>
 <span class="keyword">const</span> <span class="type">bool</span> running <span class="operator">=</span> f<span class="operator">.</span>isRunning(); <span class="comment">// running == false</span>
 <span class="keyword">const</span> <span class="type">bool</span> finished <span class="operator">=</span> f<span class="operator">.</span>isFinished(); <span class="comment">// finished == true</span>
</pre>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qfuture.html" translate="no">QFuture</a>, <a href="qfuture.html#isStarted" translate="no">QFuture::isStarted</a>(), <a href="qfuture.html#isRunning" translate="no">QFuture::isRunning</a>(), <a href="qfuture.html#isFinished" translate="no">QFuture::isFinished</a>(), <a href="qtfuture.html#makeReadyValueFuture" translate="no">QtFuture::makeReadyValueFuture</a>(), <a href="qtfuture.html#makeReadyRangeFuture" translate="no">QtFuture::makeReadyRangeFuture</a>(), and <a href="qtfuture.html#makeExceptionalFuture" translate="no">QtFuture::makeExceptionalFuture</a>().</p>
<!-- @@@makeReadyVoidFuture -->
<!-- $$$whenAll[overload1]$$$whenAllInputItInputIt -->
<h3 class="fn" translate="no" id="whenAll"><code class="details extra" translate="no">[since 6.3]</code> template &lt;typename OutputSequence, typename InputIt&gt; <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">OutputSequence</span>&gt; QtFuture::<span class="name">whenAll</span>(<span class="type">InputIt</span> <i>first</i>, <span class="type">InputIt</span> <i>last</i>)</h3>
<p>Returns a new <a href="qfuture.html" translate="no">QFuture</a> that succeeds when all futures from <i translate="no">first</i> to <i translate="no">last</i> complete. <i translate="no">first</i> and <i translate="no">last</i> are iterators to a sequence of futures packaging type <code translate="no">T</code>. <code translate="no">OutputSequence</code> is a sequence containing all completed futures from <i translate="no">first</i> to <i translate="no">last</i>, appearing in the same order as in the input. If the type of <code translate="no">OutputSequence</code> is not specified, the resulting futures will be returned in a <code translate="no">QList</code> of <code translate="no">QFuture&lt;T&gt;</code>. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span> inputFutures {<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>};

 <span class="comment">// whenAll has type QFuture&lt;QList&lt;QFuture&lt;int&gt;&gt;&gt;</span>
 <span class="keyword">auto</span> whenAll <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>whenAll(inputFutures<span class="operator">.</span>begin()<span class="operator">,</span> inputFutures<span class="operator">.</span>end());

 <span class="comment">// whenAllVector has type QFuture&lt;std::vector&lt;QFuture&lt;int&gt;&gt;&gt;</span>
 <span class="keyword">auto</span> whenAllVector <span class="operator">=</span>
         <span class="type">QtFuture</span><span class="operator">::</span>whenAll<span class="operator">&lt;</span>std<span class="operator">::</span>vector<span class="operator">&lt;</span><span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span><span class="operator">&gt;</span>(inputFutures<span class="operator">.</span>begin()<span class="operator">,</span> inputFutures<span class="operator">.</span>end());
</pre>
<div class="admonition note">
<p><b>Note: </b>The output sequence must support random access and the <code translate="no">resize()</code> operation.</p>
</div>
<p>If <code translate="no">first</code> equals <code translate="no">last</code>, this function returns a ready <a href="qfuture.html" translate="no">QFuture</a> that contains an empty <code translate="no">OutputSequence</code>.</p>
<p>The returned future always completes successfully after all the specified futures complete. It doesn't matter if any of these futures completes with error or is canceled. You can use <code translate="no">.then()</code> to process the completed futures after the future returned by <code translate="no">whenAll()</code> succeeds:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span> inputFutures {<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>};

 <span class="type">QtFuture</span><span class="operator">::</span>whenAll(inputFutures<span class="operator">.</span>begin()<span class="operator">,</span> inputFutures<span class="operator">.</span>end())
         <span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="operator">&amp;</span>results) {
             <span class="keyword">for</span> (<span class="keyword">auto</span> future : results) {
                 <span class="keyword">if</span> (future<span class="operator">.</span>isCanceled())
                     <span class="comment">// handle the cancellation (possibly due to an exception)</span>
                 <span class="keyword">else</span>
                     <span class="comment">// do something with the result</span>
             }
         });
</pre>
<div class="admonition note">
<p><b>Note: </b>If the input futures complete on different threads, the future returned by this method will complete in the thread that the last future completes in. Therefore, the continuations attached to the future returned by <code translate="no">whenAll()</code> cannot always make assumptions about which thread they will be run on. Use the overload of <code translate="no">.then()</code> that takes a context object if you want to control which thread the continuations are invoked on.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@whenAll -->
<!-- $$$whenAll$$$whenAllFutures&&... -->
<h3 class="fn" translate="no" id="whenAll-1"><code class="details extra" translate="no">[since 6.3]</code> template &lt;typename OutputSequence, typename... Futures&gt; <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">OutputSequence</span>&gt; QtFuture::<span class="name">whenAll</span>(<span class="type">Futures</span> &amp;&amp;... <i>futures</i>)</h3>
<p>Returns a new <a href="qfuture.html" translate="no">QFuture</a> that succeeds when all <i translate="no">futures</i> packaging arbitrary types complete. <code translate="no">OutputSequence</code> is a sequence of completed futures. The type of its entries is <code translate="no">std::variant&lt;Futures...&gt;</code>. For each <code translate="no">QFuture&lt;T&gt;</code> passed to <code translate="no">whenAll()</code>, the entry at the corresponding position in <code translate="no">OutputSequence</code> will be a <code translate="no">std::variant</code> holding that <code translate="no">QFuture&lt;T&gt;</code>, in its completed state. If the type of <code translate="no">OutputSequence</code> is not specified, the resulting futures will be returned in a <a href="qlist.html" translate="no">QList</a> of <code translate="no">std::variant&lt;Futures...&gt;</code>. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> intFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> stringFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span> voidFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;

 <span class="keyword">using</span> FuturesVariant <span class="operator">=</span> std<span class="operator">::</span>variant<span class="operator">&lt;</span><span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">,</span> <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span><span class="operator">,</span> <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span><span class="operator">&gt;</span>;

 <span class="comment">// whenAll has type QFuture&lt;QList&lt;FuturesVariant&gt;&gt;</span>
 <span class="keyword">auto</span> whenAll <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>whenAll(intFuture<span class="operator">,</span> stringFuture<span class="operator">,</span> voidFuture);

 <span class="comment">// whenAllVector has type QFuture&lt;std::vector&lt;FuturesVariant&gt;&gt;</span>
 <span class="keyword">auto</span> whenAllVector <span class="operator">=</span>
         <span class="type">QtFuture</span><span class="operator">::</span>whenAll<span class="operator">&lt;</span>std<span class="operator">::</span>vector<span class="operator">&lt;</span>FuturesVariant<span class="operator">&gt;</span><span class="operator">&gt;</span>(intFuture<span class="operator">,</span> stringFuture<span class="operator">,</span> voidFuture);
</pre>
<div class="admonition note">
<p><b>Note: </b>The output sequence should support random access and the <code translate="no">resize()</code> operation.</p>
</div>
<p>The returned future always completes successfully after all the specified futures complete. It doesn't matter if any of these futures completes with error or is canceled. You can use <code translate="no">.then()</code> to process the completed futures after the future returned by <code translate="no">whenAll()</code> succeeds:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> intFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> stringFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span> voidFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;

 <span class="keyword">using</span> FuturesVariant <span class="operator">=</span> std<span class="operator">::</span>variant<span class="operator">&lt;</span><span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">,</span> <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span><span class="operator">,</span> <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span><span class="operator">&gt;</span>;

 <span class="type">QtFuture</span><span class="operator">::</span>whenAll(intFuture<span class="operator">,</span> stringFuture<span class="operator">,</span> voidFuture)
         <span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span>FuturesVariant<span class="operator">&gt;</span> <span class="operator">&amp;</span>results) {
             <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
             <span class="keyword">for</span> (<span class="keyword">auto</span> result : results)
             {
                 <span class="comment">// assuming handleResult() is overloaded based on the QFuture type</span>
                 std<span class="operator">::</span>visit(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">auto</span> <span class="operator">&amp;</span><span class="operator">&amp;</span>future) { handleResult(future); }<span class="operator">,</span> result);
             }
             <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         });
</pre>
<div class="admonition note">
<p><b>Note: </b>If the input futures complete on different threads, the future returned by this method will complete in the thread that the last future completes in. Therefore, the continuations attached to the future returned by <code translate="no">whenAll()</code> cannot always make assumptions about which thread they will be run on. Use the overload of <code translate="no">.then()</code> that takes a context object if you want to control which thread the continuations are invoked on.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@whenAll -->
<!-- $$$whenAny[overload1]$$$whenAnyInputItInputIt -->
<h3 class="fn" translate="no" id="whenAny"><code class="details extra" translate="no">[since 6.3]</code> template &lt;typename T, typename InputIt&gt; <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type"><a href="qtfuture-whenanyresult.html" translate="no">QtFuture::WhenAnyResult</a></span>&lt;<span class="type">T</span>&gt;&gt; QtFuture::<span class="name">whenAny</span>(<span class="type">InputIt</span> <i>first</i>, <span class="type">InputIt</span> <i>last</i>)</h3>
<p>Returns a new <a href="qfuture.html" translate="no">QFuture</a> that succeeds when any of the futures from <i translate="no">first</i> to <i translate="no">last</i> completes. <i translate="no">first</i> and <i translate="no">last</i> are iterators to a sequence of futures packaging type <code translate="no">T</code>. The returned future packages a value of type <code translate="no">QtFuture::WhenAnyResult&lt;T&gt;</code> which in turn packages the index of the first completed <code translate="no">QFuture</code> and the <code translate="no">QFuture</code> itself. If <i translate="no">first</i> equals <i translate="no">last</i>, this function returns a ready <code translate="no">QFuture</code> that has <code translate="no">-1</code> for the <code translate="no">index</code> field in the <a href="qtfuture-whenanyresult.html" translate="no">QtFuture::WhenAnyResult</a> struct and a default-constructed <code translate="no">QFuture&lt;T&gt;</code> for the <code translate="no">future</code> field. Note that a default-constructed <a href="qfuture.html" translate="no">QFuture</a> is a completed future in a cancelled state.</p>
<p>The returned future always completes successfully after the first future from the specified futures completes. It doesn't matter if the first future completes with error or is canceled. You can use <code translate="no">.then()</code> to process the result after the future returned by <code translate="no">whenAny()</code> succeeds:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span> inputFutures <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;

 <span class="type">QtFuture</span><span class="operator">::</span>whenAny(inputFutures<span class="operator">.</span>begin()<span class="operator">,</span> inputFutures<span class="operator">.</span>end())
         <span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type">QtFuture</span><span class="operator">::</span>WhenAnyResult<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span>result) {
             qsizetype index <span class="operator">=</span> result<span class="operator">.</span>index;
             <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> result<span class="operator">.</span>future;
             <span class="comment">// ...</span>
         });
</pre>
<div class="admonition note">
<p><b>Note: </b>If the input futures complete on different threads, the future returned by this method will complete in the thread that the first future completes in. Therefore, the continuations attached to the future returned by <code translate="no">whenAny()</code> cannot always make assumptions about which thread they will be run on. Use the overload of <code translate="no">.then()</code> that takes a context object if you want to control which thread the continuations are invoked on.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qtfuture-whenanyresult.html" translate="no">QtFuture::WhenAnyResult</a>.</p>
<!-- @@@whenAny -->
<!-- $$$whenAny$$$whenAnyFutures&&... -->
<h3 class="fn" translate="no" id="whenAny-1"><code class="details extra" translate="no">[since 6.3]</code> template &lt;typename... Futures&gt; <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">std::variant</span>&lt;<span class="type">std::decay_t</span>&lt;<span class="type">Futures</span>&gt;...&gt;&gt; QtFuture::<span class="name">whenAny</span>(<span class="type">Futures</span> &amp;&amp;... <i>futures</i>)</h3>
<p>Returns a new <a href="qfuture.html" translate="no">QFuture</a> that succeeds when any of the <i translate="no">futures</i> completes. <i translate="no">futures</i> can package arbitrary types. The returned future packages the value of type <code translate="no">std::variant&lt;Futures...&gt;</code> which in turn packages the first completed <a href="qfuture.html" translate="no">QFuture</a> from <i translate="no">futures</i>. You can use <a href="https://en.cppreference.com/w/cpp/utility/variant/index" translate="no">std::variant::index()</a> to find out the index of the future in the sequence of <i translate="no">futures</i> that finished first.</p>
<p>The returned future always completes successfully after the first future from the specified futures completes. It doesn't matter if the first future completes with error or is canceled. You can use <code translate="no">.then()</code> to process the result after the future returned by <code translate="no">whenAny()</code> succeeds:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> intFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> stringFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span> voidFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;

 <span class="keyword">using</span> FuturesVariant <span class="operator">=</span> std<span class="operator">::</span>variant<span class="operator">&lt;</span><span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">,</span> <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span><span class="operator">,</span> <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span><span class="operator">&gt;</span>;

 <span class="type">QtFuture</span><span class="operator">::</span>whenAny(intFuture<span class="operator">,</span> stringFuture<span class="operator">,</span> voidFuture)<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> FuturesVariant <span class="operator">&amp;</span>result) {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="comment">// assuming handleResult() is overloaded based on the QFuture type</span>
     std<span class="operator">::</span>visit(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">auto</span> <span class="operator">&amp;</span><span class="operator">&amp;</span>future) { handleResult(future); }<span class="operator">,</span> result);
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 });
</pre>
<div class="admonition note">
<p><b>Note: </b>If the input futures complete on different threads, the future returned by this method will complete in the thread that the first future completes in. Therefore, the continuations attached to the future returned by <code translate="no">whenAny()</code> cannot always make assumptions about which thread they will be run on. Use the overload of <code translate="no">.then()</code> that takes a context object if you want to control which thread the continuations are invoked on.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@whenAny -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
