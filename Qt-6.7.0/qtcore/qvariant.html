<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qvariant.cpp -->
  <meta name="description" content="The QVariant class acts like a union for the most common Qt data types.">
  <title>QVariant Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QVariant</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#a-note-on-gui-types">A Note on GUI Types</a></li>
<li class="level2"><a href="#using-canconvert-and-convert-consecutively">Using canConvert() and convert() Consecutively</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QVariant Class</h1>
<!-- $$$QVariant-brief -->
<p>The QVariant class acts like a union for the most common Qt data types. <a href="#details">More...</a></p>
<!-- @@@QVariant -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QVariant&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qvariant-members.html">List of all members, including inherited members</a></li>
<li><a href="qvariant-obsolete.html">Deprecated members</a></li>
<li>QVariant is part of <a href="shared.html">Implicitly Shared Classes</a>.</li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant" translate="no">QVariant</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-1" translate="no">QVariant</a></b>(QMetaType <i>type</i>, const void *<i>copy</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-36" translate="no">QVariant</a></b>(QLineF <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-37" translate="no">QVariant</a></b>(QRect <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-38" translate="no">QVariant</a></b>(QRectF <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-39" translate="no">QVariant</a></b>(const QEasingCurve &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-40" translate="no">QVariant</a></b>(const QJsonDocument &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-41" translate="no">QVariant</a></b>(const QPersistentModelIndex &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-42" translate="no">QVariant</a></b>(const char *<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-43" translate="no">QVariant</a></b>(QLatin1StringView <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-3" translate="no">QVariant</a></b>(std::in_place_type_t&lt;T&gt;, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-4" translate="no">QVariant</a></b>(std::in_place_type_t&lt;T&gt;, std::initializer_list&lt;U&gt; <i>il</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-5" translate="no">QVariant</a></b>(int <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-6" translate="no">QVariant</a></b>(uint <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-7" translate="no">QVariant</a></b>(qlonglong <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-8" translate="no">QVariant</a></b>(qulonglong <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-9" translate="no">QVariant</a></b>(bool <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-10" translate="no">QVariant</a></b>(double <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-11" translate="no">QVariant</a></b>(float <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-12" translate="no">QVariant</a></b>(QChar <i>c</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-13" translate="no">QVariant</a></b>(QDate <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-14" translate="no">QVariant</a></b>(QTime <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-15" translate="no">QVariant</a></b>(const QBitArray &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-16" translate="no">QVariant</a></b>(const QByteArray &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-17" translate="no">QVariant</a></b>(const QDateTime &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-18" translate="no">QVariant</a></b>(const QHash&lt;QString, QVariant&gt; &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-19" translate="no">QVariant</a></b>(const QJsonArray &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-20" translate="no">QVariant</a></b>(const QJsonObject &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-21" translate="no">QVariant</a></b>(const QList&lt;QVariant&gt; &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-22" translate="no">QVariant</a></b>(const QLocale &amp;<i>l</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-23" translate="no">QVariant</a></b>(const QMap&lt;QString, QVariant&gt; &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-24" translate="no">QVariant</a></b>(const QRegularExpression &amp;<i>re</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-25" translate="no">QVariant</a></b>(const QString &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-26" translate="no">QVariant</a></b>(const QStringList &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-27" translate="no">QVariant</a></b>(const QUrl &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-28" translate="no">QVariant</a></b>(const QJsonValue &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-29" translate="no">QVariant</a></b>(const QModelIndex &amp;<i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-30" translate="no">QVariant</a></b>(QUuid <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-31" translate="no">QVariant</a></b>(QSize <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-32" translate="no">QVariant</a></b>(QSizeF <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-33" translate="no">QVariant</a></b>(QPoint <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-34" translate="no">QVariant</a></b>(QPointF <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-35" translate="no">QVariant</a></b>(QLine <i>val</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-2" translate="no">QVariant</a></b>(const QVariant &amp;<i>p</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariant-45" translate="no">QVariant</a></b>(QVariant &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#dtor.QVariant" translate="no">~QVariant</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#canConvert" translate="no">canConvert</a></b>(QMetaType <i>type</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#canView-1" translate="no">canView</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const void *</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#constData" translate="no">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#convert" translate="no">convert</a></b>(QMetaType <i>targetType</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void *</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#data" translate="no">data</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const void *</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#data-1" translate="no">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#emplace" translate="no">emplace</a></b>(Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#emplace-1" translate="no">emplace</a></b>(std::initializer_list&lt;U&gt; <i>list</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#isNull" translate="no">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QMetaType </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#metaType" translate="no">metaType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#setValue" translate="no">setValue</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#setValue-1" translate="no">setValue</a></b>(const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#setValue-2" translate="no">setValue</a></b>(QVariant &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#swap" translate="no">swap</a></b>(QVariant &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBitArray </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toBitArray" translate="no">toBitArray</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toBool" translate="no">toBool</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toByteArray" translate="no">toByteArray</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toChar" translate="no">toChar</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDate </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toDate" translate="no">toDate</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDateTime </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toDateTime" translate="no">toDateTime</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toDouble" translate="no">toDouble</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QEasingCurve </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toEasingCurve" translate="no">toEasingCurve</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toFloat" translate="no">toFloat</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHash&lt;QString, QVariant&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toHash" translate="no">toHash</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toInt" translate="no">toInt</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJsonArray </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toJsonArray" translate="no">toJsonArray</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJsonDocument </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toJsonDocument" translate="no">toJsonDocument</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJsonObject </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toJsonObject" translate="no">toJsonObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJsonValue </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toJsonValue" translate="no">toJsonValue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QLine </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toLine" translate="no">toLine</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QLineF </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toLineF" translate="no">toLineF</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QVariant&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toList" translate="no">toList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QLocale </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toLocale" translate="no">toLocale</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qlonglong </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toLongLong" translate="no">toLongLong</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap&lt;QString, QVariant&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toMap" translate="no">toMap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QModelIndex </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toModelIndex" translate="no">toModelIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPersistentModelIndex </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toPersistentModelIndex" translate="no">toPersistentModelIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPoint </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toPoint" translate="no">toPoint</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toPointF" translate="no">toPointF</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toReal" translate="no">toReal</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRect </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toRect" translate="no">toRect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toRectF" translate="no">toRectF</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpression </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toRegularExpression" translate="no">toRegularExpression</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toSize" translate="no">toSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSizeF </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toSizeF" translate="no">toSizeF</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toString" translate="no">toString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toStringList" translate="no">toStringList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTime </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toTime" translate="no">toTime</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toUInt" translate="no">toUInt</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qulonglong </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toULongLong" translate="no">toULongLong</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrl </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toUrl" translate="no">toUrl</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUuid </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#toUuid" translate="no">toUuid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#typeId" translate="no">typeId</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#typeName" translate="no">typeName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#userType" translate="no">userType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#value" translate="no">value</a></b>() const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#view" translate="no">view</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#operator-eq" translate="no">operator=</a></b>(const QVariant &amp;<i>variant</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#operator-eq-1" translate="no">operator=</a></b>(QVariant &amp;&amp;<i>other</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QPartialOrdering </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#compare" translate="no">compare</a></b>(const QVariant &amp;<i>lhs</i>, const QVariant &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#fromMetaType" translate="no">fromMetaType</a></b>(QMetaType <i>type</i>, const void *<i>copy</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#fromStdVariant" translate="no">fromStdVariant</a></b>(const std::variant&lt;Types...&gt; &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#fromStdVariant-1" translate="no">fromStdVariant</a></b>(std::variant&lt;Types...&gt; &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#fromValue" translate="no">fromValue</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#fromValue-1" translate="no">fromValue</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariantHash-typedef" translate="no">QVariantHash</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariantList-typedef" translate="no">QVariantList</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#get" translate="no">get</a></b>(QVariant &amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#get-1" translate="no">get</a></b>(const QVariant &amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> T &amp;&amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#get-2" translate="no">get</a></b>(QVariant &amp;&amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> const T &amp;&amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#get-3" translate="no">get</a></b>(const QVariant &amp;&amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> T *</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#get_if" translate="no">get_if</a></b>(QVariant *<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> const T *</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#get_if-1" translate="no">get_if</a></b>(const QVariant *<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> T </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#qvariant_cast" translate="no">qvariant_cast</a></b>(QVariant &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#qvariant_cast-1" translate="no">qvariant_cast</a></b>(const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#operator-not-eq" translate="no">operator!=</a></b>(const QVariant &amp;<i>v1</i>, const QVariant &amp;<i>v2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#operator-lt-lt-2" translate="no">operator&lt;&lt;</a></b>(QDataStream &amp;<i>s</i>, const QVariant &amp;<i>p</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#operator-eq-eq" translate="no">operator==</a></b>(const QVariant &amp;<i>v1</i>, const QVariant &amp;<i>v2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvariant.html#operator-gt-gt-2" translate="no">operator&gt;&gt;</a></b>(QDataStream &amp;<i>s</i>, QVariant &amp;<i>p</i>)</td></tr>
</table></div>
<!-- $$$QVariant-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Because C++ forbids unions from including types that have non-default constructors or destructors, most interesting Qt classes cannot be used in unions. Without QVariant, this would be a problem for <a href="qobject.html#property" translate="no">QObject::property</a>() and for database work, etc.</p>
<p>A QVariant object holds a single value of a single <a href="qvariant.html#typeId" translate="no">typeId</a>() at a time. (Some types are multi-valued, for example a string list.) You can find out what type, T, the variant holds, convert it to a different type using <a href="qvariant.html#convert" translate="no">convert</a>(), get its value using one of the toT() functions (e.g., <a href="qvariant.html#toSize" translate="no">toSize</a>()), and check whether the type can be converted to a particular type using <a href="qvariant.html#canConvert-2" translate="no">canConvert</a>().</p>
<p>The methods named toT() (e.g., <a href="qvariant.html#toInt" translate="no">toInt</a>(), <a href="qvariant.html#toString" translate="no">toString</a>()) are const. If you ask for the stored type, they return a copy of the stored object. If you ask for a type that can be generated from the stored type, toT() copies and converts and leaves the object itself unchanged. If you ask for a type that cannot be generated from the stored type, the result depends on the type; see the function documentation for details.</p>
<p>Here is some example code to demonstrate the use of QVariant:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> out(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
 <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> v(<span class="number">123</span>);                <span class="comment">// The variant now contains an int</span>
 <span class="type">int</span> x <span class="operator">=</span> v<span class="operator">.</span>toInt();              <span class="comment">// x = 123</span>
 out <span class="operator">&lt;</span><span class="operator">&lt;</span> v;                       <span class="comment">// Writes a type tag and an int to out</span>
 v <span class="operator">=</span> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span>(tr(<span class="string">&quot;hello&quot;</span>));      <span class="comment">// The variant now contains a QString</span>
 <span class="type">int</span> y <span class="operator">=</span> v<span class="operator">.</span>toInt();              <span class="comment">// y = 0 since v cannot be converted to an int</span>
 <span class="type"><a href="qstring.html" translate="no">QString</a></span> s <span class="operator">=</span> v<span class="operator">.</span>toString();       <span class="comment">// s = tr(&quot;hello&quot;)  (see QObject::tr())</span>
 out <span class="operator">&lt;</span><span class="operator">&lt;</span> v;                       <span class="comment">// Writes a type tag and a QString to out</span>
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> in(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);            <span class="comment">// (opening the previously written stream)</span>
 in <span class="operator">&gt;</span><span class="operator">&gt;</span> v;                        <span class="comment">// Reads an Int variant</span>
 <span class="type">int</span> z <span class="operator">=</span> v<span class="operator">.</span>toInt();              <span class="comment">// z = 123</span>
 <a href="qtlogging.html#qDebug" translate="no">qDebug</a>(<span class="string">&quot;Type is %s&quot;</span><span class="operator">,</span>            <span class="comment">// prints &quot;Type is int&quot;</span>
         v<span class="operator">.</span>typeName());
 v <span class="operator">=</span> v<span class="operator">.</span>toInt() <span class="operator">+</span> <span class="number">100</span>;            <span class="comment">// The variant now holds the value 223</span>
 v <span class="operator">=</span> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span>(<span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span>());    <span class="comment">// The variant now holds a QStringList</span>
</pre>
<p>You can even store <a href="qlist.html" translate="no">QList</a>&lt;QVariant&gt; and <a href="qmap.html" translate="no">QMap</a>&lt;<a href="qstring.html" translate="no">QString</a>, QVariant&gt; values in a variant, so you can easily construct arbitrarily complex data structures of arbitrary types. This is very powerful and versatile, but may prove less memory and speed efficient than storing specific types in standard data structures.</p>
<p>QVariant also supports the notion of null values. A variant is null if the variant contains no initialized value, or contains a null pointer.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> x;                                <span class="comment">// x.isNull() == true</span>
 <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> y <span class="operator">=</span> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span><span class="operator">::</span>fromValue(nullptr); <span class="comment">// y.isNull() == true</span>
</pre>
<p>QVariant can be extended to support other types than those mentioned in the <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Type</a> enum. See <a href="custom-types.html" translate="no">Creating Custom Qt Types</a> for details.</p>
<h3 id="a-note-on-gui-types">A Note on GUI Types</h3>
<p>Because QVariant is part of the Qt Core module, it cannot provide conversion functions to data types defined in Qt GUI, such as <a href="../qtgui/qcolor.html" translate="no">QColor</a>, <a href="../qtgui/qimage.html" translate="no">QImage</a>, and <a href="../qtgui/qpixmap.html" translate="no">QPixmap</a>. In other words, there is no <code translate="no">toColor()</code> function. Instead, you can use the <a href="qvariant.html#value" translate="no">QVariant::value</a>() or the <a href="qvariant.html#qvariant_cast" translate="no">qvariant_cast</a>() template function. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> variant;
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> color <span class="operator">=</span> variant<span class="operator">.</span>value<span class="operator">&lt;</span><span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span><span class="operator">&gt;</span>();
</pre>
<p>The inverse conversion (e.g., from <a href="../qtgui/qcolor.html" translate="no">QColor</a> to QVariant) is automatic for all data types supported by QVariant, including GUI-related types:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> color <span class="operator">=</span> palette()<span class="operator">.</span>background()<span class="operator">.</span>color();
 <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> variant <span class="operator">=</span> color;
</pre>
<h3 id="using-canconvert-and-convert-consecutively">Using canConvert() and convert() Consecutively</h3>
<p>When using <a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>() consecutively, it is possible for <a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() to return true, but <a href="qvariant.html#convert" translate="no">convert</a>() to return false. This is typically because <a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() only reports the general ability of QVariant to convert between types given suitable data; it is still possible to supply data which cannot actually be converted.</p>
<p>For example, <code translate="no">canConvert(QMetaType::fromType&lt;int&gt;())</code> would return true when called on a variant containing a string because, in principle, QVariant is able to convert strings of numbers to integers. However, if the string contains non-numeric characters, it cannot be converted to an integer, and any attempt to convert it will fail. Hence, it is important to have both functions return true for a successful conversion.</p>
</div>
<p><b>See also </b><a href="qmetatype.html" translate="no">QMetaType</a>.</p>
<!-- @@@QVariant -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="typeId"><span class="type">int</span> QVariant::<span class="name">typeId</span>() const</h3><h3 class="fn fngroupitem" translate="no" id="userType"><span class="type">int</span> QVariant::<span class="name">userType</span>() const</h3></div>
<p>Returns the storage type of the value stored in the variant. This is the same as <a href="qvariant.html#metaType" translate="no">metaType</a>().id().</p>
<p><b>See also </b><a href="qvariant.html#metaType" translate="no">metaType</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="constData">const <span class="type">void</span> *QVariant::<span class="name">constData</span>() const</h3><h3 class="fn fngroupitem" translate="no" id="data-1">const <span class="type">void</span> *QVariant::<span class="name">data</span>() const</h3></div>
<p>Returns a pointer to the contained object as a generic void* that cannot be written to.</p>
<p><b>See also </b><a href="qvariant.html#get_if" translate="no">get_if</a>() and <a href="qmetatype.html" translate="no">QMetaType</a>.</p>
<!-- @@@ -->
<!-- $$$QVariant[overload1]$$$QVariant -->
<h3 class="fn" translate="no" id="QVariant"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>()</h3>
<p>Constructs an invalid variant.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQMetaTypeconstvoid* -->
<h3 class="fn" translate="no" id="QVariant-1"><code class="details extra" translate="no">[explicit]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qmetatype.html" translate="no">QMetaType</a></span> <i>type</i>, const <span class="type">void</span> *<i>copy</i> = nullptr)</h3>
<p>Constructs a variant of type <i translate="no">type</i>, and initializes it with a copy of <code translate="no">*copy</code> if <i translate="no">copy</i> is not <code translate="no">nullptr</code> (in which case, <i translate="no">copy</i> must point to an object of type <i translate="no">type</i>).</p>
<p>Note that you have to pass the address of the object you want stored.</p>
<p>Usually, you never have to use this constructor, use <a href="qvariant.html#fromValue" translate="no">QVariant::fromValue</a>() instead to construct variants from the pointer types represented by <code translate="no">QMetaType::VoidStar</code>, and <code translate="no">QMetaType::QObjectStar</code>.</p>
<p>If <i translate="no">type</i> does not support copy construction and <i translate="no">copy</i> is not <code translate="no">nullptr</code>, the variant will be invalid. Similarly, if <i translate="no">copy</i> is <code translate="no">nullptr</code> and <i translate="no">type</i> does not support default construction, the variant will be invalid.</p>
<p><b>See also </b><a href="qvariant.html#fromMetaType" translate="no">QVariant::fromMetaType</a>, <a href="qvariant.html#fromValue" translate="no">QVariant::fromValue</a>(), and <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Type</a>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQLineF -->
<h3 class="fn" translate="no" id="QVariant-36"><code class="details extra" translate="no">[noexcept(...)]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qlinef.html" translate="no">QLineF</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a line value of <i translate="no">val</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;Private::FitsInInternalSize&lt;sizeof(qreal) * 4&gt;&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQRect -->
<h3 class="fn" translate="no" id="QVariant-37"><code class="details extra" translate="no">[noexcept(...)]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qrect.html" translate="no">QRect</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a rect value of <i translate="no">val</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;Private::FitsInInternalSize&lt;sizeof(int) * 4&gt;&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQRectF -->
<h3 class="fn" translate="no" id="QVariant-38"><code class="details extra" translate="no">[noexcept(...)]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qrectf.html" translate="no">QRectF</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a rect value of <i translate="no">val</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;Private::FitsInInternalSize&lt;sizeof(qreal) * 4&gt;&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQEasingCurve& -->
<h3 class="fn" translate="no" id="QVariant-39">QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qeasingcurve.html" translate="no">QEasingCurve</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with an easing curve value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQJsonDocument& -->
<h3 class="fn" translate="no" id="QVariant-40">QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qjsondocument.html" translate="no">QJsonDocument</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a json document value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQPersistentModelIndex& -->
<h3 class="fn" translate="no" id="QVariant-41">QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qpersistentmodelindex.html" translate="no">QPersistentModelIndex</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a <a href="qpersistentmodelindex.html" translate="no">QPersistentModelIndex</a> value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstchar* -->
<h3 class="fn" translate="no" id="QVariant-42">QVariant::<span class="name">QVariant</span>(const <span class="type">char</span> *<i>val</i>)</h3>
<p>Constructs a new variant with a string value of <i translate="no">val</i>. The variant creates a deep copy of <i translate="no">val</i> into a <a href="qstring.html" translate="no">QString</a> assuming UTF-8 encoding on the input <i translate="no">val</i>.</p>
<p>Note that <i translate="no">val</i> is converted to a <a href="qstring.html" translate="no">QString</a> for storing in the variant and <a href="qvariant.html#userType" translate="no">QVariant::userType</a>() will return <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a> for the variant.</p>
<p>You can disable this operator by defining <code translate="no">QT_NO_CAST_FROM_ASCII</code> when you compile your applications.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQLatin1StringView -->
<h3 class="fn" translate="no" id="QVariant-43">QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a <a href="qstring.html" translate="no">QString</a> value from the Latin-1 string viewed by <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantstd::in_place_type_t<T>Args&&... -->
<h3 class="fn" translate="no" id="QVariant-3"><code class="details extra" translate="no">[explicit noexcept(...), since 6.6]</code> template &lt;typename T, typename... Args, QVariant::if_constructible&lt;T, Args...&gt; = true> QVariant::<span class="name">QVariant</span>(<span class="type">std::in_place_type_t</span>&lt;<span class="type">T</span>&gt;, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>Constructs a new variant containing a value of type <code translate="no">T</code>. The contained value is is initialized with the arguments <code translate="no">std::forward&lt;Args&gt;(args)...</code>.</p>
<p>This overload only participates in overload resolution if <code translate="no">T</code> can be constructed from <i translate="no">args</i>.</p>
<p>This constructor is provided for STL/std::any compatibility.</p>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 6.6.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;is_noexcept_constructible&lt;q20::remove_cvref_t&lt;T&gt;, Args...&gt;::value&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantstd::in_place_type_t<T>std::initializer_list<U>Args&&... -->
<h3 class="fn" translate="no" id="QVariant-4"><code class="details extra" translate="no">[explicit noexcept(...), since 6.6]</code> template &lt;typename T, typename U, typename... Args, QVariant::if_constructible&lt;T, std::initializer_list&lt;U&gt; &, Args...> = true> QVariant::<span class="name">QVariant</span>(<span class="type">std::in_place_type_t</span>&lt;<span class="type">T</span>&gt;, <span class="type">std::initializer_list</span>&lt;<span class="type">U</span>&gt; <i>il</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>This is an overloaded function.</p>
<p>This overload exists to support types with constructors taking an <code translate="no">initializer_list</code>. It behaves otherwise equivalent to the non-initializer list <code translate="no">in_place_type_t</code> overload.</p>
<p>This function was introduced in Qt 6.6.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;is_noexcept_constructible&lt;q20::remove_cvref_t&lt;T&gt;,
                                               std::initializer_list&lt;U&gt; &amp;,
                                               Args...
                    &gt;::value&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantint -->
<h3 class="fn" translate="no" id="QVariant-5"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type">int</span> <i>val</i>)</h3>
<p>Constructs a new variant with an integer value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantuint -->
<h3 class="fn" translate="no" id="QVariant-6"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with an unsigned integer value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantqlonglong -->
<h3 class="fn" translate="no" id="QVariant-7"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qttypes.html#qlonglong-typedef" translate="no">qlonglong</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a long long integer value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantqulonglong -->
<h3 class="fn" translate="no" id="QVariant-8"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qttypes.html#qulonglong-typedef" translate="no">qulonglong</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with an unsigned long long integer value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantbool -->
<h3 class="fn" translate="no" id="QVariant-9"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type">bool</span> <i>val</i>)</h3>
<p>Constructs a new variant with a boolean value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantdouble -->
<h3 class="fn" translate="no" id="QVariant-10"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type">double</span> <i>val</i>)</h3>
<p>Constructs a new variant with a floating point value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantfloat -->
<h3 class="fn" translate="no" id="QVariant-11"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type">float</span> <i>val</i>)</h3>
<p>Constructs a new variant with a floating point value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQChar -->
<h3 class="fn" translate="no" id="QVariant-12"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>c</i>)</h3>
<p>Constructs a new variant with a char value, <i translate="no">c</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQDate -->
<h3 class="fn" translate="no" id="QVariant-13"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qdate.html" translate="no">QDate</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a date value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQTime -->
<h3 class="fn" translate="no" id="QVariant-14"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qtime.html" translate="no">QTime</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a time value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQBitArray& -->
<h3 class="fn" translate="no" id="QVariant-15"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qbitarray.html" translate="no">QBitArray</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a bitarray value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQByteArray& -->
<h3 class="fn" translate="no" id="QVariant-16"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a bytearray value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQDateTime& -->
<h3 class="fn" translate="no" id="QVariant-17"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qdatetime.html" translate="no">QDateTime</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a date/time value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQHash<QString,QVariant>& -->
<h3 class="fn" translate="no" id="QVariant-18"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qhash.html" translate="no">QHash</a></span>&lt;<span class="type"><a href="qstring.html" translate="no">QString</a></span>, <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span>&gt; &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a hash of <a href="qvariant.html" translate="no">QVariant</a>s, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQJsonArray& -->
<h3 class="fn" translate="no" id="QVariant-19"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qjsonarray.html" translate="no">QJsonArray</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a json array value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQJsonObject& -->
<h3 class="fn" translate="no" id="QVariant-20"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qjsonobject.html" translate="no">QJsonObject</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a json object value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQList<QVariant>& -->
<h3 class="fn" translate="no" id="QVariant-21"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span>&gt; &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a list value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQLocale& -->
<h3 class="fn" translate="no" id="QVariant-22"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qlocale.html" translate="no">QLocale</a></span> &amp;<i>l</i>)</h3>
<p>Constructs a new variant with a locale value, <i translate="no">l</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQMap<QString,QVariant>& -->
<h3 class="fn" translate="no" id="QVariant-23"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qmap.html" translate="no">QMap</a></span>&lt;<span class="type"><a href="qstring.html" translate="no">QString</a></span>, <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span>&gt; &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a map of <a href="qvariant.html" translate="no">QVariant</a>s, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQRegularExpression& -->
<h3 class="fn" translate="no" id="QVariant-24"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> &amp;<i>re</i>)</h3>
<p>Constructs a new variant with the regular expression value <i translate="no">re</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQString& -->
<h3 class="fn" translate="no" id="QVariant-25"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a string value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQStringList& -->
<h3 class="fn" translate="no" id="QVariant-26"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a string list value, <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQUrl& -->
<h3 class="fn" translate="no" id="QVariant-27"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qurl.html" translate="no">QUrl</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a url value of <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQJsonValue& -->
<h3 class="fn" translate="no" id="QVariant-28"><code class="details extra" translate="no">[noexcept(...)]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qjsonvalue.html" translate="no">QJsonValue</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a json value, <i translate="no">val</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;Private::FitsInInternalSize&lt;sizeof(CborValueStandIn)&gt;&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQModelIndex& -->
<h3 class="fn" translate="no" id="QVariant-29"><code class="details extra" translate="no">[noexcept(...)]</code> QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qmodelindex.html" translate="no">QModelIndex</a></span> &amp;<i>val</i>)</h3>
<p>Constructs a new variant with a <a href="qmodelindex.html" translate="no">QModelIndex</a> value, <i translate="no">val</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;Private::FitsInInternalSize&lt;8 + 2 * sizeof(quintptr)&gt;&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQUuid -->
<h3 class="fn" translate="no" id="QVariant-30"><code class="details extra" translate="no">[noexcept(...)]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="quuid.html" translate="no">QUuid</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with an uuid value, <i translate="no">val</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;Private::FitsInInternalSize&lt;16&gt;&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQSize -->
<h3 class="fn" translate="no" id="QVariant-31"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qsize.html" translate="no">QSize</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a size value of <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQSizeF -->
<h3 class="fn" translate="no" id="QVariant-32"><code class="details extra" translate="no">[noexcept(...)]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qsizef.html" translate="no">QSizeF</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a size value of <i translate="no">val</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;Private::FitsInInternalSize&lt;sizeof(qreal) * 2&gt;&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQPoint -->
<h3 class="fn" translate="no" id="QVariant-33"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qpoint.html" translate="no">QPoint</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a point value of <i translate="no">val</i>.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQPointF -->
<h3 class="fn" translate="no" id="QVariant-34"><code class="details extra" translate="no">[noexcept(...)]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qpointf.html" translate="no">QPointF</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a point value of <i translate="no">val</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;Private::FitsInInternalSize&lt;sizeof(qreal) * 2&gt;&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQLine -->
<h3 class="fn" translate="no" id="QVariant-35"><code class="details extra" translate="no">[noexcept(...)]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qline.html" translate="no">QLine</a></span> <i>val</i>)</h3>
<p>Constructs a new variant with a line value of <i translate="no">val</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;Private::FitsInInternalSize&lt;sizeof(int) * 4&gt;&quot; is true.</p>
</div>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantconstQVariant& -->
<h3 class="fn" translate="no" id="QVariant-2">QVariant::<span class="name">QVariant</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>p</i>)</h3>
<p>Constructs a copy of the variant, <i translate="no">p</i>, passed as the argument to this constructor.</p>
<!-- @@@QVariant -->
<!-- $$$QVariant$$$QVariantQVariant&& -->
<h3 class="fn" translate="no" id="QVariant-45"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">QVariant</span>(<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a QVariant instance, making it point at the same object that <i translate="no">other</i> was pointing to.</p>
<!-- @@@QVariant -->
<!-- $$$~QVariant[overload1]$$$~QVariant -->
<h3 class="fn" translate="no" id="dtor.QVariant"><code class="details extra" translate="no">[noexcept]</code> QVariant::<span class="name">~QVariant</span>()</h3>
<p>Destroys the <a href="qvariant.html" translate="no">QVariant</a> and the contained object.</p>
<!-- @@@~QVariant -->
<!-- $$$canConvert[overload1]$$$canConvertQMetaType -->
<h3 class="fn" translate="no" id="canConvert"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">bool</span> QVariant::<span class="name">canConvert</span>(<span class="type"><a href="qmetatype.html" translate="no">QMetaType</a></span> <i>type</i>) const</h3>
<p>Returns <code translate="no">true</code> if the variant's type can be cast to the requested type, <i translate="no">type</i>. Such casting is done automatically when calling the <a href="qvariant.html#toInt" translate="no">toInt</a>(), <a href="qvariant.html#toBool" translate="no">toBool</a>(), ... methods.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qmetatype.html#canConvert" translate="no">QMetaType::canConvert</a>().</p>
<!-- @@@canConvert -->
<!-- $$$canConvert$$$canConvert -->
<h3 class="fn" translate="no" id="canConvert-2">template &lt;typename T&gt; <span class="type">bool</span> QVariant::<span class="name">canConvert</span>() const</h3>
<p>Returns <code translate="no">true</code> if the variant can be converted to the template type <code translate="no">T</code>, otherwise false.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> v <span class="operator">=</span> <span class="number">42</span>;

 v<span class="operator">.</span>canConvert<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>();              <span class="comment">// returns true</span>
 v<span class="operator">.</span>canConvert<span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span>();          <span class="comment">// returns true</span>

 MyCustomStruct s;
 v<span class="operator">.</span>setValue(s);

 v<span class="operator">.</span>canConvert<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>();              <span class="comment">// returns false</span>
 v<span class="operator">.</span>canConvert<span class="operator">&lt;</span>MyCustomStruct<span class="operator">&gt;</span>();   <span class="comment">// returns true</span>
</pre>
<p>A <a href="qvariant.html" translate="no">QVariant</a> containing a pointer to a type derived from <a href="qobject.html" translate="no">QObject</a> will also return true for this function if a <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a> to the template type <code translate="no">T</code> would succeed. Note that this only works for <a href="qobject.html" translate="no">QObject</a> subclasses which use the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro.</p>
<p><b>See also </b><a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@canConvert -->
<!-- $$$canView$$$canView -->
<h3 class="fn" translate="no" id="canView-1">template &lt;typename T&gt; <span class="type">bool</span> QVariant::<span class="name">canView</span>() const</h3>
<p>Returns <code translate="no">true</code> if a mutable view of the template type <code translate="no">T</code> can be created on this variant, otherwise <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qvariant.html#value" translate="no">value</a>().</p>
<!-- @@@canView -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QVariant::<span class="name">clear</span>()</h3>
<p>Convert this variant to type <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UnknownType</a> and free up any resources used.</p>
<!-- @@@clear -->
<!-- $$$compare[overload1]$$$compareconstQVariant&constQVariant& -->
<h3 class="fn" translate="no" id="compare"><code class="details extra" translate="no">[static, since 6.0]</code> <span class="type"><a href="qpartialordering.html" translate="no">QPartialOrdering</a></span> QVariant::<span class="name">compare</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>lhs</i>, const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>rhs</i>)</h3>
<p>Compares the objects at <i translate="no">lhs</i> and <i translate="no">rhs</i> for ordering.</p>
<p>Returns <a href="qpartialordering.html#Unordered-var" translate="no">QPartialOrdering::Unordered</a> if comparison is not supported or the values are unordered. Otherwise, returns <a href="qpartialordering.html#Less-var" translate="no">QPartialOrdering::Less</a>, <a href="qpartialordering.html#Equivalent-var" translate="no">QPartialOrdering::Equivalent</a> or <a href="qpartialordering.html#Greater-var" translate="no">QPartialOrdering::Greater</a> if <i translate="no">lhs</i> is less than, equivalent to or greater than <i translate="no">rhs</i>, respectively.</p>
<p>If the variants contain data with a different metatype, the values are considered unordered unless they are both of numeric or pointer types, where regular numeric or pointer comparison rules will be used.</p>
<div class="admonition note">
<p><b>Note: </b>: If a numeric comparison is done and at least one value is NaN, <a href="qpartialordering.html#Unordered-var" translate="no">QPartialOrdering::Unordered</a> is returned.</p>
</div>
<p>If both variants contain data of the same metatype, the method will use the <a href="qmetatype.html#compare" translate="no">QMetaType::compare</a> method to determine the ordering of the two variants, which can also indicate that it can't establish an ordering between the two values.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qmetatype.html#compare" translate="no">QMetaType::compare</a>() and <a href="qmetatype.html#isOrdered" translate="no">QMetaType::isOrdered</a>().</p>
<!-- @@@compare -->
<!-- $$$convert[overload1]$$$convertQMetaType -->
<h3 class="fn" translate="no" id="convert"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">bool</span> QVariant::<span class="name">convert</span>(<span class="type"><a href="qmetatype.html" translate="no">QMetaType</a></span> <i>targetType</i>)</h3>
<p>Casts the variant to the requested type, <i translate="no">targetType</i>. If the cast cannot be done, the variant is still changed to the requested type, but is left in a cleared null state similar to that constructed by <a href="qvariant.html" translate="no">QVariant</a>(Type).</p>
<p>Returns <code translate="no">true</code> if the current type of the variant was successfully cast; otherwise returns <code translate="no">false</code>.</p>
<p>A <a href="qvariant.html" translate="no">QVariant</a> containing a pointer to a type derived from <a href="qobject.html" translate="no">QObject</a> will also convert and return true for this function if a <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a> to the type described by <i translate="no">targetType</i> would succeed. Note that this only works for <a href="qobject.html" translate="no">QObject</a> subclasses which use the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro.</p>
<div class="admonition note">
<p><b>Note: </b>converting QVariants that are null due to not being initialized or having failed a previous conversion will always fail, changing the type, remaining null, and returning <code translate="no">false</code>.</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#clear" translate="no">clear</a>().</p>
<!-- @@@convert -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" translate="no" id="data"><span class="type">void</span> *QVariant::<span class="name">data</span>()</h3>
<p>Returns a pointer to the contained object as a generic void* that can be written to.</p>
<p>This function detaches the <a href="qvariant.html" translate="no">QVariant</a>. When called on a <a href="qvariant.html#isNull" translate="no">null-QVariant</a>, the <a href="qvariant.html" translate="no">QVariant</a> will not be null after the call.</p>
<p><b>See also </b><a href="qvariant.html#get_if" translate="no">get_if</a>() and <a href="qmetatype.html" translate="no">QMetaType</a>.</p>
<!-- @@@data -->
<!-- $$$emplace[overload1]$$$emplaceArgs&&... -->
<h3 class="fn" translate="no" id="emplace"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename T, typename... Args, QVariant::if_constructible&lt;T, Args...&gt; = true> <span class="type">T</span> &amp;QVariant::<span class="name">emplace</span>(<span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>Replaces the object currently held in <code translate="no">*this</code> with an object of type <code translate="no">T</code>, constructed from <i translate="no">args</i><code translate="no">...</code>. If <code translate="no">*this</code> was non-null, the previously held object is destroyed first. If possible, this method will reuse memory allocated by the <a href="qvariant.html" translate="no">QVariant</a>. Returns a reference to the newly-created object.</p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@emplace -->
<!-- $$$emplace$$$emplacestd::initializer_list<U>Args&&... -->
<h3 class="fn" translate="no" id="emplace-1"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename T, typename U, typename... Args, QVariant::if_constructible&lt;T, std::initializer_list&lt;U&gt; &, Args...> = true> <span class="type">T</span> &amp;QVariant::<span class="name">emplace</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">U</span>&gt; <i>list</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>This is an overloaded function.</p>
<p>This overload exists to support types with constructors taking an <code translate="no">initializer_list</code>. It behaves otherwise equivalent to the non-initializer list overload.</p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@emplace -->
<!-- $$$fromMetaType[overload1]$$$fromMetaTypeQMetaTypeconstvoid* -->
<h3 class="fn" translate="no" id="fromMetaType"><code class="details extra" translate="no">[static, since 6.7]</code> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> QVariant::<span class="name">fromMetaType</span>(<span class="type"><a href="qmetatype.html" translate="no">QMetaType</a></span> <i>type</i>, const <span class="type">void</span> *<i>copy</i> = nullptr)</h3>
<p>Creates a variant of type <i translate="no">type</i>, and initializes it with a copy of <code translate="no">*copy</code> if <i translate="no">copy</i> is not <code translate="no">nullptr</code> (in which case, <i translate="no">copy</i> must point to an object of type <i translate="no">type</i>).</p>
<p>Note that you have to pass the address of the object you want stored.</p>
<p>Usually, you never have to use this constructor, use <a href="qvariant.html#fromValue" translate="no">QVariant::fromValue</a>() instead to construct variants from the pointer types represented by <code translate="no">QMetaType::VoidStar</code>, and <code translate="no">QMetaType::QObjectStar</code>.</p>
<p>If <i translate="no">type</i> does not support copy construction and <i translate="no">copy</i> is not <code translate="no">nullptr</code>, the variant will be invalid. Similarly, if <i translate="no">copy</i> is <code translate="no">nullptr</code> and <i translate="no">type</i> does not support default construction, the variant will be invalid.</p>
<p>Returns the <a href="qvariant.html" translate="no">QVariant</a> created as described above.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qvariant.html#fromValue" translate="no">QVariant::fromValue</a>() and <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Type</a>.</p>
<!-- @@@fromMetaType -->
<!-- $$$fromStdVariant[overload1]$$$fromStdVariantconststd::variant<Types...>& -->
<h3 class="fn" translate="no" id="fromStdVariant"><code class="details extra" translate="no">[static]</code> template &lt;typename... Types&gt; <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> QVariant::<span class="name">fromStdVariant</span>(const <span class="type">std::variant</span>&lt;<span class="type">Types</span>...&gt; &amp;<i>value</i>)</h3>
<p>Returns a <a href="qvariant.html" translate="no">QVariant</a> with the type and value of the active variant of <i translate="no">value</i>. If the active type is std::monostate a default <a href="qvariant.html" translate="no">QVariant</a> is returned.</p>
<div class="admonition note">
<p><b>Note: </b>With this method you do not need to register the variant as a Qt metatype, since the std::variant is resolved before being stored. The component types should be registered however.</p>
</div>
<p><b>See also </b><a href="qvariant.html#fromValue" translate="no">fromValue</a>().</p>
<!-- @@@fromStdVariant -->
<!-- $$$fromStdVariant$$$fromStdVariantstd::variant<Types...>&& -->
<h3 class="fn" translate="no" id="fromStdVariant-1"><code class="details extra" translate="no">[static, since 6.6]</code> template &lt;typename... Types&gt; <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> QVariant::<span class="name">fromStdVariant</span>(<span class="type">std::variant</span>&lt;<span class="type">Types</span>...&gt; &amp;&amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@fromStdVariant -->
<!-- $$$fromValue[overload1]$$$fromValueconstT& -->
<h3 class="fn" translate="no" id="fromValue"><code class="details extra" translate="no">[static]</code> template &lt;typename T&gt; <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> QVariant::<span class="name">fromValue</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Returns a <a href="qvariant.html" translate="no">QVariant</a> containing a copy of <i translate="no">value</i>. Behaves exactly like <a href="qvariant.html#setValue" translate="no">setValue</a>() otherwise.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 MyCustomStruct s;
 <span class="keyword">return</span> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span><span class="operator">::</span>fromValue(s);
</pre>
<p><b>See also </b><a href="qvariant.html#setValue" translate="no">setValue</a>() and <a href="qvariant.html#value" translate="no">value</a>().</p>
<!-- @@@fromValue -->
<!-- $$$fromValue$$$fromValueT&& -->
<h3 class="fn" translate="no" id="fromValue-1"><code class="details extra" translate="no">[static, since 6.6]</code> template &lt;typename T, QVariant::if_rvalue&lt;T&gt; = true> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> QVariant::<span class="name">fromValue</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@fromValue -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" translate="no" id="isNull"><span class="type">bool</span> QVariant::<span class="name">isNull</span>() const</h3>
<p>Returns <code translate="no">true</code> if this is a null variant, false otherwise.</p>
<p>A variant is considered null if it contains no initialized value or a null pointer.</p>
<div class="admonition note">
<p><b>Note: </b>This behavior has been changed from Qt 5, where isNull() would also return true if the variant contained an object of a builtin type with an isNull() method that returned true for that object.</p>
</div>
<p><b>See also </b><a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@isNull -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QVariant::<span class="name">isValid</span>() const</h3>
<p>Returns <code translate="no">true</code> if the storage type of this variant is not <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UnknownType</a>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isValid -->
<!-- $$$metaType[overload1]$$$metaType -->
<h3 class="fn" translate="no" id="metaType"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qmetatype.html" translate="no">QMetaType</a></span> QVariant::<span class="name">metaType</span>() const</h3>
<p>Returns the <a href="qmetatype.html" translate="no">QMetaType</a> of the value stored in the variant.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@metaType -->
<!-- $$$setValue[overload1]$$$setValueT&& -->
<h3 class="fn" translate="no" id="setValue">template &lt;typename T, typename = std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;T&gt;, QVariant>>> <span class="type">void</span> QVariant::<span class="name">setValue</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>Stores a copy of <i translate="no">value</i>. If <code translate="no">T</code> is a type that <a href="qvariant.html" translate="no">QVariant</a> doesn't support, <a href="qmetatype.html" translate="no">QMetaType</a> is used to store the value. A compile error will occur if <a href="qmetatype.html" translate="no">QMetaType</a> doesn't handle the type.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> v;

 v<span class="operator">.</span>setValue(<span class="number">5</span>);
 <span class="type">int</span> i <span class="operator">=</span> v<span class="operator">.</span>toInt();         <span class="comment">// i is now 5</span>
 <span class="type"><a href="qstring.html" translate="no">QString</a></span> s <span class="operator">=</span> v<span class="operator">.</span>toString();  <span class="comment">// s is now &quot;5&quot;</span>

 MyCustomStruct c;
 v<span class="operator">.</span>setValue(c);

 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

 MyCustomStruct c2 <span class="operator">=</span> v<span class="operator">.</span>value<span class="operator">&lt;</span>MyCustomStruct<span class="operator">&gt;</span>();
</pre>
<p><b>See also </b><a href="qvariant.html#value" translate="no">value</a>(), <a href="qvariant.html#fromValue" translate="no">fromValue</a>(), and <a href="qvariant.html#canConvert-2" translate="no">canConvert</a>().</p>
<!-- @@@setValue -->
<!-- $$$setValue$$$setValueconstQVariant& -->
<h3 class="fn" translate="no" id="setValue-1"><span class="type">void</span> QVariant::<span class="name">setValue</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Copies <i translate="no">value</i> over this <a href="qvariant.html" translate="no">QVariant</a>. It is equivalent to simply assigning <i translate="no">value</i> to this <a href="qvariant.html" translate="no">QVariant</a>.</p>
<!-- @@@setValue -->
<!-- $$$setValue$$$setValueQVariant&& -->
<h3 class="fn" translate="no" id="setValue-2"><span class="type">void</span> QVariant::<span class="name">setValue</span>(<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;&amp;<i>value</i>)</h3>
<p>Moves <i translate="no">value</i> over this <a href="qvariant.html" translate="no">QVariant</a>. It is equivalent to simply move assigning <i translate="no">value</i> to this <a href="qvariant.html" translate="no">QVariant</a>.</p>
<!-- @@@setValue -->
<!-- $$$swap[overload1]$$$swapQVariant& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QVariant::<span class="name">swap</span>(<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>other</i>)</h3>
<p>Swaps variant <i translate="no">other</i> with this variant. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$toBitArray[overload1]$$$toBitArray -->
<h3 class="fn" translate="no" id="toBitArray"><span class="type"><a href="qbitarray.html" translate="no">QBitArray</a></span> QVariant::<span class="name">toBitArray</span>() const</h3>
<p>Returns the variant as a <a href="qbitarray.html" translate="no">QBitArray</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QBitArray</a>; otherwise returns an empty bit array.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toBitArray -->
<!-- $$$toBool[overload1]$$$toBool -->
<h3 class="fn" translate="no" id="toBool"><span class="type">bool</span> QVariant::<span class="name">toBool</span>() const</h3>
<p>Returns the variant as a bool if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() Bool.</p>
<p>Returns <code translate="no">true</code> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a> and the value is non-zero, or if the variant has type <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a> or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a> and its lower-case content is not one of the following: empty, &quot;0&quot; or &quot;false&quot;; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toBool -->
<!-- $$$toByteArray[overload1]$$$toByteArray -->
<h3 class="fn" translate="no" id="toByteArray"><span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> QVariant::<span class="name">toByteArray</span>() const</h3>
<p>Returns the variant as a <a href="qbytearray.html" translate="no">QByteArray</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a> or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a> (converted using <a href="qstring.html#fromUtf8" translate="no">QString::fromUtf8</a>()); otherwise returns an empty byte array.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toByteArray -->
<!-- $$$toChar[overload1]$$$toChar -->
<h3 class="fn" translate="no" id="toChar"><span class="type"><a href="qchar.html" translate="no">QChar</a></span> QVariant::<span class="name">toChar</span>() const</h3>
<p>Returns the variant as a <a href="qchar.html" translate="no">QChar</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>; otherwise returns an invalid <a href="qchar.html" translate="no">QChar</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toChar -->
<!-- $$$toDate[overload1]$$$toDate -->
<h3 class="fn" translate="no" id="toDate"><span class="type"><a href="qdate.html" translate="no">QDate</a></span> QVariant::<span class="name">toDate</span>() const</h3>
<p>Returns the variant as a <a href="qdate.html" translate="no">QDate</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDate</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDateTime</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>; otherwise returns an invalid date.</p>
<p>If the type() is <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, an invalid date will be returned if the string cannot be parsed as a <a href="qt.html#DateFormat-enum" translate="no">Qt::ISODate</a> format date.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toDate -->
<!-- $$$toDateTime[overload1]$$$toDateTime -->
<h3 class="fn" translate="no" id="toDateTime"><span class="type"><a href="qdatetime.html" translate="no">QDateTime</a></span> QVariant::<span class="name">toDateTime</span>() const</h3>
<p>Returns the variant as a <a href="qdatetime.html" translate="no">QDateTime</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDateTime</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDate</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>; otherwise returns an invalid date/time.</p>
<p>If the type() is <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, an invalid date/time will be returned if the string cannot be parsed as a <a href="qt.html#DateFormat-enum" translate="no">Qt::ISODate</a> format date/time.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toDateTime -->
<!-- $$$toDouble[overload1]$$$toDoublebool* -->
<h3 class="fn" translate="no" id="toDouble"><span class="type">double</span> QVariant::<span class="name">toDouble</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the variant as a double if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Float</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>; otherwise returns 0.0.</p>
<p>If <i translate="no">ok</i> is non-null: <code translate="no">*</code><i translate="no">ok</i> is set to true if the value could be converted to a double; otherwise <code translate="no">*</code><i translate="no">ok</i> is set to false.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toDouble -->
<!-- $$$toEasingCurve[overload1]$$$toEasingCurve -->
<h3 class="fn" translate="no" id="toEasingCurve"><span class="type"><a href="qeasingcurve.html" translate="no">QEasingCurve</a></span> QVariant::<span class="name">toEasingCurve</span>() const</h3>
<p>Returns the variant as a <a href="qeasingcurve.html" translate="no">QEasingCurve</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QEasingCurve</a>; otherwise returns a default easing curve.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toEasingCurve -->
<!-- $$$toFloat[overload1]$$$toFloatbool* -->
<h3 class="fn" translate="no" id="toFloat"><span class="type">float</span> QVariant::<span class="name">toFloat</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the variant as a float if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Float</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>; otherwise returns 0.0.</p>
<p>If <i translate="no">ok</i> is non-null: <code translate="no">*</code><i translate="no">ok</i> is set to true if the value could be converted to a double; otherwise <code translate="no">*</code><i translate="no">ok</i> is set to false.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toFloat -->
<!-- $$$toHash[overload1]$$$toHash -->
<h3 class="fn" translate="no" id="toHash"><span class="type"><a href="qhash.html" translate="no">QHash</a></span>&lt;<span class="type"><a href="qstring.html" translate="no">QString</a></span>, <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span>&gt; QVariant::<span class="name">toHash</span>() const</h3>
<p>Returns the variant as a <a href="qhash.html#qhash" translate="no">QHash</a>&lt;<a href="qstring.html" translate="no">QString</a>, <a href="qvariant.html" translate="no">QVariant</a>&gt; if the variant has type() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QVariantHash</a>; otherwise returns an empty map.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toHash -->
<!-- $$$toInt[overload1]$$$toIntbool* -->
<h3 class="fn" translate="no" id="toInt"><span class="type">int</span> QVariant::<span class="name">toInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the variant as an int if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>; otherwise returns 0.</p>
<p>If <i translate="no">ok</i> is non-null: <code translate="no">*</code><i translate="no">ok</i> is set to true if the value could be converted to an int; otherwise <code translate="no">*</code><i translate="no">ok</i> is set to false.</p>
<p><b>Warning:</b> If the value is convertible to a <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a> but is too large to be represented in an int, the resulting arithmetic overflow will not be reflected in <i translate="no">ok</i>. A simple workaround is to use <a href="qstring.html#toInt" translate="no">QString::toInt</a>().</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toInt -->
<!-- $$$toJsonArray[overload1]$$$toJsonArray -->
<h3 class="fn" translate="no" id="toJsonArray"><span class="type"><a href="qjsonarray.html" translate="no">QJsonArray</a></span> QVariant::<span class="name">toJsonArray</span>() const</h3>
<p>Returns the variant as a <a href="qjsonarray.html" translate="no">QJsonArray</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qjsonarray.html" translate="no">QJsonArray</a>; otherwise returns a default constructed <a href="qjsonarray.html" translate="no">QJsonArray</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toJsonArray -->
<!-- $$$toJsonDocument[overload1]$$$toJsonDocument -->
<h3 class="fn" translate="no" id="toJsonDocument"><span class="type"><a href="qjsondocument.html" translate="no">QJsonDocument</a></span> QVariant::<span class="name">toJsonDocument</span>() const</h3>
<p>Returns the variant as a <a href="qjsondocument.html" translate="no">QJsonDocument</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qjsondocument.html" translate="no">QJsonDocument</a>; otherwise returns a default constructed <a href="qjsondocument.html" translate="no">QJsonDocument</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toJsonDocument -->
<!-- $$$toJsonObject[overload1]$$$toJsonObject -->
<h3 class="fn" translate="no" id="toJsonObject"><span class="type"><a href="qjsonobject.html" translate="no">QJsonObject</a></span> QVariant::<span class="name">toJsonObject</span>() const</h3>
<p>Returns the variant as a <a href="qjsonobject.html" translate="no">QJsonObject</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qjsonobject.html" translate="no">QJsonObject</a>; otherwise returns a default constructed <a href="qjsonobject.html" translate="no">QJsonObject</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toJsonObject -->
<!-- $$$toJsonValue[overload1]$$$toJsonValue -->
<h3 class="fn" translate="no" id="toJsonValue"><span class="type"><a href="qjsonvalue.html" translate="no">QJsonValue</a></span> QVariant::<span class="name">toJsonValue</span>() const</h3>
<p>Returns the variant as a <a href="qjsonvalue.html" translate="no">QJsonValue</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qjsonvalue.html" translate="no">QJsonValue</a>; otherwise returns a default constructed <a href="qjsonvalue.html" translate="no">QJsonValue</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toJsonValue -->
<!-- $$$toLine[overload1]$$$toLine -->
<h3 class="fn" translate="no" id="toLine"><span class="type"><a href="qline.html" translate="no">QLine</a></span> QVariant::<span class="name">toLine</span>() const</h3>
<p>Returns the variant as a <a href="qline.html" translate="no">QLine</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QLine</a>; otherwise returns an invalid <a href="qline.html" translate="no">QLine</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toLine -->
<!-- $$$toLineF[overload1]$$$toLineF -->
<h3 class="fn" translate="no" id="toLineF"><span class="type"><a href="qlinef.html" translate="no">QLineF</a></span> QVariant::<span class="name">toLineF</span>() const</h3>
<p>Returns the variant as a <a href="qlinef.html" translate="no">QLineF</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QLineF</a>; otherwise returns an invalid <a href="qlinef.html" translate="no">QLineF</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toLineF -->
<!-- $$$toList[overload1]$$$toList -->
<h3 class="fn" translate="no" id="toList"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span>&gt; QVariant::<span class="name">toList</span>() const</h3>
<p>Returns the variant as a <a href="qvariant.html#QVariantList-typedef" translate="no">QVariantList</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QVariantList</a>. If it doesn't, <a href="qvariant.html" translate="no">QVariant</a> will attempt to convert the type to a list and then return it. This will succeed for any type that has registered a converter to <a href="qvariant.html#QVariantList-typedef" translate="no">QVariantList</a> or which was declared as a sequential container using <a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE" translate="no">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a>. If none of those conditions are true, this function will return an empty list.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toList -->
<!-- $$$toLocale[overload1]$$$toLocale -->
<h3 class="fn" translate="no" id="toLocale"><span class="type"><a href="qlocale.html" translate="no">QLocale</a></span> QVariant::<span class="name">toLocale</span>() const</h3>
<p>Returns the variant as a <a href="qlocale.html" translate="no">QLocale</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QLocale</a>; otherwise returns an invalid <a href="qlocale.html" translate="no">QLocale</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toLocale -->
<!-- $$$toLongLong[overload1]$$$toLongLongbool* -->
<h3 class="fn" translate="no" id="toLongLong"><span class="type"><a href="qttypes.html#qlonglong-typedef" translate="no">qlonglong</a></span> QVariant::<span class="name">toLongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the variant as a long long int if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>; otherwise returns 0.</p>
<p>If <i translate="no">ok</i> is non-null: <code translate="no">*</code><code translate="no">ok</code> is set to true if the value could be converted to an int; otherwise <code translate="no">*</code><code translate="no">ok</code> is set to false.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toLongLong -->
<!-- $$$toMap[overload1]$$$toMap -->
<h3 class="fn" translate="no" id="toMap"><span class="type"><a href="qmap.html" translate="no">QMap</a></span>&lt;<span class="type"><a href="qstring.html" translate="no">QString</a></span>, <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span>&gt; QVariant::<span class="name">toMap</span>() const</h3>
<p>Returns the variant as a <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> if the variant has type() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QVariantMap</a>. If it doesn't, <a href="qvariant.html" translate="no">QVariant</a> will attempt to convert the type to a map and then return it. This will succeed for any type that has registered a converter to <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> or which was declared as a associative container using <a href="qmetatype.html#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE" translate="no">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</a>. If none of those conditions are true, this function will return an empty map.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toMap -->
<!-- $$$toModelIndex[overload1]$$$toModelIndex -->
<h3 class="fn" translate="no" id="toModelIndex"><span class="type"><a href="qmodelindex.html" translate="no">QModelIndex</a></span> QVariant::<span class="name">toModelIndex</span>() const</h3>
<p>Returns the variant as a <a href="qmodelindex.html" translate="no">QModelIndex</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmodelindex.html" translate="no">QModelIndex</a>; otherwise returns a default constructed <a href="qmodelindex.html" translate="no">QModelIndex</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>(), <a href="qvariant.html#convert" translate="no">convert</a>(), and <a href="qvariant.html#toPersistentModelIndex" translate="no">toPersistentModelIndex</a>().</p>
<!-- @@@toModelIndex -->
<!-- $$$toPersistentModelIndex[overload1]$$$toPersistentModelIndex -->
<h3 class="fn" translate="no" id="toPersistentModelIndex"><span class="type"><a href="qpersistentmodelindex.html" translate="no">QPersistentModelIndex</a></span> QVariant::<span class="name">toPersistentModelIndex</span>() const</h3>
<p>Returns the variant as a <a href="qpersistentmodelindex.html" translate="no">QPersistentModelIndex</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qpersistentmodelindex.html" translate="no">QPersistentModelIndex</a>; otherwise returns a default constructed <a href="qpersistentmodelindex.html" translate="no">QPersistentModelIndex</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>(), <a href="qvariant.html#convert" translate="no">convert</a>(), and <a href="qvariant.html#toModelIndex" translate="no">toModelIndex</a>().</p>
<!-- @@@toPersistentModelIndex -->
<!-- $$$toPoint[overload1]$$$toPoint -->
<h3 class="fn" translate="no" id="toPoint"><span class="type"><a href="qpoint.html" translate="no">QPoint</a></span> QVariant::<span class="name">toPoint</span>() const</h3>
<p>Returns the variant as a <a href="qpoint.html" translate="no">QPoint</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QPoint</a> or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QPointF</a>; otherwise returns a null <a href="qpoint.html" translate="no">QPoint</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toPoint -->
<!-- $$$toPointF[overload1]$$$toPointF -->
<h3 class="fn" translate="no" id="toPointF"><span class="type"><a href="qpointf.html" translate="no">QPointF</a></span> QVariant::<span class="name">toPointF</span>() const</h3>
<p>Returns the variant as a <a href="qpointf.html" translate="no">QPointF</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QPoint</a> or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QPointF</a>; otherwise returns a null <a href="qpointf.html" translate="no">QPointF</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toPointF -->
<!-- $$$toReal[overload1]$$$toRealbool* -->
<h3 class="fn" translate="no" id="toReal"><span class="type"><a href="qttypes.html#qreal-typedef" translate="no">qreal</a></span> QVariant::<span class="name">toReal</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the variant as a qreal if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Float</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>; otherwise returns 0.0.</p>
<p>If <i translate="no">ok</i> is non-null: <code translate="no">*</code><i translate="no">ok</i> is set to true if the value could be converted to a double; otherwise <code translate="no">*</code><i translate="no">ok</i> is set to false.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toReal -->
<!-- $$$toRect[overload1]$$$toRect -->
<h3 class="fn" translate="no" id="toRect"><span class="type"><a href="qrect.html" translate="no">QRect</a></span> QVariant::<span class="name">toRect</span>() const</h3>
<p>Returns the variant as a <a href="qrect.html" translate="no">QRect</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QRect</a>; otherwise returns an invalid <a href="qrect.html" translate="no">QRect</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toRect -->
<!-- $$$toRectF[overload1]$$$toRectF -->
<h3 class="fn" translate="no" id="toRectF"><span class="type"><a href="qrectf.html" translate="no">QRectF</a></span> QVariant::<span class="name">toRectF</span>() const</h3>
<p>Returns the variant as a <a href="qrectf.html" translate="no">QRectF</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QRect</a> or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QRectF</a>; otherwise returns an invalid <a href="qrectf.html" translate="no">QRectF</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toRectF -->
<!-- $$$toRegularExpression[overload1]$$$toRegularExpression -->
<h3 class="fn" translate="no" id="toRegularExpression"><span class="type"><a href="qregularexpression.html" translate="no">QRegularExpression</a></span> QVariant::<span class="name">toRegularExpression</span>() const</h3>
<p>Returns the variant as a <a href="qregularexpression.html" translate="no">QRegularExpression</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qregularexpression.html" translate="no">QRegularExpression</a>; otherwise returns an empty <a href="qregularexpression.html" translate="no">QRegularExpression</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toRegularExpression -->
<!-- $$$toSize[overload1]$$$toSize -->
<h3 class="fn" translate="no" id="toSize"><span class="type"><a href="qsize.html" translate="no">QSize</a></span> QVariant::<span class="name">toSize</span>() const</h3>
<p>Returns the variant as a <a href="qsize.html" translate="no">QSize</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QSize</a>; otherwise returns an invalid <a href="qsize.html" translate="no">QSize</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toSize -->
<!-- $$$toSizeF[overload1]$$$toSizeF -->
<h3 class="fn" translate="no" id="toSizeF"><span class="type"><a href="qsizef.html" translate="no">QSizeF</a></span> QVariant::<span class="name">toSizeF</span>() const</h3>
<p>Returns the variant as a <a href="qsizef.html" translate="no">QSizeF</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QSizeF</a>; otherwise returns an invalid <a href="qsizef.html" translate="no">QSizeF</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toSizeF -->
<!-- $$$toString[overload1]$$$toString -->
<h3 class="fn" translate="no" id="toString"><span class="type"><a href="qstring.html" translate="no">QString</a></span> QVariant::<span class="name">toString</span>() const</h3>
<p>Returns the variant as a <a href="qstring.html" translate="no">QString</a> if the variant has a <a href="qvariant.html#userType" translate="no">userType</a>() including, but not limited to:</p>
<p><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDate</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDateTime</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QStringList</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QTime</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>.</p>
<p>Calling QVariant::toString() on an unsupported variant returns an empty string.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toString -->
<!-- $$$toStringList[overload1]$$$toStringList -->
<h3 class="fn" translate="no" id="toStringList"><span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> QVariant::<span class="name">toStringList</span>() const</h3>
<p>Returns the variant as a <a href="qstringlist.html" translate="no">QStringList</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QStringList</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QVariantList</a> of a type that can be converted to <a href="qstring.html" translate="no">QString</a>; otherwise returns an empty list.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toStringList -->
<!-- $$$toTime[overload1]$$$toTime -->
<h3 class="fn" translate="no" id="toTime"><span class="type"><a href="qtime.html" translate="no">QTime</a></span> QVariant::<span class="name">toTime</span>() const</h3>
<p>Returns the variant as a <a href="qtime.html" translate="no">QTime</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QTime</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDateTime</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>; otherwise returns an invalid time.</p>
<p>If the type() is <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, an invalid time will be returned if the string cannot be parsed as a <a href="qt.html#DateFormat-enum" translate="no">Qt::ISODate</a> format time.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toTime -->
<!-- $$$toUInt[overload1]$$$toUIntbool* -->
<h3 class="fn" translate="no" id="toUInt"><span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span> QVariant::<span class="name">toUInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the variant as an unsigned int if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>; otherwise returns 0.</p>
<p>If <i translate="no">ok</i> is non-null: <code translate="no">*</code><i translate="no">ok</i> is set to true if the value could be converted to an unsigned int; otherwise <code translate="no">*</code><i translate="no">ok</i> is set to false.</p>
<p><b>Warning:</b> If the value is convertible to a <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a> but is too large to be represented in an unsigned int, the resulting arithmetic overflow will not be reflected in <i translate="no">ok</i>. A simple workaround is to use <a href="qstring.html#toUInt" translate="no">QString::toUInt</a>().</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toUInt -->
<!-- $$$toULongLong[overload1]$$$toULongLongbool* -->
<h3 class="fn" translate="no" id="toULongLong"><span class="type"><a href="qttypes.html#qulonglong-typedef" translate="no">qulonglong</a></span> QVariant::<span class="name">toULongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the variant as an unsigned long long int if the variant has type() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>; otherwise returns 0.</p>
<p>If <i translate="no">ok</i> is non-null: <code translate="no">*</code><i translate="no">ok</i> is set to true if the value could be converted to an int; otherwise <code translate="no">*</code><i translate="no">ok</i> is set to false.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toULongLong -->
<!-- $$$toUrl[overload1]$$$toUrl -->
<h3 class="fn" translate="no" id="toUrl"><span class="type"><a href="qurl.html" translate="no">QUrl</a></span> QVariant::<span class="name">toUrl</span>() const</h3>
<p>Returns the variant as a <a href="qurl.html" translate="no">QUrl</a> if the variant has <a href="qvariant.html#userType" translate="no">userType</a>() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QUrl</a>; otherwise returns an invalid <a href="qurl.html" translate="no">QUrl</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toUrl -->
<!-- $$$toUuid[overload1]$$$toUuid -->
<h3 class="fn" translate="no" id="toUuid"><span class="type"><a href="quuid.html" translate="no">QUuid</a></span> QVariant::<span class="name">toUuid</span>() const</h3>
<p>Returns the variant as a <a href="quuid.html" translate="no">QUuid</a> if the variant has type() <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QUuid</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a> or <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>; otherwise returns a default-constructed <a href="quuid.html" translate="no">QUuid</a>.</p>
<p><b>See also </b><a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() and <a href="qvariant.html#convert" translate="no">convert</a>().</p>
<!-- @@@toUuid -->
<!-- $$$typeName[overload1]$$$typeName -->
<h3 class="fn" translate="no" id="typeName">const <span class="type">char</span> *QVariant::<span class="name">typeName</span>() const</h3>
<p>Returns the name of the type stored in the variant. The returned strings describe the C++ datatype used to store the data: for example, &quot;<a href="../qtgui/qfont.html" translate="no">QFont</a>&quot;, &quot;<a href="qstring.html" translate="no">QString</a>&quot;, or &quot;<a href="qvariant.html#QVariantList-typedef" translate="no">QVariantList</a>&quot;. An Invalid variant returns 0.</p>
<!-- @@@typeName -->
<!-- $$$value[overload1]$$$value -->
<h3 class="fn" translate="no" id="value">template &lt;typename T&gt; <span class="type">T</span> QVariant::<span class="name">value</span>() const &</h3>
<p>Returns the stored value converted to the template type <code translate="no">T</code>. Call <a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() to find out whether a type can be converted. If the value cannot be converted, a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a> will be returned.</p>
<p>If the type <code translate="no">T</code> is supported by <a href="qvariant.html" translate="no">QVariant</a>, this function behaves exactly as <a href="qvariant.html#toString" translate="no">toString</a>(), <a href="qvariant.html#toInt" translate="no">toInt</a>() etc.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> v;

 MyCustomStruct c;
 <span class="keyword">if</span> (v<span class="operator">.</span>canConvert<span class="operator">&lt;</span>MyCustomStruct<span class="operator">&gt;</span>())
     c <span class="operator">=</span> v<span class="operator">.</span>value<span class="operator">&lt;</span>MyCustomStruct<span class="operator">&gt;</span>();

 v <span class="operator">=</span> <span class="number">7</span>;
 <span class="type">int</span> i <span class="operator">=</span> v<span class="operator">.</span>value<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>();                        <span class="comment">// same as v.toInt()</span>
 <span class="type"><a href="qstring.html" translate="no">QString</a></span> s <span class="operator">=</span> v<span class="operator">.</span>value<span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span>();                <span class="comment">// same as v.toString(), s is now &quot;7&quot;</span>
 MyCustomStruct c2 <span class="operator">=</span> v<span class="operator">.</span>value<span class="operator">&lt;</span>MyCustomStruct<span class="operator">&gt;</span>(); <span class="comment">// conversion failed, c2 is empty</span>
</pre>
<p>If the <a href="qvariant.html" translate="no">QVariant</a> contains a pointer to a type derived from <a href="qobject.html" translate="no">QObject</a> then <code translate="no">T</code> may be any <a href="qobject.html" translate="no">QObject</a> type. If the pointer stored in the <a href="qvariant.html" translate="no">QVariant</a> can be <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a> to T, then that result is returned. Otherwise <code translate="no">nullptr</code> is returned. Note that this only works for <a href="qobject.html" translate="no">QObject</a> subclasses which use the <a href="qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro.</p>
<p>If the <a href="qvariant.html" translate="no">QVariant</a> contains a sequential container and <code translate="no">T</code> is <a href="qvariant.html#QVariantList-typedef" translate="no">QVariantList</a>, the elements of the container will be converted into <a href="qvariant.html" translate="no">QVariant</a>s and returned as a <a href="qvariant.html#QVariantList-typedef" translate="no">QVariantList</a>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> intList <span class="operator">=</span> {<span class="number">7</span><span class="operator">,</span> <span class="number">11</span><span class="operator">,</span> <span class="number">42</span>};

 <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> variant <span class="operator">=</span> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span><span class="operator">::</span>fromValue(intList);
 <span class="keyword">if</span> (variant<span class="operator">.</span>canConvert<span class="operator">&lt;</span><span class="type"><a href="qvariant.html#QVariantList-typedef" translate="no">QVariantList</a></span><span class="operator">&gt;</span>()) {
     <span class="type"><a href="qsequentialiterable.html" translate="no">QSequentialIterable</a></span> iterable <span class="operator">=</span> variant<span class="operator">.</span>value<span class="operator">&lt;</span><span class="type"><a href="qsequentialiterable.html" translate="no">QSequentialIterable</a></span><span class="operator">&gt;</span>();
     <span class="comment">// Can use foreach:</span>
     foreach (<span class="keyword">const</span> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> <span class="operator">&amp;</span>v<span class="operator">,</span> iterable) {
         <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> v;
     }
     <span class="comment">// Can use C++11 range-for:</span>
     <span class="keyword">for</span> (<span class="keyword">const</span> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> <span class="operator">&amp;</span>v : iterable) {
         <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> v;
     }
     <span class="comment">// Can use iterators:</span>
     <span class="type"><a href="qsequentialiterable.html" translate="no">QSequentialIterable</a></span><span class="operator">::</span>const_iterator it <span class="operator">=</span> iterable<span class="operator">.</span>begin();
     <span class="keyword">const</span> <span class="type"><a href="qsequentialiterable.html" translate="no">QSequentialIterable</a></span><span class="operator">::</span>const_iterator end <span class="operator">=</span> iterable<span class="operator">.</span>end();
     <span class="keyword">for</span> ( ; it <span class="operator">!</span><span class="operator">=</span> end; <span class="operator">+</span><span class="operator">+</span>it) {
         <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="operator">*</span>it;
     }
 }
</pre>
<p><b>See also </b><a href="qvariant.html#setValue" translate="no">setValue</a>(), <a href="qvariant.html#fromValue" translate="no">fromValue</a>(), <a href="qvariant.html#canConvert-2" translate="no">canConvert</a>(), and <a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE" translate="no">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a>().</p>
<!-- @@@value -->
<!-- $$$view[overload1]$$$view -->
<h3 class="fn" translate="no" id="view">template &lt;typename T&gt; <span class="type">T</span> QVariant::<span class="name">view</span>()</h3>
<p>Returns a mutable view of template type <code translate="no">T</code> on the stored value. Call <a href="qvariant.html#canView-1" translate="no">canView</a>() to find out whether such a view is supported. If no such view can be created, returns the stored value converted to the template type <code translate="no">T</code>. Call <a href="qvariant.html#canConvert-2" translate="no">canConvert</a>() to find out whether a type can be converted. If the value can neither be viewed nor converted, a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a> will be returned.</p>
<p><b>See also </b><a href="qvariant.html#canView-1" translate="no">canView</a>() and <a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE" translate="no">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a>().</p>
<!-- @@@view -->
<!-- $$$operator=[overload1]$$$operator=constQVariant& -->
<h3 class="fn" translate="no" id="operator-eq"><span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;QVariant::<span class="name">operator=</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>variant</i>)</h3>
<p>Assigns the value of the variant <i translate="no">variant</i> to this variant.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QVariant&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;QVariant::<span class="name">operator=</span>(<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qvariant.html" translate="no">QVariant</a> instance.</p>
<!-- @@@operator= -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="get_if"><code class="details extra" translate="no">[noexcept, since 6.6]</code> template &lt;typename T&gt; <span class="type">T</span> *<span class="name">get_if</span>(<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> *<i>v</i>)</h3><h3 class="fn fngroupitem" translate="no" id="get_if-1"><code class="details extra" translate="no">[noexcept, since 6.6]</code> template &lt;typename T&gt; const <span class="type">T</span> *<span class="name">get_if</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> *<i>v</i>)</h3></div>
<p>If <i translate="no">v</i> contains an object of type <code translate="no">T</code>, returns a pointer to the contained object, otherwise returns <code translate="no">nullptr</code>.</p>
<p>The overload taking a mutable <i translate="no">v</i> detaches <i translate="no">v</i>: When called on a <a href="qvariant.html#isNull" translate="no">null</a> <i translate="no">v</i> with matching type <code translate="no">T</code>, <i translate="no">v</i> will not be null after the call.</p>
<p>These functions are provided for compatibility with <code translate="no">std::variant</code>.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qvariant.html#data" translate="no">data</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="get"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename T&gt; <span class="type">T</span> &amp;<span class="name">get</span>(<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>v</i>)</h3><h3 class="fn fngroupitem" translate="no" id="get-2"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename T&gt; <span class="type">T</span> &amp;&amp;<span class="name">get</span>(<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;&amp;<i>v</i>)</h3><h3 class="fn fngroupitem" translate="no" id="get-1"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename T&gt; const <span class="type">T</span> &amp;<span class="name">get</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>v</i>)</h3><h3 class="fn fngroupitem" translate="no" id="get-3"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename T&gt; const <span class="type">T</span> &amp;&amp;<span class="name">get</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;&amp;<i>v</i>)</h3></div>
<p>If <i translate="no">v</i> contains an object of type <code translate="no">T</code>, returns a reference to the contained object, otherwise the call has undefined behavior.</p>
<p>The overloads taking a mutable <i translate="no">v</i> detach <i translate="no">v</i>: When called on a <a href="qvariant.html#isNull" translate="no">null</a> <i translate="no">v</i> with matching type <code translate="no">T</code>, <i translate="no">v</i> will not be null after the call.</p>
<p>These functions are provided for compatibility with <code translate="no">std::variant</code>.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qvariant.html#get_if" translate="no">get_if</a>() and <a href="qvariant.html#data" translate="no">data</a>().</p>
<!-- @@@ -->
<!-- $$$QVariantHash -->
<h3 class="fn" translate="no" id="QVariantHash-typedef"><code class="details extra" translate="no">[alias]</code> <span class="name">QVariantHash</span></h3>
<p>Synonym for <a href="qhash.html#qhash" translate="no">QHash</a>&lt;<a href="qstring.html" translate="no">QString</a>, <a href="qvariant.html" translate="no">QVariant</a>&gt;.</p>
<!-- @@@QVariantHash -->
<!-- $$$QVariantList -->
<h3 class="fn" translate="no" id="QVariantList-typedef"><code class="details extra" translate="no">[alias]</code> <span class="name">QVariantList</span></h3>
<p>Synonym for <a href="qlist.html" translate="no">QList</a>&lt;<a href="qvariant.html" translate="no">QVariant</a>&gt;.</p>
<!-- @@@QVariantList -->
<!-- $$$QVariantMap -->
<h3 class="fn" translate="no" id="QVariantMap-typedef"><code class="details extra" translate="no">[alias]</code> <span class="name">QVariantMap</span></h3>
<p>Synonym for <a href="qmap.html" translate="no">QMap</a>&lt;<a href="qstring.html" translate="no">QString</a>, <a href="qvariant.html" translate="no">QVariant</a>&gt;.</p>
<!-- @@@QVariantMap -->
<!-- $$$qvariant_cast[overload1]$$$qvariant_castQVariant&& -->
<h3 class="fn" translate="no" id="qvariant_cast"><code class="details extra" translate="no">[since 6.7]</code> template &lt;typename T&gt; <span class="type">T</span> <span class="name">qvariant_cast</span>(<span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;&amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns the given <i translate="no">value</i> converted to the template type <code translate="no">T</code>.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@qvariant_cast -->
<!-- $$$qvariant_cast$$$qvariant_castconstQVariant& -->
<h3 class="fn" translate="no" id="qvariant_cast-1">template &lt;typename T&gt; <span class="type">T</span> <span class="name">qvariant_cast</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Returns the given <i translate="no">value</i> converted to the template type <code translate="no">T</code>.</p>
<p>This function is equivalent to <a href="qvariant.html#value" translate="no">QVariant::value</a>().</p>
<p><b>See also </b><a href="qvariant.html#value" translate="no">QVariant::value</a>().</p>
<!-- @@@qvariant_cast -->
<!-- $$$operator!=[overload1]$$$operator!=constQVariant&constQVariant& -->
<h3 class="fn" translate="no" id="operator-not-eq"><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>v1</i>, const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>v2</i>)</h3>
<p>Returns <code translate="no">false</code> if <i translate="no">v1</i> and <i translate="no">v2</i> are equal; otherwise returns <code translate="no">true</code>.</p>
<p><a href="qvariant.html" translate="no">QVariant</a> uses the equality operator of the type() contained to check for equality.</p>
<p>Variants of different types will always compare as not equal with a few exceptions:</p>
<ul>
<li>If both types are numeric types (integers and floatins point numbers) Qt will compare those types using standard C++ type promotion rules.</li>
<li>If one type is numeric and the other one a <a href="qstring.html" translate="no">QString</a>, Qt will try to convert the <a href="qstring.html" translate="no">QString</a> to a matching numeric type and if successful compare those.</li>
<li>If both variants contain pointers to <a href="qobject.html" translate="no">QObject</a> derived types, <a href="qvariant.html" translate="no">QVariant</a> will check whether the types are related and point to the same object.</li>
</ul>
<!-- @@@operator!= -->
<!-- $$$operator<<$$$operator<<QDataStream&constQVariant& -->
<h3 class="fn" translate="no" id="operator-lt-lt-2"><span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>s</i>, const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>p</i>)</h3>
<p>Writes a variant <i translate="no">p</i> to the stream <i translate="no">s</i>.</p>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Format of the QDataStream operators</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator==[overload1]$$$operator==constQVariant&constQVariant& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>v1</i>, const <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>v2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">v1</i> and <i translate="no">v2</i> are equal; otherwise returns <code translate="no">false</code>.</p>
<p><a href="qvariant.html" translate="no">QVariant</a> uses the equality operator of the type() contained to check for equality.</p>
<p>Variants of different types will always compare as not equal with a few exceptions:</p>
<ul>
<li>If both types are numeric types (integers and floatins point numbers) Qt will compare those types using standard C++ type promotion rules.</li>
<li>If one type is numeric and the other one a <a href="qstring.html" translate="no">QString</a>, Qt will try to convert the <a href="qstring.html" translate="no">QString</a> to a matching numeric type and if successful compare those.</li>
<li>If both variants contain pointers to <a href="qobject.html" translate="no">QObject</a> derived types, <a href="qvariant.html" translate="no">QVariant</a> will check whether the types are related and point to the same object.</li>
</ul>
<p>The result of the function is not affected by the result of <a href="qvariant.html#isNull" translate="no">QVariant::isNull</a>, which means that two values can be equal even if one of them is null and another is not.</p>
<!-- @@@operator== -->
<!-- $$$operator>>$$$operator>>QDataStream&QVariant& -->
<h3 class="fn" translate="no" id="operator-gt-gt-2"><span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>s</i>, <span class="type"><a href="qvariant.html#QVariant" translate="no">QVariant</a></span> &amp;<i>p</i>)</h3>
<p>Reads a variant <i translate="no">p</i> from the stream <i translate="no">s</i>.</p>
<div class="admonition note">
<p><b>Note: </b>If the stream contains types that aren't the built-in ones (see <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Type</a>), those types must be registered using <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>() or <a href="qmetatype.html#registerType" translate="no">QMetaType::registerType</a>() before the variant can be properly loaded. If an unregistered type is found, <a href="qvariant.html" translate="no">QVariant</a> will set the corrupt flag in the stream, stop processing and print a warning. For example, for <a href="qlist.html" translate="no">QList</a>&lt;int&gt; it would print the following:</p>
</div>
<blockquote><p>QVariant::load: unknown user type with name <a href="qlist.html" translate="no">QList</a>&lt;int&gt;</p>
</blockquote>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Format of the QDataStream operators</a>.</p>
<!-- @@@operator>> -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
