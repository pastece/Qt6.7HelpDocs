<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qbytearrayview.qdoc -->
  <meta name="description" content="The QByteArrayView class provides a view on an array of bytes with a read-only subset of the QByteArray API.">
  <title>QByteArrayView Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QByteArrayView</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#compatible-byte-types">Compatible Byte Types</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QByteArrayView Class</h1>
<!-- $$$QByteArrayView-brief -->
<p>The QByteArrayView class provides a view on an array of bytes with a read-only subset of the <a href="qbytearray.html" translate="no">QByteArray</a> API. <a href="#details">More...</a></p>
<!-- @@@QByteArrayView -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QByteArrayView&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr>
</table></div>
<ul>
<li><a href="qbytearrayview-members.html">List of all members, including inherited members</a></li>
<li><a href="qbytearrayview-obsolete.html">Deprecated members</a></li>
<li>QByteArrayView is part of <a href="shared.html">Implicitly Shared Classes</a> and <a href="../qtdoc/string-processing.html">Classes for String Data</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#const_iterator-typedef" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#const_pointer-typedef" translate="no">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#const_reference-typedef" translate="no">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#iterator-typedef" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#pointer-typedef" translate="no">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#reference-typedef" translate="no">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#reverse_iterator-typedef" translate="no">reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#storage_type-typedef" translate="no">storage_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#value_type-typedef" translate="no">value_type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#QByteArrayView-1" translate="no">QByteArrayView</a></b>(std::nullptr_t)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#QByteArrayView-2" translate="no">QByteArrayView</a></b>(const Byte *<i>data</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#QByteArrayView-3" translate="no">QByteArrayView</a></b>(const Byte *<i>first</i>, const Byte *<i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#QByteArrayView-4" translate="no">QByteArrayView</a></b>(const Byte *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#QByteArrayView-5" translate="no">QByteArrayView</a></b>(const QByteArray &amp;<i>byteArray</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#QByteArrayView-6" translate="no">QByteArrayView</a></b>(const Container &amp;<i>c</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#QByteArrayView-7" translate="no">QByteArrayView</a></b>(const char (&amp;)[Size] <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#at" translate="no">at</a></b>(qsizetype <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#back" translate="no">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#begin" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#chop" translate="no">chop</a></b>(qsizetype <i>length</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#chopped" translate="no">chopped</a></b>(qsizetype <i>length</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#compare" translate="no">compare</a></b>(QByteArrayView <i>bv</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_pointer </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#constData" translate="no">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#contains" translate="no">contains</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#contains-1" translate="no">contains</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#count" translate="no">count</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#count-1" translate="no">count</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#crbegin" translate="no">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#crend" translate="no">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_pointer </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#data" translate="no">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#end" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#endsWith" translate="no">endsWith</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#endsWith-1" translate="no">endsWith</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#first" translate="no">first</a></b>(qsizetype <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#front" translate="no">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#indexOf" translate="no">indexOf</a></b>(QByteArrayView <i>bv</i>, qsizetype <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#indexOf-1" translate="no">indexOf</a></b>(char <i>ch</i>, qsizetype <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#isNull" translate="no">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#isValidUtf8" translate="no">isValidUtf8</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#last" translate="no">last</a></b>(qsizetype <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#lastIndexOf" translate="no">lastIndexOf</a></b>(QByteArrayView <i>bv</i>, qsizetype <i>from</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#lastIndexOf-1" translate="no">lastIndexOf</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#lastIndexOf-2" translate="no">lastIndexOf</a></b>(char <i>ch</i>, qsizetype <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#length" translate="no">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#rbegin" translate="no">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#rend" translate="no">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#sliced" translate="no">sliced</a></b>(qsizetype <i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#sliced-1" translate="no">sliced</a></b>(qsizetype <i>pos</i>, qsizetype <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#startsWith" translate="no">startsWith</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#startsWith-1" translate="no">startsWith</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toByteArray" translate="no">toByteArray</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> double </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toDouble" translate="no">toDouble</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> float </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toFloat" translate="no">toFloat</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toInt" translate="no">toInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> long </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toLong" translate="no">toLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> qlonglong </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toLongLong" translate="no">toLongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> short </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toShort" translate="no">toShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> uint </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toUInt" translate="no">toUInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> ulong </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toULong" translate="no">toULong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> qulonglong </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toULongLong" translate="no">toULongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> ushort </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#toUShort" translate="no">toUShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> QByteArrayView </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#trimmed" translate="no">trimmed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#truncate" translate="no">truncate</a></b>(qsizetype <i>length</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> std::string_view </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#operator-std-3a-3astring_view" translate="no">operator std::string_view</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#operator-5b-5d" translate="no">operator[]</a></b>(qsizetype <i>n</i>) const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayView </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#fromArray" translate="no">fromArray</a></b>(const Byte (&amp;)[Size] <i>data</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#operator-not-eq" translate="no">operator!=</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#operator-lt" translate="no">operator&lt;</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#operator-lt-eq" translate="no">operator&lt;=</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#operator-eq-eq" translate="no">operator==</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#operator-gt" translate="no">operator&gt;</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#operator-gt-eq" translate="no">operator&gt;=</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td></tr>
</table></div>
<!-- $$$QByteArrayView-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>A QByteArrayView references a contiguous portion of raw bytes it does not own. It acts as an interface type to all kinds of byte-array-like data, without the need to construct a <a href="qbytearray.html" translate="no">QByteArray</a> first.</p>
<p>The byte array data may be represented as an array (or an array-compatible data-structure such as <a href="qbytearray.html" translate="no">QByteArray</a>, std::basic_string, etc.) of <code translate="no">char</code>, <code translate="no">signed char</code>, <code translate="no">unsigned char</code> or <code translate="no">std::byte</code>.</p>
<p>QByteArrayView is designed as an interface type; its main use-case is as a function parameter type. When QByteArrayViews are used as automatic variables or data members, care must be taken to ensure that the referenced data (for example, owned by a <a href="qbytearray.html" translate="no">QByteArray</a>) outlives the QByteArrayView on all code paths, lest the byte array view ends up referencing deleted data.</p>
<p>When used as an interface type, QByteArrayView allows a single function to accept a wide variety of byte-array-like data sources. One function accepting QByteArrayView thus replaces several function overloads (taking, for example, <a href="qbytearray.html" translate="no">QByteArray</a>, const char *, etc.) while at the same time enabling even more byte array data sources to be passed to the function.</p>
<p>QByteArrayView should be passed by value, not by reference-to-const:</p>
<pre class="cpp" translate="no">
     <span class="type">void</span> myfun1(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> bv);        <span class="comment">// preferred</span>
     <span class="type">void</span> myfun2(<span class="keyword">const</span> <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <span class="operator">&amp;</span>bv); <span class="comment">// compiles and works, but slower</span>
</pre>
<p>If you want to give your users maximum freedom in what type of data they can pass to your function, accompany the QByteArrayView overload with overloads for</p>
<ul>
<li><i>char</i>: this overload can delegate to the QByteArrayView version:<pre class="cpp" translate="no">
     <span class="type">void</span> fun(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> bv);
     <span class="type">void</span> fun(<span class="type">char</span> ch) { fun(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span>(<span class="operator">&amp;</span>ch<span class="operator">,</span> <span class="number">1</span>)); }
</pre>
<p>even though, for technical reasons, QByteArrayView cannot provide a char constructor by itself.</p>
</li>
<li><i>QByteArray</i>: if you store an unmodified copy of the byte array and thus would like to take advantage of <a href="qbytearray.html" translate="no">QByteArray</a>'s implicit sharing.</li>
</ul>
<p>QByteArrayView can also be used as the return value of a function. If you call a function returning QByteArrayView, take extra care to not keep the QByteArrayView around longer than the function promises to keep the referenced data alive. If in doubt, obtain a strong reference to the data by calling <a href="qbytearrayview.html#toByteArray" translate="no">toByteArray</a>() to convert the QByteArrayView into a <a href="qbytearray.html" translate="no">QByteArray</a>.</p>
<p>The methods supported by QByteArrayView reflect those of <a href="qbytearray.html" translate="no">QByteArray</a>. In particular, to the limited degree that it ascribes semantics (such as character case, spacing, digits of numbers) to the character data viewed, it uses the C locale and ASCII encoding. See <a href="qbytearray.html#c-locale-and-ascii-functions" translate="no">C locale and ASCII functions</a> for details and the limitations on these methods.</p>
<h3 id="compatible-byte-types">Compatible Byte Types</h3>
<p>QByteArrayView can be constructed on any container of bytes, where the byte type is one of:</p>
<ul>
<li><code translate="no">char</code> (both signed and unsigned)</li>
<li><code translate="no">std::byte</code></li>
</ul>
</div>
<p><b>See also </b><a href="qbytearray.html" translate="no">QByteArray</a> and <a href="qstringview.html" translate="no">QStringView</a>.</p>
<!-- @@@QByteArrayView -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$const_iterator -->
<h3 class="fn" translate="no" id="const_iterator-typedef">QByteArrayView::<span class="name">const_iterator</span></h3>
<p>This typedef provides an STL-style const iterator for <a href="qbytearrayview.html" translate="no">QByteArrayView</a>.</p>
<p><b>See also </b><a href="qbytearrayview.html#iterator-typedef" translate="no">iterator</a> and <a href="qbytearrayview.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" translate="no" id="const_pointer-typedef">QByteArrayView::<span class="name">const_pointer</span></h3>
<p>Alias for <code translate="no">value_type *</code>. Provided for compatibility with the STL.</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" translate="no" id="const_reference-typedef">QByteArrayView::<span class="name">const_reference</span></h3>
<p>Alias for <code translate="no">value_type &amp;</code>. Provided for compatibility with the STL.</p>
<!-- @@@const_reference -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" translate="no" id="const_reverse_iterator-typedef">QByteArrayView::<span class="name">const_reverse_iterator</span></h3>
<p>This typedef provides an STL-style const reverse iterator for <a href="qbytearrayview.html" translate="no">QByteArrayView</a>.</p>
<p><b>See also </b><a href="qbytearrayview.html#reverse_iterator-typedef" translate="no">reverse_iterator</a> and <a href="qbytearrayview.html#const_iterator-typedef" translate="no">const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" translate="no" id="difference_type-typedef">QByteArrayView::<span class="name">difference_type</span></h3>
<p>Alias for <code translate="no">std::ptrdiff_t</code>. Provided for compatibility with the STL.</p>
<!-- @@@difference_type -->
<!-- $$$iterator -->
<h3 class="fn" translate="no" id="iterator-typedef">QByteArrayView::<span class="name">iterator</span></h3>
<p>This typedef provides an STL-style const iterator for <a href="qbytearrayview.html" translate="no">QByteArrayView</a>.</p>
<p><a href="qbytearrayview.html" translate="no">QByteArrayView</a> does not support mutable iterators, so this is the same as <a href="qbytearrayview.html#const_iterator-typedef" translate="no">const_iterator</a>.</p>
<p><b>See also </b><a href="qbytearrayview.html#const_iterator-typedef" translate="no">const_iterator</a> and <a href="qbytearrayview.html#reverse_iterator-typedef" translate="no">reverse_iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$pointer -->
<h3 class="fn" translate="no" id="pointer-typedef">QByteArrayView::<span class="name">pointer</span></h3>
<p>Alias for <code translate="no">value_type *</code>. Provided for compatibility with the STL.</p>
<p><a href="qbytearrayview.html" translate="no">QByteArrayView</a> does not support mutable pointers, so this is the same as <a href="qbytearrayview.html#const_pointer-typedef" translate="no">const_pointer</a>.</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" translate="no" id="reference-typedef">QByteArrayView::<span class="name">reference</span></h3>
<p>Alias for <code translate="no">value_type &amp;</code>. Provided for compatibility with the STL.</p>
<p><a href="qbytearrayview.html" translate="no">QByteArrayView</a> does not support mutable references, so this is the same as <a href="qbytearrayview.html#const_reference-typedef" translate="no">const_reference</a>.</p>
<!-- @@@reference -->
<!-- $$$reverse_iterator -->
<h3 class="fn" translate="no" id="reverse_iterator-typedef">QByteArrayView::<span class="name">reverse_iterator</span></h3>
<p>This typedef provides an STL-style const reverse iterator for <a href="qbytearrayview.html" translate="no">QByteArrayView</a>.</p>
<p><a href="qbytearrayview.html" translate="no">QByteArrayView</a> does not support mutable reverse iterators, so this is the same as <a href="qbytearrayview.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a>.</p>
<p><b>See also </b><a href="qbytearrayview.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a> and <a href="qbytearrayview.html#iterator-typedef" translate="no">iterator</a>.</p>
<!-- @@@reverse_iterator -->
<!-- $$$size_type -->
<h3 class="fn" translate="no" id="size_type-typedef">QByteArrayView::<span class="name">size_type</span></h3>
<p>Alias for qsizetype. Provided for compatibility with the STL.</p>
<!-- @@@size_type -->
<!-- $$$storage_type -->
<h3 class="fn" translate="no" id="storage_type-typedef">QByteArrayView::<span class="name">storage_type</span></h3>
<p>Alias for <code translate="no">char</code>.</p>
<!-- @@@storage_type -->
<!-- $$$value_type -->
<h3 class="fn" translate="no" id="value_type-typedef">QByteArrayView::<span class="name">value_type</span></h3>
<p>Alias for <code translate="no">const char</code>. Provided for compatibility with the STL.</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="startsWith"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QByteArrayView::<span class="name">startsWith</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>bv</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="startsWith-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QByteArrayView::<span class="name">startsWith</span>(<span class="type">char</span> <i>ch</i>) const</h3></div>
<p>Returns <code translate="no">true</code> if this byte array view starts with byte array view <i translate="no">bv</i> or character <i translate="no">ch</i>, respectively; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qbytearrayview.html#endsWith" translate="no">endsWith</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="endsWith"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QByteArrayView::<span class="name">endsWith</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>bv</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="endsWith-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QByteArrayView::<span class="name">endsWith</span>(<span class="type">char</span> <i>ch</i>) const</h3></div>
<p>Returns <code translate="no">true</code> if this byte array view ends with byte array view <i translate="no">bv</i> or character <i translate="no">ch</i>, respectively; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qbytearrayview.html#startsWith" translate="no">startsWith</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="indexOf"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QByteArrayView::<span class="name">indexOf</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>bv</i>, <span class="type">qsizetype</span> <i>from</i> = 0) const</h3><h3 class="fn fngroupitem" translate="no" id="indexOf-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QByteArrayView::<span class="name">indexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">qsizetype</span> <i>from</i> = 0) const</h3></div>
<p>Returns the index position of either the start of the first occurrence of the sequence of bytes viewed by <i translate="no">bv</i> or the first occurrence of byte <i translate="no">ch</i>, respectively, in this byte array view, searching forward from index position <i translate="no">from.Returns</i> -1 if no match is found.</p>
<p>If <i translate="no">from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p><b>See also </b><a href="qbytearrayview.html#lastIndexOf" translate="no">lastIndexOf</a>() and <a href="qbytearrayview.html#contains" translate="no">contains</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="contains"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QByteArrayView::<span class="name">contains</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>bv</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="contains-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QByteArrayView::<span class="name">contains</span>(<span class="type">char</span> <i>ch</i>) const</h3></div>
<p>Returns <code translate="no">true</code> if this byte array view contains an occurrence of the sequence of bytes viewed by <i translate="no">bv</i> or character <i translate="no">ch</i>, respectively; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qbytearrayview.html#indexOf" translate="no">indexOf</a>() and <a href="qbytearrayview.html#lastIndexOf" translate="no">lastIndexOf</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="lastIndexOf"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QByteArrayView::<span class="name">lastIndexOf</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>bv</i>, <span class="type">qsizetype</span> <i>from</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="lastIndexOf-2"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QByteArrayView::<span class="name">lastIndexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">qsizetype</span> <i>from</i> = -1) const</h3></div>
<p>Returns the index position of either the start of the last occurrence of the sequence of bytes viewed by <i translate="no">bv</i> or the last occurrence of byte <i translate="no">ch</i>, respectively, in this byte array view, searching backward from index position <i translate="no">from</i>.</p>
<p>If <i translate="no">from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p>Returns -1 if no match is found.</p>
<div class="admonition note">
<p><b>Note: </b>When searching for a 0-length <i translate="no">bv</i>, the match at the end of the data is excluded from the search by a negative <i translate="no">from</i>, even though <code translate="no">-1</code> is normally thought of as searching from the end of the view: the match at the end is <i>after</i> the last character, so it is excluded. To include such a final empty match, either give a positive value for <i translate="no">from</i> or omit the <i translate="no">from</i> parameter entirely.</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#indexOf" translate="no">indexOf</a>() and <a href="qbytearrayview.html#contains" translate="no">contains</a>().</p>
<!-- @@@ -->
<!-- $$$QByteArrayView[overload1]$$$QByteArrayView -->
<h3 class="fn" translate="no" id="QByteArrayView"><code class="details extra" translate="no">[constexpr noexcept]</code> QByteArrayView::<span class="name">QByteArrayView</span>()</h3>
<p>Constructs a null byte array view.</p>
<p><b>See also </b><a href="qbytearrayview.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@QByteArrayView -->
<!-- $$$QByteArrayView$$$QByteArrayViewstd::nullptr_t -->
<h3 class="fn" translate="no" id="QByteArrayView-1"><code class="details extra" translate="no">[constexpr noexcept]</code> QByteArrayView::<span class="name">QByteArrayView</span>(<span class="type">std::nullptr_t</span>)</h3>
<p>Constructs a null byte array view.</p>
<p><b>See also </b><a href="qbytearrayview.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@QByteArrayView -->
<!-- $$$QByteArrayView$$$QByteArrayViewconstByte*qsizetype -->
<h3 class="fn" translate="no" id="QByteArrayView-2"><code class="details extra" translate="no">[constexpr]</code> template &lt;typename Byte, QByteArrayView::if_compatible_byte&lt;Byte&gt; = true> QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">Byte</span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>Constructs a byte array view on <i translate="no">data</i> with length <i translate="no">len</i>.</p>
<p>The range <code translate="no">[data,len)</code> must remain valid for the lifetime of this QByteArrayView.</p>
<p>Passing <code translate="no">nullptr</code> as <i translate="no">data</i> is safe if <i translate="no">len</i> is 0, too, and results in a null byte array view.</p>
<p>The behavior is undefined if <i translate="no">len</i> is negative or, when positive, if <i translate="no">data</i> is <code translate="no">nullptr</code>.</p>
<p>This constructor only participates in overload resolution if <code translate="no">Byte</code> is a compatible byte type.</p>
<p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types" translate="no">Compatible Byte Types</a>.</p>
<!-- @@@QByteArrayView -->
<!-- $$$QByteArrayView$$$QByteArrayViewconstByte*constByte* -->
<h3 class="fn" translate="no" id="QByteArrayView-3"><code class="details extra" translate="no">[constexpr]</code> template &lt;typename Byte, QByteArrayView::if_compatible_byte&lt;Byte&gt; = true> QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">Byte</span> *<i>first</i>, const <span class="type">Byte</span> *<i>last</i>)</h3>
<p>Constructs a byte array view on <i translate="no">first</i> with length (<i translate="no">last</i> - <i translate="no">first</i>).</p>
<p>The range <code translate="no">[first,last)</code> must remain valid for the lifetime of this QByteArrayView.</p>
<p>Passing <code translate="no">\nullptr</code> as <i translate="no">first</i> is safe if <i translate="no">last</i> is <code translate="no">nullptr</code>, too, and results in a null byte array view.</p>
<p>The behavior is undefined if <i translate="no">last</i> precedes <i translate="no">first</i>, or <i translate="no">first</i> is <code translate="no">nullptr</code> and <i translate="no">last</i> is not.</p>
<p>This constructor only participates in overload resolution if <code translate="no">Byte</code> is a compatible byte type.</p>
<p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types" translate="no">Compatible Byte Types</a>.</p>
<!-- @@@QByteArrayView -->
<!-- $$$QByteArrayView$$$QByteArrayViewconstByte* -->
<h3 class="fn" translate="no" id="QByteArrayView-4"><code class="details extra" translate="no">[constexpr noexcept]</code> template &lt;typename Byte&gt; QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">Byte</span> *<i>data</i>)</h3>
<p>Constructs a byte array view on <i translate="no">data</i>. The length is determined by scanning for the first <code translate="no">Byte(0)</code>.</p>
<p><i translate="no">data</i> must remain valid for the lifetime of this byte array view object.</p>
<p>Passing <code translate="no">nullptr</code> as <i translate="no">data</i> is safe and results in a null byte array view.</p>
<p>This constructor only participates in overload resolution if <i translate="no">data</i> is not an array and if <code translate="no">Byte</code> is a compatible byte type.</p>
<p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types" translate="no">Compatible Byte Types</a>.</p>
<!-- @@@QByteArrayView -->
<!-- $$$QByteArrayView$$$QByteArrayViewconstQByteArray& -->
<h3 class="fn" translate="no" id="QByteArrayView-5"><code class="details extra" translate="no">[noexcept]</code> QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>byteArray</i>)</h3>
<p>Constructs a byte array view on <i translate="no">byteArray</i>.</p>
<p><code translate="no">byteArray.data()</code> must remain valid for the lifetime of this byte array view object.</p>
<p>The byte array view will be null if and only if <code translate="no">byteArray.isNull()</code>.</p>
<!-- @@@QByteArrayView -->
<!-- $$$QByteArrayView$$$QByteArrayViewconstContainer& -->
<h3 class="fn" translate="no" id="QByteArrayView-6"><code class="details extra" translate="no">[constexpr noexcept]</code> template &lt;typename Container, QByteArrayView::if_compatible_container&lt;Container&gt; = true> QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">Container</span> &amp;<i>c</i>)</h3>
<p>Constructs a byte array view on the array-like container <i translate="no">c</i>. The length and data are set via <code translate="no">std::size(c)</code> and <code translate="no">std::data(c)</code> respectively.</p>
<p>The container's data must remain valid for the lifetime of this byte array view object.</p>
<p>This constructor participates in overload resolution if <i translate="no">c</i> is any contiguous container with elements of a compatible byte type.</p>
<p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types" translate="no">Compatible Byte Types</a>.</p>
<!-- @@@QByteArrayView -->
<!-- $$$QByteArrayView$$$QByteArrayViewconstchar(&)[Size] -->
<h3 class="fn" translate="no" id="QByteArrayView-7"><code class="details extra" translate="no">[constexpr noexcept]</code> template &lt;size_t Size&gt; QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">char</span> (&amp;)[<span class="type">Size</span>] <i>data</i>)</h3>
<p>Constructs a byte array view on the char array <i translate="no">data</i>. The view covers the array until the first <code translate="no">'\0'</code> is encountered, or <code translate="no">Size</code>, whichever comes first. If you need the full array, use <a href="qbytearrayview.html#fromArray" translate="no">fromArray</a>() instead.</p>
<p><i translate="no">data</i> must remain valid for the lifetime of this byte array view object.</p>
<div class="admonition note">
<p><b>Note: </b>This constructor is only available for char array literals. The reasoning behind that is for compatibility with C-libraries which predefine &quot;large-enough&quot; arrays, but only use some of the preallocated space. To support this in an intuitive way in an implicit constructor overload, we need to stop at the first <code translate="no">char(0)</code>. This is logical for a char array, but not for a <code translate="no">std::byte</code> array.</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#fromArray" translate="no">fromArray</a>.</p>
<!-- @@@QByteArrayView -->
<!-- $$$at[overload1]$$$atqsizetype -->
<h3 class="fn" translate="no" id="at"><code class="details extra" translate="no">[constexpr]</code> <span class="type">char</span> QByteArrayView::<span class="name">at</span>(<span class="type">qsizetype</span> <i>n</i>) const</h3>
<p>Returns the character at position <i translate="no">n</i> in this byte array view.</p>
<p>The behavior is undefined if <i translate="no">n</i> is negative or not less than <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="qbytearrayview.html#operator-5b-5d" translate="no">operator[]</a>(), <a href="qbytearrayview.html#front" translate="no">front</a>(), and <a href="qbytearrayview.html#back" translate="no">back</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" translate="no" id="back"><code class="details extra" translate="no">[constexpr]</code> <span class="type">char</span> QByteArrayView::<span class="name">back</span>() const</h3>
<p>Returns the last byte in the byte array view.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array view constitutes undefined behavior.</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#front" translate="no">front</a>().</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" translate="no" id="begin"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_iterator-typedef" translate="no">QByteArrayView::const_iterator</a></span> QByteArrayView::<span class="name">begin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first byte in the byte array view.</p>
<p>This function is provided for STL compatibility.</p>
<p><b>See also </b><a href="qbytearrayview.html#end" translate="no">end</a>(), <a href="qbytearrayview.html#cbegin" translate="no">cbegin</a>(), <a href="qbytearrayview.html#rbegin" translate="no">rbegin</a>(), and <a href="qbytearrayview.html#data" translate="no">data</a>().</p>
<!-- @@@begin -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" translate="no" id="cbegin"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_iterator-typedef" translate="no">QByteArrayView::const_iterator</a></span> QByteArrayView::<span class="name">cbegin</span>() const</h3>
<p>Same as <a href="qbytearrayview.html#begin" translate="no">begin</a>().</p>
<p>This function is provided for STL compatibility.</p>
<p><b>See also </b><a href="qbytearrayview.html#cend" translate="no">cend</a>(), <a href="qbytearrayview.html#begin" translate="no">begin</a>(), <a href="qbytearrayview.html#crbegin" translate="no">crbegin</a>(), and <a href="qbytearrayview.html#data" translate="no">data</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" translate="no" id="cend"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_iterator-typedef" translate="no">QByteArrayView::const_iterator</a></span> QByteArrayView::<span class="name">cend</span>() const</h3>
<p>Same as <a href="qbytearrayview.html#end" translate="no">end</a>().</p>
<p>This function is provided for STL compatibility.</p>
<p><b>See also </b><a href="qbytearrayview.html#cbegin" translate="no">cbegin</a>(), <a href="qbytearrayview.html#end" translate="no">end</a>(), and <a href="qbytearrayview.html#crend" translate="no">crend</a>().</p>
<!-- @@@cend -->
<!-- $$$chop[overload1]$$$chopqsizetype -->
<h3 class="fn" translate="no" id="chop"><code class="details extra" translate="no">[constexpr]</code> <span class="type">void</span> QByteArrayView::<span class="name">chop</span>(<span class="type">qsizetype</span> <i>length</i>)</h3>
<p>Truncates this byte array view by <i translate="no">length</i> characters.</p>
<p>Same as <code translate="no">*this = first(size() - length)</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">length</i> &lt; 0 or <i translate="no">length</i> &gt; <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#sliced" translate="no">sliced</a>(), <a href="qbytearrayview.html#first" translate="no">first</a>(), <a href="qbytearrayview.html#last" translate="no">last</a>(), <a href="qbytearrayview.html#chopped" translate="no">chopped</a>(), and <a href="qbytearrayview.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@chop -->
<!-- $$$chopped[overload1]$$$choppedqsizetype -->
<h3 class="fn" translate="no" id="chopped"><code class="details extra" translate="no">[constexpr]</code> <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> QByteArrayView::<span class="name">chopped</span>(<span class="type">qsizetype</span> <i>length</i>) const</h3>
<p>Returns a copy of this byte array view that omits its last <i translate="no">length</i> bytes. In other words, returns a byte array view of length <a href="qbytearrayview.html#size" translate="no">size</a>() - <i translate="no">length</i> starting at the beginning of this object.</p>
<p>Same as <code translate="no">first(size() - length)</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">length</i> &lt; 0 or <i translate="no">length</i> &gt; <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#first" translate="no">first</a>(), <a href="qbytearrayview.html#last" translate="no">last</a>(), <a href="qbytearrayview.html#sliced" translate="no">sliced</a>(), <a href="qbytearrayview.html#chop" translate="no">chop</a>(), and <a href="qbytearrayview.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@chopped -->
<!-- $$$compare[overload1]$$$compareQByteArrayViewQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="compare"><code class="details extra" translate="no">[noexcept, since 6.2]</code> <span class="type">int</span> QByteArrayView::<span class="name">compare</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>bv</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns an integer less than, equal to, or greater than zero depending on whether this <a href="qbytearrayview.html" translate="no">QByteArrayView</a> sorts before, at the same position as, or after the <a href="qbytearrayview.html" translate="no">QByteArrayView</a> <i translate="no">bv</i>. The comparison is performed according to case sensitivity <i translate="no">cs</i>.</p>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qbytearrayview.html#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@compare -->
<!-- $$$constData[overload1]$$$constData -->
<h3 class="fn" translate="no" id="constData"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_pointer-typedef" translate="no">QByteArrayView::const_pointer</a></span> QByteArrayView::<span class="name">constData</span>() const</h3>
<p>Returns a const <code translate="no">char</code> pointer to the first byte in the byte array view.</p>
<div class="admonition note">
<p><b>Note: </b>The character array represented by the return value is <i>not</i> guaranteed to be null-terminated. The returned pointer is only safe to use for accessing bytes at indices that are less than this byte array view's <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#data" translate="no">data</a>(), <a href="qbytearrayview.html#begin" translate="no">begin</a>(), and <a href="qbytearrayview.html#end" translate="no">end</a>().</p>
<!-- @@@constData -->
<!-- $$$count[overload1]$$$countQByteArrayView -->
<h3 class="fn" translate="no" id="count"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QByteArrayView::<span class="name">count</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>bv</i>) const</h3>
<p>Returns the number of (potentially overlapping) occurrences of the sequence of bytes viewed by <i translate="no">bv</i> in this byte array view.</p>
<p><b>See also </b><a href="qbytearrayview.html#contains" translate="no">contains</a>() and <a href="qbytearrayview.html#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countchar -->
<h3 class="fn" translate="no" id="count-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QByteArrayView::<span class="name">count</span>(<span class="type">char</span> <i>ch</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the number of occurrences of byte <i translate="no">ch</i> in this byte array view.</p>
<p><b>See also </b><a href="qbytearrayview.html#contains" translate="no">contains</a>() and <a href="qbytearrayview.html#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" translate="no" id="crbegin"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_reverse_iterator-typedef" translate="no">QByteArrayView::const_reverse_iterator</a></span> QByteArrayView::<span class="name">crbegin</span>() const</h3>
<p>Same as <a href="qbytearrayview.html#rbegin" translate="no">rbegin</a>().</p>
<p>This function is provided for STL compatibility.</p>
<p><b>See also </b><a href="qbytearrayview.html#crend" translate="no">crend</a>(), <a href="qbytearrayview.html#rbegin" translate="no">rbegin</a>(), and <a href="qbytearrayview.html#cbegin" translate="no">cbegin</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" translate="no" id="crend"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_reverse_iterator-typedef" translate="no">QByteArrayView::const_reverse_iterator</a></span> QByteArrayView::<span class="name">crend</span>() const</h3>
<p>Same as <a href="qbytearrayview.html#rend" translate="no">rend</a>().</p>
<p>This function is provided for STL compatibility.</p>
<p><b>See also </b><a href="qbytearrayview.html#crbegin" translate="no">crbegin</a>(), <a href="qbytearrayview.html#rend" translate="no">rend</a>(), and <a href="qbytearrayview.html#cend" translate="no">cend</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" translate="no" id="data"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_pointer-typedef" translate="no">QByteArrayView::const_pointer</a></span> QByteArrayView::<span class="name">data</span>() const</h3>
<p>Returns a const <code translate="no">char</code> pointer to the first byte in the byte array view.</p>
<div class="admonition note">
<p><b>Note: </b>The character array represented by the return value is <i>not</i> guaranteed to be null-terminated. The returned pointer is only safe to use for accessing bytes at indices that are less than this byte array view's <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#begin" translate="no">begin</a>() and <a href="qbytearrayview.html#end" translate="no">end</a>().</p>
<!-- @@@data -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" translate="no" id="empty"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">bool</span> QByteArrayView::<span class="name">empty</span>() const</h3>
<p>Returns <code translate="no">true</code> if this byte array view is empty - that is, <code translate="no">size() == 0</code>.</p>
<p>This function is provided for STL compatibility.</p>
<p><b>See also </b><a href="qbytearrayview.html#isEmpty" translate="no">isEmpty</a>(), <a href="qbytearrayview.html#isNull" translate="no">isNull</a>(), and <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_iterator-typedef" translate="no">QByteArrayView::const_iterator</a></span> QByteArrayView::<span class="name">end</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing just after the last byte in the byte array view.</p>
<p>This function is provided for STL compatibility.</p>
<p><b>See also </b><a href="qbytearrayview.html#begin" translate="no">begin</a>(), <a href="qbytearrayview.html#cend" translate="no">cend</a>(), and <a href="qbytearrayview.html#rend" translate="no">rend</a>().</p>
<!-- @@@end -->
<!-- $$$first[overload1]$$$firstqsizetype -->
<h3 class="fn" translate="no" id="first"><code class="details extra" translate="no">[constexpr]</code> <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> QByteArrayView::<span class="name">first</span>(<span class="type">qsizetype</span> <i>n</i>) const</h3>
<p>Returns a byte array view that points to the first <i translate="no">n</i> bytes of this byte array view. Equivalent to <code translate="no">sliced(0, n)</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">n</i> &lt; 0 or <i translate="no">n</i> &gt; <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#last" translate="no">last</a>(), <a href="qbytearrayview.html#startsWith" translate="no">startsWith</a>(), <a href="qbytearrayview.html#chopped" translate="no">chopped</a>(), <a href="qbytearrayview.html#chop" translate="no">chop</a>(), and <a href="qbytearrayview.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@first -->
<!-- $$$fromArray[overload1]$$$fromArrayconstByte(&)[Size] -->
<h3 class="fn" translate="no" id="fromArray"><code class="details extra" translate="no">[static constexpr noexcept]</code> template &lt;typename Byte, size_t Size&gt; <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> QByteArrayView::<span class="name">fromArray</span>(const <span class="type">Byte</span> (&amp;)[<span class="type">Size</span>] <i>data</i>)</h3>
<p>Constructs a byte array view on the array literal <i translate="no">data</i>. The view covers the full array. That includes the trailing null-terminator of <code translate="no">char</code> array literals. If you don't want the null-terminator included in the view, you can <a href="qbytearrayview.html#chop" translate="no">chop</a>() it off when you are certain it is at the end. Alternatively you can use the constructor overload taking a char array literal which will create a view up to, but not including, the first null-terminator in the data.</p>
<p>This function will work with any array literal of a compatible byte type.</p>
<p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types" translate="no">Compatible Byte Types</a> and <a href="qbytearrayview.html" translate="no">QByteArrayView</a>.</p>
<!-- @@@fromArray -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" translate="no" id="front"><code class="details extra" translate="no">[constexpr]</code> <span class="type">char</span> QByteArrayView::<span class="name">front</span>() const</h3>
<p>Returns the first byte in the byte array view.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array view constitutes undefined behavior.</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#back" translate="no">back</a>().</p>
<!-- @@@front -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" translate="no" id="isEmpty"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">bool</span> QByteArrayView::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code translate="no">true</code> if this byte array view is empty - that is, <code translate="no">size() == 0</code>.</p>
<p><b>See also </b><a href="qbytearrayview.html#empty" translate="no">empty</a>(), <a href="qbytearrayview.html#isNull" translate="no">isNull</a>(), and <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" translate="no" id="isNull"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">bool</span> QByteArrayView::<span class="name">isNull</span>() const</h3>
<p>Returns <code translate="no">true</code> if this byte array view is null - that is, <code translate="no">data() == nullptr</code>.</p>
<p><b>See also </b><a href="qbytearrayview.html#empty" translate="no">empty</a>(), <a href="qbytearrayview.html#isEmpty" translate="no">isEmpty</a>(), and <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
<!-- @@@isNull -->
<!-- $$$isValidUtf8[overload1]$$$isValidUtf8 -->
<h3 class="fn" translate="no" id="isValidUtf8"><code class="details extra" translate="no">[noexcept, since 6.3]</code> <span class="type">bool</span> QByteArrayView::<span class="name">isValidUtf8</span>() const</h3>
<p>Returns <code translate="no">true</code> if this byte array view contains valid UTF-8 encoded data, or <code translate="no">false</code> otherwise.</p>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@isValidUtf8 -->
<!-- $$$last[overload1]$$$lastqsizetype -->
<h3 class="fn" translate="no" id="last"><code class="details extra" translate="no">[constexpr]</code> <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> QByteArrayView::<span class="name">last</span>(<span class="type">qsizetype</span> <i>n</i>) const</h3>
<p>Returns a byte array view that points to the last <i translate="no">n</i> bytes of this byte array view.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">n</i> &lt; 0 or <i translate="no">n</i> &gt; <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#first" translate="no">first</a>(), <a href="qbytearrayview.html#endsWith" translate="no">endsWith</a>(), <a href="qbytearrayview.html#chopped" translate="no">chopped</a>(), <a href="qbytearrayview.html#chop" translate="no">chop</a>(), and <a href="qbytearrayview.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@last -->
<!-- $$$lastIndexOf$$$lastIndexOfQByteArrayView -->
<h3 class="fn" translate="no" id="lastIndexOf-1"><code class="details extra" translate="no">[noexcept, since 6.2]</code> <span class="type">qsizetype</span> QByteArrayView::<span class="name">lastIndexOf</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>bv</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the start of the last occurrence of the sequence of bytes viewed by <i translate="no">bv</i> in this byte array view, searching backward from the end of this byte array view. Returns -1 if no match is found.</p>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qbytearrayview.html#indexOf" translate="no">indexOf</a>() and <a href="qbytearrayview.html#contains" translate="no">contains</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" translate="no" id="length"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">qsizetype</span> QByteArrayView::<span class="name">length</span>() const</h3>
<p>Same as <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="qbytearrayview.html#empty" translate="no">empty</a>(), <a href="qbytearrayview.html#isEmpty" translate="no">isEmpty</a>(), <a href="qbytearrayview.html#isNull" translate="no">isNull</a>(), and <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
<!-- @@@length -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" translate="no" id="rbegin"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_reverse_iterator-typedef" translate="no">QByteArrayView::const_reverse_iterator</a></span> QByteArrayView::<span class="name">rbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first byte in the byte array view, in reverse order.</p>
<p>This function is provided for STL compatibility.</p>
<p><b>See also </b><a href="qbytearrayview.html#rend" translate="no">rend</a>(), <a href="qbytearrayview.html#crbegin" translate="no">crbegin</a>(), and <a href="qbytearrayview.html#begin" translate="no">begin</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" translate="no" id="rend"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type"><a href="qbytearrayview.html#const_reverse_iterator-typedef" translate="no">QByteArrayView::const_reverse_iterator</a></span> QByteArrayView::<span class="name">rend</span>() const</h3>
<p>Returns a <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to one past the last byte in the byte array view, in reverse order.</p>
<p>This function is provided for STL compatibility.</p>
<p><b>See also </b><a href="qbytearrayview.html#rbegin" translate="no">rbegin</a>(), <a href="qbytearrayview.html#crend" translate="no">crend</a>(), and <a href="qbytearrayview.html#end" translate="no">end</a>().</p>
<!-- @@@rend -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">qsizetype</span> QByteArrayView::<span class="name">size</span>() const</h3>
<p>Returns the number of bytes in this byte array view.</p>
<p><b>See also </b><a href="qbytearrayview.html#empty" translate="no">empty</a>(), <a href="qbytearrayview.html#isEmpty" translate="no">isEmpty</a>(), and <a href="qbytearrayview.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@size -->
<!-- $$$sliced[overload1]$$$slicedqsizetype -->
<h3 class="fn" translate="no" id="sliced"><code class="details extra" translate="no">[constexpr]</code> <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> QByteArrayView::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>) const</h3>
<p>Returns a byte array view starting at position <i translate="no">pos</i> in this object, and extending to its end.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">pos</i> &lt; 0 or <i translate="no">pos</i> &gt; <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#first" translate="no">first</a>(), <a href="qbytearrayview.html#last" translate="no">last</a>(), <a href="qbytearrayview.html#chopped" translate="no">chopped</a>(), <a href="qbytearrayview.html#chop" translate="no">chop</a>(), and <a href="qbytearrayview.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@sliced -->
<!-- $$$sliced$$$slicedqsizetypeqsizetype -->
<h3 class="fn" translate="no" id="sliced-1"><code class="details extra" translate="no">[constexpr]</code> <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> QByteArrayView::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>n</i>) const</h3>
<p>Returns a byte array view that points to <i translate="no">n</i> bytes of this byte array view, starting at position <i translate="no">pos</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">pos</i> &lt; 0, <i translate="no">n</i> &lt; 0, or <i translate="no">pos</i> + <i translate="no">n</i> &gt; <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#first" translate="no">first</a>(), <a href="qbytearrayview.html#last" translate="no">last</a>(), <a href="qbytearrayview.html#chopped" translate="no">chopped</a>(), <a href="qbytearrayview.html#chop" translate="no">chop</a>(), and <a href="qbytearrayview.html#truncate" translate="no">truncate</a>().</p>
<!-- @@@sliced -->
<!-- $$$toByteArray[overload1]$$$toByteArray -->
<h3 class="fn" translate="no" id="toByteArray"><span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> QByteArrayView::<span class="name">toByteArray</span>() const</h3>
<p>Returns a deep copy of this byte array view's data as a <a href="qbytearray.html" translate="no">QByteArray</a>.</p>
<p>The return value will be a null <a href="qbytearray.html" translate="no">QByteArray</a> if and only if this byte array view is null.</p>
<!-- @@@toByteArray -->
<!-- $$$toDouble[overload1]$$$toDoublebool* -->
<h3 class="fn" translate="no" id="toDouble"><code class="details extra" translate="no">[since 6.3]</code> <span class="type">double</span> QByteArrayView::<span class="name">toDouble</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns this byte array view converted to a <code translate="no">double</code> value.</p>
<p>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition warning">
<p><b>Warning: </b>The <a href="qbytearrayview.html" translate="no">QByteArrayView</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function ignores leading and trailing spacing characters.</p>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toDouble -->
<!-- $$$toFloat[overload1]$$$toFloatbool* -->
<h3 class="fn" translate="no" id="toFloat"><code class="details extra" translate="no">[since 6.3]</code> <span class="type">float</span> QByteArrayView::<span class="name">toFloat</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns this byte array view converted to a <code translate="no">float</code> value.</p>
<p>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> string(<span class="string">&quot;1234.56 Volt&quot;</span>);
 <span class="type">bool</span> ok;
 <span class="type">float</span> a <span class="operator">=</span> str<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);       <span class="comment">// a == 0, ok == false</span>
 a <span class="operator">=</span> string<span class="operator">.</span>first(<span class="number">7</span>)<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok); <span class="comment">// a == 1234.56, ok == true</span>
</pre>
<div class="admonition warning">
<p><b>Warning: </b>The <a href="qbytearrayview.html" translate="no">QByteArrayView</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function ignores leading and trailing whitespace.</p>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toFloat -->
<!-- $$$toInt[overload1]$$$toIntbool*int -->
<h3 class="fn" translate="no" id="toInt"><code class="details extra" translate="no">[since 6.3]</code> <span class="type">int</span> QByteArrayView::<span class="name">toInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns this byte array view converted to an <code translate="no">int</code> using base <i translate="no">base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: if the byte array view begins with &quot;0x&quot;, the rest of it is read as hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, the rest of it is read as octal (base 8); otherwise it is read as decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> str(<span class="string">&quot;FF&quot;</span>);
 <span class="type">bool</span> ok;
 <span class="type">int</span> hex <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
 <span class="type">int</span> dec <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toInt -->
<!-- $$$toLong[overload1]$$$toLongbool*int -->
<h3 class="fn" translate="no" id="toLong"><code class="details extra" translate="no">[since 6.3]</code> <span class="type">long</span> QByteArrayView::<span class="name">toLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns this byte array view converted to a <code translate="no">long</code> int using base <i translate="no">base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: if the byte array view begins with &quot;0x&quot;, the rest of it is read as hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, the rest of it is read as octal (base 8); otherwise it is read as decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> str(<span class="string">&quot;FF&quot;</span>);
 <span class="type">bool</span> ok;
 <span class="type">long</span> hex <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);   <span class="comment">// hex == 255, ok == true</span>
 <span class="type">long</span> dec <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);   <span class="comment">// dec == 0, ok == false</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toLong -->
<!-- $$$toLongLong[overload1]$$$toLongLongbool*int -->
<h3 class="fn" translate="no" id="toLongLong"><code class="details extra" translate="no">[since 6.3]</code> <span class="type"><a href="qttypes.html#qlonglong-typedef" translate="no">qlonglong</a></span> QByteArrayView::<span class="name">toLongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns this byte array view converted to a <code translate="no">long long</code> using base <i translate="no">base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: if the byte array view begins with &quot;0x&quot;, the rest of it is read as hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, the rest of it is read as octal (base 8); otherwise it is read as decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toLongLong -->
<!-- $$$toShort[overload1]$$$toShortbool*int -->
<h3 class="fn" translate="no" id="toShort"><code class="details extra" translate="no">[since 6.3]</code> <span class="type">short</span> QByteArrayView::<span class="name">toShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns this byte array view converted to a <code translate="no">short</code> using base <i translate="no">base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: if the byte array view begins with &quot;0x&quot;, the rest of it is read as hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, the rest of it is read as octal (base 8); otherwise it is read as decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toShort -->
<!-- $$$toUInt[overload1]$$$toUIntbool*int -->
<h3 class="fn" translate="no" id="toUInt"><code class="details extra" translate="no">[since 6.3]</code> <span class="type"><a href="qttypes.html#uint-typedef" translate="no">uint</a></span> QByteArrayView::<span class="name">toUInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns this byte array view converted to an <code translate="no">unsigned int</code> using base <i translate="no">base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: if the byte array view begins with &quot;0x&quot;, the rest of it is read as hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, the rest of it is read as octal (base 8); otherwise it is read as decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toUInt -->
<!-- $$$toULong[overload1]$$$toULongbool*int -->
<h3 class="fn" translate="no" id="toULong"><code class="details extra" translate="no">[since 6.3]</code> <span class="type"><a href="qttypes.html#ulong-typedef" translate="no">ulong</a></span> QByteArrayView::<span class="name">toULong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns this byte array view converted to an <code translate="no">unsigned long int</code> using base <i translate="no">base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: if the byte array view begins with &quot;0x&quot;, the rest of it is read as hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, the rest of it is read as octal (base 8); otherwise it is read as decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toULong -->
<!-- $$$toULongLong[overload1]$$$toULongLongbool*int -->
<h3 class="fn" translate="no" id="toULongLong"><code class="details extra" translate="no">[since 6.3]</code> <span class="type"><a href="qttypes.html#qulonglong-typedef" translate="no">qulonglong</a></span> QByteArrayView::<span class="name">toULongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns this byte array view converted to an <code translate="no">unsigned long long</code> using base <i translate="no">base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: if the byte array view begins with &quot;0x&quot;, the rest of it is read as hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, the rest of it is read as octal (base 8); otherwise it is read as decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toULongLong -->
<!-- $$$toUShort[overload1]$$$toUShortbool*int -->
<h3 class="fn" translate="no" id="toUShort"><code class="details extra" translate="no">[since 6.3]</code> <span class="type"><a href="qttypes.html#ushort-typedef" translate="no">ushort</a></span> QByteArrayView::<span class="name">toUShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns this byte array view converted to an <code translate="no">unsigned short</code> using base <i translate="no">base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: if the byte array view begins with &quot;0x&quot;, the rest of it is read as hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, the rest of it is read as octal (base 8); otherwise it is read as decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html" translate="no">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@toUShort -->
<!-- $$$trimmed[overload1]$$$trimmed -->
<h3 class="fn" translate="no" id="trimmed"><code class="details extra" translate="no">[noexcept, since 6.3]</code> <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> QByteArrayView::<span class="name">trimmed</span>() const</h3>
<p>Returns a copy of this byte array view with spacing characters removed from the start and end.</p>
<p>The spacing characters are those for which the standard C++ <code translate="no">isspace()</code> function returns <code translate="no">true</code> in the C locale; these are the ASCII characters tabulation '\t', line feed '\n', carriage return '\r', vertical tabulation '\v', form feed '\f', and space ' '.</p>
<p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qchar.html#SpecialCharacter-enum" translate="no">QChar::SpecialCharacter</a> and <a href="qbytearray.html#spacing-characters" translate="no">Spacing Characters</a>.</p>
<!-- @@@trimmed -->
<!-- $$$truncate[overload1]$$$truncateqsizetype -->
<h3 class="fn" translate="no" id="truncate"><code class="details extra" translate="no">[constexpr]</code> <span class="type">void</span> QByteArrayView::<span class="name">truncate</span>(<span class="type">qsizetype</span> <i>length</i>)</h3>
<p>Truncates this byte array view to length <i translate="no">length</i>.</p>
<p>Same as <code translate="no">*this = first(length)</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i translate="no">length</i> &lt; 0 or <i translate="no">length</i> &gt; <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html#first" translate="no">first</a>(), <a href="qbytearrayview.html#last" translate="no">last</a>(), <a href="qbytearrayview.html#sliced" translate="no">sliced</a>(), <a href="qbytearrayview.html#chopped" translate="no">chopped</a>(), and <a href="qbytearrayview.html#chop" translate="no">chop</a>().</p>
<!-- @@@truncate -->
<!-- $$$operator std::string_view[overload1]$$$operator std::string_view -->
<h3 class="fn" translate="no" id="operator-std-3a-3astring_view"><code class="details extra" translate="no">[constexpr noexcept, since 6.7]</code> <span class="type">std::string_view</span> QByteArrayView::<span class="name">operator std::string_view</span>() const</h3>
<p>Converts this <a href="qbytearrayview.html" translate="no">QByteArrayView</a> object to a <code translate="no">std::string_view</code> object. The returned view will have the same data pointer and length of this view.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@operator std::string_view -->
<!-- $$$operator[][overload1]$$$operator[]qsizetype -->
<h3 class="fn" translate="no" id="operator-5b-5d"><code class="details extra" translate="no">[constexpr]</code> <span class="type">char</span> QByteArrayView::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>n</i>) const</h3>
<p>Returns the character at position <i translate="no">n</i> in this byte array view.</p>
<p>The behavior is undefined if <i translate="no">n</i> is negative or not less than <a href="qbytearrayview.html#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="qbytearrayview.html#at" translate="no">at</a>(), <a href="qbytearrayview.html#front" translate="no">front</a>(), and <a href="qbytearrayview.html#back" translate="no">back</a>().</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="operator-not-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator!=</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-lt"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&lt;</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-lt-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&lt;=</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-eq-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator==</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-gt"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&gt;</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-gt-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator&gt;=</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView" translate="no">QByteArrayView</a></span> <i>rhs</i>)</h3></div>
<p>Comparison operators for <a href="qbytearrayview.html" translate="no">QByteArrayView</a>.</p>
<!-- @@@ -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
