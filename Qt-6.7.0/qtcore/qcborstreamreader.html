<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qcborstreamreader.cpp -->
  <meta name="description" content="The QCborStreamReader class is a simple CBOR stream decoder, operating on either a QByteArray or QIODevice.">
  <title>QCborStreamReader Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QCborStreamReader</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#cbor-support">CBOR support</a></li>
<li class="level2"><a href="#dealing-with-invalid-or-incomplete-cbor-streams">Dealing with invalid or incomplete CBOR streams</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QCborStreamReader Class</h1>
<!-- $$$QCborStreamReader-brief -->
<p>The QCborStreamReader class is a simple CBOR stream decoder, operating on either a <a href="qbytearray.html" translate="no">QByteArray</a> or <a href="qiodevice.html" translate="no">QIODevice</a>. <a href="#details">More...</a></p>
<!-- @@@QCborStreamReader -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QCborStreamReader&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qcborstreamreader-members.html">List of all members, including inherited members</a></li>
<li>QCborStreamReader is part of <a href="cbor.html">CBOR Support in Qt</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader-stringresult.html" translate="no">StringResult</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#StringResultCode-enum" translate="no">StringResultCode</a></b> { EndOfString, Ok, Error }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#Type-enum" translate="no">Type</a></b> { UnsignedInteger, NegativeInteger, ByteArray, ByteString, String, &hellip;, Invalid }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#QCborStreamReader-1" translate="no">QCborStreamReader</a></b>(const char *<i>data</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#QCborStreamReader-2" translate="no">QCborStreamReader</a></b>(const quint8 *<i>data</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#QCborStreamReader-3" translate="no">QCborStreamReader</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#QCborStreamReader-4" translate="no">QCborStreamReader</a></b>(QIODevice *<i>device</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#dtor.QCborStreamReader" translate="no">~QCborStreamReader</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#addData" translate="no">addData</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#addData-1" translate="no">addData</a></b>(const char *<i>data</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#addData-2" translate="no">addData</a></b>(const quint8 *<i>data</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#containerDepth" translate="no">containerDepth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#currentOffset" translate="no">currentOffset</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#currentStringChunkSize" translate="no">currentStringChunkSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QIODevice *</td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#device" translate="no">device</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#hasNext" translate="no">hasNext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isArray" translate="no">isArray</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isBool" translate="no">isBool</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isContainer" translate="no">isContainer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isDouble" translate="no">isDouble</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isFalse" translate="no">isFalse</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isFloat16" translate="no">isFloat16</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isFloat" translate="no">isFloat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isInteger" translate="no">isInteger</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isInvalid" translate="no">isInvalid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isMap" translate="no">isMap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isNegativeInteger" translate="no">isNegativeInteger</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isNull" translate="no">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isSimpleType-1" translate="no">isSimpleType</a></b>(QCborSimpleType <i>st</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isString" translate="no">isString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isTag" translate="no">isTag</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isTrue" translate="no">isTrue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isUndefined" translate="no">isUndefined</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isUnsignedInteger" translate="no">isUnsignedInteger</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborError </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#lastError" translate="no">lastError</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#length" translate="no">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#next" translate="no">next</a></b>(int <i>maxRecursion</i> = 10000)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborStreamReader::Type </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#parentContainerType" translate="no">parentContainerType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readAllByteArray" translate="no">readAllByteArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> QString </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readAllString" translate="no">readAllString</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readAllUtf8String" translate="no">readAllUtf8String</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readAndAppendToByteArray" translate="no">readAndAppendToByteArray</a></b>(QByteArray &amp;<i>dst</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readAndAppendToString" translate="no">readAndAppendToString</a></b>(QString &amp;<i>dst</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readAndAppendToUtf8String" translate="no">readAndAppendToUtf8String</a></b>(QByteArray &amp;<i>dst</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborStreamReader::StringResult&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborStreamReader::StringResult&lt;QString&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readString" translate="no">readString</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborStreamReader::StringResult&lt;qsizetype&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a></b>(char *<i>ptr</i>, qsizetype <i>maxlen</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> QCborStreamReader::StringResult&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#readUtf8String" translate="no">readUtf8String</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#reparse" translate="no">reparse</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#reset" translate="no">reset</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#setDevice" translate="no">setDevice</a></b>(QIODevice *<i>device</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#toBool" translate="no">toBool</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#toDouble" translate="no">toDouble</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qfloat16 </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#toFloat16" translate="no">toFloat16</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#toFloat" translate="no">toFloat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborNegativeInteger </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#toNegativeInteger" translate="no">toNegativeInteger</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborSimpleType </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborTag </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#toTag" translate="no">toTag</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#toUnsignedInteger" translate="no">toUnsignedInteger</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborStreamReader::Type </td><td class="memItemRight bottomAlign"><b><a href="qcborstreamreader.html#type" translate="no">type</a></b>() const</td></tr>
</table></div>
<!-- $$$QCborStreamReader-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>This class can be used to decode a stream of CBOR content directly from either a <a href="qbytearray.html" translate="no">QByteArray</a> or a <a href="qiodevice.html" translate="no">QIODevice</a>. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is compatible with JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <a href="https://datatracker.ietf.org/doc/html/rfc7252" translate="no">CoAP protocol</a>.</p>
<p>QCborStreamReader provides a StAX-like API, similar to that of <a href="qxmlstreamreader.html" translate="no">QXmlStreamReader</a>. Using it requires a bit of knowledge of CBOR encoding. For a simpler API, see <a href="qcborvalue.html" translate="no">QCborValue</a> and especially the decoding function <a href="qcborvalue.html#fromCbor" translate="no">QCborValue::fromCbor</a>().</p>
<p>Typically, one creates a QCborStreamReader by passing the source <a href="qbytearray.html" translate="no">QByteArray</a> or <a href="qiodevice.html" translate="no">QIODevice</a> as a parameter to the constructor, then pop elements off the stream if there were no errors in decoding. There are three kinds of CBOR types:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Kind</th><th >Types</th><th >Behavior</th></tr></thead>
<tr valign="top" class="odd"><td >Fixed-width</td><td >Integers, Tags, Simple types, Floating point</td><td >Value is pre-parsed by QCborStreamReader, so accessor functions are <code translate="no">const</code>. Must call <a href="qcborstreamreader.html#next" translate="no">next</a>() to advance.</td></tr>
<tr valign="top" class="even"><td >Strings</td><td >Byte arrays, Text strings</td><td >Length (if known) is pre-parsed, but the string itself is not. The accessor functions are not const and may allocate memory. Once called, the accessor functions automatically advance to the next element.</td></tr>
<tr valign="top" class="odd"><td >Containers</td><td >Arrays, Maps</td><td >Length (if known) is pre-parsed. To access the elements, you must call <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>(), read all elements, then call <a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a>(). That function advances to the next element.</td></tr>
</table></div>
<p>So a processor function typically looks like this:</p>
<pre class="cpp" translate="no">
    <span class="type">void</span> handleStream(<span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span> <span class="operator">&amp;</span>reader)
    {
        <span class="keyword">switch</span> (reader<span class="operator">.</span>type())
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>UnsignedInteger:
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>NegativeInteger:
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>SimpleType:
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Float16:
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Float:
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Double:
            handleFixedWidth(reader);
            reader<span class="operator">.</span>next();
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>ByteArray:
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>String:
            handleString(reader);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Array:
        <span class="keyword">case</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Map:
            reader<span class="operator">.</span>enterContainer();
            <span class="keyword">while</span> (reader<span class="operator">.</span>lastError() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborerror.html" translate="no">QCborError</a></span><span class="operator">::</span>NoError)
                handleStream(reader);
            <span class="keyword">if</span> (reader<span class="operator">.</span>lastError() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborerror.html" translate="no">QCborError</a></span><span class="operator">::</span>NoError)
                reader<span class="operator">.</span>leaveContainer();
        }
    }
</pre>
<h3 id="cbor-support">CBOR support</h3>
<p>The following table lists the CBOR features that QCborStreamReader supports.</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Feature</th><th >Support</th></tr></thead>
<tr valign="top" class="odd"><td >Unsigned numbers</td><td >Yes (full range)</td></tr>
<tr valign="top" class="even"><td >Negative numbers</td><td >Yes (full range)</td></tr>
<tr valign="top" class="odd"><td >Byte strings</td><td >Yes</td></tr>
<tr valign="top" class="even"><td >Text strings</td><td >Yes</td></tr>
<tr valign="top" class="odd"><td >Chunked strings</td><td >Yes</td></tr>
<tr valign="top" class="even"><td >Tags</td><td >Yes (arbitrary)</td></tr>
<tr valign="top" class="odd"><td >Booleans</td><td >Yes</td></tr>
<tr valign="top" class="even"><td >Null</td><td >Yes</td></tr>
<tr valign="top" class="odd"><td >Undefined</td><td >Yes</td></tr>
<tr valign="top" class="even"><td >Arbitrary simple values</td><td >Yes</td></tr>
<tr valign="top" class="odd"><td >Half-precision float (16-bit)</td><td >Yes</td></tr>
<tr valign="top" class="even"><td >Single-precision float (32-bit)</td><td >Yes</td></tr>
<tr valign="top" class="odd"><td >Double-precision float (64-bit)</td><td >Yes</td></tr>
<tr valign="top" class="even"><td >Infinities and NaN floating point</td><td >Yes</td></tr>
<tr valign="top" class="odd"><td >Determinate-length arrays and maps</td><td >Yes</td></tr>
<tr valign="top" class="even"><td >Indeterminate-length arrays and maps</td><td >Yes</td></tr>
<tr valign="top" class="odd"><td >Map key types other than strings and integers</td><td >Yes (arbitrary)</td></tr>
</table></div>
<h3 id="dealing-with-invalid-or-incomplete-cbor-streams">Dealing with invalid or incomplete CBOR streams</h3>
<p>QCborStreamReader is capable of detecting corrupt input on its own. The library it uses has been extensively tested against invalid input of any kind and is quite able to report errors. If any is detected, QCborStreamReader will set <a href="qcborstreamreader.html#lastError" translate="no">lastError</a>() to a value besides <a href="qcborerror.html#Code-enum" translate="no">QCborError::NoError</a>, indicating which situation was detected.</p>
<p>Most errors detected by QCborStreamReader during normal item parsing are not recoverable. The code using QCborStreamReader may opt to handle the data that was properly decoded or it can opt to discard the entire data.</p>
<p>The only recoverable error is <a href="qcborerror.html#Code-enum" translate="no">QCborError::EndOfFile</a>, which indicates that more data is required in order to complete the parsing. This situation is useful when data is being read from an asynchronous source, such as a pipe (<a href="qprocess.html" translate="no">QProcess</a>) or a socket (<a href="../qtnetwork/qtcpsocket.html" translate="no">QTcpSocket</a>, <a href="../qtnetwork/qudpsocket.html" translate="no">QUdpSocket</a>, <a href="../qtnetwork/qnetworkreply.html" translate="no">QNetworkReply</a>, etc.). When more data arrives, the surrounding code needs to call either <a href="qcborstreamreader.html#addData" translate="no">addData</a>(), if parsing from a <a href="qbytearray.html" translate="no">QByteArray</a>, or <a href="qcborstreamreader.html#reparse" translate="no">reparse</a>(), if it is instead reading directly a the QIDOevice that now has more data available (see <a href="qcborstreamreader.html#setDevice" translate="no">setDevice</a>()).</p>
</div>
<p><b>See also </b><a href="qcborstreamwriter.html" translate="no">QCborStreamWriter</a>, <a href="qcborvalue.html" translate="no">QCborValue</a>, <a href="qxmlstreamreader.html" translate="no">QXmlStreamReader</a>, <a href="qtcore-serialization-cbordump-example.html" translate="no">Parsing and displaying CBOR data</a>, <a href="qtcore-serialization-convert-example.html" translate="no">Serialization Converter</a>, and <a href="qtcore-serialization-savegame-example.html" translate="no">Saving and Loading a Game</a>.</p>
<!-- @@@QCborStreamReader -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$StringResultCode$$$EndOfString$$$Ok$$$Error -->
<h3 class="fn" translate="no" id="StringResultCode-enum">enum QCborStreamReader::<span class="name">StringResultCode</span></h3>
<p>This enum is returned by <a href="qcborstreamreader.html#readString" translate="no">readString</a>() and <a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>() and is used to indicate what the status of the parsing is.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::EndOfString</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The parsing for the string is complete, with no error.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::Ok</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The function returned data; there was no error.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::Error</code></td><td class="topAlign tblval"><code translate="no">-1</code></td><td class="topAlign">Parsing failed with an error.</td></tr>
</table></div>
<!-- @@@StringResultCode -->
<!-- $$$Type$$$UnsignedInteger$$$NegativeInteger$$$ByteString$$$ByteArray$$$TextString$$$String$$$Array$$$Map$$$Tag$$$SimpleType$$$HalfFloat$$$Float16$$$Float$$$Double$$$Invalid -->
<h3 class="fn" translate="no" id="Type-enum">enum QCborStreamReader::<span class="name">Type</span></h3>
<p>This enumeration contains all possible CBOR types as decoded by <a href="qcborstreamreader.html" translate="no">QCborStreamReader</a>. CBOR has 7 major types, plus a number of simple types carrying no value, and floating point values.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::UnsignedInteger</code></td><td class="topAlign tblval"><code translate="no">0x00</code></td><td class="topAlign">(Major type 0) Ranges from 0 to 2<sup>64</sup> - 1 (18,446,744,073,709,551,616)</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::NegativeInteger</code></td><td class="topAlign tblval"><code translate="no">0x20</code></td><td class="topAlign">(Major type 1) Ranges from -1 to -2<sup>64</sup> (-18,446,744,073,709,551,616)</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::ByteArray</code></td><td class="topAlign tblval"><code translate="no">ByteString</code></td><td class="topAlign">(Major type 2) Arbitrary binary data.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::ByteString</code></td><td class="topAlign tblval"><code translate="no">0x40</code></td><td class="topAlign">An alias to ByteArray.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::String</code></td><td class="topAlign tblval"><code translate="no">TextString</code></td><td class="topAlign">(Major type 3) Unicode text, possibly containing NULs.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::TextString</code></td><td class="topAlign tblval"><code translate="no">0x60</code></td><td class="topAlign">An alias to String</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::Array</code></td><td class="topAlign tblval"><code translate="no">0x80</code></td><td class="topAlign">(Major type 4) Array of heterogeneous items.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::Map</code></td><td class="topAlign tblval"><code translate="no">0xa0</code></td><td class="topAlign">(Major type 5) Map/dictionary of heterogeneous items.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::Tag</code></td><td class="topAlign tblval"><code translate="no">0xc0</code></td><td class="topAlign">(Major type 6) Numbers giving further semantic value to generic CBOR items. See <a href="qtcborcommon.html#QCborTag-enum" translate="no">QCborTag</a> for more information.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::SimpleType</code></td><td class="topAlign tblval"><code translate="no">0xe0</code></td><td class="topAlign">(Major type 7) Types carrying no further value. Includes booleans (true and false), null, undefined.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::Float16</code></td><td class="topAlign tblval"><code translate="no">HalfFloat</code></td><td class="topAlign">IEEE 754 half-precision floating point (<code translate="no">qfloat16</code>).</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::HalfFloat</code></td><td class="topAlign tblval"><code translate="no">0xf9</code></td><td class="topAlign">An alias to Float16.</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::Float</code></td><td class="topAlign tblval"><code translate="no">0xfa</code></td><td class="topAlign">IEEE 754 single-precision floating point (<code translate="no">float</code>).</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::Double</code></td><td class="topAlign tblval"><code translate="no">0xfb</code></td><td class="topAlign">IEEE 754 double-precision floating point (<code translate="no">double</code>).</td></tr>
<tr><td class="topAlign"><code translate="no">QCborStreamReader::Invalid</code></td><td class="topAlign tblval"><code translate="no">0xff</code></td><td class="topAlign">Not a valid type, either due to parsing error or due to reaching the end of an array or map.</td></tr>
</table></div>
<!-- @@@Type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QCborStreamReader[overload1]$$$QCborStreamReader -->
<h3 class="fn" translate="no" id="QCborStreamReader">QCborStreamReader::<span class="name">QCborStreamReader</span>()</h3>
<p>Creates a QCborStreamReader object with no source data. After construction, QCborStreamReader will report an error parsing.</p>
<p>You can add more data by calling <a href="qcborstreamreader.html#addData" translate="no">addData</a>() or by setting a different source device using <a href="qcborstreamreader.html#setDevice" translate="no">setDevice</a>().</p>
<p><b>See also </b><a href="qcborstreamreader.html#addData" translate="no">addData</a>() and <a href="qcborstreamreader.html#isValid" translate="no">isValid</a>().</p>
<!-- @@@QCborStreamReader -->
<!-- $$$QCborStreamReader$$$QCborStreamReaderconstchar*qsizetype -->
<h3 class="fn" translate="no" id="QCborStreamReader-1">QCborStreamReader::<span class="name">QCborStreamReader</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>This is an overloaded function.</p>
<p>Creates a QCborStreamReader object with <i translate="no">len</i> bytes of data starting at <i translate="no">data</i>. The pointer must remain valid until QCborStreamReader is destroyed.</p>
<!-- @@@QCborStreamReader -->
<!-- $$$QCborStreamReader$$$QCborStreamReaderconstquint8*qsizetype -->
<h3 class="fn" translate="no" id="QCborStreamReader-2">QCborStreamReader::<span class="name">QCborStreamReader</span>(const <span class="type"><a href="qttypes.html#quint8-typedef" translate="no">quint8</a></span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>This is an overloaded function.</p>
<p>Creates a QCborStreamReader object with <i translate="no">len</i> bytes of data starting at <i translate="no">data</i>. The pointer must remain valid until QCborStreamReader is destroyed.</p>
<!-- @@@QCborStreamReader -->
<!-- $$$QCborStreamReader$$$QCborStreamReaderconstQByteArray& -->
<h3 class="fn" translate="no" id="QCborStreamReader-3"><code class="details extra" translate="no">[explicit]</code> QCborStreamReader::<span class="name">QCborStreamReader</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>This is an overloaded function.</p>
<p>Creates a QCborStreamReader object that will parse the CBOR stream found in <i translate="no">data</i>.</p>
<!-- @@@QCborStreamReader -->
<!-- $$$QCborStreamReader$$$QCborStreamReaderQIODevice* -->
<h3 class="fn" translate="no" id="QCborStreamReader-4"><code class="details extra" translate="no">[explicit]</code> QCborStreamReader::<span class="name">QCborStreamReader</span>(<span class="type"><a href="qiodevice.html" translate="no">QIODevice</a></span> *<i>device</i>)</h3>
<p>This is an overloaded function.</p>
<p>Creates a QCborStreamReader object that will parse the CBOR stream found by reading from <i translate="no">device</i>. QCborStreamReader does not take ownership of <i translate="no">device</i>, so it must remain valid until this object is destroyed.</p>
<!-- @@@QCborStreamReader -->
<!-- $$$~QCborStreamReader[overload1]$$$~QCborStreamReader -->
<h3 class="fn" translate="no" id="dtor.QCborStreamReader"><code class="details extra" translate="no">[noexcept]</code> QCborStreamReader::<span class="name">~QCborStreamReader</span>()</h3>
<p>Destroys this <a href="qcborstreamreader.html" translate="no">QCborStreamReader</a> object and frees any associated resources.</p>
<!-- @@@~QCborStreamReader -->
<!-- $$$addData[overload1]$$$addDataconstQByteArray& -->
<h3 class="fn" translate="no" id="addData"><span class="type">void</span> QCborStreamReader::<span class="name">addData</span>(const <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Adds <i translate="no">data</i> to the CBOR stream and reparses the current element. This function is useful if the end of the data was previously reached while processing the stream, but now more data is available.</p>
<!-- @@@addData -->
<!-- $$$addData$$$addDataconstchar*qsizetype -->
<h3 class="fn" translate="no" id="addData-1"><span class="type">void</span> QCborStreamReader::<span class="name">addData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>This is an overloaded function.</p>
<p>Adds <i translate="no">len</i> bytes of data starting at <i translate="no">data</i> to the CBOR stream and reparses the current element. This function is useful if the end of the data was previously reached while processing the stream, but now more data is available.</p>
<!-- @@@addData -->
<!-- $$$addData$$$addDataconstquint8*qsizetype -->
<h3 class="fn" translate="no" id="addData-2"><span class="type">void</span> QCborStreamReader::<span class="name">addData</span>(const <span class="type"><a href="qttypes.html#quint8-typedef" translate="no">quint8</a></span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>This is an overloaded function.</p>
<p>Adds <i translate="no">len</i> bytes of data starting at <i translate="no">data</i> to the CBOR stream and reparses the current element. This function is useful if the end of the data was previously reached while processing the stream, but now more data is available.</p>
<!-- @@@addData -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QCborStreamReader::<span class="name">clear</span>()</h3>
<p>Clears the decoder state and resets the input source data to an empty byte array. After this function is called, <a href="qcborstreamreader.html" translate="no">QCborStreamReader</a> will be indicating an error parsing.</p>
<p>Call <a href="qcborstreamreader.html#addData" translate="no">addData</a>() to add more data to be parsed.</p>
<p><b>See also </b><a href="qcborstreamreader.html#reset" translate="no">reset</a>() and <a href="qcborstreamreader.html#setDevice" translate="no">setDevice</a>().</p>
<!-- @@@clear -->
<!-- $$$containerDepth[overload1]$$$containerDepth -->
<h3 class="fn" translate="no" id="containerDepth"><span class="type">int</span> QCborStreamReader::<span class="name">containerDepth</span>() const</h3>
<p>Returns the number of containers that this stream has entered with <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>() but not yet left.</p>
<p><b>See also </b><a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>() and <a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a>().</p>
<!-- @@@containerDepth -->
<!-- $$$currentOffset[overload1]$$$currentOffset -->
<h3 class="fn" translate="no" id="currentOffset"><span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> QCborStreamReader::<span class="name">currentOffset</span>() const</h3>
<p>Returns the offset in the input stream of the item currently being decoded. The current offset is the number of decoded bytes so far only if the source data is a <a href="qbytearray.html" translate="no">QByteArray</a> or it is a <a href="qiodevice.html" translate="no">QIODevice</a> that was positioned at its beginning when decoding started.</p>
<p><b>See also </b><a href="qcborstreamreader.html#reset" translate="no">reset</a>(), <a href="qcborstreamreader.html#clear" translate="no">clear</a>(), and <a href="qcborstreamreader.html#device" translate="no">device</a>().</p>
<!-- @@@currentOffset -->
<!-- $$$currentStringChunkSize[overload1]$$$currentStringChunkSize -->
<h3 class="fn" translate="no" id="currentStringChunkSize"><span class="type">qsizetype</span> QCborStreamReader::<span class="name">currentStringChunkSize</span>() const</h3>
<p>Returns the size of the current text or byte string chunk. If the CBOR stream contains a non-chunked string (that is, if <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>() returns <code translate="no">true</code>), this function returns the size of the entire string, the same as <a href="qcborstreamreader.html#length" translate="no">length</a>().</p>
<p>This function is useful to pre-allocate the buffer whose pointer can be passed to <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>() later.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readString" translate="no">readString</a>(), <a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>(), and <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>().</p>
<!-- @@@currentStringChunkSize -->
<!-- $$$device[overload1]$$$device -->
<h3 class="fn" translate="no" id="device"><span class="type"><a href="qiodevice.html" translate="no">QIODevice</a></span> *QCborStreamReader::<span class="name">device</span>() const</h3>
<p>Returns the <a href="qiodevice.html" translate="no">QIODevice</a> that was set with either <a href="qcborstreamreader.html#setDevice" translate="no">setDevice</a>() or the <a href="qcborstreamreader.html" translate="no">QCborStreamReader</a> constructor. If this object was reading from a <a href="qbytearray.html" translate="no">QByteArray</a>, this function returns nullptr instead.</p>
<p><b>See also </b><a href="qcborstreamreader.html#setDevice" translate="no">setDevice</a>().</p>
<!-- @@@device -->
<!-- $$$enterContainer[overload1]$$$enterContainer -->
<h3 class="fn" translate="no" id="enterContainer"><span class="type">bool</span> QCborStreamReader::<span class="name">enterContainer</span>()</h3>
<p>Enters the array or map that is the current item and prepares for iterating the elements contained in the container. Returns true if entering the container succeeded, false otherwise (usually, a parsing error). Each call to enterContainer() must be paired with a call to <a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a>().</p>
<p>This function may only be called if the current item is an array or a map (that is, if <a href="qcborstreamreader.html#isArray" translate="no">isArray</a>(), <a href="qcborstreamreader.html#isMap" translate="no">isMap</a>() or <a href="qcborstreamreader.html#isContainer" translate="no">isContainer</a>() is true). Calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a>(), <a href="qcborstreamreader.html#isContainer" translate="no">isContainer</a>(), <a href="qcborstreamreader.html#isArray" translate="no">isArray</a>(), and <a href="qcborstreamreader.html#isMap" translate="no">isMap</a>().</p>
<!-- @@@enterContainer -->
<!-- $$$hasNext[overload1]$$$hasNext -->
<h3 class="fn" translate="no" id="hasNext"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QCborStreamReader::<span class="name">hasNext</span>() const</h3>
<p>Returns true if there are more items to be decoded in the current container or false of we've reached its end. If we're parsing the root element, hasNext() returning false indicates the parsing is complete; otherwise, if the container depth is non-zero, then the outer code needs to call <a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a>().</p>
<p><b>See also </b><a href="qcborstreamreader.html#parentContainerType" translate="no">parentContainerType</a>(), <a href="qcborstreamreader.html#containerDepth" translate="no">containerDepth</a>(), and <a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a>().</p>
<!-- @@@hasNext -->
<!-- $$$isArray[overload1]$$$isArray -->
<h3 class="fn" translate="no" id="isArray"><span class="type">bool</span> QCborStreamReader::<span class="name">isArray</span>() const</h3>
<p>Returns true if the type of the current element is an array (that is, if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Array</a>). If this function returns true, you may call <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>() to begin parsing that container.</p>
<p>When the current element is an array, you may also call <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>() to find out if the array's size is explicit in the CBOR stream. If it is, that size can be obtained by calling <a href="qcborstreamreader.html#length" translate="no">length</a>().</p>
<p>The following example pre-allocates a <a href="qvariant.html#QVariantList-typedef" translate="no">QVariantList</a> given the array's size for more efficient decoding:</p>
<pre class="cpp" translate="no">
    <span class="type">QVariantList</span> populateFromCbor(<span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span> <span class="operator">&amp;</span>reader)
    {
        <span class="type">QVariantList</span> list;
        <span class="keyword">if</span> (reader<span class="operator">.</span>isLengthKnown())
            list<span class="operator">.</span>reserve(reader<span class="operator">.</span>length());

        reader<span class="operator">.</span>enterContainer();
        <span class="keyword">while</span> (reader<span class="operator">.</span>lastError() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborerror.html" translate="no">QCborError</a></span><span class="operator">::</span>NoError <span class="operator">&amp;</span><span class="operator">&amp;</span> reader<span class="operator">.</span>hasNext())
            list<span class="operator">.</span>append(readOneElement(reader));
        <span class="keyword">if</span> (reader<span class="operator">.</span>lastError() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborerror.html" translate="no">QCborError</a></span><span class="operator">::</span>NoError)
            reader<span class="operator">.</span>leaveContainer();
    }
</pre>
<div class="admonition note">
<p><b>Note: </b>The code above does not validate that the length is a sensible value. If the input stream reports that the length is 1 billion elements, the above function will try to allocate some 16 GB or more of RAM, which can lead to a crash.</p>
</div>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isMap" translate="no">isMap</a>(), <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>(), <a href="qcborstreamreader.html#length" translate="no">length</a>(), <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>(), and <a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a>().</p>
<!-- @@@isArray -->
<!-- $$$isBool[overload1]$$$isBool -->
<h3 class="fn" translate="no" id="isBool"><span class="type">bool</span> QCborStreamReader::<span class="name">isBool</span>() const</h3>
<p>Returns true if the current element is a boolean value (<code translate="no">true</code> or <code translate="no">false</code>), false if it is anything else. If this function returns true, you may call <a href="qcborstreamreader.html#toBool" translate="no">toBool</a>() to retrieve the value of the boolean. You may also call <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>() and compare to either QCborSimpleValue::True or QCborSimpleValue::False.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isFalse" translate="no">isFalse</a>(), <a href="qcborstreamreader.html#isTrue" translate="no">isTrue</a>(), <a href="qcborstreamreader.html#toBool" translate="no">toBool</a>(), <a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a>(), and <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>().</p>
<!-- @@@isBool -->
<!-- $$$isByteArray[overload1]$$$isByteArray -->
<h3 class="fn" translate="no" id="isByteArray"><span class="type">bool</span> QCborStreamReader::<span class="name">isByteArray</span>() const</h3>
<p>Returns true if the type of the current element is a byte array (that is, if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::ByteArray</a>). If this function returns true, you may call <a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>() to read that data.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>(), and <a href="qcborstreamreader.html#isString" translate="no">isString</a>().</p>
<!-- @@@isByteArray -->
<!-- $$$isContainer[overload1]$$$isContainer -->
<h3 class="fn" translate="no" id="isContainer"><span class="type">bool</span> QCborStreamReader::<span class="name">isContainer</span>() const</h3>
<p>Returns true if the current element is a container (that is, an array or a map), false if it is anything else. If the current element is a container, the <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>() function may be used to find out if the container's size is explicit in the stream and, if so, <a href="qcborstreamreader.html#length" translate="no">length</a>() can be used to get that size.</p>
<p>More importantly, for a container, the <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>() function is available to begin iterating through the elements contained therein.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isArray" translate="no">isArray</a>(), <a href="qcborstreamreader.html#isMap" translate="no">isMap</a>(), <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>(), <a href="qcborstreamreader.html#length" translate="no">length</a>(), <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>(), <a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a>(), and <a href="qcborstreamreader.html#containerDepth" translate="no">containerDepth</a>().</p>
<!-- @@@isContainer -->
<!-- $$$isDouble[overload1]$$$isDouble -->
<h3 class="fn" translate="no" id="isDouble"><span class="type">bool</span> QCborStreamReader::<span class="name">isDouble</span>() const</h3>
<p>Returns true if the type of the current element is an IEEE 754 double-precision floating point (that is, if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Double</a>). If this function returns true, you may call <a href="qcborstreamreader.html#toDouble" translate="no">toDouble</a>() to read that data.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#toDouble" translate="no">toDouble</a>(), <a href="qcborstreamreader.html#isFloat16" translate="no">isFloat16</a>(), and <a href="qcborstreamreader.html#isFloat" translate="no">isFloat</a>().</p>
<!-- @@@isDouble -->
<!-- $$$isFalse[overload1]$$$isFalse -->
<h3 class="fn" translate="no" id="isFalse"><span class="type">bool</span> QCborStreamReader::<span class="name">isFalse</span>() const</h3>
<p>Returns true if the current element is the <code translate="no">false</code> value, false if it is anything else.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isTrue" translate="no">isTrue</a>(), <a href="qcborstreamreader.html#isBool" translate="no">isBool</a>(), <a href="qcborstreamreader.html#toBool" translate="no">toBool</a>(), <a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a>(), and <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>().</p>
<!-- @@@isFalse -->
<!-- $$$isFloat16[overload1]$$$isFloat16 -->
<h3 class="fn" translate="no" id="isFloat16"><span class="type">bool</span> QCborStreamReader::<span class="name">isFloat16</span>() const</h3>
<p>Returns true if the type of the current element is an IEEE 754 half-precision floating point (that is, if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Float16</a>). If this function returns true, you may call <a href="qcborstreamreader.html#toFloat16" translate="no">toFloat16</a>() to read that data.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#toFloat16" translate="no">toFloat16</a>(), <a href="qcborstreamreader.html#isFloat" translate="no">isFloat</a>(), and <a href="qcborstreamreader.html#isDouble" translate="no">isDouble</a>().</p>
<!-- @@@isFloat16 -->
<!-- $$$isFloat[overload1]$$$isFloat -->
<h3 class="fn" translate="no" id="isFloat"><span class="type">bool</span> QCborStreamReader::<span class="name">isFloat</span>() const</h3>
<p>Returns true if the type of the current element is an IEEE 754 single-precision floating point (that is, if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Float</a>). If this function returns true, you may call <a href="qcborstreamreader.html#toFloat" translate="no">toFloat</a>() to read that data.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#toFloat" translate="no">toFloat</a>(), <a href="qcborstreamreader.html#isFloat16" translate="no">isFloat16</a>(), and <a href="qcborstreamreader.html#isDouble" translate="no">isDouble</a>().</p>
<!-- @@@isFloat -->
<!-- $$$isInteger[overload1]$$$isInteger -->
<h3 class="fn" translate="no" id="isInteger"><span class="type">bool</span> QCborStreamReader::<span class="name">isInteger</span>() const</h3>
<p>Returns true if the type of the current element is either an unsigned integer or a negative one (that is, if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::UnsignedInteger</a> or <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::NegativeInteger</a>). If this function returns true, you may call <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>() to read that value.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>(), <a href="qcborstreamreader.html#toUnsignedInteger" translate="no">toUnsignedInteger</a>(), <a href="qcborstreamreader.html#toNegativeInteger" translate="no">toNegativeInteger</a>(), <a href="qcborstreamreader.html#isUnsignedInteger" translate="no">isUnsignedInteger</a>(), and <a href="qcborstreamreader.html#isNegativeInteger" translate="no">isNegativeInteger</a>().</p>
<!-- @@@isInteger -->
<!-- $$$isInvalid[overload1]$$$isInvalid -->
<h3 class="fn" translate="no" id="isInvalid"><span class="type">bool</span> QCborStreamReader::<span class="name">isInvalid</span>() const</h3>
<p>Returns true if the current element is invalid, false otherwise. The current element may be invalid if there was a decoding error or we've just parsed the last element in an array or map.</p>
<div class="admonition note">
<p><b>Note: </b>This function is not to be confused with <a href="qcborstreamreader.html#isNull" translate="no">isNull</a>(). Null is a normal CBOR type that must be handled by the application.</p>
</div>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>() and <a href="qcborstreamreader.html#isValid" translate="no">isValid</a>().</p>
<!-- @@@isInvalid -->
<!-- $$$isLengthKnown[overload1]$$$isLengthKnown -->
<h3 class="fn" translate="no" id="isLengthKnown"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QCborStreamReader::<span class="name">isLengthKnown</span>() const</h3>
<p>Returns true if the length of the current array, map, byte array or string is known (explicit in the CBOR stream), false otherwise. This function should only be called if the element is one of those.</p>
<p>If the length is known, it may be obtained by calling <a href="qcborstreamreader.html#length" translate="no">length</a>().</p>
<p>If the length of a map or an array is not known, it is implied by the number of elements present in the stream. <a href="qcborstreamreader.html" translate="no">QCborStreamReader</a> has no API to calculate the length in that condition.</p>
<p>Strings and byte arrays may also have indeterminate length (that is, they may be transmitted in multiple chunks). Those cannot currently be created with <a href="qcborstreamwriter.html" translate="no">QCborStreamWriter</a>, but they could be with other encoders, so <a href="qcborstreamreader.html" translate="no">QCborStreamReader</a> supports them.</p>
<p><b>See also </b><a href="qcborstreamreader.html#length" translate="no">length</a>(), <a href="qcborstreamwriter.html#startArray" translate="no">QCborStreamWriter::startArray</a>(), and <a href="qcborstreamwriter.html#startMap" translate="no">QCborStreamWriter::startMap</a>().</p>
<!-- @@@isLengthKnown -->
<!-- $$$isMap[overload1]$$$isMap -->
<h3 class="fn" translate="no" id="isMap"><span class="type">bool</span> QCborStreamReader::<span class="name">isMap</span>() const</h3>
<p>Returns true if the type of the current element is a map (that is, if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Map</a>). If this function returns true, you may call <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>() to begin parsing that container.</p>
<p>When the current element is a map, you may also call <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>() to find out if the map's size is explicit in the CBOR stream. If it is, that size can be obtained by calling <a href="qcborstreamreader.html#length" translate="no">length</a>().</p>
<p>The following example pre-allocates a <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> given the map's size for more efficient decoding:</p>
<pre class="cpp" translate="no">
    <span class="type">QVariantMap</span> populateFromCbor(<span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span> <span class="operator">&amp;</span>reader)
    {
        <span class="type">QVariantMap</span> map;
        <span class="keyword">if</span> (reader<span class="operator">.</span>isLengthKnown())
            map<span class="operator">.</span>reserve(reader<span class="operator">.</span>length());

        reader<span class="operator">.</span>enterContainer();
        <span class="keyword">while</span> (reader<span class="operator">.</span>lastError() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborerror.html" translate="no">QCborError</a></span><span class="operator">::</span>NoError <span class="operator">&amp;</span><span class="operator">&amp;</span> reader<span class="operator">.</span>hasNext()) {
            <span class="type"><a href="qstring.html" translate="no">QString</a></span> key <span class="operator">=</span> readElementAsString(reader);
            map<span class="operator">.</span>insert(key<span class="operator">,</span> readOneElement(reader));
        }
        <span class="keyword">if</span> (reader<span class="operator">.</span>lastError() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborerror.html" translate="no">QCborError</a></span><span class="operator">::</span>NoError)
            reader<span class="operator">.</span>leaveContainer();
    }
</pre>
<p>The example above uses a function called <code translate="no">readElementAsString</code> to read the map's keys and obtain a string. That is because CBOR maps may contain any type as keys, not just strings. User code needs to either perform this conversion, reject non-string keys, or instead use a different container besides <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> and <a href="qvariant.html#QVariantHash-typedef" translate="no">QVariantHash</a>. For example, if the map is expected to contain integer keys, which is recommended as it reduces stream size and parsing, the correct container would be <code translate="no">\l{QMap}&lt;int, QVariant&gt;</code> or <code translate="no">\l{QHash}&lt;int, QVariant&gt;</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The code above does not validate that the length is a sensible value. If the input stream reports that the length is 1 billion elements, the above function will try to allocate some 24 GB or more of RAM, which can lead to a crash.</p>
</div>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isArray" translate="no">isArray</a>(), <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>(), <a href="qcborstreamreader.html#length" translate="no">length</a>(), <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>(), and <a href="qcborstreamreader.html#leaveContainer" translate="no">leaveContainer</a>().</p>
<!-- @@@isMap -->
<!-- $$$isNegativeInteger[overload1]$$$isNegativeInteger -->
<h3 class="fn" translate="no" id="isNegativeInteger"><span class="type">bool</span> QCborStreamReader::<span class="name">isNegativeInteger</span>() const</h3>
<p>Returns true if the type of the current element is a negative integer (that is if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::NegativeInteger</a>). If this function returns true, you may call <a href="qcborstreamreader.html#toNegativeInteger" translate="no">toNegativeInteger</a>() or <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>() to read that value.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#toNegativeInteger" translate="no">toNegativeInteger</a>(), <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>(), <a href="qcborstreamreader.html#isInteger" translate="no">isInteger</a>(), and <a href="qcborstreamreader.html#isUnsignedInteger" translate="no">isUnsignedInteger</a>().</p>
<!-- @@@isNegativeInteger -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" translate="no" id="isNull"><span class="type">bool</span> QCborStreamReader::<span class="name">isNull</span>() const</h3>
<p>Returns true if the current element is the <code translate="no">null</code> value, false if it is anything else. Null values may be used to indicate the absence of some optional data.</p>
<div class="admonition note">
<p><b>Note: </b>This function is not the opposite of <a href="qcborstreamreader.html#isValid" translate="no">isValid</a>(). A Null value is a valid CBOR value.</p>
</div>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a>(), and <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>().</p>
<!-- @@@isNull -->
<!-- $$$isSimpleType[overload1]$$$isSimpleType -->
<h3 class="fn" translate="no" id="isSimpleType"><span class="type">bool</span> QCborStreamReader::<span class="name">isSimpleType</span>() const</h3>
<p>Returns true if the type of the current element is any CBOR simple type, including a boolean value (true and false) as well as null and undefined. To find out which simple type this is, call <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>(). Alternatively, to test for one specific simple type, call the overload that takes a <a href="qtcborcommon.html#QCborSimpleType-enum" translate="no">QCborSimpleType</a> parameter.</p>
<p>CBOR simple types are types that do not carry extra value. There are 255 possibilities, but there are currently only four values that have defined meaning. Code is not expected to cope with unknown simple types and may simply discard the stream as invalid if it finds an unknown one.</p>
<p><b>See also </b><a href="qtcborcommon.html#QCborSimpleType-enum" translate="no">QCborSimpleType</a>, <a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isSimpleType-1" translate="no">isSimpleType</a>(QCborSimpleType), and <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>().</p>
<!-- @@@isSimpleType -->
<!-- $$$isSimpleType$$$isSimpleTypeQCborSimpleType -->
<h3 class="fn" translate="no" id="isSimpleType-1"><span class="type">bool</span> QCborStreamReader::<span class="name">isSimpleType</span>(<span class="type"><a href="qtcborcommon.html#QCborSimpleType-enum" translate="no">QCborSimpleType</a></span> <i>st</i>) const</h3>
<p>Returns true if the type of the current element is the simple type <i translate="no">st</i>, false otherwise. If this function returns true, then <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>() will return <i translate="no">st</i>.</p>
<p>CBOR simple types are types that do not carry extra value. There are 255 possibilities, but there are currently only four values that have defined meaning. Code is not expected to cope with unknown simple types and may simply discard the stream as invalid if it finds an unknown one.</p>
<p><b>See also </b><a href="qtcborcommon.html#QCborSimpleType-enum" translate="no">QCborSimpleType</a>, <a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a>(), and <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>().</p>
<!-- @@@isSimpleType -->
<!-- $$$isString[overload1]$$$isString -->
<h3 class="fn" translate="no" id="isString"><span class="type">bool</span> QCborStreamReader::<span class="name">isString</span>() const</h3>
<p>Returns true if the type of the current element is a text string (that is, if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::String</a>). If this function returns true, you may call <a href="qcborstreamreader.html#readString" translate="no">readString</a>() to read that data.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#readString" translate="no">readString</a>(), and <a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a>().</p>
<!-- @@@isString -->
<!-- $$$isTag[overload1]$$$isTag -->
<h3 class="fn" translate="no" id="isTag"><span class="type">bool</span> QCborStreamReader::<span class="name">isTag</span>() const</h3>
<p>Returns true if the type of the current element is a CBOR tag (that is, if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Tag</a>). If this function returns true, you may call <a href="qcborstreamreader.html#toTag" translate="no">toTag</a>() to read that data.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>() and <a href="qcborstreamreader.html#toTag" translate="no">toTag</a>().</p>
<!-- @@@isTag -->
<!-- $$$isTrue[overload1]$$$isTrue -->
<h3 class="fn" translate="no" id="isTrue"><span class="type">bool</span> QCborStreamReader::<span class="name">isTrue</span>() const</h3>
<p>Returns true if the current element is the <code translate="no">true</code> value, false if it is anything else.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isFalse" translate="no">isFalse</a>(), <a href="qcborstreamreader.html#isBool" translate="no">isBool</a>(), <a href="qcborstreamreader.html#toBool" translate="no">toBool</a>(), <a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a>(), and <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>().</p>
<!-- @@@isTrue -->
<!-- $$$isUndefined[overload1]$$$isUndefined -->
<h3 class="fn" translate="no" id="isUndefined"><span class="type">bool</span> QCborStreamReader::<span class="name">isUndefined</span>() const</h3>
<p>Returns true if the current element is the <code translate="no">undefined</code> value, false if it is anything else. Undefined values may be encoded to indicate that some conversion failed or was not possible when creating the stream. <a href="qcborstreamreader.html" translate="no">QCborStreamReader</a> never performs any replacement and this function will only return true if the stream contains an explicit undefined value.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a>(), and <a href="qcborstreamreader.html#toSimpleType" translate="no">toSimpleType</a>().</p>
<!-- @@@isUndefined -->
<!-- $$$isUnsignedInteger[overload1]$$$isUnsignedInteger -->
<h3 class="fn" translate="no" id="isUnsignedInteger"><span class="type">bool</span> QCborStreamReader::<span class="name">isUnsignedInteger</span>() const</h3>
<p>Returns true if the type of the current element is an unsigned integer (that is if <a href="qcborstreamreader.html#type" translate="no">type</a>() returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::UnsignedInteger</a>). If this function returns true, you may call <a href="qcborstreamreader.html#toUnsignedInteger" translate="no">toUnsignedInteger</a>() or <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>() to read that value.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#toUnsignedInteger" translate="no">toUnsignedInteger</a>(), <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>(), <a href="qcborstreamreader.html#isInteger" translate="no">isInteger</a>(), and <a href="qcborstreamreader.html#isNegativeInteger" translate="no">isNegativeInteger</a>().</p>
<!-- @@@isUnsignedInteger -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QCborStreamReader::<span class="name">isValid</span>() const</h3>
<p>Returns true if the current element is valid, false otherwise. The current element may be invalid if there was a decoding error or we've just parsed the last element in an array or map.</p>
<div class="admonition note">
<p><b>Note: </b>This function is not the opposite of <a href="qcborstreamreader.html#isNull" translate="no">isNull</a>(). Null is a normal CBOR type that must be handled by the application.</p>
</div>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>() and <a href="qcborstreamreader.html#isInvalid" translate="no">isInvalid</a>().</p>
<!-- @@@isValid -->
<!-- $$$lastError[overload1]$$$lastError -->
<h3 class="fn" translate="no" id="lastError"><span class="type"><a href="qcborerror.html" translate="no">QCborError</a></span> QCborStreamReader::<span class="name">lastError</span>() const</h3>
<p>Returns the last error in decoding the stream, if any. If no error was encountered, this returns an <a href="qcborerror.html#Code-enum" translate="no">QCborError::NoError</a>.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isValid" translate="no">isValid</a>().</p>
<!-- @@@lastError -->
<!-- $$$leaveContainer[overload1]$$$leaveContainer -->
<h3 class="fn" translate="no" id="leaveContainer"><span class="type">bool</span> QCborStreamReader::<span class="name">leaveContainer</span>()</h3>
<p>Leaves the array or map whose items were being processed and positions the decoder at the next item after the end of the container. Returns true if leaving the container succeeded, false otherwise (usually, a parsing error). Each call to <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>() must be paired with a call to leaveContainer().</p>
<p>This function may only be called if <a href="qcborstreamreader.html#hasNext" translate="no">hasNext</a>() has returned false and <a href="qcborstreamreader.html#containerDepth" translate="no">containerDepth</a>() is not zero. Calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>(), <a href="qcborstreamreader.html#parentContainerType" translate="no">parentContainerType</a>(), and <a href="qcborstreamreader.html#containerDepth" translate="no">containerDepth</a>().</p>
<!-- @@@leaveContainer -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" translate="no" id="length"><span class="type"><a href="qttypes.html#quint64-typedef" translate="no">quint64</a></span> QCborStreamReader::<span class="name">length</span>() const</h3>
<p>Returns the length of the string or byte array, or the number of items in an array or the number, of item pairs in a map, if known. This function must not be called if the length is unknown (that is, if <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>() returned false). It is an error to do that and it will cause <a href="qcborstreamreader.html" translate="no">QCborStreamReader</a> to stop parsing the input stream.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>(), <a href="qcborstreamwriter.html#startArray" translate="no">QCborStreamWriter::startArray</a>(), and <a href="qcborstreamwriter.html#startMap" translate="no">QCborStreamWriter::startMap</a>().</p>
<!-- @@@length -->
<!-- $$$next[overload1]$$$nextint -->
<h3 class="fn" translate="no" id="next"><span class="type">bool</span> QCborStreamReader::<span class="name">next</span>(<span class="type">int</span> <i>maxRecursion</i> = 10000)</h3>
<p>Advance the CBOR stream decoding one element. You should usually call this function when parsing fixed-width basic elements (that is, integers, simple values, tags and floating point values). But this function can be called when the current item is a string, array or map too and it will skip over that entire element, including all contained elements.</p>
<p>This function returns true if advancing was successful, false otherwise. It may fail if the stream is corrupt, incomplete or if the nesting level of arrays and maps exceeds <i translate="no">maxRecursion</i>. Calling this function when <a href="qcborstreamreader.html#hasNext" translate="no">hasNext</a>() has returned false is also an error. If this function returns false, <a href="qcborstreamreader.html#lastError" translate="no">lastError</a>() will return the error code detailing what the failure was.</p>
<p><b>See also </b><a href="qcborstreamreader.html#lastError" translate="no">lastError</a>(), <a href="qcborstreamreader.html#isValid" translate="no">isValid</a>(), and <a href="qcborstreamreader.html#hasNext" translate="no">hasNext</a>().</p>
<!-- @@@next -->
<!-- $$$parentContainerType[overload1]$$$parentContainerType -->
<h3 class="fn" translate="no" id="parentContainerType"><span class="type"><a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Type</a></span> QCborStreamReader::<span class="name">parentContainerType</span>() const</h3>
<p>Returns either <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Array</a> or <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Map</a>, indicating whether the container that contains the current item was an array or map, respectively. If we're currently parsing the root element, this function returns <a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Invalid</a>.</p>
<p><b>See also </b><a href="qcborstreamreader.html#containerDepth" translate="no">containerDepth</a>() and <a href="qcborstreamreader.html#enterContainer" translate="no">enterContainer</a>().</p>
<!-- @@@parentContainerType -->
<!-- $$$readAllByteArray[overload1]$$$readAllByteArray -->
<h3 class="fn" translate="no" id="readAllByteArray"><code class="details extra" translate="no">[since 6.7]</code> <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> QCborStreamReader::<span class="name">readAllByteArray</span>()</h3>
<p>Decodes the current byte string and returns it. If the string is chunked, this function will iterate over all chunks and concatenate them. If an error happens, this function returns a default-constructed QByteArray(), but that may not be distinguishable from certain empty byte strings. Instead, check <a href="qcborstreamreader.html#lastError" translate="no">lastError</a>() to determine if an error has happened.</p>
<p>This function does not perform any type conversions, including from integers or from strings. Therefore, it may only be called if <a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a>() is true; calling it in any other condition is an error.</p>
<div class="admonition note">
<p><b>Note: </b>This function cannot be resumed. That is, this function should not be used in contexts where the CBOR data may still be received, for example from a socket or pipe. It should only be used when the full data has already been received and is available in the input <a href="qbytearray.html" translate="no">QByteArray</a> or <a href="qiodevice.html" translate="no">QIODevice</a>.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>(), <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>(), <a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a>(), and <a href="qcborstreamreader.html#readAllString" translate="no">readAllString</a>().</p>
<!-- @@@readAllByteArray -->
<!-- $$$readAllString[overload1]$$$readAllString -->
<h3 class="fn" translate="no" id="readAllString"><code class="details extra" translate="no">[since 6.7]</code> <span class="type"><a href="qstring.html" translate="no">QString</a></span> QCborStreamReader::<span class="name">readAllString</span>()</h3>
<p>Decodes the current text string and returns it. If the string is chunked, this function will iterate over all chunks and concatenate them. If an error happens, this function returns a default-constructed QString(), but that may not be distinguishable from certain empty text strings. Instead, check <a href="qcborstreamreader.html#lastError" translate="no">lastError</a>() to determine if an error has happened.</p>
<p>This function does not perform any type conversions, including from integers or from byte arrays. Therefore, it may only be called if <a href="qcborstreamreader.html#isString" translate="no">isString</a>() returned true; calling it in any other condition is an error.</p>
<div class="admonition note">
<p><b>Note: </b>This function cannot be resumed. That is, this function should not be used in contexts where the CBOR data may still be received, for example from a socket or pipe. It should only be used when the full data has already been received and is available in the input <a href="qbytearray.html" translate="no">QByteArray</a> or <a href="qiodevice.html" translate="no">QIODevice</a>.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readString" translate="no">readString</a>(), <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>(), <a href="qcborstreamreader.html#isString" translate="no">isString</a>(), and <a href="qcborstreamreader.html#readAllByteArray" translate="no">readAllByteArray</a>().</p>
<!-- @@@readAllString -->
<!-- $$$readAllUtf8String[overload1]$$$readAllUtf8String -->
<h3 class="fn" translate="no" id="readAllUtf8String"><code class="details extra" translate="no">[since 6.7]</code> <span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> QCborStreamReader::<span class="name">readAllUtf8String</span>()</h3>
<p>Decodes the current text string and returns it. If the string is chunked, this function will iterate over all chunks and concatenate them. If an error happens, this function returns a default-constructed QString(), but that may not be distinguishable from certain empty text strings. Instead, check <a href="qcborstreamreader.html#lastError" translate="no">lastError</a>() to determine if an error has happened.</p>
<p>This function does not perform any type conversions, including from integers or from byte arrays. Therefore, it may only be called if <a href="qcborstreamreader.html#isString" translate="no">isString</a>() returned true; calling it in any other condition is an error.</p>
<div class="admonition note">
<p><b>Note: </b>This function cannot be resumed. That is, this function should not be used in contexts where the CBOR data may still be received, for example from a socket or pipe. It should only be used when the full data has already been received and is available in the input <a href="qbytearray.html" translate="no">QByteArray</a> or <a href="qiodevice.html" translate="no">QIODevice</a>.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readString" translate="no">readString</a>(), <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>(), <a href="qcborstreamreader.html#isString" translate="no">isString</a>(), and <a href="qcborstreamreader.html#readAllByteArray" translate="no">readAllByteArray</a>().</p>
<!-- @@@readAllUtf8String -->
<!-- $$$readAndAppendToByteArray[overload1]$$$readAndAppendToByteArrayQByteArray& -->
<h3 class="fn" translate="no" id="readAndAppendToByteArray"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">bool</span> QCborStreamReader::<span class="name">readAndAppendToByteArray</span>(<span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>dst</i>)</h3>
<p>Decodes the current byte string and appends to <i translate="no">dst</i>. If the string is chunked, this function will iterate over all chunks and concatenate them. If an error happens during decoding, other chunks that could be decoded successfully may have been written to <i translate="no">dst</i> nonetheless. Returns <code translate="no">true</code> if the decoding happened without errors, <code translate="no">false</code> otherwise.</p>
<p>This function does not perform any type conversions, including from integers or from strings. Therefore, it may only be called if <a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a>() is true; calling it in any other condition is an error.</p>
<div class="admonition note">
<p><b>Note: </b>This function cannot be resumed. That is, this function should not be used in contexts where the CBOR data may still be received, for example from a socket or pipe. It should only be used when the full data has already been received and is available in the input <a href="qbytearray.html" translate="no">QByteArray</a> or <a href="qiodevice.html" translate="no">QIODevice</a>.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>(), <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>(), <a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a>(), and <a href="qcborstreamreader.html#readAndAppendToString" translate="no">readAndAppendToString</a>().</p>
<!-- @@@readAndAppendToByteArray -->
<!-- $$$readAndAppendToString[overload1]$$$readAndAppendToStringQString& -->
<h3 class="fn" translate="no" id="readAndAppendToString"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">bool</span> QCborStreamReader::<span class="name">readAndAppendToString</span>(<span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>dst</i>)</h3>
<p>Decodes the current text string and appends to <i translate="no">dst</i>. If the string is chunked, this function will iterate over all chunks and concatenate them. If an error happens during decoding, other chunks that could be decoded successfully may have been written to <i translate="no">dst</i> nonetheless. Returns <code translate="no">true</code> if the decoding happened without errors, <code translate="no">false</code> otherwise.</p>
<p>This function does not perform any type conversions, including from integers or from byte arrays. Therefore, it may only be called if <a href="qcborstreamreader.html#isString" translate="no">isString</a>() returned true; calling it in any other condition is an error.</p>
<div class="admonition note">
<p><b>Note: </b>This function cannot be resumed. That is, this function should not be used in contexts where the CBOR data may still be received, for example from a socket or pipe. It should only be used when the full data has already been received and is available in the input <a href="qbytearray.html" translate="no">QByteArray</a> or <a href="qiodevice.html" translate="no">QIODevice</a>.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readString" translate="no">readString</a>(), <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>(), <a href="qcborstreamreader.html#isString" translate="no">isString</a>(), and <a href="qcborstreamreader.html#readAndAppendToByteArray" translate="no">readAndAppendToByteArray</a>().</p>
<!-- @@@readAndAppendToString -->
<!-- $$$readAndAppendToUtf8String[overload1]$$$readAndAppendToUtf8StringQByteArray& -->
<h3 class="fn" translate="no" id="readAndAppendToUtf8String"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">bool</span> QCborStreamReader::<span class="name">readAndAppendToUtf8String</span>(<span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>dst</i>)</h3>
<p>Decodes the current text string and appends to <i translate="no">dst</i>. If the string is chunked, this function will iterate over all chunks and concatenate them. If an error happens during decoding, other chunks that could be decoded successfully may have been written to <i translate="no">dst</i> nonetheless. Returns <code translate="no">true</code> if the decoding happened without errors, <code translate="no">false</code> otherwise.</p>
<p>This function does not perform any type conversions, including from integers or from byte arrays. Therefore, it may only be called if <a href="qcborstreamreader.html#isString" translate="no">isString</a>() returned true; calling it in any other condition is an error.</p>
<div class="admonition note">
<p><b>Note: </b>This function cannot be resumed. That is, this function should not be used in contexts where the CBOR data may still be received, for example from a socket or pipe. It should only be used when the full data has already been received and is available in the input <a href="qbytearray.html" translate="no">QByteArray</a> or <a href="qiodevice.html" translate="no">QIODevice</a>.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readString" translate="no">readString</a>(), <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>(), <a href="qcborstreamreader.html#isString" translate="no">isString</a>(), and <a href="qcborstreamreader.html#readAndAppendToByteArray" translate="no">readAndAppendToByteArray</a>().</p>
<!-- @@@readAndAppendToUtf8String -->
<!-- $$$readByteArray[overload1]$$$readByteArray -->
<h3 class="fn" translate="no" id="readByteArray"><span class="type"><a href="qcborstreamreader-stringresult.html" translate="no">QCborStreamReader::StringResult</a></span>&lt;<span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span>&gt; QCborStreamReader::<span class="name">readByteArray</span>()</h3>
<p>Decodes one byte array chunk from the CBOR string and returns it. This function is used for both regular and chunked contents, so the caller must always loop around calling this function, even if <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>() is true. The typical use of this function is as follows:</p>
<pre class="cpp" translate="no">
    <span class="type">QBytearray</span> decodeBytearray(<span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span> <span class="operator">&amp;</span>reader)
    {
        <span class="type">QBytearray</span> result;
        <span class="keyword">auto</span> r <span class="operator">=</span> reader<span class="operator">.</span>readBytearray();
        <span class="keyword">while</span> (r<span class="operator">.</span>status <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Ok) {
            result <span class="operator">+</span><span class="operator">=</span> r<span class="operator">.</span>data;
            r <span class="operator">=</span> reader<span class="operator">.</span>readByteArray();
        }

        <span class="keyword">if</span> (r<span class="operator">.</span>status <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Error) {
            <span class="comment">// handle error condition</span>
            result<span class="operator">.</span>clear();
        }
        <span class="keyword">return</span> result;
    }
</pre>
<p>The <a href="qcborstreamreader.html#readAllByteArray" translate="no">readAllByteArray</a>() function implements the above loop and some extra checks.</p>
<p>This function does not perform any type conversions, including from integers or from strings. Therefore, it may only be called if <a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a>() is true; calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readAllByteArray" translate="no">readAllByteArray</a>(), <a href="qcborstreamreader.html#readString" translate="no">readString</a>(), <a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a>(), and <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>().</p>
<!-- @@@readByteArray -->
<!-- $$$readString[overload1]$$$readString -->
<h3 class="fn" translate="no" id="readString"><span class="type"><a href="qcborstreamreader-stringresult.html" translate="no">QCborStreamReader::StringResult</a></span>&lt;<span class="type"><a href="qstring.html" translate="no">QString</a></span>&gt; QCborStreamReader::<span class="name">readString</span>()</h3>
<p>Decodes one string chunk from the CBOR string and returns it. This function is used for both regular and chunked string contents, so the caller must always loop around calling this function, even if <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>() is true. The typical use of this function is as follows:</p>
<pre class="cpp" translate="no">
    <span class="type"><a href="qstring.html" translate="no">QString</a></span> decodeString(<span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span> <span class="operator">&amp;</span>reader)
    {
        <span class="type"><a href="qstring.html" translate="no">QString</a></span> result;
        <span class="keyword">auto</span> r <span class="operator">=</span> reader<span class="operator">.</span>readString();
        <span class="keyword">while</span> (r<span class="operator">.</span>status <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Ok) {
            result <span class="operator">+</span><span class="operator">=</span> r<span class="operator">.</span>data;
            r <span class="operator">=</span> reader<span class="operator">.</span>readString();
        }

        <span class="keyword">if</span> (r<span class="operator">.</span>status <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Error) {
            <span class="comment">// handle error condition</span>
            result<span class="operator">.</span>clear();
        }
        <span class="keyword">return</span> result;
    }
</pre>
<p>The <a href="qcborstreamreader.html#readAllString" translate="no">readAllString</a>() function implements the above loop and some extra checks.</p>
<p>This function does not perform any type conversions, including from integers or from byte arrays. Therefore, it may only be called if <a href="qcborstreamreader.html#isString" translate="no">isString</a>() returned true; calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readAllString" translate="no">readAllString</a>(), <a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>(), <a href="qcborstreamreader.html#isString" translate="no">isString</a>(), and <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>().</p>
<!-- @@@readString -->
<!-- $$$readStringChunk[overload1]$$$readStringChunkchar*qsizetype -->
<h3 class="fn" translate="no" id="readStringChunk"><span class="type"><a href="qcborstreamreader-stringresult.html" translate="no">QCborStreamReader::StringResult</a></span>&lt;<span class="type">qsizetype</span>&gt; QCborStreamReader::<span class="name">readStringChunk</span>(<span class="type">char</span> *<i>ptr</i>, <span class="type">qsizetype</span> <i>maxlen</i>)</h3>
<p>Reads the current string chunk into the buffer pointed to by <i translate="no">ptr</i>, whose size is <i translate="no">maxlen</i>. This function returns a <a href="qcborstreamreader-stringresult.html" translate="no">StringResult</a> object, with the number of bytes copied into <i translate="no">ptr</i> saved in the <code translate="no">\l</code> <a href="qcborstreamreader-stringresult.html#data-var" translate="no">StringResult::data</a> member. The <code translate="no">\l</code> <a href="qcborstreamreader-stringresult.html#status-var" translate="no">StringResult::status</a> member indicates whether there was an error reading the string, whether data was copied or whether this was the last chunk.</p>
<p>This function can be called for both <a href="qcborstreamreader.html#Type-enum" translate="no">String</a> and <a href="qcborstreamreader.html#Type-enum" translate="no">ByteArray</a> types. For the latter, this function will read the same data that <a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>() would have returned. For strings, it returns the UTF-8 equivalent of the <a href="qstring.html" translate="no">QString</a> that would have been returned.</p>
<p>This function is usually used alongside <a href="qcborstreamreader.html#currentStringChunkSize" translate="no">currentStringChunkSize</a>() in a loop. For example:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">&lt;</span>qsizetype<span class="operator">&gt;</span> result;
     <span class="keyword">do</span> {
         qsizetype size <span class="operator">=</span> reader<span class="operator">.</span>currentStringChunkSize();
         qsizetype oldsize <span class="operator">=</span> buffer<span class="operator">.</span>size();
         buffer<span class="operator">.</span>resize(oldsize <span class="operator">+</span> size);
         result <span class="operator">=</span> reader<span class="operator">.</span>readStringChunk(buffer<span class="operator">.</span>data() <span class="operator">+</span> oldsize<span class="operator">,</span> size);
     } <span class="keyword">while</span> (result<span class="operator">.</span>status() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Ok);
</pre>
<p>Unlike <a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>() and <a href="qcborstreamreader.html#readString" translate="no">readString</a>(), this function is not limited by implementation limits of <a href="qbytearray.html" translate="no">QByteArray</a> and <a href="qstring.html" translate="no">QString</a>.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not perform verification that the UTF-8 contents are properly formatted. That means this function does not produce the <a href="qcborerror.html#Code-enum" translate="no">QCborError::InvalidUtf8String</a> error, even when <a href="qcborstreamreader.html#readString" translate="no">readString</a>() does.</p>
</div>
<p><b>See also </b><a href="qcborstreamreader.html#currentStringChunkSize" translate="no">currentStringChunkSize</a>(), <a href="qcborstreamreader.html#readString" translate="no">readString</a>(), <a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>(), <a href="qcborstreamreader.html#isString" translate="no">isString</a>(), and <a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a>().</p>
<!-- @@@readStringChunk -->
<!-- $$$readUtf8String[overload1]$$$readUtf8String -->
<h3 class="fn" translate="no" id="readUtf8String"><code class="details extra" translate="no">[since 6.7]</code> <span class="type"><a href="qcborstreamreader-stringresult.html" translate="no">QCborStreamReader::StringResult</a></span>&lt;<span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span>&gt; QCborStreamReader::<span class="name">readUtf8String</span>()</h3>
<p>Decodes one string chunk from the CBOR string and returns it. This function is used for both regular and chunked string contents, so the caller must always loop around calling this function, even if <a href="qcborstreamreader.html#isLengthKnown" translate="no">isLengthKnown</a>() is true. The typical use of this function is as for <a href="qcborstreamreader.html#readString" translate="no">readString</a>() in the following:</p>
<pre class="cpp" translate="no">
    <span class="type"><a href="qstring.html" translate="no">QString</a></span> decodeString(<span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span> <span class="operator">&amp;</span>reader)
    {
        <span class="type"><a href="qstring.html" translate="no">QString</a></span> result;
        <span class="keyword">auto</span> r <span class="operator">=</span> reader<span class="operator">.</span>readString();
        <span class="keyword">while</span> (r<span class="operator">.</span>status <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Ok) {
            result <span class="operator">+</span><span class="operator">=</span> r<span class="operator">.</span>data;
            r <span class="operator">=</span> reader<span class="operator">.</span>readString();
        }

        <span class="keyword">if</span> (r<span class="operator">.</span>status <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qcborstreamreader.html#QCborStreamReader" translate="no">QCborStreamReader</a></span><span class="operator">::</span>Error) {
            <span class="comment">// handle error condition</span>
            result<span class="operator">.</span>clear();
        }
        <span class="keyword">return</span> result;
    }
</pre>
<p>The <a href="qcborstreamreader.html#readAllUtf8String" translate="no">readAllUtf8String</a>() function implements the above loop and some extra checks.</p>
<p>This function does not perform any type conversions, including from integers or from byte arrays. Therefore, it may only be called if <a href="qcborstreamreader.html#isString" translate="no">isString</a>() returned true; calling it in any other condition is an error.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qcborstreamreader.html#readAllString" translate="no">readAllString</a>(), <a href="qcborstreamreader.html#readByteArray" translate="no">readByteArray</a>(), <a href="qcborstreamreader.html#isString" translate="no">isString</a>(), and <a href="qcborstreamreader.html#readStringChunk" translate="no">readStringChunk</a>().</p>
<!-- @@@readUtf8String -->
<!-- $$$reparse[overload1]$$$reparse -->
<h3 class="fn" translate="no" id="reparse"><span class="type">void</span> QCborStreamReader::<span class="name">reparse</span>()</h3>
<p>Reparses the current element. This function must be called when more data becomes available in the source <a href="qiodevice.html" translate="no">QIODevice</a> after parsing failed due to reaching the end of the input data before the end of the CBOR stream.</p>
<p>When reading from QByteArray(), the <a href="qcborstreamreader.html#addData" translate="no">addData</a>() function automatically calls this function. Calling it when the reading had not failed is a no-op.</p>
<!-- @@@reparse -->
<!-- $$$reset[overload1]$$$reset -->
<h3 class="fn" translate="no" id="reset"><span class="type">void</span> QCborStreamReader::<span class="name">reset</span>()</h3>
<p>Resets the source back to the beginning and clears the decoder state. If the source data was a <a href="qbytearray.html" translate="no">QByteArray</a>, <a href="qcborstreamreader.html" translate="no">QCborStreamReader</a> will restart from the beginning of the array.</p>
<p>If the source data is a <a href="qiodevice.html" translate="no">QIODevice</a>, this function will call <a href="qiodevice.html#reset" translate="no">QIODevice::reset</a>(), which will seek to byte position 0. If the CBOR stream is not found at the beginning of the device (e.g., beginning of a file), then this function will likely do the wrong thing. Instead, position the <a href="qiodevice.html" translate="no">QIODevice</a> to the right offset and call <a href="qcborstreamreader.html#setDevice" translate="no">setDevice</a>().</p>
<p><b>See also </b><a href="qcborstreamreader.html#clear" translate="no">clear</a>() and <a href="qcborstreamreader.html#setDevice" translate="no">setDevice</a>().</p>
<!-- @@@reset -->
<!-- $$$setDevice[overload1]$$$setDeviceQIODevice* -->
<h3 class="fn" translate="no" id="setDevice"><span class="type">void</span> QCborStreamReader::<span class="name">setDevice</span>(<span class="type"><a href="qiodevice.html" translate="no">QIODevice</a></span> *<i>device</i>)</h3>
<p>Sets the source of data to <i translate="no">device</i>, resetting the decoder to its initial state.</p>
<p><b>See also </b><a href="qcborstreamreader.html#device" translate="no">device</a>().</p>
<!-- @@@setDevice -->
<!-- $$$toBool[overload1]$$$toBool -->
<h3 class="fn" translate="no" id="toBool"><span class="type">bool</span> QCborStreamReader::<span class="name">toBool</span>() const</h3>
<p>Returns the boolean value of the current element.</p>
<p>This function does not perform any type conversions, including from integer. Therefore, it may only be called if <a href="qcborstreamreader.html#isTrue" translate="no">isTrue</a>(), <a href="qcborstreamreader.html#isFalse" translate="no">isFalse</a>() or <a href="qcborstreamreader.html#isBool" translate="no">isBool</a>() returned true; calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isBool" translate="no">isBool</a>(), <a href="qcborstreamreader.html#isTrue" translate="no">isTrue</a>(), <a href="qcborstreamreader.html#isFalse" translate="no">isFalse</a>(), and <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>().</p>
<!-- @@@toBool -->
<!-- $$$toDouble[overload1]$$$toDouble -->
<h3 class="fn" translate="no" id="toDouble"><span class="type">double</span> QCborStreamReader::<span class="name">toDouble</span>() const</h3>
<p>Returns the 64-bit double-precision floating point value of the current element.</p>
<p>This function does not perform any type conversions, including from other floating point types or from integer values. Therefore, it may only be called if <a href="qcborstreamreader.html#isDouble" translate="no">isDouble</a>() is true; calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isDouble" translate="no">isDouble</a>(), <a href="qcborstreamreader.html#toFloat16" translate="no">toFloat16</a>(), and <a href="qcborstreamreader.html#toFloat" translate="no">toFloat</a>().</p>
<!-- @@@toDouble -->
<!-- $$$toFloat16[overload1]$$$toFloat16 -->
<h3 class="fn" translate="no" id="toFloat16"><span class="type"><a href="qfloat16.html" translate="no">qfloat16</a></span> QCborStreamReader::<span class="name">toFloat16</span>() const</h3>
<p>Returns the 16-bit half-precision floating point value of the current element.</p>
<p>This function does not perform any type conversions, including from other floating point types or from integer values. Therefore, it may only be called if <a href="qcborstreamreader.html#isFloat16" translate="no">isFloat16</a>() is true; calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isFloat16" translate="no">isFloat16</a>(), <a href="qcborstreamreader.html#toFloat" translate="no">toFloat</a>(), and <a href="qcborstreamreader.html#toDouble" translate="no">toDouble</a>().</p>
<!-- @@@toFloat16 -->
<!-- $$$toFloat[overload1]$$$toFloat -->
<h3 class="fn" translate="no" id="toFloat"><span class="type">float</span> QCborStreamReader::<span class="name">toFloat</span>() const</h3>
<p>Returns the 32-bit single-precision floating point value of the current element.</p>
<p>This function does not perform any type conversions, including from other floating point types or from integer values. Therefore, it may only be called if <a href="qcborstreamreader.html#isFloat" translate="no">isFloat</a>() is true; calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isFloat" translate="no">isFloat</a>(), <a href="qcborstreamreader.html#toFloat16" translate="no">toFloat16</a>(), and <a href="qcborstreamreader.html#toDouble" translate="no">toDouble</a>().</p>
<!-- @@@toFloat -->
<!-- $$$toInteger[overload1]$$$toInteger -->
<h3 class="fn" translate="no" id="toInteger"><span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> QCborStreamReader::<span class="name">toInteger</span>() const</h3>
<p>Returns the integer value of the current element, be it negative, positive or zero. If the value is larger than 2<sup>63</sup> - 1 or smaller than -2<sup>63</sup>, the returned value will overflow and will have an incorrect sign. If handling those values is required, use <a href="qcborstreamreader.html#toUnsignedInteger" translate="no">toUnsignedInteger</a>() or <a href="qcborstreamreader.html#toNegativeInteger" translate="no">toNegativeInteger</a>() instead.</p>
<p>This function does not perform any type conversions, including from boolean or CBOR tag. Therefore, it may only be called if <a href="qcborstreamreader.html#isInteger" translate="no">isInteger</a>() is true; calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isInteger" translate="no">isInteger</a>(), <a href="qcborstreamreader.html#toUnsignedInteger" translate="no">toUnsignedInteger</a>(), and <a href="qcborstreamreader.html#toNegativeInteger" translate="no">toNegativeInteger</a>().</p>
<!-- @@@toInteger -->
<!-- $$$toNegativeInteger[overload1]$$$toNegativeInteger -->
<h3 class="fn" translate="no" id="toNegativeInteger"><span class="type">QCborNegativeInteger</span> QCborStreamReader::<span class="name">toNegativeInteger</span>() const</h3>
<p>Returns the negative integer value of the current element. QCborNegativeValue is a 64-bit unsigned integer containing the absolute value of the negative number that was stored in the CBOR stream. Additionally, QCborNegativeValue(0) represents the number -2<sup>64</sup>.</p>
<p>This function does not perform any type conversions, including from boolean or CBOR tag. Therefore, it may only be called if <a href="qcborstreamreader.html#isNegativeInteger" translate="no">isNegativeInteger</a>() is true; calling it in any other condition is an error.</p>
<p>This function may be used to obtain numbers beyond the range of the return type of <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>(). However, use of negative numbers smaller than -2<sup>63</sup> is extremely discouraged.</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>(), <a href="qcborstreamreader.html#isNegativeInteger" translate="no">isNegativeInteger</a>(), and <a href="qcborstreamreader.html#isUnsignedInteger" translate="no">isUnsignedInteger</a>().</p>
<!-- @@@toNegativeInteger -->
<!-- $$$toSimpleType[overload1]$$$toSimpleType -->
<h3 class="fn" translate="no" id="toSimpleType"><span class="type"><a href="qtcborcommon.html#QCborSimpleType-enum" translate="no">QCborSimpleType</a></span> QCborStreamReader::<span class="name">toSimpleType</span>() const</h3>
<p>Returns value of the current simple type.</p>
<p>This function does not perform any type conversions, including from integer. Therefore, it may only be called if <a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a>() is true; calling it in any other condition is an error.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a>(), <a href="qcborstreamreader.html#isTrue" translate="no">isTrue</a>(), <a href="qcborstreamreader.html#isFalse" translate="no">isFalse</a>(), <a href="qcborstreamreader.html#isBool" translate="no">isBool</a>(), <a href="qcborstreamreader.html#isNull" translate="no">isNull</a>(), and <a href="qcborstreamreader.html#isUndefined" translate="no">isUndefined</a>().</p>
<!-- @@@toSimpleType -->
<!-- $$$toTag[overload1]$$$toTag -->
<h3 class="fn" translate="no" id="toTag"><span class="type"><a href="qtcborcommon.html#QCborTag-enum" translate="no">QCborTag</a></span> QCborStreamReader::<span class="name">toTag</span>() const</h3>
<p>Returns the tag value of the current element.</p>
<p>This function does not perform any type conversions, including from integer. Therefore, it may only be called if <a href="qcborstreamreader.html#isTag" translate="no">isTag</a>() is true; calling it in any other condition is an error.</p>
<p>Tags are 64-bit numbers attached to generic CBOR types that give them further meaning. For a list of known tags, see the <a href="qtcborcommon.html#QCborKnownTags-enum" translate="no">QCborKnownTags</a> enumeration.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isTag" translate="no">isTag</a>(), <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>(), and <a href="qtcborcommon.html#QCborKnownTags-enum" translate="no">QCborKnownTags</a>.</p>
<!-- @@@toTag -->
<!-- $$$toUnsignedInteger[overload1]$$$toUnsignedInteger -->
<h3 class="fn" translate="no" id="toUnsignedInteger"><span class="type"><a href="qttypes.html#quint64-typedef" translate="no">quint64</a></span> QCborStreamReader::<span class="name">toUnsignedInteger</span>() const</h3>
<p>Returns the unsigned integer value of the current element.</p>
<p>This function does not perform any type conversions, including from boolean or CBOR tag. Therefore, it may only be called if <a href="qcborstreamreader.html#isUnsignedInteger" translate="no">isUnsignedInteger</a>() is true; calling it in any other condition is an error.</p>
<p>This function may be used to obtain numbers beyond the range of the return type of <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>().</p>
<p><b>See also </b><a href="qcborstreamreader.html#type" translate="no">type</a>(), <a href="qcborstreamreader.html#toInteger" translate="no">toInteger</a>(), <a href="qcborstreamreader.html#isUnsignedInteger" translate="no">isUnsignedInteger</a>(), and <a href="qcborstreamreader.html#isNegativeInteger" translate="no">isNegativeInteger</a>().</p>
<!-- @@@toUnsignedInteger -->
<!-- $$$type[overload1]$$$type -->
<h3 class="fn" translate="no" id="type"><span class="type"><a href="qcborstreamreader.html#Type-enum" translate="no">QCborStreamReader::Type</a></span> QCborStreamReader::<span class="name">type</span>() const</h3>
<p>Returns the type of the current element. It is one of the valid types or Invalid.</p>
<p><b>See also </b><a href="qcborstreamreader.html#isValid" translate="no">isValid</a>(), <a href="qcborstreamreader.html#isUnsignedInteger" translate="no">isUnsignedInteger</a>(), <a href="qcborstreamreader.html#isNegativeInteger" translate="no">isNegativeInteger</a>(), <a href="qcborstreamreader.html#isInteger" translate="no">isInteger</a>(), <a href="qcborstreamreader.html#isByteArray" translate="no">isByteArray</a>(), <a href="qcborstreamreader.html#isString" translate="no">isString</a>(), <a href="qcborstreamreader.html#isArray" translate="no">isArray</a>(), <a href="qcborstreamreader.html#isMap" translate="no">isMap</a>(), <a href="qcborstreamreader.html#isTag" translate="no">isTag</a>(), <a href="qcborstreamreader.html#isSimpleType" translate="no">isSimpleType</a>(), <a href="qcborstreamreader.html#isBool" translate="no">isBool</a>(), <a href="qcborstreamreader.html#isFalse" translate="no">isFalse</a>(), <a href="qcborstreamreader.html#isTrue" translate="no">isTrue</a>(), <a href="qcborstreamreader.html#isNull" translate="no">isNull</a>(), <a href="qcborstreamreader.html#isUndefined" translate="no">isUndefined</a>(), <a href="qcborstreamreader.html#isFloat16" translate="no">isFloat16</a>(), <a href="qcborstreamreader.html#isFloat" translate="no">isFloat</a>(), and <a href="qcborstreamreader.html#isDouble" translate="no">isDouble</a>().</p>
<!-- @@@type -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
