<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qproperty.cpp -->
  <meta name="description" content="The QProperty class is a template class that enables automatic property bindings.">
  <title>QProperty Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QProperty</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QProperty Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QProperty</span>
<!-- $$$QProperty-brief -->
<p>The QProperty class is a template class that enables automatic property bindings. <a href="#details">More...</a></p>
<!-- @@@QProperty -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QProperty&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qpropertydata.html" translate="no">QPropertyData</a></td></tr>
</table></div>
<ul>
<li><a href="qproperty-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty" translate="no">QProperty</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty-3" translate="no">QProperty</a></b>(const QPropertyBinding&lt;T&gt; &amp;<i>binding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty-4" translate="no">QProperty</a></b>(Functor &amp;&amp;<i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty-7" translate="no">QProperty</a></b>(const T &amp;<i>initialValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty-8" translate="no">QProperty</a></b>(T &amp;&amp;<i>initialValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#dtor.QProperty" translate="no">~QProperty</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyNotifier </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#addNotifier" translate="no">addNotifier</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#binding" translate="no">binding</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyChangeHandler&lt;Functor&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#onValueChanged" translate="no">onValueChanged</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setBinding" translate="no">setBinding</a></b>(const QPropertyBinding&lt;T&gt; &amp;<i>newBinding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setBinding-1" translate="no">setBinding</a></b>(const QUntypedPropertyBinding &amp;<i>newBinding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setBinding-2" translate="no">setBinding</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setValue" translate="no">setValue</a></b>(QProperty&lt;T&gt;::rvalue_ref <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setValue-1" translate="no">setValue</a></b>(QProperty&lt;T&gt;::parameter_type <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyChangeHandler&lt;Functor&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#subscribe" translate="no">subscribe</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#takeBinding" translate="no">takeBinding</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QProperty&lt;T&gt;::parameter_type </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#value" translate="no">value</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QProperty&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#operator-eq" translate="no">operator=</a></b>(QProperty&lt;T&gt;::rvalue_ref <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QProperty&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#operator-eq-1" translate="no">operator=</a></b>(QProperty&lt;T&gt;::parameter_type <i>newValue</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#beginPropertyUpdateGroup" translate="no">beginPropertyUpdateGroup</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#endPropertyUpdateGroup" translate="no">endPropertyUpdateGroup</a></b>()</td></tr>
</table></div>
<!-- $$$QProperty-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QProperty&lt;T&gt; is one of the classes implementing <a href="bindableproperties.html" translate="no">Qt Bindable Properties</a>. It is a container that holds an instance of T. You can assign a value to it and you can read it via the <a href="qproperty.html#value" translate="no">value</a>() function or the T conversion operator. You can also tie the property to an expression that computes the value dynamically, the binding expression. It is represented as a C++ lambda and can be used to express relationships between different properties in your application.</p>
<div class="admonition note">
<p><b>Note: </b>For QML, it's important to expose the <a href="qproperty.html" translate="no">QProperty</a> in <a href="qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a> with the BINDABLE keyword. As a result, the QML engine uses it as the bindable interface to set up the property binding. In turn, the binding can then be interacted with C++ via the normal API: QProperty&lt;T&gt;::onValueChanged, <a href="qproperty.html#takeBinding" translate="no">QProperty::takeBinding</a> and QBindable::hasBinding If the property is BINDABLE, the engine will use the change-tracking inherent to the C++ property system for getting notified about changes, and it won't rely on signals being emitted.</p>
</div>
</div>
<!-- @@@QProperty -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="setValue-1"><span class="type">void</span> QProperty::<span class="name">setValue</span>(<span class="type"><a href="qproperty.html#QProperty" translate="no">QProperty</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::parameter_type</span> <i>newValue</i>)</h3><h3 class="fn fngroupitem" translate="no" id="setValue"><span class="type">void</span> QProperty::<span class="name">setValue</span>(<span class="type"><a href="qproperty.html#QProperty" translate="no">QProperty</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::rvalue_ref</span> <i>newValue</i>)</h3></div>
<p>Assigns <i translate="no">newValue</i> to this property and removes the property's associated binding, if present.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="operator-eq-1"><span class="type"><a href="qproperty.html#QProperty" translate="no">QProperty</a></span>&lt;<span class="type">T</span>&gt; &amp;QProperty::<span class="name">operator=</span>(<span class="type"><a href="qproperty.html#QProperty" translate="no">QProperty</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::parameter_type</span> <i>newValue</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-eq"><span class="type"><a href="qproperty.html#QProperty" translate="no">QProperty</a></span>&lt;<span class="type">T</span>&gt; &amp;QProperty::<span class="name">operator=</span>(<span class="type"><a href="qproperty.html#QProperty" translate="no">QProperty</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::rvalue_ref</span> <i>newValue</i>)</h3></div>
<p>Assigns <i translate="no">newValue</i> to this property and returns a reference to this <a href="qproperty.html" translate="no">QProperty</a>.</p>
<!-- @@@ -->
<!-- $$$QProperty[overload1]$$$QProperty -->
<h3 class="fn" translate="no" id="QProperty">QProperty::<span class="name">QProperty</span>()</h3>
<p>Constructs a property with a default constructed instance of T.</p>
<!-- @@@QProperty -->
<!-- $$$QProperty$$$QPropertyconstQPropertyBinding<T>& -->
<h3 class="fn" translate="no" id="QProperty-3"><code class="details extra" translate="no">[explicit]</code> QProperty::<span class="name">QProperty</span>(const <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;<i>binding</i>)</h3>
<p>Constructs a property that is tied to the provided <i translate="no">binding</i> expression. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<!-- @@@QProperty -->
<!-- $$$QProperty$$$QPropertyFunctor&& -->
<h3 class="fn" translate="no" id="QProperty-4"><code class="details extra" translate="no">[explicit]</code> template &lt;typename Functor&gt; QProperty::<span class="name">QProperty</span>(<span class="type">Functor</span> &amp;&amp;<i>f</i>)</h3>
<p>Constructs a property that is tied to the provided binding expression <i translate="no">f</i>. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<!-- @@@QProperty -->
<!-- $$$QProperty$$$QPropertyconstT& -->
<h3 class="fn" translate="no" id="QProperty-7"><code class="details extra" translate="no">[explicit default]</code> QProperty::<span class="name">QProperty</span>(const <span class="type">T</span> &amp;<i>initialValue</i>)</h3>
<p>Constructs a property with the provided <i translate="no">initialValue</i>.</p>
<!-- @@@QProperty -->
<!-- $$$QProperty$$$QPropertyT&& -->
<h3 class="fn" translate="no" id="QProperty-8"><code class="details extra" translate="no">[explicit default]</code> QProperty::<span class="name">QProperty</span>(<span class="type">T</span> &amp;&amp;<i>initialValue</i>)</h3>
<p>Move-Constructs a property with the provided <i translate="no">initialValue</i>.</p>
<!-- @@@QProperty -->
<!-- $$$~QProperty[overload1]$$$~QProperty -->
<h3 class="fn" translate="no" id="dtor.QProperty">QProperty::<span class="name">~QProperty</span>()</h3>
<p>Destroys the property.</p>
<!-- @@@~QProperty -->
<!-- $$$addNotifier[overload1]$$$addNotifierFunctor -->
<h3 class="fn" translate="no" id="addNotifier">template &lt;typename Functor&gt; <span class="type"><a href="qpropertynotifier.html" translate="no">QPropertyNotifier</a></span> QProperty::<span class="name">addNotifier</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>Subscribes the given functor <i translate="no">f</i> as a callback that is called whenever the value of the property changes.</p>
<p>The callback <i translate="no">f</i> is expected to be a type that has a plain call operator <code translate="no">()</code> without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p>
<p>The returned property change handler object keeps track of the subscription. When it goes out of scope, the callback is unsubscribed.</p>
<p>This method is in some cases easier to use than <a href="qproperty.html#onValueChanged" translate="no">onValueChanged</a>(), as the returned object is not a template. It can therefore more easily be stored, e.g. as a member in a class.</p>
<p><b>See also </b><a href="qproperty.html#onValueChanged" translate="no">onValueChanged</a>() and <a href="qproperty.html#subscribe" translate="no">subscribe</a>().</p>
<!-- @@@addNotifier -->
<!-- $$$binding[overload1]$$$binding -->
<h3 class="fn" translate="no" id="binding"><span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QProperty::<span class="name">binding</span>() const</h3>
<p>Returns the binding expression that is associated with this property. A default constructed QPropertyBinding&lt;T&gt; will be returned if no such association exists.</p>
<p><b>See also </b><a href="qproperty.html#setBinding" translate="no">setBinding</a>().</p>
<!-- @@@binding -->
<!-- $$$onValueChanged[overload1]$$$onValueChangedFunctor -->
<h3 class="fn" translate="no" id="onValueChanged">template &lt;typename Functor&gt; <span class="type"><a href="qpropertychangehandler.html" translate="no">QPropertyChangeHandler</a></span>&lt;<span class="type">Functor</span>&gt; QProperty::<span class="name">onValueChanged</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>Registers the given functor <i translate="no">f</i> as a callback that shall be called whenever the value of the property changes. On each value change, the handler is either called immediately, or deferred, depending on the context.</p>
<p>The callback <i translate="no">f</i> is expected to be a type that has a plain call operator <code translate="no">()</code> without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p>
<p>The returned property change handler object keeps track of the registration. When it goes out of scope, the callback is de-registered.</p>
<!-- @@@onValueChanged -->
<!-- $$$setBinding[overload1]$$$setBindingconstQPropertyBinding<T>& -->
<h3 class="fn" translate="no" id="setBinding"><span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QProperty::<span class="name">setBinding</span>(const <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;<i>newBinding</i>)</h3>
<p>Associates the value of this property with the provided <i translate="no">newBinding</i> expression and returns the previously associated binding. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<p><b>See also </b><a href="qproperty.html#binding" translate="no">binding</a>().</p>
<!-- @@@setBinding -->
<!-- $$$setBinding$$$setBindingconstQUntypedPropertyBinding& -->
<h3 class="fn" translate="no" id="setBinding-1"><span class="type">bool</span> QProperty::<span class="name">setBinding</span>(const <span class="type">QUntypedPropertyBinding</span> &amp;<i>newBinding</i>)</h3>
<p>This is an overloaded function.</p>
<p>Associates the value of this property with the provided <i translate="no">newBinding</i> expression. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<p>Returns true if the type of this property is the same as the type the binding function returns; false otherwise.</p>
<!-- @@@setBinding -->
<!-- $$$setBinding$$$setBindingFunctor -->
<h3 class="fn" translate="no" id="setBinding-2">template &lt;typename Functor&gt; <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QProperty::<span class="name">setBinding</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>This is an overloaded function.</p>
<p>Associates the value of this property with the provided functor <i translate="no">f</i> and returns the previously associated binding. The property's value is set to the result of evaluating the new binding. Whenever a dependency of the binding changes, the binding will be re-evaluated, and the property's value gets updated accordingly.</p>
<p><b>See also </b><a href="bindableproperties.html#formulating-a-property-binding" translate="no">Formulating a Property Binding</a>.</p>
<!-- @@@setBinding -->
<!-- $$$subscribe[overload1]$$$subscribeFunctor -->
<h3 class="fn" translate="no" id="subscribe">template &lt;typename Functor&gt; <span class="type"><a href="qpropertychangehandler.html" translate="no">QPropertyChangeHandler</a></span>&lt;<span class="type">Functor</span>&gt; QProperty::<span class="name">subscribe</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>Subscribes the given functor <i translate="no">f</i> as a callback that is called immediately and whenever the value of the property changes in the future. On each value change, the handler is either called immediately, or deferred, depending on the context.</p>
<p>The callback <i translate="no">f</i> is expected to be a type that can be copied and has a plain call operator() without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p>
<p>The returned property change handler object keeps track of the subscription. When it goes out of scope, the callback is unsubscribed.</p>
<!-- @@@subscribe -->
<!-- $$$takeBinding[overload1]$$$takeBinding -->
<h3 class="fn" translate="no" id="takeBinding"><span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QProperty::<span class="name">takeBinding</span>()</h3>
<p>Disassociates the binding expression from this property and returns it. After calling this function, the value of the property will only change if you assign a new value to it, or when a new binding is set.</p>
<!-- @@@takeBinding -->
<!-- $$$value[overload1]$$$value -->
<h3 class="fn" translate="no" id="value"><span class="type"><a href="qproperty.html#QProperty" translate="no">QProperty</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::parameter_type</span> QProperty::<span class="name">value</span>() const</h3>
<p>Returns the value of the property. This may evaluate a binding expression that is tied to this property, before returning the value.</p>
<p><b>See also </b><a href="qproperty.html#setValue" translate="no">setValue</a>().</p>
<!-- @@@value -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$beginPropertyUpdateGroup[overload1]$$$beginPropertyUpdateGroup -->
<h3 class="fn" translate="no" id="beginPropertyUpdateGroup"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">void</span> <span class="name">beginPropertyUpdateGroup</span>()</h3>
<p>Marks the beginning of a property update group. Inside this group, changing a property does neither immediately update any dependent properties nor does it trigger change notifications. Those are instead deferred until the group is ended by a call to <a href="qproperty.html#endPropertyUpdateGroup" translate="no">endPropertyUpdateGroup</a>.</p>
<p>Groups can be nested. In that case, the deferral ends only after the outermost group has been ended.</p>
<div class="admonition note">
<p><b>Note: </b>Change notifications are only send after all property values affected by the group have been updated to their new values. This allows re-establishing a class invariant if multiple properties need to be updated, preventing any external observer from noticing an inconsistent state.</p>
</div>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qproperty.html#endPropertyUpdateGroup" translate="no">Qt::endPropertyUpdateGroup</a> and <a href="qscopedpropertyupdategroup.html" translate="no">QScopedPropertyUpdateGroup</a>.</p>
<!-- @@@beginPropertyUpdateGroup -->
<!-- $$$endPropertyUpdateGroup[overload1]$$$endPropertyUpdateGroup -->
<h3 class="fn" translate="no" id="endPropertyUpdateGroup"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">void</span> <span class="name">endPropertyUpdateGroup</span>()</h3>
<p>Ends a property update group. If the outermost group has been ended, and deferred binding evaluations and notifications happen now.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling endPropertyUpdateGroup without a preceding call to <a href="qproperty.html#beginPropertyUpdateGroup" translate="no">beginPropertyUpdateGroup</a> results in undefined behavior.</p>
</div>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qproperty.html#beginPropertyUpdateGroup" translate="no">Qt::beginPropertyUpdateGroup</a> and <a href="qscopedpropertyupdategroup.html" translate="no">QScopedPropertyUpdateGroup</a>.</p>
<!-- @@@endPropertyUpdateGroup -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
