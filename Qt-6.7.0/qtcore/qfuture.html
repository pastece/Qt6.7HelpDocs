<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qfuture.qdoc -->
  <meta name="description" content="The QFuture class represents the result of an asynchronous computation.">
  <title>QFuture Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QFuture</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QFuture Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QFuture</span>
<!-- $$$QFuture-brief -->
<p>The QFuture class represents the result of an asynchronous computation. <a href="#details">More...</a></p>
<!-- @@@QFuture -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QFuture&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qfuture-members.html">List of all members, including inherited members</a></li>
<li><a href="qfuture-obsolete.html">Deprecated members</a></li>
<li>QFuture is part of <a href="../qtdoc/thread.html">Threading Classes</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a> with the following exceptions:</p>
<ul>
<li><a href="qfuture-const-iterator.html" translate="no">const_iterator</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qfuture-const-iterator.html" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#ConstIterator-typedef" translate="no">ConstIterator</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#QFuture" translate="no">QFuture</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#QFuture-4" translate="no">QFuture</a></b>(const QFuture&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#dtor.QFuture" translate="no">~QFuture</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#begin" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#cancel" translate="no">cancel</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#end" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#isCanceled" translate="no">isCanceled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#isFinished" translate="no">isFinished</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#isResultReadyAt" translate="no">isResultReadyAt</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#isRunning" translate="no">isRunning</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#isStarted" translate="no">isStarted</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#isSuspended" translate="no">isSuspended</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#isSuspending" translate="no">isSuspending</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#onCanceled" translate="no">onCanceled</a></b>(Function &amp;&amp;<i>handler</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#onCanceled-1" translate="no">onCanceled</a></b>(QObject *<i>context</i>, Function &amp;&amp;<i>handler</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#onFailed" translate="no">onFailed</a></b>(Function &amp;&amp;<i>handler</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#onFailed-1" translate="no">onFailed</a></b>(QObject *<i>context</i>, Function &amp;&amp;<i>handler</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#progressMaximum" translate="no">progressMaximum</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#progressMinimum" translate="no">progressMinimum</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#progressText" translate="no">progressText</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#progressValue" translate="no">progressValue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#result" translate="no">result</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#resultAt" translate="no">resultAt</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#resultCount" translate="no">resultCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#results" translate="no">results</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#resume" translate="no">resume</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#setSuspended" translate="no">setSuspended</a></b>(bool <i>suspend</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#suspend" translate="no">suspend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> T </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#takeResult" translate="no">takeResult</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QFuture&lt;QFuture&lt;T&gt;::ResultType&lt;Function&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#then" translate="no">then</a></b>(Function &amp;&amp;<i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QFuture&lt;QFuture&lt;T&gt;::ResultType&lt;Function&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#then-1" translate="no">then</a></b>(QtFuture::Launch <i>policy</i>, Function &amp;&amp;<i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QFuture&lt;QFuture&lt;T&gt;::ResultType&lt;Function&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#then-2" translate="no">then</a></b>(QThreadPool *<i>pool</i>, Function &amp;&amp;<i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QFuture&lt;QFuture&lt;T&gt;::ResultType&lt;Function&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#then-3" translate="no">then</a></b>(QObject *<i>context</i>, Function &amp;&amp;<i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#toggleSuspended" translate="no">toggleSuspended</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QFuture&lt;U&gt; </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#unwrap" translate="no">unwrap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#waitForFinished" translate="no">waitForFinished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qfuture.html#operator-eq-1" translate="no">operator=</a></b>(const QFuture&lt;T&gt; &amp;<i>other</i>)</td></tr>
</table></div>
<!-- $$$QFuture-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QFuture allows threads to be synchronized against one or more results which will be ready at a later point in time. The result can be of any type that has default, copy and possibly move constructors. If a result is not available at the time of calling the <a href="qfuture.html#result" translate="no">result</a>(), <a href="qfuture.html#resultAt" translate="no">resultAt</a>(), <a href="qfuture.html#results" translate="no">results</a>() and <a href="qfuture.html#takeResult" translate="no">takeResult</a>() functions, QFuture will wait until the result becomes available. You can use the <a href="qfuture.html#isResultReadyAt" translate="no">isResultReadyAt</a>() function to determine if a result is ready or not. For QFuture objects that report more than one result, the <a href="qfuture.html#resultCount" translate="no">resultCount</a>() function returns the number of continuous results. This means that it is always safe to iterate through the results from 0 to <a href="qfuture.html#resultCount" translate="no">resultCount</a>(). <a href="qfuture.html#takeResult" translate="no">takeResult</a>() invalidates a future, and any subsequent attempt to access result or results from the future leads to undefined behavior. <a href="qfuture.html#isValid" translate="no">isValid</a>() tells you if results can be accessed.</p>
<p>QFuture provides a <a href="java-style-iterators.html#java-style-iterators" translate="no">Java-style iterator</a> (<a href="qfutureiterator.html" translate="no">QFutureIterator</a>) and an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> (<a href="qfuture-const-iterator.html" translate="no">QFuture::const_iterator</a>). Using these iterators is another way to access results in the future.</p>
<p>If the result of one asynchronous computation needs to be passed to another, QFuture provides a convenient way of chaining multiple sequential computations using <a href="qfuture.html#then" translate="no">then</a>(). <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>() can be used for adding a handler to be called if the QFuture is canceled. Additionally, <a href="qfuture.html#onFailed" translate="no">onFailed</a>() can be used to handle any failures that occurred in the chain. Note that QFuture relies on exceptions for the error handling. If using exceptions is not an option, you can still indicate the error state of QFuture, by making the error type part of the QFuture type. For example, you can use std::variant, std::any or similar for keeping the result or failure or make your custom type.</p>
<p>The example below demonstrates how the error handling can be done without using exceptions. Let's say we want to send a network request to obtain a large file from a network location. Then we want to write it to the file system and return its location in case of a success. Both of these operations may fail with different errors. So, we use <code translate="no">std::variant</code> to keep the result or error:</p>
<pre class="cpp" translate="no">
 <span class="keyword">using</span> NetworkReply <span class="operator">=</span> std<span class="operator">::</span>variant<span class="operator">&lt;</span><span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span><span class="operator">,</span> <span class="type"><a href="../qtnetwork/qnetworkreply.html" translate="no">QNetworkReply</a></span><span class="operator">::</span>NetworkError<span class="operator">&gt;</span>;

 <span class="keyword">enum</span> <span class="keyword">class</span> IOError { FailedToRead<span class="operator">,</span> FailedToWrite };
 <span class="keyword">using</span> IOResult <span class="operator">=</span> std<span class="operator">::</span>variant<span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> IOError<span class="operator">&gt;</span>;
</pre>
<p>And we combine the two operations using <a href="qfuture.html#then" translate="no">then</a>():</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span>IOResult<span class="operator">&gt;</span> future <span class="operator">=</span> <span class="type">QtConcurrent</span><span class="operator">::</span>run(<span class="operator">[</span>url<span class="operator">]</span> {
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         <span class="keyword">return</span> NetworkReply(<span class="type"><a href="../qtnetwork/qnetworkreply.html" translate="no">QNetworkReply</a></span><span class="operator">::</span>TimeoutError);
 })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(NetworkReply reply) {
     <span class="keyword">if</span> (<span class="keyword">auto</span> error <span class="operator">=</span> std<span class="operator">::</span>get_if<span class="operator">&lt;</span><span class="type"><a href="../qtnetwork/qnetworkreply.html" translate="no">QNetworkReply</a></span><span class="operator">::</span>NetworkError<span class="operator">&gt;</span>(<span class="operator">&amp;</span>reply))
         <span class="keyword">return</span> IOResult(IOError<span class="operator">::</span>FailedToRead);

     <span class="keyword">auto</span> data <span class="operator">=</span> std<span class="operator">::</span>get_if<span class="operator">&lt;</span><span class="type"><a href="qbytearray.html" translate="no">QByteArray</a></span><span class="operator">&gt;</span>(<span class="operator">&amp;</span>reply);
     <span class="comment">// try to write *data and return IOError::FailedToWrite on failure</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 });

 <span class="keyword">auto</span> result <span class="operator">=</span> future<span class="operator">.</span>result();
 <span class="keyword">if</span> (<span class="keyword">auto</span> filePath <span class="operator">=</span> std<span class="operator">::</span>get_if<span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span>(<span class="operator">&amp;</span>result)) {
     <span class="comment">// do something with *filePath</span>
 <span class="keyword">else</span>
     <span class="comment">// process the error</span>
</pre>
<p>It's possible to chain multiple continuations and handlers in any order. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> testFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="keyword">auto</span> resultFuture <span class="operator">=</span> testFuture<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res) {
     <span class="comment">// Block 1</span>
 })<span class="operator">.</span>onCanceled(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 2</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 3</span>
 })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 4</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 5</span>
 })<span class="operator">.</span>onCanceled(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 6</span>
 });
</pre>
<p>Depending on the state of <code translate="no">testFuture</code> (canceled, has exception or has a result), the next <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>(), <a href="qfuture.html#onFailed" translate="no">onFailed</a>() or <a href="qfuture.html#then" translate="no">then</a>() will be called. So if <code translate="no">testFuture</code> is successfully fulfilled, <code translate="no">Block 1</code> will be called. If it succeeds as well, the next <a href="qfuture.html#then" translate="no">then</a>() (<code translate="no">Block 4</code>) is called. If <code translate="no">testFuture</code> gets canceled or fails with an exception, either <code translate="no">Block 2</code> or <code translate="no">Block 3</code> will be called respectively. The next <a href="qfuture.html#then" translate="no">then</a>() will be called afterwards, and the story repeats.</p>
<div class="admonition note">
<p><b>Note: </b>If <code translate="no">Block 2</code> is invoked and throws an exception, the following <a href="qfuture.html#onFailed" translate="no">onFailed</a>() (<code translate="no">Block 3</code>) will handle it. If the order of <a href="qfuture.html#onFailed" translate="no">onFailed</a>() and <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>() were reversed, the exception state would propagate to the next continuations and eventually would be caught in <code translate="no">Block 5</code>.</p>
</div>
<p>In the next example the first <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>() (<code translate="no">Block 2</code>) is removed:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> testFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="keyword">auto</span> resultFuture <span class="operator">=</span> testFuture<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res) {
     <span class="comment">// Block 1</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 3</span>
 })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 4</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 5</span>
 })<span class="operator">.</span>onCanceled(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 6</span>
 });
</pre>
<p>If <code translate="no">testFuture</code> gets canceled, its state is propagated to the next <a href="qfuture.html#then" translate="no">then</a>(), which will be also canceled. So in this case <code translate="no">Block 6</code> will be called.</p>
<p>The future can have only one continuation. Consider the following example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qpromise.html" translate="no">QPromise</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> p;

 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> f1 <span class="operator">=</span> p<span class="operator">.</span>future();
 f1<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span>) { <a href="qtlogging.html#qDebug" translate="no">qDebug</a>(<span class="string">&quot;first&quot;</span>); });

 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> f2 <span class="operator">=</span> p<span class="operator">.</span>future();
 f2<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span>) { <a href="qtlogging.html#qDebug" translate="no">qDebug</a>(<span class="string">&quot;second&quot;</span>); });

 p<span class="operator">.</span>start();
 p<span class="operator">.</span>addResult(<span class="number">42</span>);
 p<span class="operator">.</span>finish();
</pre>
<p>In this case <code translate="no">f1</code> and <code translate="no">f2</code> are effectively the same QFuture object, as they share the same internal state. As a result, calling <a href="qfuture.html#then" translate="no">then</a> on <code translate="no">f2</code> will overwrite the continuation specified for <code translate="no">f1</code>. So, only <code translate="no">&quot;second&quot;</code> will be printed when this code is executed.</p>
<p>QFuture also offers ways to interact with a running computation. For instance, the computation can be canceled with the <a href="qfuture.html#cancel" translate="no">cancel</a>() function. To suspend or resume the computation, use the <a href="qfuture.html#setSuspended" translate="no">setSuspended</a>() function or one of the <a href="qfuture.html#suspend" translate="no">suspend</a>(), <a href="qfuture.html#resume" translate="no">resume</a>(), or <a href="qfuture.html#toggleSuspended" translate="no">toggleSuspended</a>() convenience functions. Be aware that not all running asynchronous computations can be canceled or suspended. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</p>
<p>Progress information is provided by the <a href="qfuture.html#progressValue" translate="no">progressValue</a>(), <a href="qfuture.html#progressMinimum" translate="no">progressMinimum</a>(), <a href="qfuture.html#progressMaximum" translate="no">progressMaximum</a>(), and <a href="qfuture.html#progressText" translate="no">progressText</a>() functions. The <a href="qfuture.html#waitForFinished" translate="no">waitForFinished</a>() function causes the calling thread to block and wait for the computation to finish, ensuring that all results are available.</p>
<p>The state of the computation represented by a QFuture can be queried using the <a href="qfuture.html#isCanceled" translate="no">isCanceled</a>(), <a href="qfuture.html#isStarted" translate="no">isStarted</a>(), <a href="qfuture.html#isFinished" translate="no">isFinished</a>(), <a href="qfuture.html#isRunning" translate="no">isRunning</a>(), <a href="qfuture.html#isSuspending" translate="no">isSuspending</a>() or <a href="qfuture.html#isSuspended" translate="no">isSuspended</a>() functions.</p>
<p>QFuture&lt;void&gt; is specialized to not contain any of the result fetching functions. Any QFuture&lt;T&gt; can be assigned or copied into a QFuture&lt;void&gt; as well. This is useful if only status or progress information is needed - not the actual result data.</p>
<p>To interact with running tasks using signals and slots, use <a href="qfuturewatcher.html" translate="no">QFutureWatcher</a>.</p>
<p>You can also use <a href="qtfuture.html#connect" translate="no">QtFuture::connect</a>() to connect signals to a QFuture object which will be resolved when a signal is emitted. This allows working with signals like with QFuture objects. For example, if you combine it with <a href="qfuture.html#then" translate="no">then</a>(), you can attach multiple continuations to a signal, which are invoked in the same thread or a new thread.</p>
<p>The <a href="qtfuture.html#whenAll" translate="no">QtFuture::whenAll</a>() and <a href="qtfuture.html#whenAny" translate="no">QtFuture::whenAny</a>() functions can be used to combine several futures and track when the last or first of them completes.</p>
<p>A ready QFuture object with a value or a QFuture object holding exception can be created using convenience functions <a href="qtfuture.html#makeReadyVoidFuture" translate="no">QtFuture::makeReadyVoidFuture</a>(), <a href="qtfuture.html#makeReadyValueFuture" translate="no">QtFuture::makeReadyValueFuture</a>(), <a href="qtfuture.html#makeReadyRangeFuture" translate="no">QtFuture::makeReadyRangeFuture</a>(), and <a href="qtfuture.html#makeExceptionalFuture" translate="no">QtFuture::makeExceptionalFuture</a>().</p>
<div class="admonition note">
<p><b>Note: </b>Some APIs (see <a href="qfuture.html#then" translate="no">QFuture::then</a>() or various <a href="../qtconcurrent/qtconcurrent-module.html" translate="no">QtConcurrent</a> method overloads) allow scheduling the computation to a specific thread pool. However, QFuture implements a work-stealing algorithm to prevent deadlocks and optimize thread usage. As a result, computations can be executed directly in the thread which requests the QFuture's result.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>To start a computation and store results in a QFuture, use <a href="qpromise.html" translate="no">QPromise</a> or one of the APIs in the <a href="../qtconcurrent/qtconcurrent-index.html" translate="no">Qt Concurrent</a> framework.</p>
</div>
</div>
<p><b>See also </b><a href="qpromise.html" translate="no">QPromise</a>, <a href="qtfuture.html#connect" translate="no">QtFuture::connect</a>(), <a href="qtfuture.html#makeReadyVoidFuture" translate="no">QtFuture::makeReadyVoidFuture</a>(), <a href="qtfuture.html#makeReadyValueFuture" translate="no">QtFuture::makeReadyValueFuture</a>(), <a href="qtfuture.html#makeReadyRangeFuture" translate="no">QtFuture::makeReadyRangeFuture</a>(), <a href="qtfuture.html#makeExceptionalFuture" translate="no">QtFuture::makeExceptionalFuture</a>(), <a href="qfuturewatcher.html" translate="no">QFutureWatcher</a>, and <a href="../qtconcurrent/qtconcurrent-index.html" translate="no">Qt Concurrent</a>.</p>
<!-- @@@QFuture -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" translate="no" id="ConstIterator-typedef">QFuture::<span class="name">ConstIterator</span></h3>
<p>Qt-style synonym for <a href="qfuture-const-iterator.html" translate="no">QFuture::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QFuture[overload1]$$$QFuture -->
<h3 class="fn" translate="no" id="QFuture">QFuture::<span class="name">QFuture</span>()</h3>
<p>Constructs an empty, canceled future.</p>
<!-- @@@QFuture -->
<!-- $$$QFuture$$$QFutureconstQFuture<T>& -->
<h3 class="fn" translate="no" id="QFuture-4">QFuture::<span class="name">QFuture</span>(const <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p><b>See also </b><a href="qfuture.html#operator-eq-1" translate="no">operator=</a>().</p>
<!-- @@@QFuture -->
<!-- $$$~QFuture[overload1]$$$~QFuture -->
<h3 class="fn" translate="no" id="dtor.QFuture">QFuture::<span class="name">~QFuture</span>()</h3>
<p>Destroys the future.</p>
<p>Note that this neither waits nor cancels the asynchronous computation. Use <a href="qfuture.html#waitForFinished" translate="no">waitForFinished</a>() or <a href="qfuturesynchronizer.html" translate="no">QFutureSynchronizer</a> when you need to ensure that the computation is completed before the future is destroyed.</p>
<!-- @@@~QFuture -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" translate="no" id="begin">template &lt;typename U = T, typename = QtPrivate::EnableForNonVoid&lt;U&gt;> <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QFuture::<span class="name">begin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first result in the future.</p>
<p><b>See also </b><a href="qfuture.html#constBegin" translate="no">constBegin</a>() and <a href="qfuture.html#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$cancel[overload1]$$$cancel -->
<h3 class="fn" translate="no" id="cancel"><span class="type">void</span> QFuture::<span class="name">cancel</span>()</h3>
<p>Cancels the asynchronous computation represented by this future. Note that the cancellation is asynchronous. Use <a href="qfuture.html#waitForFinished" translate="no">waitForFinished</a>() after calling cancel() when you need synchronous cancellation.</p>
<p>Results currently available may still be accessed on a canceled future, but new results will <i>not</i> become available after calling this function. Any <a href="qfuturewatcher.html" translate="no">QFutureWatcher</a> object that is watching this future will not deliver progress and result ready signals on a canceled future.</p>
<p>Be aware that not all running asynchronous computations can be canceled. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</p>
<!-- @@@cancel -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" translate="no" id="constBegin">template &lt;typename U = T, typename = QtPrivate::EnableForNonVoid&lt;U&gt;> <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QFuture::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first result in the future.</p>
<p><b>See also </b><a href="qfuture.html#begin" translate="no">begin</a>() and <a href="qfuture.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" translate="no" id="constEnd">template &lt;typename U = T, typename = QtPrivate::EnableForNonVoid&lt;U&gt;> <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QFuture::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary result after the last result in the future.</p>
<p><b>See also </b><a href="qfuture.html#constBegin" translate="no">constBegin</a>() and <a href="qfuture.html#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end">template &lt;typename U = T, typename = QtPrivate::EnableForNonVoid&lt;U&gt;> <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QFuture::<span class="name">end</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary result after the last result in the future.</p>
<p><b>See also </b><a href="qfuture.html#begin" translate="no">begin</a>() and <a href="qfuture.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$isCanceled[overload1]$$$isCanceled -->
<h3 class="fn" translate="no" id="isCanceled"><span class="type">bool</span> QFuture::<span class="name">isCanceled</span>() const</h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation has been canceled with the <a href="qfuture.html#cancel" translate="no">cancel</a>() function; otherwise returns <code translate="no">false</code>.</p>
<p>Be aware that the computation may still be running even though this function returns <code translate="no">true</code>. See <a href="qfuture.html#cancel" translate="no">cancel</a>() for more details.</p>
<!-- @@@isCanceled -->
<!-- $$$isFinished[overload1]$$$isFinished -->
<h3 class="fn" translate="no" id="isFinished"><span class="type">bool</span> QFuture::<span class="name">isFinished</span>() const</h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation represented by this future has finished; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isFinished -->
<!-- $$$isResultReadyAt[overload1]$$$isResultReadyAtint -->
<h3 class="fn" translate="no" id="isResultReadyAt">template &lt;typename U = T, typename = QtPrivate::EnableForNonVoid&lt;U&gt;> <span class="type">bool</span> QFuture::<span class="name">isResultReadyAt</span>(<span class="type">int</span> <i>index</i>) const</h3>
<p>Returns <code translate="no">true</code> if the result at <i translate="no">index</i> is immediately available; otherwise returns <code translate="no">false</code>.</p>
<div class="admonition note">
<p><b>Note: </b>Calling isResultReadyAt() leads to undefined behavior if <a href="qfuture.html#isValid" translate="no">isValid</a>() returns <code translate="no">false</code> for this <a href="qfuture.html" translate="no">QFuture</a>.</p>
</div>
<p><b>See also </b><a href="qfuture.html#resultAt" translate="no">resultAt</a>(), <a href="qfuture.html#resultCount" translate="no">resultCount</a>(), and <a href="qfuture.html#takeResult" translate="no">takeResult</a>().</p>
<!-- @@@isResultReadyAt -->
<!-- $$$isRunning[overload1]$$$isRunning -->
<h3 class="fn" translate="no" id="isRunning"><span class="type">bool</span> QFuture::<span class="name">isRunning</span>() const</h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation represented by this future is currently running; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isRunning -->
<!-- $$$isStarted[overload1]$$$isStarted -->
<h3 class="fn" translate="no" id="isStarted"><span class="type">bool</span> QFuture::<span class="name">isStarted</span>() const</h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation represented by this future has been started; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isStarted -->
<!-- $$$isSuspended[overload1]$$$isSuspended -->
<h3 class="fn" translate="no" id="isSuspended"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">bool</span> QFuture::<span class="name">isSuspended</span>() const</h3>
<p>Returns <code translate="no">true</code> if a suspension of the asynchronous computation has been requested, and it is in effect, meaning that no more results or progress changes are expected.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#setSuspended" translate="no">setSuspended</a>(), <a href="qfuture.html#toggleSuspended" translate="no">toggleSuspended</a>(), and <a href="qfuture.html#isSuspending" translate="no">isSuspending</a>().</p>
<!-- @@@isSuspended -->
<!-- $$$isSuspending[overload1]$$$isSuspending -->
<h3 class="fn" translate="no" id="isSuspending"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">bool</span> QFuture::<span class="name">isSuspending</span>() const</h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation has been suspended with the <a href="qfuture.html#suspend" translate="no">suspend</a>() function, but the work is not yet suspended, and computation is still running. Returns <code translate="no">false</code> otherwise.</p>
<p>To check if suspension is actually in effect, use <a href="qfuture.html#isSuspended" translate="no">isSuspended</a>() instead.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#setSuspended" translate="no">setSuspended</a>(), <a href="qfuture.html#toggleSuspended" translate="no">toggleSuspended</a>(), and <a href="qfuture.html#isSuspended" translate="no">isSuspended</a>().</p>
<!-- @@@isSuspending -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">bool</span> QFuture::<span class="name">isValid</span>() const</h3>
<p>Returns <code translate="no">true</code> if a result or results can be accessed or taken from this <a href="qfuture.html" translate="no">QFuture</a> object. Returns false after the result was taken from the future.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#takeResult" translate="no">takeResult</a>(), <a href="qfuture.html#result" translate="no">result</a>(), <a href="qfuture.html#results" translate="no">results</a>(), and <a href="qfuture.html#resultAt" translate="no">resultAt</a>().</p>
<!-- @@@isValid -->
<!-- $$$onCanceled[overload1]$$$onCanceledFunction&& -->
<h3 class="fn" translate="no" id="onCanceled"><code class="details extra" translate="no">[since 6.0]</code> template &lt;typename Function, typename = std::enable_if_t&lt;std::is_invocable_r_v&lt;T, Function&gt;>> <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">onCanceled</span>(<span class="type">Function</span> &amp;&amp;<i>handler</i>)</h3>
<p>Attaches a cancellation <i translate="no">handler</i> to this future. The returned future behaves exactly as this future (has the same state and result) unless this future is cancelled. The <i translate="no">handler</i> is a callable which takes no arguments and returns a value of the type packaged by this future. After cancellation, the returned future packages the value returned by <i translate="no">handler</i>.</p>
<p>If attached before the cancellation, <i translate="no">handler</i> will be invoked in the same thread that reports the future as finished after the cancellation. If the handler is attached after this future has already been canceled, it will be invoked immediately in the thread that executes <code translate="no">onCanceled()</code>. Therefore, the handler cannot always make assumptions about which thread it will be run on. Use the overload that takes a context object if you want to control which thread the handler is invoked on.</p>
<p>The example below demonstrates how to attach a cancellation handler:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> testFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="keyword">auto</span> resultFuture <span class="operator">=</span> testFuture<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res) {
     <span class="comment">// Block 1</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">return</span> <span class="number">1</span>;
 })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res) {
     <span class="comment">// Block 2</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">return</span> <span class="number">2</span>;
 })<span class="operator">.</span>onCanceled(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Block 3</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>;
 });
</pre>
<p>If <code translate="no">testFuture</code> is canceled, <code translate="no">Block 3</code> will be called and the <code translate="no">resultFuture</code> will have <code translate="no">-1</code> as its result. Unlike <code translate="no">testFuture</code>, it won't be in a <code translate="no">Canceled</code> state. This means that you can get its result, attach countinuations to it, and so on.</p>
<p>Also note that you can cancel the chain of continuations while they are executing via the future that started the chain. Let's say <code translate="no">testFuture.cancel()</code> was called while <code translate="no">Block 1</code> is already executing. The next continuation will detect that cancellation was requested, so <code translate="no">Block 2</code> will be skipped, and the cancellation handler (<code translate="no">Block 3</code>) will be called.</p>
<div class="admonition note">
<p><b>Note: </b>This method returns a new <code translate="no">QFuture</code> representing the result of the continuation chain. Canceling the resulting <code translate="no">QFuture</code> itself won't invoke the cancellation handler in the chain that lead to it. This means that if you call <code translate="no">resultFuture.cancel()</code>, <code translate="no">Block 3</code> won't be called: because <code translate="no">resultFuture</code> is the future that results from attaching the cancellation handler to <code translate="no">testFuture</code>, no cancellation handlers have been attached to <code translate="no">resultFuture</code> itself. Only cancellation of <code translate="no">testFuture</code> or the futures returned by continuations attached before the <code translate="no">onCancelled()</code> call can trigger <code translate="no">Block 3</code>.</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#then" translate="no">then</a>() and <a href="qfuture.html#onFailed" translate="no">onFailed</a>().</p>
<!-- @@@onCanceled -->
<!-- $$$onCanceled$$$onCanceledQObject*Function&& -->
<h3 class="fn" translate="no" id="onCanceled-1"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Function, typename = std::enable_if_t&lt;std::is_invocable_r_v&lt;T, Function&gt;>> <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">onCanceled</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Function</span> &amp;&amp;<i>handler</i>)</h3>
<p>This is an overloaded function.</p>
<p>Attaches a cancellation <i translate="no">handler</i> to this future, to be called when the future is canceled. The <i translate="no">handler</i> is a callable which doesn't take any arguments. It will be invoked in the thread of the <i translate="no">context</i> object. This can be useful if the cancellation needs to be handled in a specific thread.</p>
<p>If the <i translate="no">context</i> is destroyed before the chain has finished, the future is canceled. See <a href="qfuture.html#context-lifetime" translate="no">then</a>() for details.</p>
<div class="admonition note">
<p><b>Note: </b>When calling this method, it should be guaranteed that the <i translate="no">context</i> stays alive during setup of the chain.</p>
</div>
<p>See the documentation of the other overload for more details about <i translate="no">handler</i>.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html#then" translate="no">then</a>() and <a href="qfuture.html#onFailed" translate="no">onFailed</a>().</p>
<!-- @@@onCanceled -->
<!-- $$$onFailed[overload1]$$$onFailedFunction&& -->
<h3 class="fn" translate="no" id="onFailed"><code class="details extra" translate="no">[since 6.0]</code> template &lt;typename Function, typename = std::enable_if_t&lt;!QtPrivate::ArgResolver&lt;Function&gt;::HasExtraArgs>> <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">onFailed</span>(<span class="type">Function</span> &amp;&amp;<i>handler</i>)</h3>
<p>Attaches a failure handler to this future, to handle any exceptions. The returned future behaves exactly as this future (has the same state and result) unless this future fails with an exception.</p>
<p>The <i translate="no">handler</i> is a callable which takes either no argument or one argument, to filter by specific error types, similar to the <a href="https://en.cppreference.com/w/cpp/language/try_catch" translate="no">catch</a> statement. It returns a value of the type packaged by this future. After the failure, the returned future packages the value returned by <i translate="no">handler</i>.</p>
<p>The handler will only be invoked if an exception is raised. If the exception is raised after this handler is attached, the handler is executed in the thread that reports the future as finished as a result of the exception. If the handler is attached after this future has already failed, it will be invoked immediately, in the thread that executes <code translate="no">onFailed()</code>. Therefore, the handler cannot always make assumptions about which thread it will be run on. Use the overload that takes a context object if you want to control which thread the handler is invoked on.</p>
<p>The example below demonstrates how to attach a failure handler:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="keyword">auto</span> resultFuture <span class="operator">=</span> future<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res) {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">throw</span> Error();
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> Error <span class="operator">&amp;</span>e) {
     <span class="comment">// Handle exceptions of type Error</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>;
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// Handle all other types of errors</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>;
 });

 <span class="keyword">auto</span> result <span class="operator">=</span> resultFuture<span class="operator">.</span>result(); <span class="comment">// result is -1</span>
</pre>
<p>If there are multiple handlers attached, the first handler that matches with the thrown exception type will be invoked. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 future<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res) {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">throw</span> std<span class="operator">::</span>runtime_error(<span class="string">&quot;message&quot;</span>);
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> std<span class="operator">::</span>exception <span class="operator">&amp;</span>e) {
     <span class="comment">// This handler will be invoked</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> std<span class="operator">::</span>runtime_error <span class="operator">&amp;</span>e) {
     <span class="comment">// This handler won't be invoked, because of the handler above.</span>
 });
</pre>
<p>If none of the handlers matches with the thrown exception type, the exception will be propagated to the resulted future:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="keyword">auto</span> resultFuture <span class="operator">=</span> future<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res) {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">throw</span> Error(<span class="string">&quot;message&quot;</span>);
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> std<span class="operator">::</span>exception <span class="operator">&amp;</span>e) {
     <span class="comment">// Won't be invoked</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="qexception.html" translate="no">QException</a></span> <span class="operator">&amp;</span>e) {
     <span class="comment">// Won't be invoked</span>
 });

 <span class="keyword">try</span> {
     <span class="keyword">auto</span> result <span class="operator">=</span> resultFuture<span class="operator">.</span>result();
 } <span class="keyword">catch</span>(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>) {
     <span class="comment">// Handle the exception</span>
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>You can always attach a handler taking no argument, to handle all exception types and avoid writing the try-catch block.</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#then" translate="no">then</a>() and <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>().</p>
<!-- @@@onFailed -->
<!-- $$$onFailed$$$onFailedQObject*Function&& -->
<h3 class="fn" translate="no" id="onFailed-1"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Function, typename = std::enable_if_t&lt;!QtPrivate::ArgResolver&lt;Function&gt;::HasExtraArgs>> <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">onFailed</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Function</span> &amp;&amp;<i>handler</i>)</h3>
<p>This is an overloaded function.</p>
<p>Attaches a failure handler to this future, to handle any exceptions that the future raises, or that it has already raised. Returns a <a href="qfuture.html" translate="no">QFuture</a> of the same type as this future. The handler will be invoked only in case of an exception, in the thread of the <i translate="no">context</i> object. This can be useful if the failure needs to be handled in a specific thread. For example:</p>
<pre class="cpp" translate="no">
 <span class="comment">// somewhere in the main thread</span>
 <span class="keyword">auto</span> future <span class="operator">=</span> <span class="type">QtConcurrent</span><span class="operator">::</span>run(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// This will run in a separate thread</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">throw</span> std<span class="operator">::</span>exception();
 })<span class="operator">.</span>onFailed(<span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> {
    <span class="comment">// Update UI elements</span>
 });
</pre>
<p>The failure handler attached into <a href="../qtconcurrent/qtconcurrent.html#run" translate="no">QtConcurrent::run</a> updates the UI elements and cannot be invoked from a non-gui thread. So <code translate="no">this</code> is provided as a context to <code translate="no">.onFailed()</code>, to make sure that it will be invoked in the main thread.</p>
<p>If the <i translate="no">context</i> is destroyed before the chain has finished, the future is canceled. See <a href="qfuture.html#context-lifetime" translate="no">then</a>() for details.</p>
<div class="admonition note">
<p><b>Note: </b>When calling this method, it should be guaranteed that the <i translate="no">context</i> stays alive during setup of the chain.</p>
</div>
<p>See the documentation of the other overload for more details about <i translate="no">handler</i>.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html#then" translate="no">then</a>() and <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>().</p>
<!-- @@@onFailed -->
<!-- $$$progressMaximum[overload1]$$$progressMaximum -->
<h3 class="fn" translate="no" id="progressMaximum"><span class="type">int</span> QFuture::<span class="name">progressMaximum</span>() const</h3>
<p>Returns the maximum <a href="qfuture.html#progressValue" translate="no">progressValue</a>().</p>
<p><b>See also </b><a href="qfuture.html#progressValue" translate="no">progressValue</a>() and <a href="qfuture.html#progressMinimum" translate="no">progressMinimum</a>().</p>
<!-- @@@progressMaximum -->
<!-- $$$progressMinimum[overload1]$$$progressMinimum -->
<h3 class="fn" translate="no" id="progressMinimum"><span class="type">int</span> QFuture::<span class="name">progressMinimum</span>() const</h3>
<p>Returns the minimum <a href="qfuture.html#progressValue" translate="no">progressValue</a>().</p>
<p><b>See also </b><a href="qfuture.html#progressValue" translate="no">progressValue</a>() and <a href="qfuture.html#progressMaximum" translate="no">progressMaximum</a>().</p>
<!-- @@@progressMinimum -->
<!-- $$$progressText[overload1]$$$progressText -->
<h3 class="fn" translate="no" id="progressText"><span class="type"><a href="qstring.html" translate="no">QString</a></span> QFuture::<span class="name">progressText</span>() const</h3>
<p>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</p>
<p>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</p>
<!-- @@@progressText -->
<!-- $$$progressValue[overload1]$$$progressValue -->
<h3 class="fn" translate="no" id="progressValue"><span class="type">int</span> QFuture::<span class="name">progressValue</span>() const</h3>
<p>Returns the current progress value, which is between the <a href="qfuture.html#progressMinimum" translate="no">progressMinimum</a>() and <a href="qfuture.html#progressMaximum" translate="no">progressMaximum</a>().</p>
<p><b>See also </b><a href="qfuture.html#progressMinimum" translate="no">progressMinimum</a>() and <a href="qfuture.html#progressMaximum" translate="no">progressMaximum</a>().</p>
<!-- @@@progressValue -->
<!-- $$$result[overload1]$$$result -->
<h3 class="fn" translate="no" id="result">template &lt;typename U = T, typename = QtPrivate::EnableForNonVoid&lt;U&gt;> <span class="type">T</span> QFuture::<span class="name">result</span>() const</h3>
<p>Returns the first result in the future. If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <a href="qfuture.html#resultAt" translate="no">resultAt</a>(0). Note that <code translate="no">result()</code> returns a copy of the internally stored result. If <code translate="no">T</code> is a move-only type, or you don't want to copy the result, use <a href="qfuture.html#takeResult" translate="no">takeResult</a>() instead.</p>
<div class="admonition note">
<p><b>Note: </b>Calling <code translate="no">result()</code> leads to undefined behavior if <a href="qfuture.html#isValid" translate="no">isValid</a>() returns <code translate="no">false</code> for this <a href="qfuture.html" translate="no">QFuture</a>.</p>
</div>
<p><b>See also </b><a href="qfuture.html#resultAt" translate="no">resultAt</a>(), <a href="qfuture.html#results" translate="no">results</a>(), and <a href="qfuture.html#takeResult" translate="no">takeResult</a>().</p>
<!-- @@@result -->
<!-- $$$resultAt[overload1]$$$resultAtint -->
<h3 class="fn" translate="no" id="resultAt">template &lt;typename U = T, typename = QtPrivate::EnableForNonVoid&lt;U&gt;> <span class="type">T</span> QFuture::<span class="name">resultAt</span>(<span class="type">int</span> <i>index</i>) const</h3>
<p>Returns the result at <i translate="no">index</i> in the future. If the result is not immediately available, this function will block and wait for the result to become available.</p>
<div class="admonition note">
<p><b>Note: </b>Calling resultAt() leads to undefined behavior if <a href="qfuture.html#isValid" translate="no">isValid</a>() returns <code translate="no">false</code> for this <a href="qfuture.html" translate="no">QFuture</a>.</p>
</div>
<p><b>See also </b><a href="qfuture.html#result" translate="no">result</a>(), <a href="qfuture.html#results" translate="no">results</a>(), <a href="qfuture.html#takeResult" translate="no">takeResult</a>(), and <a href="qfuture.html#resultCount" translate="no">resultCount</a>().</p>
<!-- @@@resultAt -->
<!-- $$$resultCount[overload1]$$$resultCount -->
<h3 class="fn" translate="no" id="resultCount"><span class="type">int</span> QFuture::<span class="name">resultCount</span>() const</h3>
<p>Returns the number of continuous results available in this future. The real number of results stored might be different from this value, due to gaps in the result set. It is always safe to iterate through the results from 0 to resultCount().</p>
<p><b>See also </b><a href="qfuture.html#result" translate="no">result</a>(), <a href="qfuture.html#resultAt" translate="no">resultAt</a>(), <a href="qfuture.html#results" translate="no">results</a>(), and <a href="qfuture.html#takeResult" translate="no">takeResult</a>().</p>
<!-- @@@resultCount -->
<!-- $$$results[overload1]$$$results -->
<h3 class="fn" translate="no" id="results">template &lt;typename U = T, typename = QtPrivate::EnableForNonVoid&lt;U&gt;> <span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">results</span>() const</h3>
<p>Returns all results from the future. If the results are not immediately available, this function will block and wait for them to become available. Note that <code translate="no">results()</code> returns a copy of the internally stored results. Getting all results of a move-only type <code translate="no">T</code> is not supported at the moment. However you can still iterate through the list of move-only results by using <a href="containers.html#stl-style-iterators" translate="no">STL-style iterators</a> or read-only <a href="java-style-iterators.html#java-style-iterators" translate="no">Java-style iterators</a>.</p>
<div class="admonition note">
<p><b>Note: </b>Calling <code translate="no">results()</code> leads to undefined behavior if <a href="qfuture.html#isValid" translate="no">isValid</a>() returns <code translate="no">false</code> for this <a href="qfuture.html" translate="no">QFuture</a>.</p>
</div>
<p><b>See also </b><a href="qfuture.html#result" translate="no">result</a>(), <a href="qfuture.html#resultAt" translate="no">resultAt</a>(), <a href="qfuture.html#takeResult" translate="no">takeResult</a>(), <a href="qfuture.html#resultCount" translate="no">resultCount</a>(), and <a href="qfuture.html#isValid" translate="no">isValid</a>().</p>
<!-- @@@results -->
<!-- $$$resume[overload1]$$$resume -->
<h3 class="fn" translate="no" id="resume"><span class="type">void</span> QFuture::<span class="name">resume</span>()</h3>
<p>Resumes the asynchronous computation represented by the future(). This is a convenience method that simply calls <a href="qfuture.html#setSuspended" translate="no">setSuspended</a>(false).</p>
<p><b>See also </b><a href="qfuture.html#suspend" translate="no">suspend</a>().</p>
<!-- @@@resume -->
<!-- $$$setSuspended[overload1]$$$setSuspendedbool -->
<h3 class="fn" translate="no" id="setSuspended"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">void</span> QFuture::<span class="name">setSuspended</span>(<span class="type">bool</span> <i>suspend</i>)</h3>
<p>If <i translate="no">suspend</i> is true, this function suspends the asynchronous computation represented by the future(). If the computation is already suspended, this function does nothing. <a href="qfuturewatcher.html" translate="no">QFutureWatcher</a> will not immediately stop delivering progress and result ready signals when the future is suspended. At the moment of suspending there may still be computations that are in progress and cannot be stopped. Signals for such computations will still be delivered.</p>
<p>If <i translate="no">suspend</i> is false, this function resumes the asynchronous computation. If the computation was not previously suspended, this function does nothing.</p>
<p>Be aware that not all computations can be suspended. For example, the <a href="qfuture.html" translate="no">QFuture</a> returned by QtConcurrent::run() cannot be suspended; but the <a href="qfuture.html" translate="no">QFuture</a> returned by QtConcurrent::mappedReduced() can.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#isSuspended" translate="no">isSuspended</a>(), <a href="qfuture.html#suspend" translate="no">suspend</a>(), <a href="qfuture.html#resume" translate="no">resume</a>(), and <a href="qfuture.html#toggleSuspended" translate="no">toggleSuspended</a>().</p>
<!-- @@@setSuspended -->
<!-- $$$suspend[overload1]$$$suspend -->
<h3 class="fn" translate="no" id="suspend"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">void</span> QFuture::<span class="name">suspend</span>()</h3>
<p>Suspends the asynchronous computation represented by this future. This is a convenience method that simply calls <a href="qfuture.html#setSuspended" translate="no">setSuspended</a>(true).</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#resume" translate="no">resume</a>().</p>
<!-- @@@suspend -->
<!-- $$$takeResult[overload1]$$$takeResult -->
<h3 class="fn" translate="no" id="takeResult"><code class="details extra" translate="no">[since 6.0]</code> template &lt;typename U = T, typename = QtPrivate::EnableForNonVoid&lt;U&gt;> <span class="type">T</span> QFuture::<span class="name">takeResult</span>()</h3>
<p>Call this function only if <a href="qfuture.html#isValid" translate="no">isValid</a>() returns <code translate="no">true</code>, otherwise the behavior is undefined. This function takes (moves) the first result from the <a href="qfuture.html" translate="no">QFuture</a> object, when only one result is expected. If there are any other results, they are discarded after taking the first one. If the result is not immediately available, this function will block and wait for the result to become available. The <a href="qfuture.html" translate="no">QFuture</a> will try to use move semantics if possible, and will fall back to copy construction if the type is not movable. After the result was taken, <a href="qfuture.html#isValid" translate="no">isValid</a>() will evaluate as <code translate="no">false</code>.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qfuture.html" translate="no">QFuture</a> in general allows sharing the results between different <a href="qfuture.html" translate="no">QFuture</a> objects (and potentially between different threads). takeResult() was introduced to make <a href="qfuture.html" translate="no">QFuture</a> also work with move-only types (like std::unique_ptr), so it assumes that only one thread can move the results out of the future, and do it only once. Also note that taking the list of all results is not supported at the moment. However you can still iterate through the list of move-only results by using <a href="containers.html#stl-style-iterators" translate="no">STL-style iterators</a> or read-only <a href="java-style-iterators.html#java-style-iterators" translate="no">Java-style iterators</a>.</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#result" translate="no">result</a>(), <a href="qfuture.html#results" translate="no">results</a>(), <a href="qfuture.html#resultAt" translate="no">resultAt</a>(), and <a href="qfuture.html#isValid" translate="no">isValid</a>().</p>
<!-- @@@takeResult -->
<!-- $$$then[overload1]$$$thenFunction&& -->
<h3 class="fn" translate="no" id="then"><code class="details extra" translate="no">[since 6.0]</code> template &lt;typename Function&gt; <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::ResultType</span>&lt;<span class="type">Function</span>&gt;&gt; QFuture::<span class="name">then</span>(<span class="type">Function</span> &amp;&amp;<i>function</i>)</h3>
<p>This is an overloaded function.</p>
<p>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired, using the <a href="qtfuture.html#Launch-enum" translate="no">Sync</a> policy. <i translate="no">function</i> is a callable that takes an argument of the type packaged by this future if this has a result (is not a <a href="qfuture.html" translate="no">QFuture</a>&lt;void&gt;). Otherwise it takes no arguments. This method returns a new <a href="qfuture.html" translate="no">QFuture</a> that packages a value of the type returned by <i translate="no">function</i>. The returned future will be in an uninitialized state until the attached continuation is invoked, or until this future fails or is canceled.</p>
<div class="admonition note">
<p><b>Note: </b>Use other overloads of this method if you need to launch the continuation in a separate thread.</p>
</div>
<p>You can chain multiple operations like this:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 future<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res1){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res2){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> })<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>Or:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 future<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> })<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>The continuation can also take a <a href="qfuture.html" translate="no">QFuture</a> argument (instead of its value), representing the previous future. This can be useful if, for example, <a href="qfuture.html" translate="no">QFuture</a> has multiple results, and the user wants to access them inside the continuation. Or the user needs to handle the exception of the previous future inside the continuation, to not interrupt the chain of multiple continuations. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
     future<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> f) {
         <span class="keyword">try</span> {
             <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
             <span class="keyword">auto</span> result <span class="operator">=</span> f<span class="operator">.</span>result();
             <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         } <span class="keyword">catch</span> (<span class="type"><a href="qexception.html" translate="no">QException</a></span> <span class="operator">&amp;</span>e) {
             <span class="comment">// handle the exception</span>
         }
     })<span class="operator">.</span>then(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
</pre>
<p>If the previous future throws an exception and it is not handled inside the continuation, the exception will be propagated to the continuation future, to allow the caller to handle it:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="keyword">auto</span> continuation <span class="operator">=</span> future<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res1){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res2){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> })<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="comment">// future throws an exception</span>
 <span class="keyword">try</span> {
     <span class="keyword">auto</span> result <span class="operator">=</span> continuation<span class="operator">.</span>result();
 } <span class="keyword">catch</span> (<span class="type"><a href="qexception.html" translate="no">QException</a></span> <span class="operator">&amp;</span>e) {
     <span class="comment">// handle the exception</span>
 }
</pre>
<p>In this case the whole chain of continuations will be interrupted.</p>
<div class="admonition note">
<p><b>Note: </b>If this future gets canceled, the continuations attached to it will also be canceled.</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#onFailed" translate="no">onFailed</a>() and <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>().</p>
<!-- @@@then -->
<!-- $$$then$$$thenQtFuture::LaunchFunction&& -->
<h3 class="fn" translate="no" id="then-1"><code class="details extra" translate="no">[since 6.0]</code> template &lt;typename Function&gt; <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::ResultType</span>&lt;<span class="type">Function</span>&gt;&gt; QFuture::<span class="name">then</span>(<span class="type"><a href="qtfuture.html#Launch-enum" translate="no">QtFuture::Launch</a></span> <i>policy</i>, <span class="type">Function</span> &amp;&amp;<i>function</i>)</h3>
<p>This is an overloaded function.</p>
<p>Attaches a continuation to this future, allowing to chain multiple asynchronous computations. When the asynchronous computation represented by this future finishes, <i translate="no">function</i> will be invoked according to the given launch <i translate="no">policy</i>. A new <a href="qfuture.html" translate="no">QFuture</a> representing the result of the continuation is returned.</p>
<p>Depending on the <i translate="no">policy</i>, continuation will be invoked in the same thread as this future, in a new thread, or will inherit the launch policy and thread pool of this future. If no launch policy is specified (see the overload taking only a callable), the <code translate="no">Sync</code> policy will be used.</p>
<p>In the following example both continuations will be invoked in a new thread (but in the same one).</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 future<span class="operator">.</span>then(<span class="type">QtFuture</span><span class="operator">::</span>Launch<span class="operator">::</span>Async<span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res2){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> });
</pre>
<p>In the following example both continuations will be invoked in new threads using the same thread pool.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 future<span class="operator">.</span>then(<span class="type">QtFuture</span><span class="operator">::</span>Launch<span class="operator">::</span>Async<span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> })
       <span class="operator">.</span>then(<span class="type">QtFuture</span><span class="operator">::</span>Launch<span class="operator">::</span>Inherit<span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> res2){ <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> });
</pre>
<p>See the documentation of the other overload for more details about <i translate="no">function</i>.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#onFailed" translate="no">onFailed</a>() and <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>().</p>
<!-- @@@then -->
<!-- $$$then$$$thenQThreadPool*Function&& -->
<h3 class="fn" translate="no" id="then-2"><code class="details extra" translate="no">[since 6.0]</code> template &lt;typename Function&gt; <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::ResultType</span>&lt;<span class="type">Function</span>&gt;&gt; QFuture::<span class="name">then</span>(<span class="type"><a href="qthreadpool.html" translate="no">QThreadPool</a></span> *<i>pool</i>, <span class="type">Function</span> &amp;&amp;<i>function</i>)</h3>
<p>This is an overloaded function.</p>
<p>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired. When the asynchronous computation represented by this future finishes, <i translate="no">function</i> will be scheduled on <i translate="no">pool</i>.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#onFailed" translate="no">onFailed</a>() and <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>().</p>
<!-- @@@then -->
<!-- $$$then$$$thenQObject*Function&& -->
<h3 class="fn" translate="no" id="then-3"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Function&gt; <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::ResultType</span>&lt;<span class="type">Function</span>&gt;&gt; QFuture::<span class="name">then</span>(<span class="type"><a href="qobject.html" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Function</span> &amp;&amp;<i>function</i>)</h3>
<p>This is an overloaded function.</p>
<p>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired. When the asynchronous computation represented by this future finishes, <i translate="no">function</i> will be invoked in the thread of the <i translate="no">context</i> object. This can be useful if the continuation needs to be invoked in a specific thread. For example:</p>
<pre class="cpp" translate="no">
 <span class="comment">// somewhere in the main thread</span>
 <span class="keyword">auto</span> future <span class="operator">=</span> <span class="type">QtConcurrent</span><span class="operator">::</span>run(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// This will run in a separate thread</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 })<span class="operator">.</span>then(<span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> {
    <span class="comment">// Update UI elements</span>
 });
</pre>
<p>The continuation attached into <a href="../qtconcurrent/qtconcurrent.html#run" translate="no">QtConcurrent::run</a> updates the UI elements and cannot be invoked from a non-gui thread. So <code translate="no">this</code> is provided as a context to <code translate="no">.then()</code>, to make sure that it will be invoked in the main thread.</p>
<p>The following continuations will be also invoked from the same context, unless a different context or launch policy is specified:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> future <span class="operator">=</span> <span class="type">QtConcurrent</span><span class="operator">::</span>run(<span class="operator">[</span><span class="operator">]</span> {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 })<span class="operator">.</span>then(<span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> {
    <span class="comment">// Update UI elements</span>
 })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// This will also run in the main thread</span>
 });
</pre>
<p>This is because by default <code translate="no">.then()</code> is invoked from the same thread as the previous one.</p>
<p>But note that if the continuation is attached after this future has already finished, it will be invoked immediately, in the thread that executes <code translate="no">then()</code>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>context <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="keyword">auto</span> future <span class="operator">=</span> cachedResultsReady <span class="operator">?</span> <span class="type">QtFuture</span><span class="operator">::</span>makeReadyValueFuture(result)
                                  : <span class="type">QtConcurrent</span><span class="operator">::</span>run(<span class="operator">[</span><span class="operator">]</span> { <span class="comment">/* compute result */</span>});
 <span class="keyword">auto</span> continuation <span class="operator">=</span> future<span class="operator">.</span>then(context<span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (Result result) {
     <span class="comment">// Runs in the context's thread</span>
 })<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// May or may not run in the context's thread</span>
 });
</pre>
<p>In the above example if <code translate="no">cachedResultsReady</code> is <code translate="no">true</code>, and a ready future is returned, it is possible that the first <code translate="no">.then()</code> finishes before the second one is attached. In this case it will be resolved in the current thread. Therefore, when in doubt, pass the context explicitly.</p>
<span id="context-lifetime"></span><p>If the <i translate="no">context</i> is destroyed before the chain has finished, the future is canceled. This implies that a cancellation handler might be invoked when the <i translate="no">context</i> is not valid anymore. To guard against this, capture the <i translate="no">context</i> as a <a href="qpointer.html" translate="no">QPointer</a>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>context <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="keyword">auto</span> future <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="keyword">auto</span> continuation <span class="operator">=</span> future<span class="operator">.</span>then(context<span class="operator">,</span> <span class="operator">[</span>context<span class="operator">]</span>(Result result) {
                                <span class="comment">// ...</span>
                            })<span class="operator">.</span>onCanceled(<span class="operator">[</span>context <span class="operator">=</span> <span class="type"><a href="qpointer.html" translate="no">QPointer</a></span>(context)<span class="operator">]</span> {
                                <span class="keyword">if</span> (<span class="operator">!</span>context)
                                    <span class="keyword">return</span>;  <span class="comment">// context was destroyed already</span>
                                <span class="comment">// handle cancellation</span>
                            });
</pre>
<p>When the context object is destroyed, cancellation happens immediately. Previous futures in the chain are <i>not</i> cancelled and keep running until they are finished.</p>
<div class="admonition note">
<p><b>Note: </b>When calling this method, it should be guaranteed that the <i translate="no">context</i> stays alive during setup of the chain.</p>
</div>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html#onFailed" translate="no">onFailed</a>() and <a href="qfuture.html#onCanceled" translate="no">onCanceled</a>().</p>
<!-- @@@then -->
<!-- $$$toggleSuspended[overload1]$$$toggleSuspended -->
<h3 class="fn" translate="no" id="toggleSuspended"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">void</span> QFuture::<span class="name">toggleSuspended</span>()</h3>
<p>Toggles the suspended state of the asynchronous computation. In other words, if the computation is currently suspending or suspended, calling this function resumes it; if the computation is running, it is suspended. This is a convenience method for calling <a href="qfuture.html#setSuspended" translate="no">setSuspended</a>(!(<a href="qfuture.html#isSuspending" translate="no">isSuspending</a>() || <a href="qfuture.html#isSuspended" translate="no">isSuspended</a>())).</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#setSuspended" translate="no">setSuspended</a>(), <a href="qfuture.html#suspend" translate="no">suspend</a>(), and <a href="qfuture.html#resume" translate="no">resume</a>().</p>
<!-- @@@toggleSuspended -->
<!-- $$$unwrap[overload1]$$$unwrap -->
<h3 class="fn" translate="no" id="unwrap"><code class="details extra" translate="no">[since 6.4]</code> template &lt;typename U&gt; <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">U</span>&gt; QFuture::<span class="name">unwrap</span>()</h3>
<p>Unwraps the inner future from this <code translate="no">QFuture&lt;T&gt;</code>, where <code translate="no">T</code> is a future of type <code translate="no">QFuture&lt;U&gt;</code>, i.e. this future has type of <code translate="no">QFuture&lt;QFuture&lt;U&gt;&gt;</code>. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span> outerFuture <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> unwrappedFuture <span class="operator">=</span> outerFuture<span class="operator">.</span>unwrap();
</pre>
<p><code translate="no">unwrappedFuture</code> will be fulfilled as soon as the inner future nested inside the <code translate="no">outerFuture</code> is fulfilled, with the same result or exception and in the same thread that reports the inner future as finished. If the inner future is canceled, <code translate="no">unwrappedFuture</code> will also be canceled.</p>
<p>This is especially useful when chaining multiple computations, and one of them returns a <code translate="no">QFuture</code> as its result type. For example, let's say we want to download multiple images from an URL, scale the images, and reduce them to a single image using QtConcurrent::mappedReduced(). We could write something like:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> downloadImages <span class="operator">=</span> <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">const</span> <span class="type"><a href="qurl.html" translate="no">QUrl</a></span> <span class="operator">&amp;</span>url) {
     <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span><span class="operator">&gt;</span> images;
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">return</span> images;
 };

 <span class="keyword">auto</span> processImages <span class="operator">=</span> <span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span><span class="operator">&gt;</span> <span class="operator">&amp;</span>images) {
    <span class="keyword">return</span> <span class="type">QtConcurrent</span><span class="operator">::</span>mappedReduced(images<span class="operator">,</span> scale<span class="operator">,</span> reduceImages);
 }

 <span class="keyword">auto</span> show <span class="operator">=</span> <span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span> <span class="operator">&amp;</span>image) { <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> };

 <span class="keyword">auto</span> future <span class="operator">=</span> <span class="type">QtConcurrent</span><span class="operator">::</span>run(downloadImages<span class="operator">,</span> url)
                <span class="operator">.</span>then(processImages)
                <span class="operator">.</span>unwrap()
                <span class="operator">.</span>then(show);
</pre>
<p>Here <code translate="no">QtConcurrent::mappedReduced()</code> returns a <code translate="no">QFuture&lt;QImage&gt;</code>, so <code translate="no">.then(processImages)</code> returns a <code translate="no">QFuture&lt;QFuture&lt;QImage&gt;&gt;</code>. Since <code translate="no">show()</code> takes a <code translate="no">QImage</code> as argument, the result of <code translate="no">.then(processImages)</code> can't be passed to it directly. We need to call <code translate="no">.unwrap()</code>, that will get the result of the inner future when it's ready and pass it to the next continuation.</p>
<p>In case of multiple nesting, <code translate="no">.unwrap()</code> goes down to the innermost level:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span><span class="operator">&gt;</span><span class="operator">&gt;</span> outerFuture;
 <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> unwrappedFuture <span class="operator">=</span> outerFuture<span class="operator">.</span>unwrap();
</pre>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@unwrap -->
<!-- $$$waitForFinished[overload1]$$$waitForFinished -->
<h3 class="fn" translate="no" id="waitForFinished"><span class="type">void</span> QFuture::<span class="name">waitForFinished</span>()</h3>
<p>Waits for the asynchronous computation to finish (including <a href="qfuture.html#cancel" translate="no">cancel</a>()ed computations), i.e. until <a href="qfuture.html#isFinished" translate="no">isFinished</a>() returns <code translate="no">true</code>.</p>
<!-- @@@waitForFinished -->
<!-- $$$operator=$$$operator=constQFuture<T>& -->
<h3 class="fn" translate="no" id="operator-eq-1"><span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;QFuture::<span class="name">operator=</span>(const <span class="type"><a href="qfuture.html#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Assigns <i translate="no">other</i> to this future and returns a reference to this future.</p>
<!-- @@@operator= -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
