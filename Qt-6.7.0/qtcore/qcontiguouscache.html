<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qcontiguouscache.cpp -->
  <meta name="description" content="The QContiguousCache class is a template class that provides a contiguous cache.">
  <title>QContiguousCache Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QContiguousCache</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QContiguousCache Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QContiguousCache</span>
<!-- $$$QContiguousCache-brief -->
<p>The QContiguousCache class is a template class that provides a contiguous cache. <a href="#details">More...</a></p>
<!-- @@@QContiguousCache -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QContiguousCache&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qcontiguouscache-members.html">List of all members, including inherited members</a></li>
<li>QContiguousCache is part of <a href="shared.html">Implicitly Shared Classes</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></b>(qsizetype <i>capacity</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#QContiguousCache-1" translate="no">QContiguousCache</a></b>(const QContiguousCache&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#dtor.QContiguousCache" translate="no">~QContiguousCache</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#append-1" translate="no">append</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#areIndexesValid" translate="no">areIndexesValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#at" translate="no">at</a></b>(qsizetype <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#available" translate="no">available</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#capacity" translate="no">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#containsIndex" translate="no">containsIndex</a></b>(qsizetype <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#count" translate="no">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#first" translate="no">first</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#first-1" translate="no">first</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#firstIndex" translate="no">firstIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#insert-1" translate="no">insert</a></b>(qsizetype <i>i</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#isFull" translate="no">isFull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#last" translate="no">last</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#last-1" translate="no">last</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#lastIndex" translate="no">lastIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#normalizeIndexes" translate="no">normalizeIndexes</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#prepend-1" translate="no">prepend</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#removeFirst" translate="no">removeFirst</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#removeLast" translate="no">removeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#setCapacity" translate="no">setCapacity</a></b>(qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#swap" translate="no">swap</a></b>(QContiguousCache&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#takeFirst" translate="no">takeFirst</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#takeLast" translate="no">takeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-not-eq" translate="no">operator!=</a></b>(const QContiguousCache&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QContiguousCache&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-eq" translate="no">operator=</a></b>(const QContiguousCache&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QContiguousCache&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-eq-1" translate="no">operator=</a></b>(QContiguousCache&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-eq-eq" translate="no">operator==</a></b>(const QContiguousCache&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-5b-5d" translate="no">operator[]</a></b>(qsizetype <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcontiguouscache.html#operator-5b-5d-1" translate="no">operator[]</a></b>(qsizetype <i>i</i>) const</td></tr>
</table></div>
<!-- $$$QContiguousCache-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QContiguousCache class provides an efficient way of caching items for display in a user interface view. Unlike <a href="qcache.html" translate="no">QCache</a>, it adds a restriction that elements within the cache are contiguous. This has the advantage of matching how user interface views most commonly request data, as a set of rows localized around the current scrolled position. This restriction allows the cache to consume less memory and processor cycles than <a href="qcache.html" translate="no">QCache</a>.</p>
<p>QContiguousCache operates on a fixed capacity, set with <a href="qcontiguouscache.html#setCapacity" translate="no">setCapacity</a>() or passed as a parameter to the constructor. This capacity is the upper bound on memory usage by the cache itself, not including the memory allocated by the elements themselves. Note that a cache with a capacity of zero (the default) means no items will be stored: the <a href="qcontiguouscache.html#insert-1" translate="no">insert</a>(), <a href="qcontiguouscache.html#append-1" translate="no">append</a>() and <a href="qcontiguouscache.html#prepend-1" translate="no">prepend</a>() operations will effectively be no-ops. Therefore, it's important to set the capacity to a reasonable value before adding items to the cache.</p>
<p>The simplest way of using a contiguous cache is to use the <a href="qcontiguouscache.html#append-1" translate="no">append</a>() and <a href="qcontiguouscache.html#prepend-1" translate="no">prepend</a>().</p>
<pre class="cpp" translate="no">
 MyRecord record(<span class="type">int</span> row) <span class="keyword">const</span>
 {
     Q_ASSERT(row <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> row <span class="operator">&lt;</span> count());

     <span class="keyword">while</span> (row <span class="operator">&gt;</span> cache<span class="operator">.</span>lastIndex())
         cache<span class="operator">.</span>append(slowFetchRecord(cache<span class="operator">.</span>lastIndex()<span class="operator">+</span><span class="number">1</span>));
     <span class="keyword">while</span> (row <span class="operator">&lt;</span> cache<span class="operator">.</span>firstIndex())
         cache<span class="operator">.</span>prepend(slowFetchRecord(cache<span class="operator">.</span>firstIndex()<span class="operator">-</span><span class="number">1</span>));

     <span class="keyword">return</span> cache<span class="operator">.</span>at(row);
 }
</pre>
<p>If the cache is full then the item at the opposite end of the cache from where the new item is appended or prepended will be removed.</p>
<p>This usage can be further optimized by using the <a href="qcontiguouscache.html#insert-1" translate="no">insert</a>() function in the case where the requested row is a long way from the currently cached items. If there is a gap between where the new item is inserted and the currently cached items then the existing cached items are first removed to retain the contiguous nature of the cache. Hence it is important to take some care then when using <a href="qcontiguouscache.html#insert-1" translate="no">insert</a>() in order to avoid unwanted clearing of the cache.</p>
<p>The range of valid indexes for the QContiguousCache class are from 0 to INT_MAX. Calling <a href="qcontiguouscache.html#prepend-1" translate="no">prepend</a>() such that the first index would become less than 0 or <a href="qcontiguouscache.html#append-1" translate="no">append</a>() such that the last index would become greater than INT_MAX can result in the indexes of the cache being invalid. When the cache indexes are invalid it is important to call <a href="qcontiguouscache.html#normalizeIndexes" translate="no">normalizeIndexes</a>() before calling any of <a href="qcontiguouscache.html#containsIndex" translate="no">containsIndex</a>(), <a href="qcontiguouscache.html#firstIndex" translate="no">firstIndex</a>(), <a href="qcontiguouscache.html#lastIndex" translate="no">lastIndex</a>(), <a href="qcontiguouscache.html#at" translate="no">at</a>() or <a href="qcontiguouscache.html#operator-5b-5d" translate="no">operator[]</a>(). Calling these functions when the cache has invalid indexes will result in undefined behavior. The indexes can be checked by using <a href="qcontiguouscache.html#areIndexesValid" translate="no">areIndexesValid</a>()</p>
<p>In most cases the indexes will not exceed 0 to INT_MAX, and <a href="qcontiguouscache.html#normalizeIndexes" translate="no">normalizeIndexes</a>() will not need to be used.</p>
<p>See the <a href="qtcore-tools-contiguouscache-example.html" translate="no">Contiguous Cache</a> example.</p>
</div>
<!-- @@@QContiguousCache -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QContiguousCache[overload1]$$$QContiguousCacheqsizetype -->
<h3 class="fn" translate="no" id="QContiguousCache"><code class="details extra" translate="no">[explicit]</code> QContiguousCache::<span class="name">QContiguousCache</span>(<span class="type">qsizetype</span> <i>capacity</i> = 0)</h3>
<p>Constructs a cache with the given <i translate="no">capacity</i>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#setCapacity" translate="no">setCapacity</a>().</p>
<!-- @@@QContiguousCache -->
<!-- $$$QContiguousCache$$$QContiguousCacheconstQContiguousCache<T>& -->
<h3 class="fn" translate="no" id="QContiguousCache-1">QContiguousCache::<span class="name">QContiguousCache</span>(const <span class="type"><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p>This operation takes <a href="containers.html#constant-time" translate="no">constant time</a>, because QContiguousCache is <a href="implicit-sharing.html" translate="no">implicitly shared</a>. This makes returning a QContiguousCache from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <a href="containers.html#linear-time" translate="no">linear time</a>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QContiguousCache -->
<!-- $$$~QContiguousCache[overload1]$$$~QContiguousCache -->
<h3 class="fn" translate="no" id="dtor.QContiguousCache">QContiguousCache::<span class="name">~QContiguousCache</span>()</h3>
<p>Destroys the cache.</p>
<!-- @@@~QContiguousCache -->
<!-- $$$append$$$appendconstT& -->
<h3 class="fn" translate="no" id="append-1"><span class="type">void</span> QContiguousCache::<span class="name">append</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts <i translate="no">value</i> at the end of the cache. If the cache is already full the item at the start of the cache will be removed.</p>
<p><b>See also </b><a href="qcontiguouscache.html#prepend-1" translate="no">prepend</a>(), <a href="qcontiguouscache.html#insert-1" translate="no">insert</a>(), and <a href="qcontiguouscache.html#isFull" translate="no">isFull</a>().</p>
<!-- @@@append -->
<!-- $$$areIndexesValid[overload1]$$$areIndexesValid -->
<h3 class="fn" translate="no" id="areIndexesValid"><span class="type">bool</span> QContiguousCache::<span class="name">areIndexesValid</span>() const</h3>
<p>Returns whether the indexes for items stored in the cache are valid. Indexes can become invalid if items are appended after the index position INT_MAX or prepended before the index position 0. This is only expected to occur in very long lived circular buffer style usage of the contiguous cache. Indexes can be made valid again by calling <a href="qcontiguouscache.html#normalizeIndexes" translate="no">normalizeIndexes</a>().</p>
<p><b>See also </b><a href="qcontiguouscache.html#normalizeIndexes" translate="no">normalizeIndexes</a>(), <a href="qcontiguouscache.html#append-1" translate="no">append</a>(), and <a href="qcontiguouscache.html#prepend-1" translate="no">prepend</a>().</p>
<!-- @@@areIndexesValid -->
<!-- $$$at[overload1]$$$atqsizetype -->
<h3 class="fn" translate="no" id="at">const <span class="type">T</span> &amp;QContiguousCache::<span class="name">at</span>(<span class="type">qsizetype</span> <i>i</i>) const</h3>
<p>Returns the item at index position <i translate="no">i</i> in the cache. <i translate="no">i</i> must be a valid index position in the cache (i.e, <a href="qcontiguouscache.html#firstIndex" translate="no">firstIndex</a>() &lt;= <i translate="no">i</i> &lt;= <a href="qcontiguouscache.html#lastIndex" translate="no">lastIndex</a>()).</p>
<p>The indexes in the cache refer to the number of positions the item is from the first item appended into the cache. That is to say a cache with a capacity of 100, that has had 150 items appended will have a valid index range of 50 to 149. This allows inserting and retrieving items into the cache based on a theoretical infinite list</p>
<p><b>See also </b><a href="qcontiguouscache.html#firstIndex" translate="no">firstIndex</a>(), <a href="qcontiguouscache.html#lastIndex" translate="no">lastIndex</a>(), <a href="qcontiguouscache.html#insert-1" translate="no">insert</a>(), and <a href="qcontiguouscache.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$available[overload1]$$$available -->
<h3 class="fn" translate="no" id="available"><span class="type">qsizetype</span> QContiguousCache::<span class="name">available</span>() const</h3>
<p>Returns the number of items that can be added to the cache before it becomes full.</p>
<p><b>See also </b><a href="qcontiguouscache.html#size" translate="no">size</a>(), <a href="qcontiguouscache.html#capacity" translate="no">capacity</a>(), and <a href="qcontiguouscache.html#isFull" translate="no">isFull</a>().</p>
<!-- @@@available -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" translate="no" id="capacity"><span class="type">qsizetype</span> QContiguousCache::<span class="name">capacity</span>() const</h3>
<p>Returns the number of items the cache can store before it is full. When a cache contains a number of items equal to its capacity, adding new items will cause items farthest from the added item to be removed.</p>
<p><b>See also </b><a href="qcontiguouscache.html#setCapacity" translate="no">setCapacity</a>() and <a href="qcontiguouscache.html#size" translate="no">size</a>().</p>
<!-- @@@capacity -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QContiguousCache::<span class="name">clear</span>()</h3>
<p>Removes all items from the cache. The capacity is unchanged.</p>
<!-- @@@clear -->
<!-- $$$containsIndex[overload1]$$$containsIndexqsizetype -->
<h3 class="fn" translate="no" id="containsIndex"><span class="type">bool</span> QContiguousCache::<span class="name">containsIndex</span>(<span class="type">qsizetype</span> <i>i</i>) const</h3>
<p>Returns <code translate="no">true</code> if the cache's index range includes the given index <i translate="no">i</i>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#firstIndex" translate="no">firstIndex</a>() and <a href="qcontiguouscache.html#lastIndex" translate="no">lastIndex</a>().</p>
<!-- @@@containsIndex -->
<!-- $$$count[overload1]$$$count -->
<h3 class="fn" translate="no" id="count"><span class="type">qsizetype</span> QContiguousCache::<span class="name">count</span>() const</h3>
<p>Same as <a href="qcontiguouscache.html#size" translate="no">size</a>().</p>
<!-- @@@count -->
<!-- $$$first[overload1]$$$first -->
<h3 class="fn" translate="no" id="first"><span class="type">T</span> &amp;QContiguousCache::<span class="name">first</span>()</h3>
<p>Returns a reference to the first item in the cache. This function assumes that the cache isn't empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#last" translate="no">last</a>() and <a href="qcontiguouscache.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@first -->
<!-- $$$first$$$first -->
<h3 class="fn" translate="no" id="first-1">const <span class="type">T</span> &amp;QContiguousCache::<span class="name">first</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@first -->
<!-- $$$firstIndex[overload1]$$$firstIndex -->
<h3 class="fn" translate="no" id="firstIndex"><span class="type">qsizetype</span> QContiguousCache::<span class="name">firstIndex</span>() const</h3>
<p>Returns the first valid index in the cache. The index will be invalid if the cache is empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#capacity" translate="no">capacity</a>(), <a href="qcontiguouscache.html#size" translate="no">size</a>(), and <a href="qcontiguouscache.html#lastIndex" translate="no">lastIndex</a>().</p>
<!-- @@@firstIndex -->
<!-- $$$insert$$$insertqsizetypeconstT& -->
<h3 class="fn" translate="no" id="insert-1"><span class="type">void</span> QContiguousCache::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts the <i translate="no">value</i> at the index position <i translate="no">i</i>. If the cache already contains an item at <i translate="no">i</i> then that value is replaced. If <i translate="no">i</i> is either one more than <a href="qcontiguouscache.html#lastIndex" translate="no">lastIndex</a>() or one less than <a href="qcontiguouscache.html#firstIndex" translate="no">firstIndex</a>() it is the equivalent to an <a href="qcontiguouscache.html#append-1" translate="no">append</a>() or a <a href="qcontiguouscache.html#prepend-1" translate="no">prepend</a>().</p>
<p>If the given index <i translate="no">i</i> is not within the current range of the cache nor adjacent to the bounds of the cache's index range, the cache is first cleared before inserting the item. At this point the cache will have a size of 1. It is worthwhile taking effort to insert items in an order that starts adjacent to the current index range for the cache.</p>
<p>The range of valid indexes for the <a href="qcontiguouscache.html" translate="no">QContiguousCache</a> class are from 0 to INT_MAX. Inserting outside of this range has undefined behavior.</p>
<p><b>See also </b><a href="qcontiguouscache.html#prepend-1" translate="no">prepend</a>(), <a href="qcontiguouscache.html#append-1" translate="no">append</a>(), <a href="qcontiguouscache.html#isFull" translate="no">isFull</a>(), <a href="qcontiguouscache.html#firstIndex" translate="no">firstIndex</a>(), and <a href="qcontiguouscache.html#lastIndex" translate="no">lastIndex</a>().</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" translate="no" id="isEmpty"><span class="type">bool</span> QContiguousCache::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code translate="no">true</code> if no items are stored within the cache.</p>
<p><b>See also </b><a href="qcontiguouscache.html#size" translate="no">size</a>() and <a href="qcontiguouscache.html#capacity" translate="no">capacity</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$isFull[overload1]$$$isFull -->
<h3 class="fn" translate="no" id="isFull"><span class="type">bool</span> QContiguousCache::<span class="name">isFull</span>() const</h3>
<p>Returns <code translate="no">true</code> if the number of items stored within the cache is equal to the capacity of the cache.</p>
<p><b>See also </b><a href="qcontiguouscache.html#size" translate="no">size</a>() and <a href="qcontiguouscache.html#capacity" translate="no">capacity</a>().</p>
<!-- @@@isFull -->
<!-- $$$last[overload1]$$$last -->
<h3 class="fn" translate="no" id="last"><span class="type">T</span> &amp;QContiguousCache::<span class="name">last</span>()</h3>
<p>Returns a reference to the last item in the cache. This function assumes that the cache isn't empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#first" translate="no">first</a>() and <a href="qcontiguouscache.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@last -->
<!-- $$$last$$$last -->
<h3 class="fn" translate="no" id="last-1">const <span class="type">T</span> &amp;QContiguousCache::<span class="name">last</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@last -->
<!-- $$$lastIndex[overload1]$$$lastIndex -->
<h3 class="fn" translate="no" id="lastIndex"><span class="type">qsizetype</span> QContiguousCache::<span class="name">lastIndex</span>() const</h3>
<p>Returns the last valid index in the cache. The index will be invalid if the cache is empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#capacity" translate="no">capacity</a>(), <a href="qcontiguouscache.html#size" translate="no">size</a>(), and <a href="qcontiguouscache.html#firstIndex" translate="no">firstIndex</a>().</p>
<!-- @@@lastIndex -->
<!-- $$$normalizeIndexes[overload1]$$$normalizeIndexes -->
<h3 class="fn" translate="no" id="normalizeIndexes"><span class="type">void</span> QContiguousCache::<span class="name">normalizeIndexes</span>()</h3>
<p>Moves the first index and last index of the cache such that they point to valid indexes. The function does not modify the contents of the cache or the ordering of elements within the cache.</p>
<p>It is provided so that index overflows can be corrected when using the cache as a circular buffer.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> cache(<span class="number">10</span>);
 cache<span class="operator">.</span>insert(INT_MAX<span class="operator">,</span> <span class="number">1</span>); <span class="comment">// cache contains one value and has valid indexes, INT_MAX to INT_MAX</span>
 cache<span class="operator">.</span>append(<span class="number">2</span>); <span class="comment">// cache contains two values but does not have valid indexes.</span>
 cache<span class="operator">.</span>normalizeIndexes(); <span class="comment">// cache has two values, 1 and 2.  New first index will be in the range of 0 to capacity().</span>
</pre>
<p><b>See also </b><a href="qcontiguouscache.html#areIndexesValid" translate="no">areIndexesValid</a>(), <a href="qcontiguouscache.html#append-1" translate="no">append</a>(), and <a href="qcontiguouscache.html#prepend-1" translate="no">prepend</a>().</p>
<!-- @@@normalizeIndexes -->
<!-- $$$prepend$$$prependconstT& -->
<h3 class="fn" translate="no" id="prepend-1"><span class="type">void</span> QContiguousCache::<span class="name">prepend</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts <i translate="no">value</i> at the start of the cache. If the cache is already full the item at the end of the cache will be removed.</p>
<p><b>See also </b><a href="qcontiguouscache.html#append-1" translate="no">append</a>(), <a href="qcontiguouscache.html#insert-1" translate="no">insert</a>(), and <a href="qcontiguouscache.html#isFull" translate="no">isFull</a>().</p>
<!-- @@@prepend -->
<!-- $$$removeFirst[overload1]$$$removeFirst -->
<h3 class="fn" translate="no" id="removeFirst"><span class="type">void</span> QContiguousCache::<span class="name">removeFirst</span>()</h3>
<p>Removes the first item from the cache. This function assumes that the cache isn't empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#removeLast" translate="no">removeLast</a>().</p>
<!-- @@@removeFirst -->
<!-- $$$removeLast[overload1]$$$removeLast -->
<h3 class="fn" translate="no" id="removeLast"><span class="type">void</span> QContiguousCache::<span class="name">removeLast</span>()</h3>
<p>Removes the last item from the cache. This function assumes that the cache isn't empty.</p>
<p><b>See also </b><a href="qcontiguouscache.html#removeFirst" translate="no">removeFirst</a>().</p>
<!-- @@@removeLast -->
<!-- $$$setCapacity[overload1]$$$setCapacityqsizetype -->
<h3 class="fn" translate="no" id="setCapacity"><span class="type">void</span> QContiguousCache::<span class="name">setCapacity</span>(<span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Sets the capacity of the cache to the given <i translate="no">size</i>. A cache can hold a number of items equal to its capacity. When inserting, appending or prepending items to the cache, if the cache is already full then the item farthest from the added item will be removed.</p>
<p>If the given <i translate="no">size</i> is smaller than the current count of items in the cache then only the last <i translate="no">size</i> items from the cache will remain.</p>
<p><b>See also </b><a href="qcontiguouscache.html#capacity" translate="no">capacity</a>() and <a href="qcontiguouscache.html#isFull" translate="no">isFull</a>().</p>
<!-- @@@setCapacity -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><span class="type">qsizetype</span> QContiguousCache::<span class="name">size</span>() const</h3>
<p>Returns the number of items contained within the cache.</p>
<p><b>See also </b><a href="qcontiguouscache.html#capacity" translate="no">capacity</a>().</p>
<!-- @@@size -->
<!-- $$$swap[overload1]$$$swapQContiguousCache<T>& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QContiguousCache::<span class="name">swap</span>(<span class="type"><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Swaps cache <i translate="no">other</i> with this cache. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$takeFirst[overload1]$$$takeFirst -->
<h3 class="fn" translate="no" id="takeFirst"><span class="type">T</span> QContiguousCache::<span class="name">takeFirst</span>()</h3>
<p>Removes the first item in the cache and returns it. This function assumes that the cache isn't empty.</p>
<p>If you don't use the return value, <a href="qcontiguouscache.html#removeFirst" translate="no">removeFirst</a>() is more efficient.</p>
<p><b>See also </b><a href="qcontiguouscache.html#takeLast" translate="no">takeLast</a>() and <a href="qcontiguouscache.html#removeFirst" translate="no">removeFirst</a>().</p>
<!-- @@@takeFirst -->
<!-- $$$takeLast[overload1]$$$takeLast -->
<h3 class="fn" translate="no" id="takeLast"><span class="type">T</span> QContiguousCache::<span class="name">takeLast</span>()</h3>
<p>Removes the last item in the cache and returns it. This function assumes that the cache isn't empty.</p>
<p>If you don't use the return value, <a href="qcontiguouscache.html#removeLast" translate="no">removeLast</a>() is more efficient.</p>
<p><b>See also </b><a href="qcontiguouscache.html#takeFirst" translate="no">takeFirst</a>() and <a href="qcontiguouscache.html#removeLast" translate="no">removeLast</a>().</p>
<!-- @@@takeLast -->
<!-- $$$operator!=[overload1]$$$operator!=constQContiguousCache<T>& -->
<h3 class="fn" translate="no" id="operator-not-eq"><span class="type">bool</span> QContiguousCache::<span class="name">operator!=</span>(const <span class="type"><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is not equal to this cache; otherwise returns <code translate="no">false</code>.</p>
<p>Two caches are considered equal if they contain the same values at the same indexes. This function requires the value type to implement the <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator=[overload1]$$$operator=constQContiguousCache<T>& -->
<h3 class="fn" translate="no" id="operator-eq"><span class="type"><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></span>&lt;<span class="type">T</span>&gt; &amp;QContiguousCache::<span class="name">operator=</span>(const <span class="type"><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Assigns <i translate="no">other</i> to this cache and returns a reference to this cache.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QContiguousCache<T>&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></span>&lt;<span class="type">T</span>&gt; &amp;QContiguousCache::<span class="name">operator=</span>(<span class="type"><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qcontiguouscache.html" translate="no">QContiguousCache</a> instance.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQContiguousCache<T>& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><span class="type">bool</span> QContiguousCache::<span class="name">operator==</span>(const <span class="type"><a href="qcontiguouscache.html#QContiguousCache" translate="no">QContiguousCache</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is equal to this cache; otherwise returns <code translate="no">false</code>.</p>
<p>Two caches are considered equal if they contain the same values at the same indexes. This function requires the value type to implement the <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qcontiguouscache.html#operator-not-eq" translate="no">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator[][overload1]$$$operator[]qsizetype -->
<h3 class="fn" translate="no" id="operator-5b-5d"><span class="type">T</span> &amp;QContiguousCache::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>i</i>)</h3>
<p>Returns the item at index position <i translate="no">i</i> as a modifiable reference. If the cache does not contain an item at the given index position <i translate="no">i</i> then it will first insert an empty item at that position.</p>
<p>In most cases it is better to use either <a href="qcontiguouscache.html#at" translate="no">at</a>() or <a href="qcontiguouscache.html#insert-1" translate="no">insert</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This non-const overload of operator[] requires <a href="qcontiguouscache.html" translate="no">QContiguousCache</a> to make a deep copy. Use <a href="qcontiguouscache.html#at" translate="no">at</a>() for read-only access to a non-const <a href="qcontiguouscache.html" translate="no">QContiguousCache</a>.</p>
</div>
<p><b>See also </b><a href="qcontiguouscache.html#insert-1" translate="no">insert</a>() and <a href="qcontiguouscache.html#at" translate="no">at</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]qsizetype -->
<h3 class="fn" translate="no" id="operator-5b-5d-1">const <span class="type">T</span> &amp;QContiguousCache::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>i</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Same as at(<i translate="no">i</i>).</p>
<!-- @@@operator[] -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
