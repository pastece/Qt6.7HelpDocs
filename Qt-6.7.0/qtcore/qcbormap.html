<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qcbormap.cpp -->
  <meta name="description" content="The QCborMap class is used to hold an associative container representable in CBOR.">
  <title>QCborMap Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QCborMap</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QCborMap Class</h1>
<!-- $$$QCborMap-brief -->
<p>The QCborMap class is used to hold an associative container representable in CBOR. <a href="#details">More...</a></p>
<!-- @@@QCborMap -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QCborMap&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qcbormap-members.html">List of all members, including inherited members</a></li>
<li>QCborMap is part of <a href="cbor.html">CBOR Support in Qt</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qcbormap-constiterator.html" translate="no">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qcbormap-iterator.html" translate="no">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#const_iterator-typedef" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#iterator-typedef" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#key_type-typedef" translate="no">key_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#mapped_type-typedef" translate="no">mapped_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#value_type-typedef" translate="no">value_type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#QCborMap-2" translate="no">QCborMap</a></b>(std::initializer_list&lt;QCborMap::value_type&gt; <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#QCborMap-1" translate="no">QCborMap</a></b>(const QCborMap &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#dtor.QCborMap" translate="no">~QCborMap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#compare" translate="no">compare</a></b>(const QCborMap &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#constFind" translate="no">constFind</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#constFind-1" translate="no">constFind</a></b>(QLatin1StringView <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#constFind-2" translate="no">constFind</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#constFind-3" translate="no">constFind</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#contains" translate="no">contains</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#contains-1" translate="no">contains</a></b>(QLatin1StringView <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#contains-2" translate="no">contains</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#contains-3" translate="no">contains</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#erase" translate="no">erase</a></b>(QCborMap::const_iterator <i>it</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#erase-1" translate="no">erase</a></b>(QCborMap::iterator <i>it</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#extract" translate="no">extract</a></b>(QCborMap::iterator <i>it</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#extract-1" translate="no">extract</a></b>(QCborMap::const_iterator <i>it</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#find" translate="no">find</a></b>(qint64 <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#find-1" translate="no">find</a></b>(QLatin1StringView <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#find-2" translate="no">find</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#find-3" translate="no">find</a></b>(const QCborValue &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#find-4" translate="no">find</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#find-5" translate="no">find</a></b>(QLatin1StringView <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#find-6" translate="no">find</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#find-7" translate="no">find</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#insert" translate="no">insert</a></b>(qint64 <i>key</i>, const QCborValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#insert-1" translate="no">insert</a></b>(QLatin1StringView <i>key</i>, const QCborValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#insert-2" translate="no">insert</a></b>(const QString &amp;<i>key</i>, const QCborValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#insert-3" translate="no">insert</a></b>(const QCborValue &amp;<i>key</i>, const QCborValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#insert-4" translate="no">insert</a></b>(QCborMap::value_type <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QCborValue&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#keys" translate="no">keys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#remove" translate="no">remove</a></b>(qint64 <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#remove-1" translate="no">remove</a></b>(QLatin1StringView <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#remove-2" translate="no">remove</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#remove-3" translate="no">remove</a></b>(const QCborValue &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#swap" translate="no">swap</a></b>(QCborMap &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#take" translate="no">take</a></b>(qint64 <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#take-1" translate="no">take</a></b>(QLatin1StringView <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#take-2" translate="no">take</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#take-3" translate="no">take</a></b>(const QCborValue &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#toCborValue" translate="no">toCborValue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJsonObject </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#toJsonObject" translate="no">toJsonObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariantHash </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#toVariantHash" translate="no">toVariantHash</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariantMap </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#toVariantMap" translate="no">toVariantMap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#value" translate="no">value</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#value-1" translate="no">value</a></b>(QLatin1StringView <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#value-2" translate="no">value</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#value-3" translate="no">value</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-not-eq" translate="no">operator!=</a></b>(const QCborMap &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-lt" translate="no">operator&lt;</a></b>(const QCborMap &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap &amp;</td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-eq" translate="no">operator=</a></b>(const QCborMap &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-eq-eq" translate="no">operator==</a></b>(const QCborMap &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a></b>(QLatin1StringView <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QCborValue </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValueRef </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-5b-5d-5" translate="no">operator[]</a></b>(qint64 <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValueRef </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-5b-5d-6" translate="no">operator[]</a></b>(QLatin1StringView <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValueRef </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-5b-5d-7" translate="no">operator[]</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValueRef </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#operator-5b-5d-8" translate="no">operator[]</a></b>(const QCborValue &amp;<i>key</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#fromJsonObject" translate="no">fromJsonObject</a></b>(const QJsonObject &amp;<i>obj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> QCborMap </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#fromJsonObject-1" translate="no">fromJsonObject</a></b>(QJsonObject &amp;&amp;<i>obj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#fromVariantHash" translate="no">fromVariantHash</a></b>(const QVariantHash &amp;<i>hash</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap </td><td class="memItemRight bottomAlign"><b><a href="qcbormap.html#fromVariantMap" translate="no">fromVariantMap</a></b>(const QVariantMap &amp;<i>map</i>)</td></tr>
</table></div>
<!-- $$$QCborMap-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>This class can be used to hold an associative container in CBOR, a map between a key and a value type. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is a superset of JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <a href="https://datatracker.ietf.org/doc/html/rfc7252" translate="no">CoAP protocol</a>.</p>
<p>Unlike JSON and <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a>, CBOR map keys can be of any type, not just strings. For that reason, QCborMap is effectively a map between <a href="qcborvalue.html" translate="no">QCborValue</a> keys to <a href="qcborvalue.html" translate="no">QCborValue</a> value elements.</p>
<p>However, for all member functions that take a key parameter, QCborMap provides overloads that will work efficiently with integers and strings. In fact, the use of integer keys is encouraged, since they occupy fewer bytes to transmit and are simpler to encode and decode. Newer protocols designed by the IETF CoRE WG to work specifically with CBOR are known to use them.</p>
<p>QCborMap is not sorted, because of that, searching for keys has linear complexity (O(n)). QCborMap actually keeps the elements in the order that they were inserted, which means that it is possible to make sorted QCborMaps by carefully inserting elements in sorted order. CBOR does not require sorting, but recommends it.</p>
<p>QCborMap can also be converted to and from <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> and <a href="qjsonobject.html" translate="no">QJsonObject</a>. However, when performing the conversion, any non-string keys will be stringified using a one-way method that the conversion back to QCborMap will not undo.</p>
</div>
<p><b>See also </b><a href="qcborarray.html" translate="no">QCborArray</a>, <a href="qcborvalue.html" translate="no">QCborValue</a>, <a href="qjsondocument.html" translate="no">QJsonDocument</a>, <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a>, <a href="qtcore-serialization-cbordump-example.html" translate="no">Parsing and displaying CBOR data</a>, <a href="qtcore-serialization-convert-example.html" translate="no">Serialization Converter</a>, and <a href="qtcore-serialization-savegame-example.html" translate="no">Saving and Loading a Game</a>.</p>
<!-- @@@QCborMap -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$const_iterator -->
<h3 class="fn" translate="no" id="const_iterator-typedef">QCborMap::<span class="name">const_iterator</span></h3>
<p>A synonym for <a href="qcbormap-constiterator.html" translate="no">QCborMap::ConstIterator</a></p>
<!-- @@@const_iterator -->
<!-- $$$iterator -->
<h3 class="fn" translate="no" id="iterator-typedef">QCborMap::<span class="name">iterator</span></h3>
<p>A synonym for <a href="qcbormap-iterator.html" translate="no">QCborMap::Iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$key_type -->
<h3 class="fn" translate="no" id="key_type-typedef">QCborMap::<span class="name">key_type</span></h3>
<p>The key type for this map. Since <a href="qcbormap.html" translate="no">QCborMap</a> keys can be any CBOR type, this is a <a href="qcborvalue.html" translate="no">QCborValue</a>.</p>
<!-- @@@key_type -->
<!-- $$$mapped_type -->
<h3 class="fn" translate="no" id="mapped_type-typedef">QCborMap::<span class="name">mapped_type</span></h3>
<p>The type that is mapped to (the value), that is, a <a href="qcborvalue.html" translate="no">QCborValue</a>.</p>
<!-- @@@mapped_type -->
<!-- $$$size_type -->
<h3 class="fn" translate="no" id="size_type-typedef">QCborMap::<span class="name">size_type</span></h3>
<p>The type that <a href="qcbormap.html" translate="no">QCborMap</a> uses for sizes.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" translate="no" id="value_type-typedef">QCborMap::<span class="name">value_type</span></h3>
<p>The value that is stored in this container: a pair of QCborValues</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="find"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>)</h3><h3 class="fn fngroupitem" translate="no" id="find-4"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const</h3></div>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap.html#end" translate="no">end</a>().</p>
<p>CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#constFind" translate="no">constFind</a>(qint64), <a href="qcbormap.html#remove" translate="no">remove</a>(qint64), <a href="qcbormap.html#contains" translate="no">contains</a>(qint64), <a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), and <a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="find-1"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>)</h3><h3 class="fn fngroupitem" translate="no" id="find-5"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>) const</h3></div>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap.html#end" translate="no">end</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), <a href="qcbormap.html#constFind-1" translate="no">constFind</a>(QLatin1StringView), <a href="qcbormap.html#remove-1" translate="no">remove</a>(QLatin1StringView), <a href="qcbormap.html#contains-1" translate="no">contains</a>(QLatin1StringView), <a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), and <a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="find-2"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>)</h3><h3 class="fn fngroupitem" translate="no" id="find-6"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>) const</h3></div>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap.html#end" translate="no">end</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), <a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="qcbormap.html#constFind-2" translate="no">constFind</a>(const QString &amp;), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), <a href="qcbormap.html#contains-2" translate="no">contains</a>(const QString &amp;), <a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), and <a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="find-3"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>)</h3><h3 class="fn fngroupitem" translate="no" id="find-7"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>) const</h3></div>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap.html#end" translate="no">end</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="qcbormap.html#constFind-3" translate="no">constFind</a>(const QCborValue &amp;), <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;), <a href="qcbormap.html#contains-3" translate="no">contains</a>(const QCborValue &amp;), <a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), and <a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="extract-1"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">extract</span>(<span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> <i>it</i>)</h3><h3 class="fn fngroupitem" translate="no" id="extract"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">extract</span>(<span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> <i>it</i>)</h3></div>
<p>Extracts a value from the map at the position indicated by iterator <i translate="no">it</i> and returns the value so extracted.</p>
<p><b>See also </b><a href="qcbormap.html#insert" translate="no">insert</a>(), <a href="qcbormap.html#erase" translate="no">erase</a>(), <a href="qcbormap.html#take" translate="no">take</a>(), and <a href="qcbormap.html#remove" translate="no">remove</a>().</p>
<!-- @@@ -->
<!-- $$$QCborMap[overload1]$$$QCborMap -->
<h3 class="fn" translate="no" id="QCborMap"><code class="details extra" translate="no">[noexcept]</code> QCborMap::<span class="name">QCborMap</span>()</h3>
<p>Constructs an empty CBOR Map object.</p>
<p><b>See also </b><a href="qcbormap.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@QCborMap -->
<!-- $$$QCborMap$$$QCborMapstd::initializer_list<QCborMap::value_type> -->
<h3 class="fn" translate="no" id="QCborMap-2">QCborMap::<span class="name">QCborMap</span>(<span class="type">std::initializer_list</span>&lt;<span class="type"><a href="qcbormap.html#value_type-typedef" translate="no">QCborMap::value_type</a></span>&gt; <i>args</i>)</h3>
<p>Constructs a QCborMap with items from a brace-initialization list found in <i translate="no">args</i>, as in the following example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> map <span class="operator">=</span> {
     {<span class="number">0</span><span class="operator">,</span> <span class="string">&quot;Hello&quot;</span>}<span class="operator">,</span>
     {<span class="number">1</span><span class="operator">,</span> <span class="string">&quot;World&quot;</span>}<span class="operator">,</span>
     {<span class="string">&quot;foo&quot;</span><span class="operator">,</span> nullptr}<span class="operator">,</span>
     {<span class="string">&quot;bar&quot;</span><span class="operator">,</span> <span class="type"><a href="qcborarray.html" translate="no">QCborArray</a></span>{<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">4</span>}}
 };
</pre>
<!-- @@@QCborMap -->
<!-- $$$QCborMap$$$QCborMapconstQCborMap& -->
<h3 class="fn" translate="no" id="QCborMap-1"><code class="details extra" translate="no">[noexcept]</code> QCborMap::<span class="name">QCborMap</span>(const <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>)</h3>
<p>Creates a QCborMap object that is a copy of <i translate="no">other</i>.</p>
<!-- @@@QCborMap -->
<!-- $$$~QCborMap[overload1]$$$~QCborMap -->
<h3 class="fn" translate="no" id="dtor.QCborMap"><code class="details extra" translate="no">[noexcept]</code> QCborMap::<span class="name">~QCborMap</span>()</h3>
<p>Destroys this <a href="qcbormap.html" translate="no">QCborMap</a> object and frees any associated resources it owns.</p>
<!-- @@@~QCborMap -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" translate="no" id="begin"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">begin</span>()</h3>
<p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="qcbormap.html#end" translate="no">end</a>().</p>
<p><b>See also </b><a href="qcbormap.html#constBegin" translate="no">constBegin</a>() and <a href="qcbormap.html#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" translate="no" id="begin-1"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">begin</span>() const</h3>
<p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="qcbormap.html#begin" translate="no">begin</a>() and <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@begin -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" translate="no" id="cbegin"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">cbegin</span>() const</h3>
<p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="qcbormap.html#begin" translate="no">begin</a>() and <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" translate="no" id="cend"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">cend</span>() const</h3>
<p>Returns a map iterator representing an element just past the last element in the map.</p>
<p><b>See also </b><a href="qcbormap.html#begin" translate="no">begin</a>(), <a href="qcbormap.html#constBegin" translate="no">constBegin</a>(), <a href="qcbormap.html#find" translate="no">find</a>(), and <a href="qcbormap.html#constFind" translate="no">constFind</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QCborMap::<span class="name">clear</span>()</h3>
<p>Empties this map.</p>
<p><b>See also </b><a href="qcbormap.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@clear -->
<!-- $$$compare[overload1]$$$compareconstQCborMap& -->
<h3 class="fn" translate="no" id="compare"><code class="details extra" translate="no">[noexcept]</code> <span class="type">int</span> QCborMap::<span class="name">compare</span>(const <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>) const</h3>
<p>Compares this map and <i translate="no">other</i>, comparing each element in sequence, and returns an integer that indicates whether this map should be sorted prior to (if the result is negative) or after <i translate="no">other</i> (if the result is positive). If this function returns 0, the two maps are equal and contain the same elements.</p>
<p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p>
<p>For more information on CBOR sorting order, see <a href="qcborvalue.html#compare" translate="no">QCborValue::compare</a>().</p>
<p><b>See also </b><a href="qcborvalue.html#compare" translate="no">QCborValue::compare</a>(), <a href="qcborarray.html#compare" translate="no">QCborArray::compare</a>(), and <a href="qcbormap.html#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@compare -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" translate="no" id="constBegin"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constBegin</span>() const</h3>
<p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="qcbormap.html#begin" translate="no">begin</a>() and <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" translate="no" id="constEnd"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constEnd</span>() const</h3>
<p>Returns a map iterator representing an element just past the last element in the map.</p>
<p><b>See also </b><a href="qcbormap.html#begin" translate="no">begin</a>(), <a href="qcbormap.html#constBegin" translate="no">constBegin</a>(), <a href="qcbormap.html#find" translate="no">find</a>(), and <a href="qcbormap.html#constFind" translate="no">constFind</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind[overload1]$$$constFindqint64 -->
<h3 class="fn" translate="no" id="constFind"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const</h3>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<p>CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#find" translate="no">find</a>(qint64), <a href="qcbormap.html#remove" translate="no">remove</a>(qint64), <a href="qcbormap.html#contains" translate="no">contains</a>(qint64), <a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), and <a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;).</p>
<!-- @@@constFind -->
<!-- $$$constFind$$$constFindQLatin1StringView -->
<h3 class="fn" translate="no" id="constFind-1"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), <a href="qcbormap.html#find-1" translate="no">find</a>(QLatin1StringView), <a href="qcbormap.html#remove-1" translate="no">remove</a>(QLatin1StringView), <a href="qcbormap.html#contains-1" translate="no">contains</a>(QLatin1StringView), <a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), and <a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;).</p>
<!-- @@@constFind -->
<!-- $$$constFind$$$constFindconstQString& -->
<h3 class="fn" translate="no" id="constFind-2"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), <a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="qcbormap.html#find-2" translate="no">find</a>(const QString &amp;), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), <a href="qcbormap.html#contains-2" translate="no">contains</a>(const QString &amp;), <a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), and <a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;).</p>
<!-- @@@constFind -->
<!-- $$$constFind$$$constFindconstQCborValue& -->
<h3 class="fn" translate="no" id="constFind-3"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap.html#constEnd" translate="no">constEnd</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="qcbormap.html#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;), <a href="qcbormap.html#contains-3" translate="no">contains</a>(const QCborValue &amp;), <a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), and <a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;).</p>
<!-- @@@constFind -->
<!-- $$$contains[overload1]$$$containsqint64 -->
<h3 class="fn" translate="no" id="contains"><span class="type">bool</span> QCborMap::<span class="name">contains</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const</h3>
<p>Returns true if this map contains a key-value pair identified by key <i translate="no">key</i>. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p><b>See also </b><a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#find" translate="no">find</a>(qint64), <a href="qcbormap.html#remove" translate="no">remove</a>(qint64), <a href="qcbormap.html#contains-1" translate="no">contains</a>(QLatin1StringView), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;).</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsQLatin1StringView -->
<h3 class="fn" translate="no" id="contains-1"><span class="type">bool</span> QCborMap::<span class="name">contains</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns true if this map contains a key-value pair identified by key <i translate="no">key</i>.</p>
<p><b>See also </b><a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), <a href="qcbormap.html#find-1" translate="no">find</a>(QLatin1StringView), <a href="qcbormap.html#remove-1" translate="no">remove</a>(QLatin1StringView), <a href="qcbormap.html#contains" translate="no">contains</a>(qint64), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;).</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQString& -->
<h3 class="fn" translate="no" id="contains-2"><span class="type">bool</span> QCborMap::<span class="name">contains</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns true if this map contains a key-value pair identified by key <i translate="no">key</i>.</p>
<p><b>See also </b><a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), <a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="qcbormap.html#find-2" translate="no">find</a>(const QString &amp;), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), <a href="qcbormap.html#contains" translate="no">contains</a>(qint64), <a href="qcbormap.html#remove-1" translate="no">remove</a>(QLatin1StringView), and <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;).</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQCborValue& -->
<h3 class="fn" translate="no" id="contains-3"><span class="type">bool</span> QCborMap::<span class="name">contains</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>) const</h3>
<p>Returns true if this map contains a key-value pair identified by key <i translate="no">key</i>.</p>
<p><b>See also </b><a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="qcbormap.html#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;), <a href="qcbormap.html#contains" translate="no">contains</a>(qint64), <a href="qcbormap.html#remove-1" translate="no">remove</a>(QLatin1StringView), and <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;).</p>
<!-- @@@contains -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" translate="no" id="empty"><span class="type">bool</span> QCborMap::<span class="name">empty</span>() const</h3>
<p>Synonym for <a href="qcbormap.html#isEmpty" translate="no">isEmpty</a>(). This function is provided for compatibility with generic code that uses the Standard Library API.</p>
<p>Returns true if this map is empty (<a href="qcbormap.html#size" translate="no">size</a>() == 0).</p>
<p><b>See also </b><a href="qcbormap.html#isEmpty" translate="no">isEmpty</a>() and <a href="qcbormap.html#size" translate="no">size</a>().</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">end</span>()</h3>
<p>Returns a map iterator representing an element just past the last element in the map.</p>
<p><b>See also </b><a href="qcbormap.html#begin" translate="no">begin</a>(), <a href="qcbormap.html#constBegin" translate="no">constBegin</a>(), <a href="qcbormap.html#find" translate="no">find</a>(), and <a href="qcbormap.html#constFind" translate="no">constFind</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" translate="no" id="end-1"><span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">end</span>() const</h3>
<p>Returns a map iterator representing an element just past the last element in the map.</p>
<p><b>See also </b><a href="qcbormap.html#begin" translate="no">begin</a>(), <a href="qcbormap.html#constBegin" translate="no">constBegin</a>(), <a href="qcbormap.html#find" translate="no">find</a>(), and <a href="qcbormap.html#constFind" translate="no">constFind</a>().</p>
<!-- @@@end -->
<!-- $$$erase[overload1]$$$eraseQCborMap::const_iterator -->
<h3 class="fn" translate="no" id="erase"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">erase</span>(<span class="type"><a href="qcbormap.html#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> <i>it</i>)</h3>
<p>Removes the key-value pair pointed to by the map iterator <i translate="no">it</i> and returns a pointer to the next element, after removal.</p>
<p><b>See also </b><a href="qcbormap.html#remove" translate="no">remove</a>(), <a href="qcbormap.html#begin" translate="no">begin</a>(), <a href="qcbormap.html#end" translate="no">end</a>(), <a href="qcbormap.html#insert" translate="no">insert</a>(), and <a href="qcbormap.html#extract" translate="no">extract</a>().</p>
<!-- @@@erase -->
<!-- $$$erase$$$eraseQCborMap::iterator -->
<h3 class="fn" translate="no" id="erase-1"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">erase</span>(<span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> <i>it</i>)</h3>
<p>This is an overloaded function.</p>
<p>Removes the key-value pair pointed to by the map iterator <i translate="no">it</i> and returns a pointer to the next element, after removal.</p>
<p><b>See also </b><a href="qcbormap.html#remove" translate="no">remove</a>(), <a href="qcbormap.html#begin" translate="no">begin</a>(), <a href="qcbormap.html#end" translate="no">end</a>(), and <a href="qcbormap.html#insert" translate="no">insert</a>().</p>
<!-- @@@erase -->
<!-- $$$fromJsonObject[overload1]$$$fromJsonObjectconstQJsonObject& -->
<h3 class="fn" translate="no" id="fromJsonObject"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> QCborMap::<span class="name">fromJsonObject</span>(const <span class="type"><a href="qjsonobject.html" translate="no">QJsonObject</a></span> &amp;<i>obj</i>)</h3>
<p>Converts all JSON items found in the <i translate="no">obj</i> object to CBOR using QCborValue::fromJson(), and returns the map composed of those elements.</p>
<p>This conversion is lossless, as the CBOR type system is a superset of JSON's. Moreover, the map returned by this function can be converted back to the original <i translate="no">obj</i> by using <a href="qcbormap.html#toJsonObject" translate="no">toJsonObject</a>().</p>
<p><b>See also </b><a href="qcbormap.html#toJsonObject" translate="no">toJsonObject</a>(), <a href="qcbormap.html#toVariantMap" translate="no">toVariantMap</a>(), <a href="qcborvalue.html#fromJsonValue" translate="no">QCborValue::fromJsonValue</a>(), and <a href="qcborarray.html#fromJsonArray" translate="no">QCborArray::fromJsonArray</a>().</p>
<!-- @@@fromJsonObject -->
<!-- $$$fromJsonObject$$$fromJsonObjectQJsonObject&& -->
<h3 class="fn" translate="no" id="fromJsonObject-1"><code class="details extra" translate="no">[static noexcept, since 6.3]</code> <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> QCborMap::<span class="name">fromJsonObject</span>(<span class="type"><a href="qjsonobject.html" translate="no">QJsonObject</a></span> &amp;&amp;<i>obj</i>)</h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@fromJsonObject -->
<!-- $$$fromVariantHash[overload1]$$$fromVariantHashconstQVariantHash& -->
<h3 class="fn" translate="no" id="fromVariantHash"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> QCborMap::<span class="name">fromVariantHash</span>(const <span class="type">QVariantHash</span> &amp;<i>hash</i>)</h3>
<p>Converts all the items in <i translate="no">hash</i> to CBOR using <a href="qcborvalue.html#fromVariant" translate="no">QCborValue::fromVariant</a>() and returns the map composed of those elements.</p>
<p>Conversion from <a href="qvariant.html" translate="no">QVariant</a> is not completely lossless. Please see the documentation in <a href="qcborvalue.html#fromVariant" translate="no">QCborValue::fromVariant</a>() for more information.</p>
<p><b>See also </b><a href="qcbormap.html#toVariantHash" translate="no">toVariantHash</a>(), <a href="qcbormap.html#fromVariantMap" translate="no">fromVariantMap</a>(), <a href="qcbormap.html#fromJsonObject" translate="no">fromJsonObject</a>(), and <a href="qcborvalue.html#fromVariant" translate="no">QCborValue::fromVariant</a>().</p>
<!-- @@@fromVariantHash -->
<!-- $$$fromVariantMap[overload1]$$$fromVariantMapconstQVariantMap& -->
<h3 class="fn" translate="no" id="fromVariantMap"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> QCborMap::<span class="name">fromVariantMap</span>(const <span class="type">QVariantMap</span> &amp;<i>map</i>)</h3>
<p>Converts all the items in <i translate="no">map</i> to CBOR using <a href="qcborvalue.html#fromVariant" translate="no">QCborValue::fromVariant</a>() and returns the map composed of those elements.</p>
<p>Conversion from <a href="qvariant.html" translate="no">QVariant</a> is not completely lossless. Please see the documentation in <a href="qcborvalue.html#fromVariant" translate="no">QCborValue::fromVariant</a>() for more information.</p>
<p><b>See also </b><a href="qcbormap.html#toVariantMap" translate="no">toVariantMap</a>(), <a href="qcbormap.html#fromVariantHash" translate="no">fromVariantHash</a>(), <a href="qcbormap.html#fromJsonObject" translate="no">fromJsonObject</a>(), and <a href="qcborvalue.html#fromVariant" translate="no">QCborValue::fromVariant</a>().</p>
<!-- @@@fromVariantMap -->
<!-- $$$insert[overload1]$$$insertqint64constQCborValue& -->
<h3 class="fn" translate="no" id="insert"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>, const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts the key <i translate="no">key</i> and value <i translate="no">value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <i translate="no">key</i>, its value will be overwritten by <i translate="no">value</i>.</p>
<p><b>See also </b><a href="qcbormap.html#erase" translate="no">erase</a>(), <a href="qcbormap.html#remove" translate="no">remove</a>(qint64), <a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#find" translate="no">find</a>(qint64), <a href="qcbormap.html#contains" translate="no">contains</a>(qint64), <a href="qcbormap.html#take" translate="no">take</a>(qint64), and <a href="qcbormap.html#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertQLatin1StringViewconstQCborValue& -->
<h3 class="fn" translate="no" id="insert-1"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>, const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts the key <i translate="no">key</i> and value <i translate="no">value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <i translate="no">key</i>, its value will be overwritten by <i translate="no">value</i>.</p>
<p><b>See also </b><a href="qcbormap.html#erase" translate="no">erase</a>(), <a href="qcbormap.html#remove-1" translate="no">remove</a>(QLatin1StringView), <a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), <a href="qcbormap.html#find-1" translate="no">find</a>(QLatin1StringView), <a href="qcbormap.html#contains-1" translate="no">contains</a>(QLatin1StringView), <a href="qcbormap.html#take-1" translate="no">take</a>(QLatin1StringView), and <a href="qcbormap.html#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertconstQString&constQCborValue& -->
<h3 class="fn" translate="no" id="insert-2"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>, const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts the key <i translate="no">key</i> and value <i translate="no">value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <i translate="no">key</i>, its value will be overwritten by <i translate="no">value</i>.</p>
<p><b>See also </b><a href="qcbormap.html#erase" translate="no">erase</a>(), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), <a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), <a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="qcbormap.html#find-2" translate="no">find</a>(const QString &amp;), <a href="qcbormap.html#contains-2" translate="no">contains</a>(const QString &amp;), <a href="qcbormap.html#take-2" translate="no">take</a>(const QString &amp;), and <a href="qcbormap.html#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertconstQCborValue&constQCborValue& -->
<h3 class="fn" translate="no" id="insert-3"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>, const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts the key <i translate="no">key</i> and value <i translate="no">value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <i translate="no">key</i>, its value will be overwritten by <i translate="no">value</i>.</p>
<p><b>See also </b><a href="qcbormap.html#erase" translate="no">erase</a>(), <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;), <a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="qcbormap.html#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="qcbormap.html#contains-3" translate="no">contains</a>(const QCborValue &amp;), <a href="qcbormap.html#take-3" translate="no">take</a>(const QCborValue &amp;), and <a href="qcbormap.html#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertQCborMap::value_type -->
<h3 class="fn" translate="no" id="insert-4"><span class="type"><a href="qcbormap.html#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(<span class="type"><a href="qcbormap.html#value_type-typedef" translate="no">QCborMap::value_type</a></span> <i>v</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts the key-value pair in <i translate="no">v</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <code translate="no">v.first</code>, its value will be overwritten by <code translate="no">v.second</code>.</p>
<p><b>See also </b><a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>, <a href="qcbormap.html#erase" translate="no">erase</a>(), and <a href="qcbormap.html#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" translate="no" id="isEmpty"><span class="type">bool</span> QCborMap::<span class="name">isEmpty</span>() const</h3>
<p>Returns true if this map is empty (that is, <a href="qcbormap.html#size" translate="no">size</a>() is 0).</p>
<p><b>See also </b><a href="qcbormap.html#size" translate="no">size</a>() and <a href="qcbormap.html#clear" translate="no">clear</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$keys[overload1]$$$keys -->
<h3 class="fn" translate="no" id="keys"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span>&gt; QCborMap::<span class="name">keys</span>() const</h3>
<p>Returns a list of all keys in this map.</p>
<p><b>See also </b><a href="qmap.html#keys" translate="no">QMap::keys</a>() and <a href="qhash.html#keys" translate="no">QHash::keys</a>().</p>
<!-- @@@keys -->
<!-- $$$remove[overload1]$$$removeqint64 -->
<h3 class="fn" translate="no" id="remove"><span class="type">void</span> QCborMap::<span class="name">remove</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>)</h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>remove(<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>), remove(const <a href="qstring.html" translate="no">QString</a> &amp;), remove(const <a href="qcborvalue.html" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#find" translate="no">find</a>(qint64), and <a href="qcbormap.html#contains" translate="no">contains</a>(qint64).</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeQLatin1StringView -->
<h3 class="fn" translate="no" id="remove-1"><span class="type">void</span> QCborMap::<span class="name">remove</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>)</h3>
<p>This is an overloaded function.</p>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), <a href="qcbormap.html#find-1" translate="no">find</a>(QLatin1StringView), <a href="qcbormap.html#contains-1" translate="no">contains</a>(QLatin1StringView), <a href="qcbormap.html#remove" translate="no">remove</a>(qint64), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;).</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstQString& -->
<h3 class="fn" translate="no" id="remove-2"><span class="type">void</span> QCborMap::<span class="name">remove</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>)</h3>
<p>This is an overloaded function.</p>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>remove(qint64), remove(<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>), remove(const <a href="qcborvalue.html" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), <a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="qcbormap.html#find-2" translate="no">find</a>(const QString &amp;), and <a href="qcbormap.html#contains-2" translate="no">contains</a>(const QString &amp;).</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstQCborValue& -->
<h3 class="fn" translate="no" id="remove-3"><span class="type">void</span> QCborMap::<span class="name">remove</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>)</h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>remove(qint64), remove(<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>), remove(const <a href="qstring.html" translate="no">QString</a> &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="qcbormap.html#find-3" translate="no">find</a>(const QCborValue &amp;), and <a href="qcbormap.html#contains-3" translate="no">contains</a>(const QCborValue &amp;).</p>
<!-- @@@remove -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QCborMap::<span class="name">size</span>() const</h3>
<p>Returns the number of elements in this map.</p>
<p><b>See also </b><a href="qcbormap.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@size -->
<!-- $$$swap[overload1]$$$swapQCborMap& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QCborMap::<span class="name">swap</span>(<span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>)</h3>
<p>Swaps the contents of this map and <i translate="no">other</i>.</p>
<!-- @@@swap -->
<!-- $$$take[overload1]$$$takeqint64 -->
<h3 class="fn" translate="no" id="take"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">take</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>)</h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#find" translate="no">find</a>(qint64), <a href="qcbormap.html#contains" translate="no">contains</a>(qint64), <a href="qcbormap.html#take-1" translate="no">take</a>(QLatin1StringView), <a href="qcbormap.html#take-2" translate="no">take</a>(const QString &amp;), <a href="qcbormap.html#take-3" translate="no">take</a>(const QCborValue &amp;), and <a href="qcbormap.html#insert" translate="no">insert</a>().</p>
<!-- @@@take -->
<!-- $$$take$$$takeQLatin1StringView -->
<h3 class="fn" translate="no" id="take-1"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">take</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>)</h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), <a href="qcbormap.html#find-1" translate="no">find</a>(QLatin1StringView), <a href="qcbormap.html#contains-1" translate="no">contains</a>(QLatin1StringView), <a href="qcbormap.html#take" translate="no">take</a>(qint64), <a href="qcbormap.html#take-2" translate="no">take</a>(const QString &amp;), <a href="qcbormap.html#take-3" translate="no">take</a>(const QCborValue &amp;), and <a href="qcbormap.html#insert" translate="no">insert</a>().</p>
<!-- @@@take -->
<!-- $$$take$$$takeconstQString& -->
<h3 class="fn" translate="no" id="take-2"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">take</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>)</h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), <a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="qcbormap.html#find-2" translate="no">find</a>(const QString &amp;), <a href="qcbormap.html#contains-2" translate="no">contains</a>(const QString &amp;), <a href="qcbormap.html#take-1" translate="no">take</a>(QLatin1StringView), <a href="qcbormap.html#take" translate="no">take</a>(qint64), <a href="qcbormap.html#take-3" translate="no">take</a>(const QCborValue &amp;), and <a href="qcbormap.html#insert" translate="no">insert</a>().</p>
<!-- @@@take -->
<!-- $$$take$$$takeconstQCborValue& -->
<h3 class="fn" translate="no" id="take-3"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">take</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>)</h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="qcbormap.html#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="qcbormap.html#contains-3" translate="no">contains</a>(const QCborValue &amp;), <a href="qcbormap.html#take-1" translate="no">take</a>(QLatin1StringView), <a href="qcbormap.html#take-2" translate="no">take</a>(const QString &amp;), <a href="qcbormap.html#take" translate="no">take</a>(qint64), and <a href="qcbormap.html#insert" translate="no">insert</a>().</p>
<!-- @@@take -->
<!-- $$$toCborValue[overload1]$$$toCborValue -->
<h3 class="fn" translate="no" id="toCborValue"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">toCborValue</span>() const</h3>
<p>Explicitly constructs a <a href="qcborvalue.html" translate="no">QCborValue</a> object that represents this map. This function is usually not necessary since <a href="qcborvalue.html" translate="no">QCborValue</a> has a constructor for <a href="qcbormap.html" translate="no">QCborMap</a>, so the conversion is implicit.</p>
<p>Converting <a href="qcbormap.html" translate="no">QCborMap</a> to <a href="qcborvalue.html" translate="no">QCborValue</a> allows it to be used in any context where QCborValues can be used, including as keys and mapped types in <a href="qcbormap.html" translate="no">QCborMap</a>, as well as <a href="qcborvalue.html#toCbor" translate="no">QCborValue::toCbor</a>().</p>
<p><b>See also </b><a href="qcborvalue.html#QCborValue-14" translate="no">QCborValue::QCborValue</a>(const QCborMap &amp;).</p>
<!-- @@@toCborValue -->
<!-- $$$toJsonObject[overload1]$$$toJsonObject -->
<h3 class="fn" translate="no" id="toJsonObject"><span class="type"><a href="qjsonobject.html" translate="no">QJsonObject</a></span> QCborMap::<span class="name">toJsonObject</span>() const</h3>
<p>Recursively converts every <a href="qcborvalue.html" translate="no">QCborValue</a> value in this map to JSON using <a href="qcborvalue.html#toJsonValue" translate="no">QCborValue::toJsonValue</a>() and creates a string key for all keys that aren't strings, then returns the corresponding <a href="qjsonobject.html" translate="no">QJsonObject</a> composed of those associations.</p>
<p>Please note that CBOR contains a richer and wider type set than JSON, so some information may be lost in this conversion. For more details on what conversions are applied, see <a href="qcborvalue.html#toJsonValue" translate="no">QCborValue::toJsonValue</a>().</p>
<h6 id="map-key-conversion-to-string">Map key conversion to string</h6>
<p>JSON objects are defined as having string keys, unlike CBOR, so the conversion of a <a href="qcbormap.html" translate="no">QCborMap</a> to <a href="qjsonobject.html" translate="no">QJsonObject</a> will imply a step of &quot;stringification&quot; of the key values. The conversion will use the special handling of tags and extended types from above and will also convert the rest of the types as follows:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Type</th><th >Transformation</th></tr></thead>
<tr valign="top" class="odd"><td >Bool</td><td >&quot;true&quot; and &quot;false&quot;</td></tr>
<tr valign="top" class="even"><td >Null</td><td >&quot;null&quot;</td></tr>
<tr valign="top" class="odd"><td >Undefined</td><td >&quot;undefined&quot;</td></tr>
<tr valign="top" class="even"><td >Integer</td><td >The decimal string form of the number</td></tr>
<tr valign="top" class="odd"><td >Double</td><td >The decimal string form of the number</td></tr>
<tr valign="top" class="even"><td >Byte array</td><td >Unless tagged differently (see above), encoded as Base64url</td></tr>
<tr valign="top" class="odd"><td >Array</td><td >Replaced by the compact form of its <a href="qcborvalue.html#toDiagnosticNotation" translate="no">Diagnostic notation</a></td></tr>
<tr valign="top" class="even"><td >Map</td><td >Replaced by the compact form of its <a href="qcborvalue.html#toDiagnosticNotation" translate="no">Diagnostic notation</a></td></tr>
<tr valign="top" class="odd"><td >Tags and extended types</td><td >Tag number is dropped and the tagged value is converted to string</td></tr>
</table></div>
<p><b>See also </b><a href="qcbormap.html#fromJsonObject" translate="no">fromJsonObject</a>(), <a href="qcborvalue.html#toJsonValue" translate="no">QCborValue::toJsonValue</a>(), <a href="qcborarray.html#toJsonArray" translate="no">QCborArray::toJsonArray</a>(), and <a href="qcbormap.html#toVariantMap" translate="no">toVariantMap</a>().</p>
<!-- @@@toJsonObject -->
<!-- $$$toVariantHash[overload1]$$$toVariantHash -->
<h3 class="fn" translate="no" id="toVariantHash"><span class="type">QVariantHash</span> QCborMap::<span class="name">toVariantHash</span>() const</h3>
<p>Converts the CBOR values to <a href="qvariant.html" translate="no">QVariant</a> using <a href="qcborvalue.html#toVariant" translate="no">QCborValue::toVariant</a>() and &quot;stringifies&quot; all the CBOR keys in this map, returning the <a href="qvariant.html#QVariantHash-typedef" translate="no">QVariantHash</a> that results from that association list.</p>
<p>QVariantMaps have string keys, unlike CBOR, so the conversion of a <a href="qcbormap.html" translate="no">QCborMap</a> to <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> will imply a step of &quot;stringification&quot; of the key values. See <a href="qcbormap.html#toJsonObject" translate="no">QCborMap::toJsonObject</a>() for details.</p>
<p>In addition, the conversion to <a href="qvariant.html" translate="no">QVariant</a> is not completely lossless. Please see the documentation in <a href="qcborvalue.html#toVariant" translate="no">QCborValue::toVariant</a>() for more information.</p>
<p><b>See also </b><a href="qcbormap.html#fromVariantHash" translate="no">fromVariantHash</a>(), <a href="qcbormap.html#toVariantMap" translate="no">toVariantMap</a>(), <a href="qcbormap.html#toJsonObject" translate="no">toJsonObject</a>(), <a href="qcborvalue.html#toVariant" translate="no">QCborValue::toVariant</a>(), and <a href="qcborarray.html#toVariantList" translate="no">QCborArray::toVariantList</a>().</p>
<!-- @@@toVariantHash -->
<!-- $$$toVariantMap[overload1]$$$toVariantMap -->
<h3 class="fn" translate="no" id="toVariantMap"><span class="type">QVariantMap</span> QCborMap::<span class="name">toVariantMap</span>() const</h3>
<p>Converts the CBOR values to <a href="qvariant.html" translate="no">QVariant</a> using <a href="qcborvalue.html#toVariant" translate="no">QCborValue::toVariant</a>() and &quot;stringifies&quot; all the CBOR keys in this map, returning the <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> that results from that association list.</p>
<p>QVariantMaps have string keys, unlike CBOR, so the conversion of a <a href="qcbormap.html" translate="no">QCborMap</a> to <a href="qvariant.html#QVariantMap-typedef" translate="no">QVariantMap</a> will imply a step of &quot;stringification&quot; of the key values. See <a href="qcbormap.html#toJsonObject" translate="no">QCborMap::toJsonObject</a>() for details.</p>
<p>In addition, the conversion to <a href="qvariant.html" translate="no">QVariant</a> is not completely lossless. Please see the documentation in <a href="qcborvalue.html#toVariant" translate="no">QCborValue::toVariant</a>() for more information.</p>
<p><b>See also </b><a href="qcbormap.html#fromVariantMap" translate="no">fromVariantMap</a>(), <a href="qcbormap.html#toVariantHash" translate="no">toVariantHash</a>(), <a href="qcbormap.html#toJsonObject" translate="no">toJsonObject</a>(), <a href="qcborvalue.html#toVariant" translate="no">QCborValue::toVariant</a>(), and <a href="qcborarray.html#toVariantList" translate="no">QCborArray::toVariantList</a>().</p>
<!-- @@@toVariantMap -->
<!-- $$$value[overload1]$$$valueqint64 -->
<h3 class="fn" translate="no" id="value"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">value</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const</h3>
<p>Returns the <a href="qcborvalue.html" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="qcborvalue.html" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return from function will reference. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>), value(const <a href="qstring.html" translate="no">QString</a> &amp;), value(const <a href="qcborvalue.html" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#find" translate="no">find</a>(qint64), <a href="qcbormap.html#constFind" translate="no">constFind</a>(qint64), <a href="qcbormap.html#remove" translate="no">remove</a>(qint64), and <a href="qcbormap.html#contains" translate="no">contains</a>(qint64).</p>
<!-- @@@value -->
<!-- $$$value$$$valueQLatin1StringView -->
<h3 class="fn" translate="no" id="value-1"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">value</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the <a href="qcborvalue.html" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="qcborvalue.html" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(const <a href="qstring.html" translate="no">QString</a> &amp;), value(const <a href="qcborvalue.html" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), <a href="qcbormap.html#find-1" translate="no">find</a>(QLatin1StringView), <a href="qcbormap.html#constFind-1" translate="no">constFind</a>(QLatin1StringView), <a href="qcbormap.html#remove-1" translate="no">remove</a>(QLatin1StringView), and <a href="qcbormap.html#contains-1" translate="no">contains</a>(QLatin1StringView).</p>
<!-- @@@value -->
<!-- $$$value$$$valueconstQString& -->
<h3 class="fn" translate="no" id="value-2"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">value</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the <a href="qcborvalue.html" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="qcborvalue.html" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>), value(const <a href="qcborvalue.html" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="qcbormap.html#find-2" translate="no">find</a>(const QString &amp;), <a href="qcbormap.html#constFind-2" translate="no">constFind</a>(const QString &amp;), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="qcbormap.html#contains-2" translate="no">contains</a>(const QString &amp;).</p>
<!-- @@@value -->
<!-- $$$value$$$valueconstQCborValue& -->
<h3 class="fn" translate="no" id="value-3"><span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">value</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>) const</h3>
<p>Returns the <a href="qcborvalue.html" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="qcborvalue.html" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>), value(const <a href="qstring.html" translate="no">QString</a> &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="qcbormap.html#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="qcbormap.html#constFind-3" translate="no">constFind</a>(const QCborValue &amp;), <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;), and <a href="qcbormap.html#contains-3" translate="no">contains</a>(const QCborValue &amp;).</p>
<!-- @@@value -->
<!-- $$$operator!=[overload1]$$$operator!=constQCborMap& -->
<h3 class="fn" translate="no" id="operator-not-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QCborMap::<span class="name">operator!=</span>(const <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>) const</h3>
<p>Compares this map and <i translate="no">other</i>, comparing each element in sequence, and returns true if the two maps contains any different elements or elements in different orders, false otherwise.</p>
<p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p>
<p>For more information on CBOR equality in Qt, see, <a href="qcborvalue.html#compare" translate="no">QCborValue::compare</a>().</p>
<p><b>See also </b><a href="qcbormap.html#compare" translate="no">compare</a>(), <a href="qcborvalue.html#operator-eq-eq" translate="no">QCborValue::operator==</a>(), <a href="qcbormap.html#operator-eq-eq" translate="no">QCborMap::operator==</a>(), <a href="qcbormap.html#operator-eq-eq" translate="no">operator==</a>(), and <a href="qcbormap.html#operator-lt" translate="no">operator&lt;</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator<[overload1]$$$operator<constQCborMap& -->
<h3 class="fn" translate="no" id="operator-lt"><span class="type">bool</span> QCborMap::<span class="name">operator&lt;</span>(const <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>) const</h3>
<p>Compares this map and <i translate="no">other</i>, comparing each element in sequence, and returns true if this map should be sorted before <i translate="no">other</i>, false otherwise.</p>
<p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p>
<p>For more information on CBOR sorting order, see <a href="qcborvalue.html#compare" translate="no">QCborValue::compare</a>().</p>
<p><b>See also </b><a href="qcbormap.html#compare" translate="no">compare</a>(), <a href="qcborvalue.html#operator-eq-eq" translate="no">QCborValue::operator==</a>(), <a href="qcbormap.html#operator-eq-eq" translate="no">QCborMap::operator==</a>(), <a href="qcbormap.html#operator-eq-eq" translate="no">operator==</a>(), and <a href="qcbormap.html#operator-not-eq" translate="no">operator!=</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator=[overload1]$$$operator=constQCborMap& -->
<h3 class="fn" translate="no" id="operator-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> &amp;QCborMap::<span class="name">operator=</span>(const <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>)</h3>
<p>Replaces the contents of this object with a copy of <i translate="no">other</i>, then returns a reference to this object.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQCborMap& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QCborMap::<span class="name">operator==</span>(const <span class="type"><a href="qcbormap.html#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>) const</h3>
<p>Compares this map and <i translate="no">other</i>, comparing each element in sequence, and returns true if the two maps contains the same elements in the same order, false otherwise.</p>
<p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p>
<p>For more information on CBOR equality in Qt, see, <a href="qcborvalue.html#compare" translate="no">QCborValue::compare</a>().</p>
<p><b>See also </b><a href="qcbormap.html#compare" translate="no">compare</a>(), <a href="qcborvalue.html#operator-eq-eq" translate="no">QCborValue::operator==</a>(), QCborMap::operator==(), <a href="qcbormap.html#operator-not-eq" translate="no">operator!=</a>(), and <a href="qcbormap.html#operator-lt" translate="no">operator&lt;</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator[][overload1]$$$operator[]qint64 -->
<h3 class="fn" translate="no" id="operator-5b-5d">const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const</h3>
<p>Returns the <a href="qcborvalue.html" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="qcborvalue.html" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>operator[](<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>), operator[](const <a href="qstring.html" translate="no">QString</a> &amp;), operator[](const QCborOperator[] &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#find" translate="no">find</a>(qint64), <a href="qcbormap.html#constFind" translate="no">constFind</a>(qint64), <a href="qcbormap.html#remove" translate="no">remove</a>(qint64), and <a href="qcbormap.html#contains" translate="no">contains</a>(qint64).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-5b-5d-1">const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the <a href="qcborvalue.html" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="qcborvalue.html" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>operator[](qint64), operator[](const <a href="qstring.html" translate="no">QString</a> &amp;), operator[](const QCborOperator[] &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#find-1" translate="no">find</a>(QLatin1StringView), <a href="qcbormap.html#constFind-1" translate="no">constFind</a>(QLatin1StringView), <a href="qcbormap.html#remove-1" translate="no">remove</a>(QLatin1StringView), and <a href="qcbormap.html#contains-1" translate="no">contains</a>(QLatin1StringView).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constQString& -->
<h3 class="fn" translate="no" id="operator-5b-5d-2">const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the <a href="qcborvalue.html" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="qcborvalue.html" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>operator[](qint64), operator[](<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>), operator[](const QCborOperator[] &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), <a href="qcbormap.html#find-2" translate="no">find</a>(const QString &amp;), <a href="qcbormap.html#constFind-2" translate="no">constFind</a>(const QString &amp;), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="qcbormap.html#contains-2" translate="no">contains</a>(const QString &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constQCborValue& -->
<h3 class="fn" translate="no" id="operator-5b-5d-3">const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>) const</h3>
<p>Returns the <a href="qcborvalue.html" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="qcborvalue.html" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>operator[](qint64), operator[](<a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>), operator[](const QCborOperator[] &amp;)</p>
<p><b>See also </b><a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="qcbormap.html#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="qcbormap.html#constFind-3" translate="no">constFind</a>(const QCborValue &amp;), <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;), and <a href="qcbormap.html#contains-3" translate="no">contains</a>(const QCborValue &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]qint64 -->
<h3 class="fn" translate="no" id="operator-5b-5d-5"><span class="type">QCborValueRef</span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>key</i>)</h3>
<p>Returns a QCborValueRef to the value in this map that corresponds to key <i translate="no">key</i>. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p>QCborValueRef has the exact same API as <a href="qcborvalue.html" translate="no">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p>
<p>If the map did not have a key equal to <i translate="no">key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="qcborvalue.html" translate="no">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return will reference. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value" translate="no">value</a>(qint64), <a href="qcbormap.html#find" translate="no">find</a>(qint64), <a href="qcbormap.html#contains" translate="no">contains</a>(qint64), <a href="qcbormap.html#remove" translate="no">remove</a>(qint64), <a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), <a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), and <a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]QLatin1StringView -->
<h3 class="fn" translate="no" id="operator-5b-5d-6"><span class="type">QCborValueRef</span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></span> <i>key</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a QCborValueRef to the value in this map that corresponds to key <i translate="no">key</i>.</p>
<p>QCborValueRef has the exact same API as <a href="qcborvalue.html" translate="no">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p>
<p>If the map did not have a key equal to <i translate="no">key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="qcborvalue.html" translate="no">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return will reference. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-1" translate="no">value</a>(QLatin1StringView), <a href="qcbormap.html#find-1" translate="no">find</a>(QLatin1StringView), <a href="qcbormap.html#contains-1" translate="no">contains</a>(QLatin1StringView), <a href="qcbormap.html#remove-1" translate="no">remove</a>(QLatin1StringView), <a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), and <a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constQString& -->
<h3 class="fn" translate="no" id="operator-5b-5d-7"><span class="type">QCborValueRef</span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a QCborValueRef to the value in this map that corresponds to key <i translate="no">key</i>.</p>
<p>QCborValueRef has the exact same API as <a href="qcborvalue.html" translate="no">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p>
<p>If the map did not have a key equal to <i translate="no">key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="qcborvalue.html" translate="no">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return will reference. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-2" translate="no">value</a>(const QString &amp;), <a href="qcbormap.html#find-2" translate="no">find</a>(const QString &amp;), <a href="qcbormap.html#contains-2" translate="no">contains</a>(const QString &amp;), <a href="qcbormap.html#remove-2" translate="no">remove</a>(const QString &amp;), <a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), and <a href="qcbormap.html#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constQCborValue& -->
<h3 class="fn" translate="no" id="operator-5b-5d-8"><span class="type">QCborValueRef</span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="qcborvalue.html" translate="no">QCborValue</a></span> &amp;<i>key</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a QCborValueRef to the value in this map that corresponds to key <i translate="no">key</i>.</p>
<p>QCborValueRef has the exact same API as <a href="qcborvalue.html" translate="no">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p>
<p>If the map did not have a key equal to <i translate="no">key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="qcborvalue.html" translate="no">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return will reference. <a href="qcbormap.html" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="qcbormap.html#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="qcbormap.html#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="qcbormap.html#contains-3" translate="no">contains</a>(const QCborValue &amp;), <a href="qcbormap.html#remove-3" translate="no">remove</a>(const QCborValue &amp;), <a href="qcbormap.html#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="qcbormap.html#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1StringView), and <a href="qcbormap.html#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;).</p>
<!-- @@@operator[] -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
