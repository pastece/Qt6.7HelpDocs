<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qpromise.qdoc -->
  <meta name="description" content="The QPromise class provides a way to store computation results to be accessed by QFuture.">
  <title>QPromise Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QPromise</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QPromise Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QPromise</span>
<!-- $$$QPromise-brief -->
<p>The QPromise class provides a way to store computation results to be accessed by <a href="qfuture.html" translate="no">QFuture</a>. <a href="#details">More...</a></p>
<!-- @@@QPromise -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QPromise&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr>
</table></div>
<ul>
<li><a href="qpromise-members.html">List of all members, including inherited members</a></li>
<li>QPromise is part of <a href="../qtdoc/thread.html">Threading Classes</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#QPromise" translate="no">QPromise</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#QPromise-2" translate="no">QPromise</a></b>(QPromise&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#dtor.QPromise" translate="no">~QPromise</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#addResult-1" translate="no">addResult</a></b>(const T &amp;<i>result</i>, int <i>index</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#addResult-2" translate="no">addResult</a></b>(T &amp;&amp;<i>result</i>, int <i>index</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#addResults" translate="no">addResults</a></b>(const QList&lt;T&gt; &amp;<i>results</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#emplaceResult" translate="no">emplaceResult</a></b>(Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#emplaceResultAt" translate="no">emplaceResultAt</a></b>(int <i>index</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#finish" translate="no">finish</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#future" translate="no">future</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#isCanceled" translate="no">isCanceled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#setException" translate="no">setException</a></b>(const QException &amp;<i>e</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#setException-1" translate="no">setException</a></b>(std::__exception_ptr::exception_ptr <i>e</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#setProgressRange" translate="no">setProgressRange</a></b>(int <i>minimum</i>, int <i>maximum</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#setProgressValue" translate="no">setProgressValue</a></b>(int <i>progressValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#setProgressValueAndText" translate="no">setProgressValueAndText</a></b>(int <i>progressValue</i>, const QString &amp;<i>progressText</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#start" translate="no">start</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#suspendIfRequested" translate="no">suspendIfRequested</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#swap" translate="no">swap</a></b>(QPromise&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPromise&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qpromise.html#operator-eq-1" translate="no">operator=</a></b>(QPromise&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
</table></div>
<!-- $$$QPromise-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QPromise provides a simple way to communicate progress and results of the user-defined computation to <a href="qfuture.html" translate="no">QFuture</a> in an asynchronous fashion. For the communication to work, <a href="qfuture.html" translate="no">QFuture</a> must be constructed by QPromise.</p>
<p>You can use QPromise based workloads as an alternative to <a href="../qtconcurrent/qtconcurrent-index.html" translate="no">Qt Concurrent</a> framework when fine-grained control is needed or high-level communication primitive to accompany <a href="qfuture.html" translate="no">QFuture</a> is sufficient.</p>
<p>The simplest case of promise and future collaboration would be a single result communication:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> promise;
     <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> promise<span class="operator">.</span>future();

     <span class="type"><a href="qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">&gt;</span> thread(<span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">::</span>create(<span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> promise) {
         promise<span class="operator">.</span>start();   <span class="comment">// notifies QFuture that the computation is started</span>
         promise<span class="operator">.</span>addResult(<span class="number">42</span>);
         promise<span class="operator">.</span>finish();  <span class="comment">// notifies QFuture that the computation is finished</span>
     }<span class="operator">,</span> std<span class="operator">::</span>move(promise)));
     thread<span class="operator">-</span><span class="operator">&gt;</span>start();

     future<span class="operator">.</span>waitForFinished();  <span class="comment">// blocks until QPromise::finish is called</span>
     future<span class="operator">.</span>result();  <span class="comment">// returns 42</span>
</pre>
<p>By design, QPromise is a move-only object. This behavior helps to ensure that whenever the promise is destroyed, the associated future object is notified and will not wait forever for the results to become available. However, this is inconvenient if one wants to use the same promise to report results from different threads. There is no specific way to do that at the moment, but known mechanisms exist, such as the use of smart pointers or raw pointers/references. <a href="qsharedpointer.html" translate="no">QSharedPointer</a> is a good default choice if you want to copy your promise and use it in multiple places simultaneously. Raw pointers or references are, in a sense, easier, and probably perform better (since there is no need to do a resource management) but may lead to dangling.</p>
<p>Here is an example of how a promise can be used in multiple threads:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qsharedpointer.html" translate="no">QSharedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&gt;</span> sharedPromise(<span class="keyword">new</span> <span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
     <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> sharedPromise<span class="operator">-</span><span class="operator">&gt;</span>future();

     <span class="comment">// ...</span>

     sharedPromise<span class="operator">-</span><span class="operator">&gt;</span>start();

     <span class="comment">// here, QPromise is shared between threads via a smart pointer</span>
     <span class="type"><a href="qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">&gt;</span> threads<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
         <span class="type"><a href="qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">&gt;</span>(<span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">::</span>create(<span class="operator">[</span><span class="operator">]</span> (<span class="keyword">auto</span> sharedPromise) {
             sharedPromise<span class="operator">-</span><span class="operator">&gt;</span>addResult(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span>);  <span class="comment">// adds value 0 by index 0</span>
         }<span class="operator">,</span> sharedPromise))<span class="operator">,</span>
         <span class="type"><a href="qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">&gt;</span>(<span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">::</span>create(<span class="operator">[</span><span class="operator">]</span> (<span class="keyword">auto</span> sharedPromise) {
             sharedPromise<span class="operator">-</span><span class="operator">&gt;</span>addResult(<span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="number">1</span>);  <span class="comment">// adds value -1 by index 1</span>
         }<span class="operator">,</span> sharedPromise))<span class="operator">,</span>
         <span class="type"><a href="qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">&gt;</span>(<span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">::</span>create(<span class="operator">[</span><span class="operator">]</span> (<span class="keyword">auto</span> sharedPromise) {
             sharedPromise<span class="operator">-</span><span class="operator">&gt;</span>addResult(<span class="operator">-</span><span class="number">2</span><span class="operator">,</span> <span class="number">2</span>);  <span class="comment">// adds value -2 by index 2</span>
         }<span class="operator">,</span> sharedPromise))<span class="operator">,</span>
         <span class="comment">// ...</span>
     };
     <span class="comment">// start all threads</span>
     <span class="keyword">for</span> (<span class="keyword">auto</span><span class="operator">&amp;</span> t : threads)
         t<span class="operator">-</span><span class="operator">&gt;</span>start();

     <span class="comment">// ...</span>

     future<span class="operator">.</span>resultAt(<span class="number">0</span>);  <span class="comment">// waits until result at index 0 becomes available. returns value  0</span>
     future<span class="operator">.</span>resultAt(<span class="number">1</span>);  <span class="comment">// waits until result at index 1 becomes available. returns value -1</span>
     future<span class="operator">.</span>resultAt(<span class="number">2</span>);  <span class="comment">// waits until result at index 2 becomes available. returns value -2</span>

     sharedPromise<span class="operator">-</span><span class="operator">&gt;</span>finish();
</pre>
</div>
<p><b>See also </b><a href="qfuture.html" translate="no">QFuture</a>.</p>
<!-- @@@QPromise -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="addResult-2"><span class="type">bool</span> QPromise::<span class="name">addResult</span>(<span class="type">T</span> &amp;&amp;<i>result</i>, <span class="type">int</span> <i>index</i> = -1)</h3><h3 class="fn fngroupitem" translate="no" id="addResult-1"><span class="type">bool</span> QPromise::<span class="name">addResult</span>(const <span class="type">T</span> &amp;<i>result</i>, <span class="type">int</span> <i>index</i> = -1)</h3></div>
<p>Same as</p>
<pre class="cpp" translate="no">
 emplaceResultAt(index<span class="operator">,</span> result);            <span class="comment">// first overload</span>
 emplaceResultAt(index<span class="operator">,</span> std<span class="operator">::</span>move(result)); <span class="comment">// second overload</span>
</pre>
<p>or, if <code translate="no">index == -1</code> (the default)</p>
<pre class="cpp" translate="no">
 emplaceResult(result);            <span class="comment">// first overload</span>
 emplaceResult(std<span class="operator">::</span>move(result)); <span class="comment">// second overload</span>
</pre>
<p><b>See also </b><a href="qpromise.html#emplaceResultAt" translate="no">emplaceResultAt</a>(), <a href="qpromise.html#emplaceResult" translate="no">emplaceResult</a>(), and <a href="qpromise.html#addResults" translate="no">addResults</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="emplaceResult"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename... Args, std::enable_if_t&lt;std::is_constructible_v&lt;T, Args...&gt;, bool> = true> <span class="type">bool</span> QPromise::<span class="name">emplaceResult</span>(<span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3><h3 class="fn fngroupitem" translate="no" id="emplaceResultAt"><code class="details extra" translate="no">[since 6.6]</code> template &lt;typename... Args, std::enable_if_t&lt;std::is_constructible_v&lt;T, Args...&gt;, bool> = true> <span class="type">bool</span> QPromise::<span class="name">emplaceResultAt</span>(<span class="type">int</span> <i>index</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3></div>
<p>Adds a result constructed from <i translate="no">args...</i> to the internal result collection at <i translate="no">index</i> position (<a href="qpromise.html#emplaceResultAt" translate="no">emplaceResultAt</a>()) or the end of of the collection (<a href="qpromise.html#emplaceResult" translate="no">emplaceResult</a>()).</p>
<p>Returns <code translate="no">true</code> when the result was added to the collection.</p>
<p>Returns <code translate="no">false</code> when this promise is in canceled or finished state or when the result was rejected. <a href="qpromise.html#addResult-1" translate="no">addResult</a>() rejects to add a result if there's already another result in the collection stored at the same index.</p>
<p>These functions only participate in overload resolutions if <code translate="no">T</code> is constructible from <i translate="no">args....</i></p>
<p>You can get a result at a specific index by calling <a href="qfuture.html#resultAt" translate="no">QFuture::resultAt</a>().</p>
<div class="admonition note">
<p><b>Note: </b>It is possible to specify an arbitrary index and request result at that index. However, some <a href="qfuture.html" translate="no">QFuture</a> methods operate with continuous results. For instance, iterative approaches that use <a href="qfuture.html#resultCount" translate="no">QFuture::resultCount</a>() or <a href="qfuture-const-iterator.html" translate="no">QFuture::const_iterator</a>. In order to get all available results without thinking if there are index gaps or not, use <a href="qfuture.html#results" translate="no">QFuture::results</a>().</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qpromise.html#addResult-1" translate="no">addResult</a>() and <a href="qpromise.html#addResults" translate="no">addResults</a>().</p>
<!-- @@@ -->
<!-- $$$QPromise[overload1]$$$QPromise -->
<h3 class="fn" translate="no" id="QPromise">QPromise::<span class="name">QPromise</span>()</h3>
<p>Constructs a QPromise with a default state.</p>
<!-- @@@QPromise -->
<!-- $$$QPromise$$$QPromiseQPromise<T>&& -->
<h3 class="fn" translate="no" id="QPromise-2">QPromise::<span class="name">QPromise</span>(<span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move constructs a new QPromise from <i translate="no">other</i>.</p>
<p><b>See also </b><a href="qpromise.html#operator-eq-1" translate="no">operator=</a>().</p>
<!-- @@@QPromise -->
<!-- $$$~QPromise[overload1]$$$~QPromise -->
<h3 class="fn" translate="no" id="dtor.QPromise">QPromise::<span class="name">~QPromise</span>()</h3>
<p>Destroys the promise.</p>
<div class="admonition note">
<p><b>Note: </b>The promise implicitly transitions to a canceled state on destruction unless <a href="qpromise.html#finish" translate="no">finish</a>() is called beforehand by the user.</p>
</div>
<!-- @@@~QPromise -->
<!-- $$$addResults[overload1]$$$addResultsconstQList<T>& -->
<h3 class="fn" translate="no" id="addResults"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">bool</span> QPromise::<span class="name">addResults</span>(const <span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>results</i>)</h3>
<p>Adds <i translate="no">results</i> at the end of the internal result collection.</p>
<p>Returns <code translate="no">true</code> when <i translate="no">results</i> are added to the collection.</p>
<p>Returns <code translate="no">false</code> when this promise is in canceled or finished state.</p>
<p>This is more efficient than looping over <a href="qpromise.html#addResult-1" translate="no">addResult</a>(), because associated futures will be notified only once per addResults() call, instead of once per element contained in <i translate="no">results</i>, as would be the case with individual <a href="qpromise.html#addResult-1" translate="no">addResult</a>() calls. But if the calculation of each element takes time, then the code on the receiving end (future) cannot make progress until all results are reported, so use this function only if the calculation of consecutive elements is relatively fast.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qpromise.html#addResult-1" translate="no">addResult</a>().</p>
<!-- @@@addResults -->
<!-- $$$finish[overload1]$$$finish -->
<h3 class="fn" translate="no" id="finish"><span class="type">void</span> QPromise::<span class="name">finish</span>()</h3>
<p>Reports that the computation is finished. Once finished, no new results will be added when calling <a href="qpromise.html#addResult-1" translate="no">addResult</a>(). This method accompanies <a href="qpromise.html#start" translate="no">start</a>().</p>
<p><b>See also </b><a href="qfuture.html#isFinished" translate="no">QFuture::isFinished</a>(), <a href="qfuture.html#waitForFinished" translate="no">QFuture::waitForFinished</a>(), and <a href="qpromise.html#start" translate="no">start</a>().</p>
<!-- @@@finish -->
<!-- $$$future[overload1]$$$future -->
<h3 class="fn" translate="no" id="future"><span class="type"><a href="qfuture.html" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; QPromise::<span class="name">future</span>() const</h3>
<p>Returns a future associated with this promise.</p>
<!-- @@@future -->
<!-- $$$isCanceled[overload1]$$$isCanceled -->
<h3 class="fn" translate="no" id="isCanceled"><span class="type">bool</span> QPromise::<span class="name">isCanceled</span>() const</h3>
<p>Returns whether the computation has been canceled with the <a href="qfuture.html#cancel" translate="no">QFuture::cancel</a>() function. The returned value <code translate="no">true</code> indicates that the computation should be finished and <a href="qpromise.html#finish" translate="no">finish</a>() called.</p>
<div class="admonition note">
<p><b>Note: </b>After cancellation, results currently available may still be accessed by a future, but new results will not be added when calling <a href="qpromise.html#addResult-1" translate="no">addResult</a>().</p>
</div>
<!-- @@@isCanceled -->
<!-- $$$setException[overload1]$$$setExceptionconstQException& -->
<h3 class="fn" translate="no" id="setException"><span class="type">void</span> QPromise::<span class="name">setException</span>(const <span class="type"><a href="qexception.html" translate="no">QException</a></span> &amp;<i>e</i>)</h3>
<p>Sets exception <i translate="no">e</i> to be the result of the computation.</p>
<div class="admonition note">
<p><b>Note: </b>You can set at most one exception throughout the computation execution.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This method must not be used after <a href="qfuture.html#cancel" translate="no">QFuture::cancel</a>() or <a href="qpromise.html#finish" translate="no">finish</a>().</p>
</div>
<p><b>See also </b><a href="qpromise.html#isCanceled" translate="no">isCanceled</a>().</p>
<!-- @@@setException -->
<!-- $$$setException$$$setExceptionstd::__exception_ptr::exception_ptr -->
<h3 class="fn" translate="no" id="setException-1"><span class="type">void</span> QPromise::<span class="name">setException</span>(<span class="type">std::__exception_ptr::exception_ptr</span> <i>e</i>)</h3>
<p>This is an overloaded function.</p>
<!-- @@@setException -->
<!-- $$$setProgressRange[overload1]$$$setProgressRangeintint -->
<h3 class="fn" translate="no" id="setProgressRange"><span class="type">void</span> QPromise::<span class="name">setProgressRange</span>(<span class="type">int</span> <i>minimum</i>, <span class="type">int</span> <i>maximum</i>)</h3>
<p>Sets the progress range of the computation to be between <i translate="no">minimum</i> and <i translate="no">maximum</i>.</p>
<p>If <i translate="no">maximum</i> is smaller than <i translate="no">minimum</i>, <i translate="no">minimum</i> becomes the only legal value.</p>
<p>The progress value is reset to be <i translate="no">minimum</i>.</p>
<p>The progress range usage can be disabled by using setProgressRange(0, 0). In this case progress value is also reset to 0.</p>
<p><b>See also </b><a href="qfuture.html#progressMinimum" translate="no">QFuture::progressMinimum</a>(), <a href="qfuture.html#progressMaximum" translate="no">QFuture::progressMaximum</a>(), and <a href="qfuture.html#progressValue" translate="no">QFuture::progressValue</a>().</p>
<!-- @@@setProgressRange -->
<!-- $$$setProgressValue[overload1]$$$setProgressValueint -->
<h3 class="fn" translate="no" id="setProgressValue"><span class="type">void</span> QPromise::<span class="name">setProgressValue</span>(<span class="type">int</span> <i>progressValue</i>)</h3>
<p>Sets the progress value of the computation to <i translate="no">progressValue</i>. It is possible to only increment the progress value. This is a convenience method for calling <a href="qpromise.html#setProgressValueAndText" translate="no">setProgressValueAndText</a>(progressValue, QString()).</p>
<p>In case of the <i translate="no">progressValue</i> falling out of the progress range, this method has no effect.</p>
<p><b>See also </b><a href="qfuture.html#progressValue" translate="no">QFuture::progressValue</a>() and <a href="qpromise.html#setProgressRange" translate="no">setProgressRange</a>().</p>
<!-- @@@setProgressValue -->
<!-- $$$setProgressValueAndText[overload1]$$$setProgressValueAndTextintconstQString& -->
<h3 class="fn" translate="no" id="setProgressValueAndText"><span class="type">void</span> QPromise::<span class="name">setProgressValueAndText</span>(<span class="type">int</span> <i>progressValue</i>, const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>progressText</i>)</h3>
<p>Sets the progress value and the progress text of the computation to <i translate="no">progressValue</i> and <i translate="no">progressText</i> respectively. It is possible to only increment the progress value.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect if the promise is in canceled or finished state.</p>
</div>
<p><b>See also </b><a href="qfuture.html#progressValue" translate="no">QFuture::progressValue</a>(), <a href="qfuture.html#progressText" translate="no">QFuture::progressText</a>(), <a href="qfuture.html#cancel" translate="no">QFuture::cancel</a>(), and <a href="qpromise.html#finish" translate="no">finish</a>().</p>
<!-- @@@setProgressValueAndText -->
<!-- $$$start[overload1]$$$start -->
<h3 class="fn" translate="no" id="start"><span class="type">void</span> QPromise::<span class="name">start</span>()</h3>
<p>Reports that the computation is started. Calling this method is important to state the beginning of the computation as <a href="qfuture.html" translate="no">QFuture</a> methods rely on this information.</p>
<div class="admonition note">
<p><b>Note: </b>Extra attention is required when start() is called from a newly created thread. In such case, the call might naturally be delayed due to the implementation details of the thread scheduling.</p>
</div>
<p><b>See also </b><a href="qfuture.html#isStarted" translate="no">QFuture::isStarted</a>(), <a href="qfuture.html#waitForFinished" translate="no">QFuture::waitForFinished</a>(), and <a href="qpromise.html#finish" translate="no">finish</a>().</p>
<!-- @@@start -->
<!-- $$$suspendIfRequested[overload1]$$$suspendIfRequested -->
<h3 class="fn" translate="no" id="suspendIfRequested"><span class="type">void</span> QPromise::<span class="name">suspendIfRequested</span>()</h3>
<p>Conditionally suspends current thread of execution and waits until resumed or canceled by the corresponding methods of <a href="qfuture.html" translate="no">QFuture</a>. This method does not block unless the computation is requested to be suspended by <a href="qfuture.html#suspend" translate="no">QFuture::suspend</a>() or another related method. If you want to check that the execution has been suspended, use <a href="qfuture.html#isSuspended" translate="no">QFuture::isSuspended</a>().</p>
<div class="admonition note">
<p><b>Note: </b>When using the same promise in multiple threads, <a href="qfuture.html#isSuspended" translate="no">QFuture::isSuspended</a>() becomes <code translate="no">true</code> as soon as at least one thread with the promise suspends.</p>
</div>
<p>The following code snippets show the usage of suspension mechanism:</p>
<pre class="cpp" translate="no">
     <span class="comment">// Create promise and future</span>
     <span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> promise;
     <span class="type"><a href="qfuture.html" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> promise<span class="operator">.</span>future();

     promise<span class="operator">.</span>start();
     <span class="comment">// Start a computation thread that supports suspension and cancellation</span>
     <span class="type"><a href="qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">&gt;</span> thread(<span class="type"><a href="qthread.html" translate="no">QThread</a></span><span class="operator">::</span>create(<span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> promise) {
         <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">100</span>; <span class="operator">+</span><span class="operator">+</span>i) {
             promise<span class="operator">.</span>addResult(i);
             promise<span class="operator">.</span>suspendIfRequested();   <span class="comment">// support suspension</span>
             <span class="keyword">if</span> (promise<span class="operator">.</span>isCanceled())       <span class="comment">// support cancellation</span>
                 <span class="keyword">break</span>;
         }
         promise<span class="operator">.</span>finish();
     }<span class="operator">,</span> std<span class="operator">::</span>move(promise)));
     thread<span class="operator">-</span><span class="operator">&gt;</span>start();
</pre>
<p><a href="qfuture.html#suspend" translate="no">QFuture::suspend</a>() requests the associated promise to suspend:</p>
<pre class="cpp" translate="no">
     future<span class="operator">.</span>suspend();
</pre>
<p>After <a href="qfuture.html#isSuspended" translate="no">QFuture::isSuspended</a>() becomes <code translate="no">true</code>, you can get intermediate results:</p>
<pre class="cpp" translate="no">
     future<span class="operator">.</span>resultCount();  <span class="comment">// returns some number between 0 and 100</span>
     <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> future<span class="operator">.</span>resultCount(); <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="comment">// process results available before suspension</span>
     }
</pre>
<p>When suspended, you can resume or cancel the awaiting computation:</p>
<pre class="cpp" translate="no">
     future<span class="operator">.</span>resume();  <span class="comment">// resumes computation, this call will unblock the promise</span>
     <span class="comment">// alternatively, call future.cancel() to stop the computation</span>

     future<span class="operator">.</span>waitForFinished();
     future<span class="operator">.</span>results();  <span class="comment">// returns all computation results - array of values from 0 to 99</span>
</pre>
<p><b>See also </b><a href="qfuture.html#resume" translate="no">QFuture::resume</a>(), <a href="qfuture.html#cancel" translate="no">QFuture::cancel</a>(), <a href="qfuture.html#setSuspended" translate="no">QFuture::setSuspended</a>(), and <a href="qfuture.html#toggleSuspended" translate="no">QFuture::toggleSuspended</a>().</p>
<!-- @@@suspendIfRequested -->
<!-- $$$swap[overload1]$$$swapQPromise<T>& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QPromise::<span class="name">swap</span>(<span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Swaps promise <i translate="no">other</i> with this promise. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$operator=$$$operator=QPromise<T>&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span>&lt;<span class="type">T</span>&gt; &amp;QPromise::<span class="name">operator=</span>(<span class="type"><a href="qpromise.html#QPromise" translate="no">QPromise</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move assigns <i translate="no">other</i> to this promise and returns a reference to this promise.</p>
<!-- @@@operator= -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
