<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>&lt;QtAssert&gt; Proxy Page | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li>&lt;QtAssert&gt; Proxy Page</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<h1 class="title">&lt;QtAssert&gt; Proxy Page</h1>
<h2 id="functions">Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qtassert-qtcore-proxy.html#q_check_ptr" translate="no">q_check_ptr</a></b>(T *<i>p</i>)</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtassert-qtcore-proxy.html#Q_ASSERT" translate="no">Q_ASSERT</a></b>(bool <i>test</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtassert-qtcore-proxy.html#Q_ASSERT_X" translate="no">Q_ASSERT_X</a></b>(bool <i>test</i>, const char *<i>where</i>, const char *<i>what</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtassert-qtcore-proxy.html#Q_CHECK_PTRx" translate="no">Q_CHECK_PTR</a></b>(void *<i>pointer</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtassert-qtcore-proxy.html#Q_UNREACHABLE" translate="no">Q_UNREACHABLE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qtassert-qtcore-proxy.html#Q_UNREACHABLE_RETURN" translate="no">Q_UNREACHABLE_RETURN</a></b>(...)</td></tr>
</table></div>
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$q_check_ptr[overload1]$$$q_check_ptrT* -->
<h3 class="fn" translate="no" id="q_check_ptr">template &lt;typename T&gt; <span class="type">T</span> *<span class="name">q_check_ptr</span>(<span class="type">T</span> *<i>p</i>)</h3>
<p>Uses <a href="qtassert-qtcore-proxy.html#Q_CHECK_PTRx" translate="no">Q_CHECK_PTR</a> on <i translate="no">p</i>, then returns <i translate="no">p</i>.</p>
<p>This can be used as an inline version of <a href="qtassert-qtcore-proxy.html#Q_CHECK_PTRx" translate="no">Q_CHECK_PTR</a>.</p>
<!-- @@@q_check_ptr -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$Q_ASSERT[overload1]$$$Q_ASSERTbool -->
<h3 class="fn" translate="no" id="Q_ASSERT"><span class="type">void</span> <span class="name">Q_ASSERT</span>(<span class="type">bool</span> <i>test</i>)</h3>
<p>Prints a warning message containing the source code file name and line number if <i translate="no">test</i> is <code translate="no">false</code>.</p>
<p>Q_ASSERT() is useful for testing pre- and post-conditions during development. It does nothing if <code translate="no">QT_NO_DEBUG</code> was defined during compilation.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="comment">// File: div.cpp</span>

 <span class="preprocessor">#include &lt;QtGlobal&gt;</span>

 <span class="type">int</span> divide(<span class="type">int</span> a<span class="operator">,</span> <span class="type">int</span> b)
 {
     Q_ASSERT(b <span class="operator">!</span><span class="operator">=</span> <span class="number">0</span>);
     <span class="keyword">return</span> a <span class="operator">/</span> b;
 }
</pre>
<p>If <code translate="no">b</code> is zero, the Q_ASSERT statement will output the following message using the <a href="qtlogging.html#qFatal" translate="no">qFatal</a>() function:</p>
<pre class="cpp" translate="no">
 ASSERT: <span class="string">&quot;b != 0&quot;</span> in file div<span class="operator">.</span>cpp<span class="operator">,</span> line <span class="number">7</span>
</pre>
<p><b>See also </b><a href="qtassert-qtcore-proxy.html#Q_ASSERT_X" translate="no">Q_ASSERT_X</a>(), <a href="qtlogging.html#qFatal" translate="no">qFatal</a>(), and <a href="../qtdoc/debug.html" translate="no">Debugging Techniques</a>.</p>
<!-- @@@Q_ASSERT -->
<!-- $$$Q_ASSERT_X[overload1]$$$Q_ASSERT_Xboolconstchar*constchar* -->
<h3 class="fn" translate="no" id="Q_ASSERT_X"><span class="type">void</span> <span class="name">Q_ASSERT_X</span>(<span class="type">bool</span> <i>test</i>, const <span class="type">char</span> *<i>where</i>, const <span class="type">char</span> *<i>what</i>)</h3>
<p>Prints the message <i translate="no">what</i> together with the location <i translate="no">where</i>, the source file name and line number if <i translate="no">test</i> is <code translate="no">false</code>.</p>
<p>Q_ASSERT_X is useful for testing pre- and post-conditions during development. It does nothing if <code translate="no">QT_NO_DEBUG</code> was defined during compilation.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="comment">// File: div.cpp</span>

 <span class="preprocessor">#include &lt;QtGlobal&gt;</span>

 <span class="type">int</span> divide(<span class="type">int</span> a<span class="operator">,</span> <span class="type">int</span> b)
 {
     Q_ASSERT_X(b <span class="operator">!</span><span class="operator">=</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;divide&quot;</span><span class="operator">,</span> <span class="string">&quot;division by zero&quot;</span>);
     <span class="keyword">return</span> a <span class="operator">/</span> b;
 }
</pre>
<p>If <code translate="no">b</code> is zero, the Q_ASSERT_X statement will output the following message using the <a href="qtlogging.html#qFatal" translate="no">qFatal</a>() function:</p>
<pre class="cpp" translate="no">
 ASSERT failure in divide: <span class="string">&quot;division by zero&quot;</span><span class="operator">,</span> file div<span class="operator">.</span>cpp<span class="operator">,</span> line <span class="number">7</span>
</pre>
<p><b>See also </b><a href="qtassert-qtcore-proxy.html#Q_ASSERT" translate="no">Q_ASSERT</a>(), <a href="qtlogging.html#qFatal" translate="no">qFatal</a>(), and <a href="../qtdoc/debug.html" translate="no">Debugging Techniques</a>.</p>
<!-- @@@Q_ASSERT_X -->
<!-- $$$Q_CHECK_PTR[overload1]$$$Q_CHECK_PTRvoid* -->
<h3 class="fn" translate="no" id="Q_CHECK_PTRx"><span class="type">void</span> <span class="name">Q_CHECK_PTR</span>(<span class="type">void</span> *<i>pointer</i>)</h3>
<p>If <i translate="no">pointer</i> is <code translate="no">nullptr</code>, prints a message containing the source code's file name and line number, saying that the program ran out of memory and aborts program execution. It throws <code translate="no">std::bad_alloc</code> instead if exceptions are enabled.</p>
<p>Q_CHECK_PTR does nothing if <code translate="no">QT_NO_DEBUG</code> and <code translate="no">QT_NO_EXCEPTIONS</code> were defined during compilation. Therefore you must not use Q_CHECK_PTR to check for successful memory allocations because the check will be disabled in some cases.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> <span class="operator">*</span>a;

 Q_CHECK_PTR(a <span class="operator">=</span> <span class="keyword">new</span> <span class="type">int</span><span class="operator">[</span><span class="number">80</span><span class="operator">]</span>);   <span class="comment">// WRONG!</span>

 a <span class="operator">=</span> <span class="keyword">new</span> (nothrow) <span class="type">int</span><span class="operator">[</span><span class="number">80</span><span class="operator">]</span>;      <span class="comment">// Right</span>
 Q_CHECK_PTR(a);
</pre>
<p><b>See also </b><a href="qtlogging.html#qWarning" translate="no">qWarning</a>() and <a href="../qtdoc/debug.html" translate="no">Debugging Techniques</a>.</p>
<!-- @@@Q_CHECK_PTR -->
<!-- $$$Q_UNREACHABLE[overload1]$$$Q_UNREACHABLE -->
<h3 class="fn" translate="no" id="Q_UNREACHABLE"><span class="type">void</span> <span class="name">Q_UNREACHABLE</span></h3>
<p>Tells the compiler that the current point cannot be reached by any execution, so it may optimize any code paths leading here as dead code, as well as code continuing from here.</p>
<p>This macro is useful to mark impossible conditions. For example, given the following enum:</p>
<pre class="cpp" translate="no">
    <span class="keyword">enum</span> Shapes {
        Rectangle<span class="operator">,</span>
        Triangle<span class="operator">,</span>
        Circle<span class="operator">,</span>
        NumShapes
    };
</pre>
<p>One can write a switch table like so:</p>
<pre class="cpp" translate="no">
    <span class="keyword">switch</span> (shape) {
        <span class="keyword">case</span> Rectangle:
            <span class="keyword">return</span> rectangle();
        <span class="keyword">case</span> Triangle:
            <span class="keyword">return</span> triangle();
        <span class="keyword">case</span> Circle:
            <span class="keyword">return</span> circle();
        <span class="keyword">case</span> NumShapes:
            Q_UNREACHABLE();
            <span class="keyword">break</span>;
    }
</pre>
<p>The advantage of inserting Q_UNREACHABLE() at that point is that the compiler is told not to generate code for a shape variable containing that value. If the macro is missing, the compiler will still generate the necessary comparisons for that value. If the case label were removed, some compilers could produce a warning that some enum values were not checked.</p>
<p>By using this macro in impossible conditions, code coverage may be improved as dead code paths may be eliminated.</p>
<p>In debug builds the condition is enforced by an assert to facilitate debugging.</p>
<div class="admonition note">
<p><b>Note: </b>Use the macro <a href="qtassert-qtcore-proxy.html#Q_UNREACHABLE_RETURN" translate="no">Q_UNREACHABLE_RETURN</a>() to insert return statements for compilers that need them, without causing warnings for compilers that complain about its presence.</p>
</div>
<p><b>See also </b><a href="qtassert-qtcore-proxy.html#Q_ASSERT" translate="no">Q_ASSERT</a>(), <a href="qtlogging.html#qFatal" translate="no">qFatal</a>(), and <a href="qtassert-qtcore-proxy.html#Q_UNREACHABLE_RETURN" translate="no">Q_UNREACHABLE_RETURN</a>().</p>
<!-- @@@Q_UNREACHABLE -->
<!-- $$$Q_UNREACHABLE_RETURN[overload1]$$$Q_UNREACHABLE_RETURN... -->
<h3 class="fn" translate="no" id="Q_UNREACHABLE_RETURN"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> <span class="name">Q_UNREACHABLE_RETURN</span>(...)</h3>
<p>This is equivalent to</p>
<pre class="cpp" translate="no">
 Q_UNREACHABLE();
 <span class="keyword">return</span> __VA_ARGS__;
</pre>
<p>except it omits the return on compilers that would warn about it.</p>
<p>This macro was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qtassert-qtcore-proxy.html#Q_UNREACHABLE" translate="no">Q_UNREACHABLE</a>().</p>
<!-- @@@Q_UNREACHABLE_RETURN -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
