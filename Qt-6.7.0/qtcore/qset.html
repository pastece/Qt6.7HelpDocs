<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qset.qdoc -->
  <meta name="description" content="The QSet class is a template class that provides a hash-table-based set.">
  <title>QSet Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QSet</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QSet Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QSet</span>
<!-- $$$QSet-brief -->
<p>The QSet class is a template class that provides a hash-table-based set. <a href="#details">More...</a></p>
<!-- @@@QSet -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QSet&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qset-members.html">List of all members, including inherited members</a></li>
<li>QSet is part of <a href="shared.html">Implicitly Shared Classes</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qset-const-iterator.html" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qset-iterator.html" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#ConstIterator-typedef" translate="no">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#Iterator-typedef" translate="no">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#const_pointer-typedef" translate="no">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#const_reference-typedef" translate="no">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#key_type-typedef" translate="no">key_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#pointer-typedef" translate="no">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#reference-typedef" translate="no">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#value_type-typedef" translate="no">value_type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#QSet" translate="no">QSet</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#QSet-1" translate="no">QSet</a></b>(std::initializer_list&lt;T&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#QSet-2" translate="no">QSet</a></b>(InputIterator <i>first</i>, InputIterator <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#begin" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#begin-1" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qset.html#capacity" translate="no">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#constFind" translate="no">constFind</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#contains" translate="no">contains</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#contains-1" translate="no">contains</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qset.html#count" translate="no">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#end" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#end-1" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#erase" translate="no">erase</a></b>(QSet&lt;T&gt;::const_iterator <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#find" translate="no">find</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#find-1" translate="no">find</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#insert" translate="no">insert</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QSet&lt;T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#insert-2" translate="no">insert</a></b>(QSet&lt;T&gt;::const_iterator <i>it</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#intersect" translate="no">intersect</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#intersects" translate="no">intersects</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#remove" translate="no">remove</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qset.html#removeIf" translate="no">removeIf</a></b>(Pred <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#reserve" translate="no">reserve</a></b>(qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qset.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#squeeze" translate="no">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#subtract" translate="no">subtract</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#swap" translate="no">swap</a></b>(QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#unite" translate="no">unite</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#values" translate="no">values</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-not-eq" translate="no">operator!=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and-eq" translate="no">operator&amp;=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and-eq-1" translate="no">operator&amp;=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b-eq" translate="no">operator+=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b-eq-1" translate="no">operator+=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator--eq" translate="no">operator-=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator--eq-1" translate="no">operator-=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-lt-lt" translate="no">operator&lt;&lt;</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-eq-eq" translate="no">operator==</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c-eq" translate="no">operator|=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c-eq-1" translate="no">operator|=</a></b>(const T &amp;<i>value</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qset.html#erase_if" translate="no">erase_if</a></b>(QSet&lt;T&gt; &amp;<i>set</i>, Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and" translate="no">operator&amp;</a></b>(const QSet&lt;T&gt; &amp;<i>lhs</i>, const QSet&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and-1" translate="no">operator&amp;</a></b>(QSet&lt;T&gt; &amp;&amp;<i>lhs</i>, const QSet&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b" translate="no">operator+</a></b>(const QSet&lt;T&gt; &amp;<i>lhs</i>, const QSet&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b-1" translate="no">operator+</a></b>(QSet&lt;T&gt; &amp;&amp;<i>lhs</i>, const QSet&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-" translate="no">operator-</a></b>(const QSet&lt;T&gt; &amp;<i>lhs</i>, const QSet&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator--1" translate="no">operator-</a></b>(QSet&lt;T&gt; &amp;&amp;<i>lhs</i>, const QSet&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-lt-lt-1" translate="no">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QSet&lt;T&gt; &amp;<i>set</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-gt-gt-1" translate="no">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QSet&lt;T&gt; &amp;<i>set</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c" translate="no">operator|</a></b>(const QSet&lt;T&gt; &amp;<i>lhs</i>, const QSet&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c-1" translate="no">operator|</a></b>(QSet&lt;T&gt; &amp;&amp;<i>lhs</i>, const QSet&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
</table></div>
<!-- $$$QSet-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QSet&lt;T&gt; is one of Qt's generic <a href="containers.html" translate="no">container classes</a>. It stores values in an unspecified order and provides very fast lookup of the values. Internally, QSet&lt;T&gt; is implemented as a <a href="qhash.html#qhash" translate="no">QHash</a>.</p>
<p>Here's an example QSet with <a href="qstring.html" translate="no">QString</a> values:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> set;
</pre>
<p>To insert a value into the set, use <a href="qset.html#insert" translate="no">insert</a>():</p>
<pre class="cpp" translate="no">
 set<span class="operator">.</span>insert(<span class="string">&quot;one&quot;</span>);
 set<span class="operator">.</span>insert(<span class="string">&quot;three&quot;</span>);
 set<span class="operator">.</span>insert(<span class="string">&quot;seven&quot;</span>);
</pre>
<p>Another way to insert items into the set is to use <a href="qset.html#operator-lt-lt" translate="no">operator&lt;&lt;</a>():</p>
<pre class="cpp" translate="no">
 set <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;twelve&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;fifteen&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;nineteen&quot;</span>;
</pre>
<p>To test whether an item belongs to the set or not, use <a href="qset.html#contains" translate="no">contains</a>():</p>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (<span class="operator">!</span>set<span class="operator">.</span>contains(<span class="string">&quot;ninety-nine&quot;</span>))
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>If you want to navigate through all the values stored in a QSet, you can use an iterator. QSet supports both <a href="java-style-iterators.html#java-style-iterators" translate="no">Java-style iterators</a> (<a href="qsetiterator.html" translate="no">QSetIterator</a> and <a href="qmutablesetiterator.html" translate="no">QMutableSetIterator</a>) and <a href="containers.html#stl-style-iterators" translate="no">STL-style iterators</a> (<a href="qset-iterator.html" translate="no">QSet::iterator</a> and <a href="qset-const-iterator.html" translate="no">QSet::const_iterator</a>). Here's how to iterate over a QSet&lt;<a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> *&gt; using a Java-style iterator:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qsetiterator.html" translate="no">QSetIterator</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span> i(set);
 <span class="keyword">while</span> (i<span class="operator">.</span>hasNext()) {
     <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span> <span class="operator">*</span>w <span class="operator">=</span> i<span class="operator">.</span>next();
     <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> w;
 }
</pre>
<p>Here's the same code, but using an STL-style iterator:</p>
<pre class="cpp" translate="no">
 <span class="keyword">for</span> (<span class="keyword">auto</span> i <span class="operator">=</span> set<span class="operator">.</span>cbegin()<span class="operator">,</span> end <span class="operator">=</span> set<span class="operator">.</span>cend(); i <span class="operator">!</span><span class="operator">=</span> end; <span class="operator">+</span><span class="operator">+</span>i)
     <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="operator">*</span>i;
</pre>
<p>QSet is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <a href="qmap.html" translate="no">QMap</a>.</p>
<p>To navigate through a QSet, you can also use range-based for:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> set;
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> <span class="operator">&amp;</span>value : set)
     <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> value;
</pre>
<p>Items can be removed from the set using <a href="qset.html#remove" translate="no">remove</a>(). There is also a <a href="qset.html#clear" translate="no">clear</a>() function that removes all items.</p>
<p>QSet's value data type must be an <a href="containers.html#assignable-data-type" translate="no">assignable data type</a>. You cannot, for example, store a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> as a value; instead, store a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> *. In addition, the type must provide <code translate="no">operator==()</code>, and there must also be a global <a href="qflags.html#qHash" translate="no">qHash</a>() function that returns a hash value for an argument of the key's type. See the <a href="qhash.html#qhash" translate="no">QHash</a> documentation for a list of types supported by <a href="qflags.html#qHash" translate="no">qHash</a>().</p>
<p>Internally, QSet uses a hash table to perform lookups. The hash table automatically grows and shrinks to provide fast lookups without wasting memory. You can still control the size of the hash table by calling <a href="qset.html#reserve" translate="no">reserve</a>(), if you already know approximately how many elements the QSet will contain, but this isn't necessary to obtain good performance. You can also call <a href="qset.html#capacity" translate="no">capacity</a>() to retrieve the hash table's size.</p>
</div>
<p><b>See also </b><a href="qsetiterator.html" translate="no">QSetIterator</a>, <a href="qmutablesetiterator.html" translate="no">QMutableSetIterator</a>, <a href="qhash.html#qhash" translate="no">QHash</a>, and <a href="qmap.html" translate="no">QMap</a>.</p>
<!-- @@@QSet -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" translate="no" id="ConstIterator-typedef">QSet::<span class="name">ConstIterator</span></h3>
<p>Qt-style synonym for <a href="qset-const-iterator.html" translate="no">QSet::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn" translate="no" id="Iterator-typedef">QSet::<span class="name">Iterator</span></h3>
<p>Qt-style synonym for <a href="qset-iterator.html" translate="no">QSet::iterator</a>.</p>
<!-- @@@Iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" translate="no" id="const_pointer-typedef">QSet::<span class="name">const_pointer</span></h3>
<p>Typedef for const T *. Provided for STL compatibility.</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" translate="no" id="const_reference-typedef">QSet::<span class="name">const_reference</span></h3>
<p>Typedef for const T &amp;. Provided for STL compatibility.</p>
<!-- @@@const_reference -->
<!-- $$$difference_type -->
<h3 class="fn" translate="no" id="difference_type-typedef">QSet::<span class="name">difference_type</span></h3>
<p>Typedef for const ptrdiff_t. Provided for STL compatibility.</p>
<!-- @@@difference_type -->
<!-- $$$key_type -->
<h3 class="fn" translate="no" id="key_type-typedef">QSet::<span class="name">key_type</span></h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@key_type -->
<!-- $$$pointer -->
<h3 class="fn" translate="no" id="pointer-typedef">QSet::<span class="name">pointer</span></h3>
<p>Typedef for T *. Provided for STL compatibility.</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" translate="no" id="reference-typedef">QSet::<span class="name">reference</span></h3>
<p>Typedef for T &amp;. Provided for STL compatibility.</p>
<!-- @@@reference -->
<!-- $$$size_type -->
<h3 class="fn" translate="no" id="size_type-typedef">QSet::<span class="name">size_type</span></h3>
<p>Typedef for int. Provided for STL compatibility.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" translate="no" id="value_type-typedef">QSet::<span class="name">value_type</span></h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="operator-2b-eq-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator+=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-lt-lt"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator&lt;&lt;</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-7c-eq-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator|=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3></div>
<p>Inserts a new item <i translate="no">value</i> and returns a reference to the set. If <i translate="no">value</i> already exists in the set, the set is left unchanged.</p>
<p><b>See also </b><a href="qset.html#insert" translate="no">insert</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="operator-2b-eq"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator+=</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-7c-eq"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator|=</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3></div>
<p>Same as <a href="qset.html#unite" translate="no">unite(<i translate="no">other</i>)</a>.</p>
<p><b>See also </b><a href="qset.html#operator-7c" translate="no">operator|</a>(), <a href="qset.html#operator-and-eq" translate="no">operator&amp;=</a>(), and <a href="qset.html#operator--eq" translate="no">operator-=</a>().</p>
<!-- @@@ -->
<!-- $$$QSet[overload1]$$$QSet -->
<h3 class="fn" translate="no" id="QSet"><code class="details extra" translate="no">[noexcept]</code> QSet::<span class="name">QSet</span>()</h3>
<p>Constructs an empty set.</p>
<p><b>See also </b><a href="qset.html#clear" translate="no">clear</a>().</p>
<!-- @@@QSet -->
<!-- $$$QSet$$$QSetstd::initializer_list<T> -->
<h3 class="fn" translate="no" id="QSet-1">QSet::<span class="name">QSet</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">T</span>&gt; <i>list</i>)</h3>
<p>Constructs a set with a copy of each of the elements in the initializer list <i translate="no">list</i>.</p>
<!-- @@@QSet -->
<!-- $$$QSet$$$QSetInputIteratorInputIterator -->
<h3 class="fn" translate="no" id="QSet-2">template &lt;typename InputIterator, QtPrivate::IfIsInputIterator&lt;InputIterator&gt; = true> QSet::<span class="name">QSet</span>(<span class="type">InputIterator</span> <i>first</i>, <span class="type">InputIterator</span> <i>last</i>)</h3>
<p>Constructs a set with the contents in the iterator range [<i translate="no">first</i>, <i translate="no">last</i>).</p>
<p>The value type of <code translate="no">InputIterator</code> must be convertible to <code translate="no">T</code>.</p>
<div class="admonition note">
<p><b>Note: </b>If the range [<i translate="no">first</i>, <i translate="no">last</i>) contains duplicate elements, the first one is retained.</p>
</div>
<!-- @@@QSet -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" translate="no" id="begin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QSet::<span class="name">begin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> positioned at the first item in the set.</p>
<p><b>See also </b><a href="qset.html#constBegin" translate="no">constBegin</a>() and <a href="qset.html#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" translate="no" id="begin-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::iterator</span> QSet::<span class="name">begin</span>()</h3>
<p>This is an overloaded function.</p>
<p>Returns a non-const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> positioned at the first item in the set.</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" translate="no" id="capacity"><span class="type">qsizetype</span> QSet::<span class="name">capacity</span>() const</h3>
<p>Returns the number of buckets in the set's internal hash table.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qset.html" translate="no">QSet</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the set, call <a href="qset.html#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="qset.html#reserve" translate="no">reserve</a>() and <a href="qset.html#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" translate="no" id="cbegin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QSet::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> positioned at the first item in the set.</p>
<p><b>See also </b><a href="qset.html#begin" translate="no">begin</a>() and <a href="qset.html#cend" translate="no">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" translate="no" id="cend"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QSet::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the set.</p>
<p><b>See also </b><a href="qset.html#cbegin" translate="no">cbegin</a>() and <a href="qset.html#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QSet::<span class="name">clear</span>()</h3>
<p>Removes all elements from the set.</p>
<p><b>See also </b><a href="qset.html#remove" translate="no">remove</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" translate="no" id="constBegin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QSet::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> positioned at the first item in the set.</p>
<p><b>See also </b><a href="qset.html#begin" translate="no">begin</a>() and <a href="qset.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" translate="no" id="constEnd"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QSet::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the set.</p>
<p><b>See also </b><a href="qset.html#constBegin" translate="no">constBegin</a>() and <a href="qset.html#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind[overload1]$$$constFindconstT& -->
<h3 class="fn" translate="no" id="constFind"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QSet::<span class="name">constFind</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns a const iterator positioned at the item <i translate="no">value</i> in the set. If the set contains no item <i translate="no">value</i>, the function returns <a href="qset.html#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="qset.html#find" translate="no">find</a>() and <a href="qset.html#contains" translate="no">contains</a>().</p>
<!-- @@@constFind -->
<!-- $$$contains[overload1]$$$containsconstT& -->
<h3 class="fn" translate="no" id="contains"><span class="type">bool</span> QSet::<span class="name">contains</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns <code translate="no">true</code> if the set contains item <i translate="no">value</i>; otherwise returns false.</p>
<p><b>See also </b><a href="qset.html#insert" translate="no">insert</a>(), <a href="qset.html#remove" translate="no">remove</a>(), and <a href="qset.html#find" translate="no">find</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQSet<T>& -->
<h3 class="fn" translate="no" id="contains-1"><span class="type">bool</span> QSet::<span class="name">contains</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if the set contains all items from the <i translate="no">other</i> set; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qset.html#insert" translate="no">insert</a>(), <a href="qset.html#remove" translate="no">remove</a>(), and <a href="qset.html#find" translate="no">find</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$count -->
<h3 class="fn" translate="no" id="count"><span class="type">qsizetype</span> QSet::<span class="name">count</span>() const</h3>
<p>Same as <a href="qset.html#size" translate="no">size</a>().</p>
<!-- @@@count -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" translate="no" id="empty"><span class="type">bool</span> QSet::<span class="name">empty</span>() const</h3>
<p>Returns <code translate="no">true</code> if the set is empty. This function is provided for STL compatibility. It is equivalent to <a href="qset.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QSet::<span class="name">end</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> positioned at the imaginary item after the last item in the set.</p>
<p><b>See also </b><a href="qset.html#constEnd" translate="no">constEnd</a>() and <a href="qset.html#begin" translate="no">begin</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" translate="no" id="end-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::iterator</span> QSet::<span class="name">end</span>()</h3>
<p>This is an overloaded function.</p>
<p>Returns a non-const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the set.</p>
<!-- @@@end -->
<!-- $$$erase[overload1]$$$eraseQSet<T>::const_iterator -->
<h3 class="fn" translate="no" id="erase"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::iterator</span> QSet::<span class="name">erase</span>(<span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> <i>pos</i>)</h3>
<p>Removes the item at the iterator position <i translate="no">pos</i> from the set, and returns an iterator positioned at the next item in the set.</p>
<p>Unlike <a href="qset.html#remove" translate="no">remove</a>(), this function never causes <a href="qset.html" translate="no">QSet</a> to rehash its internal data structure. This means that it can safely be called while iterating, and won't affect the order of items in the set.</p>
<div class="admonition note">
<p><b>Note: </b>The iterator <i translate="no">pos</i> <i>must</i> be valid and dereferenceable. Calling this method on any other iterator, including its own <a href="qset.html#end" translate="no">end</a>(), results in undefined behavior. In particular, even the <a href="qset.html#begin" translate="no">begin</a>() iterator of an empty set cannot be dereferenced.</p>
</div>
<p><b>See also </b><a href="qset.html#remove" translate="no">remove</a>() and <a href="qset.html#find" translate="no">find</a>().</p>
<!-- @@@erase -->
<!-- $$$find[overload1]$$$findconstT& -->
<h3 class="fn" translate="no" id="find"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> QSet::<span class="name">find</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns a const iterator positioned at the item <i translate="no">value</i> in the set. If the set contains no item <i translate="no">value</i>, the function returns <a href="qset.html#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="qset.html#constFind" translate="no">constFind</a>() and <a href="qset.html#contains" translate="no">contains</a>().</p>
<!-- @@@find -->
<!-- $$$find$$$findconstT& -->
<h3 class="fn" translate="no" id="find-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::iterator</span> QSet::<span class="name">find</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a non-const iterator positioned at the item <i translate="no">value</i> in the set. If the set contains no item <i translate="no">value</i>, the function returns <a href="qset.html#end" translate="no">end</a>().</p>
<!-- @@@find -->
<!-- $$$insert[overload1]$$$insertconstT& -->
<h3 class="fn" translate="no" id="insert"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::iterator</span> QSet::<span class="name">insert</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts item <i translate="no">value</i> into the set, if <i translate="no">value</i> isn't already in the set, and returns an iterator pointing at the inserted item.</p>
<p><b>See also </b><a href="qset.html#operator-lt-lt" translate="no">operator&lt;&lt;</a>(), <a href="qset.html#remove" translate="no">remove</a>(), and <a href="qset.html#contains" translate="no">contains</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertQSet<T>::const_iteratorconstT& -->
<h3 class="fn" translate="no" id="insert-2"><code class="details extra" translate="no">[since 6.1]</code> <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::iterator</span> QSet::<span class="name">insert</span>(<span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt;<span class="type">::const_iterator</span> <i>it</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts item <i translate="no">value</i> into the set, if <i translate="no">value</i> isn't already in the set, and returns an iterator pointing at the inserted item.</p>
<p>The iterator <i translate="no">it</i> is ignored.</p>
<p>This function is provided for compatibility with the STL.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qset.html#operator-lt-lt" translate="no">operator&lt;&lt;</a>(), <a href="qset.html#remove" translate="no">remove</a>(), and <a href="qset.html#contains" translate="no">contains</a>().</p>
<!-- @@@insert -->
<!-- $$$intersect[overload1]$$$intersectconstQSet<T>& -->
<h3 class="fn" translate="no" id="intersect"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">intersect</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Removes all items from this set that are not contained in the <i translate="no">other</i> set. A reference to this set is returned.</p>
<p><b>See also </b><a href="qset.html#intersects" translate="no">intersects</a>(), <a href="qset.html#operator-and-eq" translate="no">operator&amp;=</a>(), <a href="qset.html#unite" translate="no">unite</a>(), and <a href="qset.html#subtract" translate="no">subtract</a>().</p>
<!-- @@@intersect -->
<!-- $$$intersects[overload1]$$$intersectsconstQSet<T>& -->
<h3 class="fn" translate="no" id="intersects"><span class="type">bool</span> QSet::<span class="name">intersects</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if this set has at least one item in common with <i translate="no">other</i>.</p>
<p><b>See also </b><a href="qset.html#contains" translate="no">contains</a>() and <a href="qset.html#intersect" translate="no">intersect</a>().</p>
<!-- @@@intersects -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" translate="no" id="isEmpty"><span class="type">bool</span> QSet::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code translate="no">true</code> if the set contains no elements; otherwise returns false.</p>
<p><b>See also </b><a href="qset.html#size" translate="no">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$remove[overload1]$$$removeconstT& -->
<h3 class="fn" translate="no" id="remove"><span class="type">bool</span> QSet::<span class="name">remove</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Removes any occurrence of item <i translate="no">value</i> from the set. Returns true if an item was actually removed; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qset.html#contains" translate="no">contains</a>() and <a href="qset.html#insert" translate="no">insert</a>().</p>
<!-- @@@remove -->
<!-- $$$removeIf[overload1]$$$removeIfPred -->
<h3 class="fn" translate="no" id="removeIf"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Pred&gt; <span class="type">qsizetype</span> QSet::<span class="name">removeIf</span>(<span class="type">Pred</span> <i>pred</i>)</h3>
<p>Removes, from this set, all elements for which the predicate <i translate="no">pred</i> returns <code translate="no">true</code>. Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@removeIf -->
<!-- $$$reserve[overload1]$$$reserveqsizetype -->
<h3 class="fn" translate="no" id="reserve"><span class="type">void</span> QSet::<span class="name">reserve</span>(<span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Ensures that the set's internal hash table consists of at least <i translate="no">size</i> buckets.</p>
<p>This function is useful for code that needs to build a huge set and wants to avoid repeated reallocation. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">&gt;</span> set;
 set<span class="operator">.</span>reserve(<span class="number">20000</span>);
 <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">20000</span>; <span class="operator">+</span><span class="operator">+</span>i)
     set<span class="operator">.</span>insert(values<span class="operator">[</span>i<span class="operator">]</span>);
</pre>
<p>Ideally, <i translate="no">size</i> should be slightly more than the maximum number of elements expected in the set. <i translate="no">size</i> doesn't have to be prime, because <a href="qset.html" translate="no">QSet</a> will use a prime number internally anyway. If <i translate="no">size</i> is an underestimate, the worst that will happen is that the <a href="qset.html" translate="no">QSet</a> will be a bit slower.</p>
<p>In general, you will rarely ever need to call this function. <a href="qset.html" translate="no">QSet</a>'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</p>
<p><b>See also </b><a href="qset.html#squeeze" translate="no">squeeze</a>() and <a href="qset.html#capacity" translate="no">capacity</a>().</p>
<!-- @@@reserve -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><span class="type">qsizetype</span> QSet::<span class="name">size</span>() const</h3>
<p>Returns the number of items in the set.</p>
<p><b>See also </b><a href="qset.html#isEmpty" translate="no">isEmpty</a>() and <a href="qset.html#count" translate="no">count</a>().</p>
<!-- @@@size -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" translate="no" id="squeeze"><span class="type">void</span> QSet::<span class="name">squeeze</span>()</h3>
<p>Reduces the size of the set's internal hash table to save memory.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qset.html" translate="no">QSet</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b>See also </b><a href="qset.html#reserve" translate="no">reserve</a>() and <a href="qset.html#capacity" translate="no">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$subtract[overload1]$$$subtractconstQSet<T>& -->
<h3 class="fn" translate="no" id="subtract"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">subtract</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Removes all items from this set that are contained in the <i translate="no">other</i> set. Returns a reference to this set.</p>
<p><b>See also </b><a href="qset.html#operator--eq" translate="no">operator-=</a>(), <a href="qset.html#unite" translate="no">unite</a>(), and <a href="qset.html#intersect" translate="no">intersect</a>().</p>
<!-- @@@subtract -->
<!-- $$$swap[overload1]$$$swapQSet<T>& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QSet::<span class="name">swap</span>(<span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Swaps set <i translate="no">other</i> with this set. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$unite[overload1]$$$uniteconstQSet<T>& -->
<h3 class="fn" translate="no" id="unite"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">unite</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Each item in the <i translate="no">other</i> set that isn't already in this set is inserted into this set. A reference to this set is returned.</p>
<p><b>See also </b><a href="qset.html#operator-7c-eq" translate="no">operator|=</a>(), <a href="qset.html#intersect" translate="no">intersect</a>(), and <a href="qset.html#subtract" translate="no">subtract</a>().</p>
<!-- @@@unite -->
<!-- $$$values[overload1]$$$values -->
<h3 class="fn" translate="no" id="values"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QSet::<span class="name">values</span>() const</h3>
<p>Returns a new <a href="qlist.html" translate="no">QList</a> containing the elements in the set. The order of the elements in the <a href="qlist.html" translate="no">QList</a> is undefined.</p>
<div class="admonition note">
<p><b>Note: </b>Since Qt 5.14, range constructors are available for Qt's generic <a href="containers.html" translate="no">container classes</a> and should be used in place of this method.</p>
</div>
<p>This function creates a new list, in <a href="containers.html#linear-time" translate="no">linear time</a>. The time and memory use that entails can be avoided by iterating from <a href="qset.html#constBegin" translate="no">constBegin</a>() to <a href="qset.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@values -->
<!-- $$$operator!=[overload1]$$$operator!=constQSet<T>& -->
<h3 class="fn" translate="no" id="operator-not-eq"><span class="type">bool</span> QSet::<span class="name">operator!=</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if the <i translate="no">other</i> set is not equal to this set; otherwise returns <code translate="no">false</code>.</p>
<p>Two sets are considered equal if they contain the same elements.</p>
<p>This function requires the value type to implement <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qset.html#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator&=[overload1]$$$operator&=constQSet<T>& -->
<h3 class="fn" translate="no" id="operator-and-eq"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator&amp;=</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Same as <a href="qset.html#intersect" translate="no">intersect(<i translate="no">other</i>)</a>.</p>
<p><b>See also </b><a href="qset.html#operator-and" translate="no">operator&amp;</a>(), <a href="qset.html#operator-7c-eq" translate="no">operator|=</a>(), and <a href="qset.html#operator--eq" translate="no">operator-=</a>().</p>
<!-- @@@operator&= -->
<!-- $$$operator&=$$$operator&=constT& -->
<h3 class="fn" translate="no" id="operator-and-eq-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator&amp;=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="qset.html#intersect" translate="no">intersect(<i>other</i>)</a>, if we consider <i>other</i> to be a set that contains the singleton <i translate="no">value</i>.</p>
<!-- @@@operator&= -->
<!-- $$$operator-=[overload1]$$$operator-=constQSet<T>& -->
<h3 class="fn" translate="no" id="operator--eq"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator-=</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Same as <a href="qset.html#subtract" translate="no">subtract(<i translate="no">other</i>)</a>.</p>
<p><b>See also </b><a href="qset.html#operator-" translate="no">operator-</a>(), <a href="qset.html#operator-7c-eq" translate="no">operator|=</a>(), and <a href="qset.html#operator-and-eq" translate="no">operator&amp;=</a>().</p>
<!-- @@@operator-= -->
<!-- $$$operator-=$$$operator-=constT& -->
<h3 class="fn" translate="no" id="operator--eq-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator-=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Removes the occurrence of item <i translate="no">value</i> from the set, if it is found, and returns a reference to the set. If the <i translate="no">value</i> is not contained the set, nothing is removed.</p>
<p><b>See also </b><a href="qset.html#remove" translate="no">remove</a>().</p>
<!-- @@@operator-= -->
<!-- $$$operator==[overload1]$$$operator==constQSet<T>& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><span class="type">bool</span> QSet::<span class="name">operator==</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if the <i translate="no">other</i> set is equal to this set; otherwise returns <code translate="no">false</code>.</p>
<p>Two sets are considered equal if they contain the same elements.</p>
<p>This function requires the value type to implement <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qset.html#operator-not-eq" translate="no">operator!=</a>().</p>
<!-- @@@operator== -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="operator-2b-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; <span class="name">operator+</span>(<span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>lhs</i>, const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-2b"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; <span class="name">operator+</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-7c-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; <span class="name">operator|</span>(<span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>lhs</i>, const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-7c"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; <span class="name">operator|</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3></div>
<p>Returns a new <a href="qset.html" translate="no">QSet</a> that is the union of sets <i translate="no">lhs</i> and <i translate="no">rhs</i>.</p>
<p><b>See also </b><a href="qset.html#unite" translate="no">unite</a>(), <a href="qset.html#operator-7c-eq" translate="no">operator|=</a>(), <a href="qset.html#operator-and" translate="no">operator&amp;</a>(), and <a href="qset.html#operator-" translate="no">operator-</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="operator-and-1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; <span class="name">operator&amp;</span>(<span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>lhs</i>, const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-and"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; <span class="name">operator&amp;</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3></div>
<p>Returns a new <a href="qset.html" translate="no">QSet</a> that is the intersection of sets <i translate="no">lhs</i> and <i translate="no">rhs</i>.</p>
<p><b>See also </b><a href="qset.html#intersect" translate="no">intersect</a>(), <a href="qset.html#operator-and-eq" translate="no">operator&amp;=</a>(), <a href="qset.html#operator-7c" translate="no">operator|</a>(), and <a href="qset.html#operator-" translate="no">operator-</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="operator--1"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; <span class="name">operator-</span>(<span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>lhs</i>, const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-"><span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; <span class="name">operator-</span>(const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3></div>
<p>Returns a new <a href="qset.html" translate="no">QSet</a> that is the set difference of sets <i translate="no">lhs</i> and <i translate="no">rhs</i>.</p>
<p><b>See also </b><a href="qset.html#subtract" translate="no">subtract</a>(), <a href="qset.html#operator--eq" translate="no">operator-=</a>(), <a href="qset.html#operator-7c" translate="no">operator|</a>(), and <a href="qset.html#operator-and" translate="no">operator&amp;</a>().</p>
<!-- @@@ -->
<!-- $$$erase_if[overload1]$$$erase_ifQSet<T>&Predicate -->
<h3 class="fn" translate="no" id="erase_if"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename T, typename Predicate&gt; <span class="type">qsizetype</span> <span class="name">erase_if</span>(<span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>set</i>, <span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i translate="no">pred</i> returns true from the set <i translate="no">set</i>. Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@erase_if -->
<!-- $$$operator<<$$$operator<<QDataStream&constQSet<T>& -->
<h3 class="fn" translate="no" id="operator-lt-lt-1">template &lt;typename T&gt; <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>set</i>)</h3>
<p>Writes the <i translate="no">set</i> to stream <i translate="no">out</i>.</p>
<p>This function requires the value type to implement <code translate="no">operator&lt;&lt;()</code>.</p>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Format of the QDataStream operators</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator>>$$$operator>>QDataStream&QSet<T>& -->
<h3 class="fn" translate="no" id="operator-gt-gt-1">template &lt;typename T&gt; <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qset.html#QSet" translate="no">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>set</i>)</h3>
<p>Reads a set from stream <i translate="no">in</i> into <i translate="no">set</i>.</p>
<p>This function requires the value type to implement <code translate="no">operator&gt;&gt;()</code>.</p>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Format of the QDataStream operators</a>.</p>
<!-- @@@operator>> -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
