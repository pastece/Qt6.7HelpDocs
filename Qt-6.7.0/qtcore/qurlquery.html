<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qurlquery.cpp -->
  <meta name="description" content="The QUrlQuery class provides a way to manipulate a key-value pairs in a URL's query.">
  <title>QUrlQuery Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QUrlQuery</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#encoding">Encoding</a></li>
<li class="level2"><a href="#non-standard-delimiters">Non-standard delimiters</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QUrlQuery Class</h1>
<!-- $$$QUrlQuery-brief -->
<p>The QUrlQuery class provides a way to manipulate a key-value pairs in a URL's query. <a href="#details">More...</a></p>
<!-- @@@QUrlQuery -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QUrlQuery&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qurlquery-members.html">List of all members, including inherited members</a></li>
<li>QUrlQuery is part of <a href="io.html">Input/Output and Networking</a>, <a href="../qtnetwork/network.html">Network Programming API</a>, and <a href="shared.html">Implicitly Shared Classes</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#QUrlQuery-1" translate="no">QUrlQuery</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#QUrlQuery-2" translate="no">QUrlQuery</a></b>(const QString &amp;<i>queryString</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#QUrlQuery-3" translate="no">QUrlQuery</a></b>(std::initializer_list&lt;std::pair&lt;QString, QString&gt;&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#QUrlQuery-4" translate="no">QUrlQuery</a></b>(const QUrlQuery &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#QUrlQuery-5" translate="no">QUrlQuery</a></b>(QUrlQuery &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#dtor.QUrlQuery" translate="no">~QUrlQuery</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#addQueryItem" translate="no">addQueryItem</a></b>(const QString &amp;<i>key</i>, const QString &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#allQueryItemValues" translate="no">allQueryItemValues</a></b>(const QString &amp;<i>key</i>, QUrl::ComponentFormattingOptions <i>encoding</i> = QUrl::PrettyDecoded) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#hasQueryItem" translate="no">hasQueryItem</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#query" translate="no">query</a></b>(QUrl::ComponentFormattingOptions <i>encoding</i> = QUrl::PrettyDecoded) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#queryItemValue" translate="no">queryItemValue</a></b>(const QString &amp;<i>key</i>, QUrl::ComponentFormattingOptions <i>encoding</i> = QUrl::PrettyDecoded) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;std::pair&lt;QString, QString&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#queryItems" translate="no">queryItems</a></b>(QUrl::ComponentFormattingOptions <i>encoding</i> = QUrl::PrettyDecoded) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#queryPairDelimiter" translate="no">queryPairDelimiter</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#queryValueDelimiter" translate="no">queryValueDelimiter</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#removeAllQueryItems" translate="no">removeAllQueryItems</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#removeQueryItem" translate="no">removeQueryItem</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#setQuery" translate="no">setQuery</a></b>(const QString &amp;<i>queryString</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a></b>(QChar <i>valueDelimiter</i>, QChar <i>pairDelimiter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#setQueryItems" translate="no">setQueryItems</a></b>(const QList&lt;std::pair&lt;QString, QString&gt;&gt; &amp;<i>query</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#swap" translate="no">swap</a></b>(QUrlQuery &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#toString" translate="no">toString</a></b>(QUrl::ComponentFormattingOptions <i>encoding</i> = QUrl::PrettyDecoded) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#operator-not-eq" translate="no">operator!=</a></b>(const QUrlQuery &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrlQuery &amp;</td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#operator-eq" translate="no">operator=</a></b>(const QUrlQuery &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrlQuery &amp;</td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#operator-eq-1" translate="no">operator=</a></b>(QUrlQuery &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#operator-eq-eq" translate="no">operator==</a></b>(const QUrlQuery &amp;<i>other</i>) const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> char16_t </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#defaultQueryPairDelimiter" translate="no">defaultQueryPairDelimiter</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char16_t </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#defaultQueryValueDelimiter" translate="no">defaultQueryValueDelimiter</a></b>()</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qurlquery.html#qHash-1" translate="no">qHash</a></b>(const QUrlQuery &amp;<i>key</i>, size_t <i>seed</i> = 0)</td></tr>
</table></div>
<!-- $$$QUrlQuery-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>It is used to parse the query strings found in URLs like the following:</p>
<p class="centerAlign"><img src="images/qurl-querystring.png" alt="" /></p><p>Query strings like the above are used to transmit options in the URL and are usually decoded into multiple key-value pairs. The one above would contain two entries in its list, with keys &quot;type&quot; and &quot;color&quot;. QUrlQuery can also be used to create a query string suitable for use in <a href="qurl.html#setQuery" translate="no">QUrl::setQuery</a>() from the individual components of the query.</p>
<p>The most common way of parsing a query string is to initialize it in the constructor by passing it the query string. Otherwise, the <a href="qurlquery.html#setQuery" translate="no">setQuery</a>() method can be used to set the query to be parsed. That method can also be used to parse a query with non-standard delimiters, after having set them using the <a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>() function.</p>
<p>The encoded query string can be obtained again using <a href="qurlquery.html#query" translate="no">query</a>(). This will take all the internally-stored items and encode the string using the delimiters.</p>
<h3 id="encoding">Encoding</h3>
<p>All of the getter methods in QUrlQuery support an optional parameter of type <a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::ComponentFormattingOptions</a>, including <a href="qurlquery.html#query" translate="no">query</a>(), which dictate how to encode the data in question. Except for <a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::FullyDecoded</a>, the returned value must still be considered a percent-encoded string, as there are certain values which cannot be expressed in decoded form (like control characters, byte sequences not decodable to UTF-8). For that reason, the percent character is always represented by the string &quot;%25&quot;.</p>
<p>All of the setter methods and the query methods like <a href="qurlquery.html#hasQueryItem" translate="no">hasQueryItem</a>() in QUrlQuery take encoded forms only. Unlike in <a href="qurl.html" translate="no">QUrl</a>, there's no optional parameter to specify that the strings being passed are decoded. If improperly-encoded strings are passed to the setter or query methods, QUrlQuery will attempt to recover instead of failing. That is to say, all functions in this class parse their string arguments as if the <a href="qurl.html#ParsingMode-enum" translate="no">QUrl::TolerantMode</a> decoding mode was specified.</p>
<p>Application code should strive to always ensure proper encoding and not rely on TolerantMode parsing fixing the strings. Notably, all user input must be first percent-encoded using <a href="qurl.html#toPercentEncoding" translate="no">QUrl::toPercentEncoding</a>() or similar functions before being passed to the functions in this class.</p>
<h4 id="handling-of-spaces-and-plus">Handling of spaces and plus (&quot;+&quot;)</h4>
<p>Web browsers usually encode spaces found in HTML FORM elements to a plus sign (&quot;+&quot;) and plus signs to its percent-encoded form (%2B). However, the Internet specifications governing URLs do not consider spaces and the plus character equivalent.</p>
<p>For that reason, QUrlQuery never encodes the space character to &quot;+&quot; and will never decode &quot;+&quot; to a space character. Instead, space characters will be rendered &quot;%20&quot; in encoded form.</p>
<p>To support encoding like that of HTML forms, QUrlQuery also never decodes the &quot;%2B&quot; sequence to a plus sign nor encode a plus sign. In fact, any &quot;%2B&quot; or &quot;+&quot; sequences found in the keys, values, or query string are left exactly like written (except for the uppercasing of &quot;%2b&quot; to &quot;%2B&quot;).</p>
<h4 id="full-decoding">Full decoding</h4>
<p>With <a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::FullyDecoded</a> formatting, all percent-encoded sequences will be decoded fully and the '%' character is used to represent itself. <a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::FullyDecoded</a> should be used with care, since it may cause data loss. See the documentation of <a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::FullyDecoded</a> for information on what data may be lost.</p>
<p>This formatting mode should be used only when dealing with text presented to the user in contexts where percent-encoding is not desired. Note that QUrlQuery setters and query methods do not support the counterpart <a href="qurl.html#ParsingMode-enum" translate="no">QUrl::DecodedMode</a> parsing, so using <a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::FullyDecoded</a> to obtain a listing of keys may result in keys not found in the object.</p>
<h3 id="non-standard-delimiters">Non-standard delimiters</h3>
<p>By default, QUrlQuery uses an equal sign (&quot;=&quot;) to separate a key from its value, and an ampersand (&quot;&amp;&quot;) to separate key-value pairs from each other. It is possible to change the delimiters that QUrlQuery uses for parsing and for reconstructing the query by calling <a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>().</p>
<p>Non-standard delimiters should be chosen from among what RFC 3986 calls &quot;sub-delimiters&quot;. They are:</p>
<pre class="cpp" translate="no">
 sub<span class="operator">-</span>delims    <span class="operator">=</span> <span class="string">&quot;!&quot;</span> <span class="operator">/</span> <span class="string">&quot;$&quot;</span> <span class="operator">/</span> <span class="string">&quot;&amp;&quot;</span> <span class="operator">/</span> <span class="string">&quot;'&quot;</span> <span class="operator">/</span> <span class="string">&quot;(&quot;</span> <span class="operator">/</span> <span class="string">&quot;)&quot;</span>
               <span class="operator">/</span> <span class="string">&quot;*&quot;</span> <span class="operator">/</span> <span class="string">&quot;+&quot;</span> <span class="operator">/</span> <span class="string">&quot;,&quot;</span> <span class="operator">/</span> <span class="string">&quot;;&quot;</span> <span class="operator">/</span> <span class="string">&quot;=&quot;</span>
</pre>
<p>Use of other characters is not supported and may result in unexpected behaviour. QUrlQuery does not verify that you passed a valid delimiter.</p>
</div>
<p><b>See also </b><a href="qurl.html" translate="no">QUrl</a>.</p>
<!-- @@@QUrlQuery -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QUrlQuery[overload1]$$$QUrlQuery -->
<h3 class="fn" translate="no" id="QUrlQuery">QUrlQuery::<span class="name">QUrlQuery</span>()</h3>
<p>Constructs an empty QUrlQuery object. A query can be set afterwards by calling <a href="qurlquery.html#setQuery" translate="no">setQuery</a>() or items can be added by using <a href="qurlquery.html#addQueryItem" translate="no">addQueryItem</a>().</p>
<p><b>See also </b><a href="qurlquery.html#setQuery" translate="no">setQuery</a>() and <a href="qurlquery.html#addQueryItem" translate="no">addQueryItem</a>().</p>
<!-- @@@QUrlQuery -->
<!-- $$$QUrlQuery$$$QUrlQueryconstQUrl& -->
<h3 class="fn" translate="no" id="QUrlQuery-1"><code class="details extra" translate="no">[explicit]</code> QUrlQuery::<span class="name">QUrlQuery</span>(const <span class="type"><a href="qurl.html" translate="no">QUrl</a></span> &amp;<i>url</i>)</h3>
<p>Constructs a QUrlQuery object and parses the query string found in the <i translate="no">url</i> URL, using the default query delimiters. To parse a query string using other delimiters, you should first set them using <a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>() and then set the query with <a href="qurlquery.html#setQuery" translate="no">setQuery</a>().</p>
<p><b>See also </b><a href="qurl.html#query" translate="no">QUrl::query</a>().</p>
<!-- @@@QUrlQuery -->
<!-- $$$QUrlQuery$$$QUrlQueryconstQString& -->
<h3 class="fn" translate="no" id="QUrlQuery-2"><code class="details extra" translate="no">[explicit]</code> QUrlQuery::<span class="name">QUrlQuery</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>queryString</i>)</h3>
<p>Constructs a QUrlQuery object and parses the <i translate="no">queryString</i> query string, using the default query delimiters. To parse a query string using other delimiters, you should first set them using <a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>() and then set the query with <a href="qurlquery.html#setQuery" translate="no">setQuery</a>().</p>
<!-- @@@QUrlQuery -->
<!-- $$$QUrlQuery$$$QUrlQuerystd::initializer_list<std::pair<QString,QString>> -->
<h3 class="fn" translate="no" id="QUrlQuery-3">QUrlQuery::<span class="name">QUrlQuery</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">std::pair</span>&lt;<span class="type"><a href="qstring.html" translate="no">QString</a></span>, <span class="type"><a href="qstring.html" translate="no">QString</a></span>&gt;&gt; <i>list</i>)</h3>
<p>Constructs a QUrlQuery object from the <i translate="no">list</i> of key/value pair.</p>
<!-- @@@QUrlQuery -->
<!-- $$$QUrlQuery$$$QUrlQueryconstQUrlQuery& -->
<h3 class="fn" translate="no" id="QUrlQuery-4">QUrlQuery::<span class="name">QUrlQuery</span>(const <span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;<i>other</i>)</h3>
<p>Copies the contents of the <i translate="no">other</i> QUrlQuery object, including the query delimiters.</p>
<!-- @@@QUrlQuery -->
<!-- $$$QUrlQuery$$$QUrlQueryQUrlQuery&& -->
<h3 class="fn" translate="no" id="QUrlQuery-5"><code class="details extra" translate="no">[noexcept, since 6.5]</code> QUrlQuery::<span class="name">QUrlQuery</span>(<span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Moves the contents of the <i translate="no">other</i> QUrlQuery object, including the query delimiters.</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@QUrlQuery -->
<!-- $$$~QUrlQuery[overload1]$$$~QUrlQuery -->
<h3 class="fn" translate="no" id="dtor.QUrlQuery"><code class="details extra" translate="no">[noexcept]</code> QUrlQuery::<span class="name">~QUrlQuery</span>()</h3>
<p>Destroys this <a href="qurlquery.html" translate="no">QUrlQuery</a> object.</p>
<!-- @@@~QUrlQuery -->
<!-- $$$addQueryItem[overload1]$$$addQueryItemconstQString&constQString& -->
<h3 class="fn" translate="no" id="addQueryItem"><span class="type">void</span> QUrlQuery::<span class="name">addQueryItem</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>, const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>value</i>)</h3>
<p>Appends the pair <i translate="no">key</i> = <i translate="no">value</i> to the end of the query string of the URL. This method does not overwrite existing items that might exist with the same key.</p>
<div class="admonition note">
<p><b>Note: </b>This method does not treat spaces (ASCII 0x20) and plus (&quot;+&quot;) signs as the same, like HTML forms do. If you need spaces to be represented as plus signs, use actual plus signs.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The key and value strings are expected to be in percent-encoded form.</p>
</div>
<p><b>See also </b><a href="qurlquery.html#hasQueryItem" translate="no">hasQueryItem</a>() and <a href="qurlquery.html#queryItemValue" translate="no">queryItemValue</a>().</p>
<!-- @@@addQueryItem -->
<!-- $$$allQueryItemValues[overload1]$$$allQueryItemValuesconstQString&QUrl::ComponentFormattingOptions -->
<h3 class="fn" translate="no" id="allQueryItemValues"><span class="type"><a href="qstringlist.html" translate="no">QStringList</a></span> QUrlQuery::<span class="name">allQueryItemValues</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>, <span class="type"><a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::ComponentFormattingOptions</a></span> <i>encoding</i> = QUrl::PrettyDecoded) const</h3>
<p>Returns the a list of query string values whose key is equal to <i translate="no">key</i> from the URL, using the options specified in <i translate="no">encoding</i> to encode the return value. If the key <i translate="no">key</i> is not found, this function returns an empty list.</p>
<div class="admonition note">
<p><b>Note: </b>The key is expected to be in percent-encoded form.</p>
</div>
<p><b>See also </b><a href="qurlquery.html#queryItemValue" translate="no">queryItemValue</a>() and <a href="qurlquery.html#addQueryItem" translate="no">addQueryItem</a>().</p>
<!-- @@@allQueryItemValues -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QUrlQuery::<span class="name">clear</span>()</h3>
<p>Clears this <a href="qurlquery.html" translate="no">QUrlQuery</a> object by removing all of the key-value pairs currently stored. If the query delimiters have been changed, this function will leave them with their changed values.</p>
<p><b>See also </b><a href="qurlquery.html#isEmpty" translate="no">isEmpty</a>() and <a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>().</p>
<!-- @@@clear -->
<!-- $$$defaultQueryPairDelimiter[overload1]$$$defaultQueryPairDelimiter -->
<h3 class="fn" translate="no" id="defaultQueryPairDelimiter"><code class="details extra" translate="no">[static constexpr noexcept]</code> <span class="type">char16_t</span> QUrlQuery::<span class="name">defaultQueryPairDelimiter</span>()</h3>
<p>Returns the default character for separating keys-value pairs from each other, an ampersand (&quot;&amp;&quot;).</p>
<div class="admonition note">
<p><b>Note: </b>Prior to Qt 6, this function returned <a href="qchar.html" translate="no">QChar</a>.</p>
</div>
<p><b>See also </b><a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>(), <a href="qurlquery.html#queryPairDelimiter" translate="no">queryPairDelimiter</a>(), and <a href="qurlquery.html#defaultQueryValueDelimiter" translate="no">defaultQueryValueDelimiter</a>().</p>
<!-- @@@defaultQueryPairDelimiter -->
<!-- $$$defaultQueryValueDelimiter[overload1]$$$defaultQueryValueDelimiter -->
<h3 class="fn" translate="no" id="defaultQueryValueDelimiter"><code class="details extra" translate="no">[static constexpr noexcept]</code> <span class="type">char16_t</span> QUrlQuery::<span class="name">defaultQueryValueDelimiter</span>()</h3>
<p>Returns the default character for separating keys from values in the query, an equal sign (&quot;=&quot;).</p>
<div class="admonition note">
<p><b>Note: </b>Prior to Qt 6, this function returned <a href="qchar.html" translate="no">QChar</a>.</p>
</div>
<p><b>See also </b><a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>(), <a href="qurlquery.html#queryValueDelimiter" translate="no">queryValueDelimiter</a>(), and <a href="qurlquery.html#defaultQueryPairDelimiter" translate="no">defaultQueryPairDelimiter</a>().</p>
<!-- @@@defaultQueryValueDelimiter -->
<!-- $$$hasQueryItem[overload1]$$$hasQueryItemconstQString& -->
<h3 class="fn" translate="no" id="hasQueryItem"><span class="type">bool</span> QUrlQuery::<span class="name">hasQueryItem</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>) const</h3>
<p>Returns <code translate="no">true</code> if there is a query string pair whose key is equal to <i translate="no">key</i> from the URL.</p>
<div class="admonition note">
<p><b>Note: </b>The key expected to be in percent-encoded form.</p>
</div>
<p><b>See also </b><a href="qurlquery.html#addQueryItem" translate="no">addQueryItem</a>() and <a href="qurlquery.html#queryItemValue" translate="no">queryItemValue</a>().</p>
<!-- @@@hasQueryItem -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" translate="no" id="isEmpty"><span class="type">bool</span> QUrlQuery::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code translate="no">true</code> if this <a href="qurlquery.html" translate="no">QUrlQuery</a> object contains no key-value pairs, such as after being default-constructed or after parsing an empty query string.</p>
<p><b>See also </b><a href="qurlquery.html#setQuery" translate="no">setQuery</a>() and <a href="qurlquery.html#clear" translate="no">clear</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$query[overload1]$$$queryQUrl::ComponentFormattingOptions -->
<h3 class="fn" translate="no" id="query"><span class="type"><a href="qstring.html" translate="no">QString</a></span> QUrlQuery::<span class="name">query</span>(<span class="type"><a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::ComponentFormattingOptions</a></span> <i>encoding</i> = QUrl::PrettyDecoded) const</h3>
<p>Returns the reconstructed query string, formed from the key-value pairs currently stored in this <a href="qurlquery.html" translate="no">QUrlQuery</a> object and separated by the query delimiters chosen for this object. The keys and values are encoded using the options given by the <i translate="no">encoding</i> parameter.</p>
<p>For this function, the only ambiguous delimiter is the hash (&quot;#&quot;), as in URLs it is used to separate the query string from the fragment that may follow.</p>
<p>The order of the key-value pairs in the returned string is exactly the same as in the original query.</p>
<p><b>See also </b><a href="qurlquery.html#setQuery" translate="no">setQuery</a>(), <a href="qurl.html#setQuery" translate="no">QUrl::setQuery</a>(), <a href="qurl.html#fragment" translate="no">QUrl::fragment</a>(), and <a href="qurlquery.html#encoding" translate="no">Encoding</a>.</p>
<!-- @@@query -->
<!-- $$$queryItemValue[overload1]$$$queryItemValueconstQString&QUrl::ComponentFormattingOptions -->
<h3 class="fn" translate="no" id="queryItemValue"><span class="type"><a href="qstring.html" translate="no">QString</a></span> QUrlQuery::<span class="name">queryItemValue</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>, <span class="type"><a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::ComponentFormattingOptions</a></span> <i>encoding</i> = QUrl::PrettyDecoded) const</h3>
<p>Returns the query value associated with key <i translate="no">key</i> from the URL, using the options specified in <i translate="no">encoding</i> to encode the return value. If the key <i translate="no">key</i> is not found, this function returns an empty string. If you need to distinguish between an empty value and a non-existent key, you should check for the key's presence first using <a href="qurlquery.html#hasQueryItem" translate="no">hasQueryItem</a>().</p>
<p>If the key <i translate="no">key</i> is multiply defined, this function will return the first one found, in the order they were present in the query string or added using <a href="qurlquery.html#addQueryItem" translate="no">addQueryItem</a>().</p>
<div class="admonition note">
<p><b>Note: </b>The key is expected to be in percent-encoded form.</p>
</div>
<p><b>See also </b><a href="qurlquery.html#addQueryItem" translate="no">addQueryItem</a>(), <a href="qurlquery.html#allQueryItemValues" translate="no">allQueryItemValues</a>(), and <a href="qurlquery.html#encoding" translate="no">Encoding</a>.</p>
<!-- @@@queryItemValue -->
<!-- $$$queryItems[overload1]$$$queryItemsQUrl::ComponentFormattingOptions -->
<h3 class="fn" translate="no" id="queryItems"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">std::pair</span>&lt;<span class="type"><a href="qstring.html" translate="no">QString</a></span>, <span class="type"><a href="qstring.html" translate="no">QString</a></span>&gt;&gt; QUrlQuery::<span class="name">queryItems</span>(<span class="type"><a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::ComponentFormattingOptions</a></span> <i>encoding</i> = QUrl::PrettyDecoded) const</h3>
<p>Returns the query string of the URL, as a map of keys and values, using the options specified in <i translate="no">encoding</i> to encode the items. The order of the elements is the same as the one found in the query string or set with <a href="qurlquery.html#setQueryItems" translate="no">setQueryItems</a>().</p>
<p><b>See also </b><a href="qurlquery.html#setQueryItems" translate="no">setQueryItems</a>() and <a href="qurlquery.html#encoding" translate="no">Encoding</a>.</p>
<!-- @@@queryItems -->
<!-- $$$queryPairDelimiter[overload1]$$$queryPairDelimiter -->
<h3 class="fn" translate="no" id="queryPairDelimiter"><span class="type"><a href="qchar.html" translate="no">QChar</a></span> QUrlQuery::<span class="name">queryPairDelimiter</span>() const</h3>
<p>Returns the character used to delimit between keys-value pairs when reconstructing the query string in <a href="qurlquery.html#query" translate="no">query</a>() or when parsing in <a href="qurlquery.html#setQuery" translate="no">setQuery</a>().</p>
<p><b>See also </b><a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>() and <a href="qurlquery.html#queryValueDelimiter" translate="no">queryValueDelimiter</a>().</p>
<!-- @@@queryPairDelimiter -->
<!-- $$$queryValueDelimiter[overload1]$$$queryValueDelimiter -->
<h3 class="fn" translate="no" id="queryValueDelimiter"><span class="type"><a href="qchar.html" translate="no">QChar</a></span> QUrlQuery::<span class="name">queryValueDelimiter</span>() const</h3>
<p>Returns the character used to delimit between keys and values when reconstructing the query string in <a href="qurlquery.html#query" translate="no">query</a>() or when parsing in <a href="qurlquery.html#setQuery" translate="no">setQuery</a>().</p>
<p><b>See also </b><a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>() and <a href="qurlquery.html#queryPairDelimiter" translate="no">queryPairDelimiter</a>().</p>
<!-- @@@queryValueDelimiter -->
<!-- $$$removeAllQueryItems[overload1]$$$removeAllQueryItemsconstQString& -->
<h3 class="fn" translate="no" id="removeAllQueryItems"><span class="type">void</span> QUrlQuery::<span class="name">removeAllQueryItems</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>)</h3>
<p>Removes all the query string pairs whose key is equal to <i translate="no">key</i> from the URL.</p>
<div class="admonition note">
<p><b>Note: </b>The key is expected to be in percent-encoded form.</p>
</div>
<p><b>See also </b><a href="qurlquery.html#removeQueryItem" translate="no">removeQueryItem</a>().</p>
<!-- @@@removeAllQueryItems -->
<!-- $$$removeQueryItem[overload1]$$$removeQueryItemconstQString& -->
<h3 class="fn" translate="no" id="removeQueryItem"><span class="type">void</span> QUrlQuery::<span class="name">removeQueryItem</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>key</i>)</h3>
<p>Removes the query string pair whose key is equal to <i translate="no">key</i> from the URL. If there are multiple items with a key equal to <i translate="no">key</i>, it removes the first item in the order they were present in the query string or added with <a href="qurlquery.html#addQueryItem" translate="no">addQueryItem</a>().</p>
<div class="admonition note">
<p><b>Note: </b>The key is expected to be in percent-encoded form.</p>
</div>
<p><b>See also </b><a href="qurlquery.html#removeAllQueryItems" translate="no">removeAllQueryItems</a>().</p>
<!-- @@@removeQueryItem -->
<!-- $$$setQuery[overload1]$$$setQueryconstQString& -->
<h3 class="fn" translate="no" id="setQuery"><span class="type">void</span> QUrlQuery::<span class="name">setQuery</span>(const <span class="type"><a href="qstring.html" translate="no">QString</a></span> &amp;<i>queryString</i>)</h3>
<p>Parses the query string in <i translate="no">queryString</i> and sets the internal items to the values found there. If any delimiters have been specified with <a href="qurlquery.html#setQueryDelimiters" translate="no">setQueryDelimiters</a>(), this function will use them instead of the default delimiters to parse the string.</p>
<p><b>See also </b><a href="qurlquery.html#query" translate="no">query</a>().</p>
<!-- @@@setQuery -->
<!-- $$$setQueryDelimiters[overload1]$$$setQueryDelimitersQCharQChar -->
<h3 class="fn" translate="no" id="setQueryDelimiters"><span class="type">void</span> QUrlQuery::<span class="name">setQueryDelimiters</span>(<span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>valueDelimiter</i>, <span class="type"><a href="qchar.html" translate="no">QChar</a></span> <i>pairDelimiter</i>)</h3>
<p>Sets the characters used for delimiting between keys and values, and between key-value pairs in the URL's query string. The default value delimiter is '=' and the default pair delimiter is '&amp;'.</p>
<p class="centerAlign"><img src="images/qurl-querystring.png" alt="" /></p><p><i translate="no">valueDelimiter</i> will be used for separating keys from values, and <i translate="no">pairDelimiter</i> will be used to separate key-value pairs. Any occurrences of these delimiting characters in the encoded representation of the keys and values of the query string are percent encoded when returned in <a href="qurlquery.html#query" translate="no">query</a>().</p>
<p>If <i translate="no">valueDelimiter</i> is set to ',' and <i translate="no">pairDelimiter</i> is ';', the above query string would instead be represented like this:</p>
<pre class="cpp" translate="no">
 http:<span class="comment">//www.example.com/cgi-bin/drawgraph.cgi?type,pie;color,green</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>Non-standard delimiters should be chosen from among what RFC 3986 calls &quot;sub-delimiters&quot;. They are:</p>
</div>
<pre class="cpp" translate="no">
 sub<span class="operator">-</span>delims    <span class="operator">=</span> <span class="string">&quot;!&quot;</span> <span class="operator">/</span> <span class="string">&quot;$&quot;</span> <span class="operator">/</span> <span class="string">&quot;&amp;&quot;</span> <span class="operator">/</span> <span class="string">&quot;'&quot;</span> <span class="operator">/</span> <span class="string">&quot;(&quot;</span> <span class="operator">/</span> <span class="string">&quot;)&quot;</span>
               <span class="operator">/</span> <span class="string">&quot;*&quot;</span> <span class="operator">/</span> <span class="string">&quot;+&quot;</span> <span class="operator">/</span> <span class="string">&quot;,&quot;</span> <span class="operator">/</span> <span class="string">&quot;;&quot;</span> <span class="operator">/</span> <span class="string">&quot;=&quot;</span>
</pre>
<p>Use of other characters is not supported and may result in unexpected behavior. This method does not verify that you passed a valid delimiter.</p>
<p><b>See also </b><a href="qurlquery.html#queryValueDelimiter" translate="no">queryValueDelimiter</a>() and <a href="qurlquery.html#queryPairDelimiter" translate="no">queryPairDelimiter</a>().</p>
<!-- @@@setQueryDelimiters -->
<!-- $$$setQueryItems[overload1]$$$setQueryItemsconstQList<std::pair<QString,QString>>& -->
<h3 class="fn" translate="no" id="setQueryItems"><span class="type">void</span> QUrlQuery::<span class="name">setQueryItems</span>(const <span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">std::pair</span>&lt;<span class="type"><a href="qstring.html" translate="no">QString</a></span>, <span class="type"><a href="qstring.html" translate="no">QString</a></span>&gt;&gt; &amp;<i>query</i>)</h3>
<p>Sets the items in this <a href="qurlquery.html" translate="no">QUrlQuery</a> object to <i translate="no">query</i>. The order of the elements in <i translate="no">query</i> is preserved.</p>
<div class="admonition note">
<p><b>Note: </b>This method does not treat spaces (ASCII 0x20) and plus (&quot;+&quot;) signs as the same, like HTML forms do. If you need spaces to be represented as plus signs, use actual plus signs.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The keys and values are expected to be in percent-encoded form.</p>
</div>
<p><b>See also </b><a href="qurlquery.html#queryItems" translate="no">queryItems</a>() and <a href="qurlquery.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@setQueryItems -->
<!-- $$$swap[overload1]$$$swapQUrlQuery& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QUrlQuery::<span class="name">swap</span>(<span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;<i>other</i>)</h3>
<p>Swaps this URL query instance with <i translate="no">other</i>. This function is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$toString[overload1]$$$toStringQUrl::ComponentFormattingOptions -->
<h3 class="fn" translate="no" id="toString"><span class="type"><a href="qstring.html" translate="no">QString</a></span> QUrlQuery::<span class="name">toString</span>(<span class="type"><a href="qurl.html#ComponentFormattingOption-enum" translate="no">QUrl::ComponentFormattingOptions</a></span> <i>encoding</i> = QUrl::PrettyDecoded) const</h3>
<p>Returns this <a href="qurlquery.html" translate="no">QUrlQuery</a> as a <a href="qstring.html" translate="no">QString</a>. <i translate="no">encoding</i> can be used to specify the URL string encoding of the return value.</p>
<!-- @@@toString -->
<!-- $$$operator!=[overload1]$$$operator!=constQUrlQuery& -->
<h3 class="fn" translate="no" id="operator-not-eq"><span class="type">bool</span> QUrlQuery::<span class="name">operator!=</span>(const <span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is not equal to this <a href="qurlquery.html" translate="no">QUrlQuery</a>. Otherwise, returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qurlquery.html#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator=[overload1]$$$operator=constQUrlQuery& -->
<h3 class="fn" translate="no" id="operator-eq"><span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;QUrlQuery::<span class="name">operator=</span>(const <span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;<i>other</i>)</h3>
<p>Copies the contents of the <i translate="no">other</i> <a href="qurlquery.html" translate="no">QUrlQuery</a> object, including the query delimiters.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QUrlQuery&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;QUrlQuery::<span class="name">operator=</span>(<span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qurlquery.html" translate="no">QUrlQuery</a> instance.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQUrlQuery& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><span class="type">bool</span> QUrlQuery::<span class="name">operator==</span>(const <span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;<i>other</i>) const</h3>
<p>Returns <code translate="no">true</code> if this object and the <i translate="no">other</i> object contain the same contents, in the same order, and use the same query delimiters.</p>
<!-- @@@operator== -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash$$$qHashconstQUrlQuery&size_t -->
<h3 class="fn" translate="no" id="qHash-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type"><a href="qurlquery.html#QUrlQuery" translate="no">QUrlQuery</a></span> &amp;<i>key</i>, <span class="type">size_t</span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for <i translate="no">key</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<!-- @@@qHash -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
