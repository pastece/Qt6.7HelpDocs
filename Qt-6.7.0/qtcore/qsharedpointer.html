<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qsharedpointer.cpp -->
  <meta name="description" content="The QSharedPointer class holds a strong reference to a shared pointer.">
  <title>QSharedPointer Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QSharedPointer</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#thread-safety">Thread-Safety</a></li>
<li class="level2"><a href="#other-pointer-classes">Other Pointer Classes</a></li>
<li class="level2"><a href="#optional-pointer-tracking">Optional Pointer Tracking</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QSharedPointer Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QSharedPointer</span>
<!-- $$$QSharedPointer-brief -->
<p>The QSharedPointer class holds a strong reference to a shared pointer. <a href="#details">More...</a></p>
<!-- @@@QSharedPointer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QSharedPointer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qsharedpointer-members.html">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-1" translate="no">QSharedPointer</a></b>(X *<i>ptr</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-2" translate="no">QSharedPointer</a></b>(X *<i>ptr</i>, Deleter <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-3" translate="no">QSharedPointer</a></b>(std::nullptr_t)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-4" translate="no">QSharedPointer</a></b>(std::nullptr_t, Deleter <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-6" translate="no">QSharedPointer</a></b>(const QWeakPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-8" translate="no">QSharedPointer</a></b>(QSharedPointer&lt;X&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-5" translate="no">QSharedPointer</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-7" translate="no">QSharedPointer</a></b>(QSharedPointer&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#dtor.QSharedPointer" translate="no">~QSharedPointer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#constCast" translate="no">constCast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#data" translate="no">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#dynamicCast" translate="no">dynamicCast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#get" translate="no">get</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#isNull" translate="no">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#objectCast" translate="no">objectCast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#owner_before" translate="no">owner_before</a></b>(const QSharedPointer&lt;X&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#owner_before-1" translate="no">owner_before</a></b>(const QWeakPointer&lt;X&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#owner_equal" translate="no">owner_equal</a></b>(const QSharedPointer&lt;X&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#owner_equal-1" translate="no">owner_equal</a></b>(const QWeakPointer&lt;X&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> size_t </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#owner_hash" translate="no">owner_hash</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#reset" translate="no">reset</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#reset-1" translate="no">reset</a></b>(T *<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#reset-2" translate="no">reset</a></b>(T *<i>t</i>, Deleter <i>deleter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#staticCast" translate="no">staticCast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#swap" translate="no">swap</a></b>(QSharedPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWeakPointer&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#toWeakRef" translate="no">toWeakRef</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-bool" translate="no">operator bool</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not" translate="no">operator!</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-2a" translate="no">operator*</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator--gt" translate="no">operator-&gt;</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq" translate="no">operator=</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-1" translate="no">operator=</a></b>(QSharedPointer&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-2" translate="no">operator=</a></b>(const QWeakPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-3" translate="no">operator=</a></b>(QSharedPointer&lt;X&gt; &amp;&amp;<i>other</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#create" translate="no">create</a></b>(Args &amp;&amp;... <i>args</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qHash-39" translate="no">qHash</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>key</i>, size_t <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerCast" translate="no">qSharedPointerCast</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerCast-1" translate="no">qSharedPointerCast</a></b>(const QWeakPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerConstCast-1" translate="no">qSharedPointerConstCast</a></b>(const QWeakPointer&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerDynamicCast" translate="no">qSharedPointerDynamicCast</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerDynamicCast-1" translate="no">qSharedPointerDynamicCast</a></b>(const QWeakPointer&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerObjectCast" translate="no">qSharedPointerObjectCast</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::shared_ptr&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerObjectCast-1" translate="no">qSharedPointerObjectCast</a></b>(const std::shared_ptr&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::shared_ptr&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerObjectCast-2" translate="no">qSharedPointerObjectCast</a></b>(std::shared_ptr&lt;T&gt; &amp;&amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerObjectCast-3" translate="no">qSharedPointerObjectCast</a></b>(const QWeakPointer&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::shared_ptr&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qobject_pointer_cast" translate="no">qobject_pointer_cast</a></b>(const std::shared_ptr&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::shared_ptr&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qobject_pointer_cast-1" translate="no">qobject_pointer_cast</a></b>(std::shared_ptr&lt;T&gt; &amp;&amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq-2" translate="no">operator!=</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>ptr1</i>, const QSharedPointer&lt;X&gt; &amp;<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq-3" translate="no">operator!=</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>ptr1</i>, const X *<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq-4" translate="no">operator!=</a></b>(const T *<i>ptr1</i>, const QSharedPointer&lt;X&gt; &amp;<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq-6" translate="no">operator!=</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>lhs</i>, std::nullptr_t)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq-7" translate="no">operator!=</a></b>(std::nullptr_t, const QSharedPointer&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDebug </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-lt-lt-48" translate="no">operator&lt;&lt;</a></b>(QDebug <i>debug</i>, const QSharedPointer&lt;T&gt; &amp;<i>ptr</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq-3" translate="no">operator==</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>ptr1</i>, const QSharedPointer&lt;X&gt; &amp;<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq-4" translate="no">operator==</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>ptr1</i>, const X *<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq-5" translate="no">operator==</a></b>(const T *<i>ptr1</i>, const QSharedPointer&lt;X&gt; &amp;<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq-8" translate="no">operator==</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>lhs</i>, std::nullptr_t)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq-9" translate="no">operator==</a></b>(std::nullptr_t, const QSharedPointer&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
</table></div>
<!-- $$$QSharedPointer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QSharedPointer is an automatic, shared pointer in C++. It behaves exactly like a normal pointer for normal purposes, including respect for constness.</p>
<p>QSharedPointer will delete the pointer it is holding when it goes out of scope, provided no other QSharedPointer objects are referencing it.</p>
<p>A QSharedPointer object can be created from a normal pointer, another QSharedPointer object or by promoting a <a href="qweakpointer.html" translate="no">QWeakPointer</a> object to a strong reference.</p>
<h3 id="thread-safety">Thread-Safety</h3>
<p>QSharedPointer and <a href="qweakpointer.html" translate="no">QWeakPointer</a> are reentrant classes. This means that, in general, a given QSharedPointer or <a href="qweakpointer.html" translate="no">QWeakPointer</a> object <b>cannot</b> be accessed by multiple threads at the same time without synchronization.</p>
<p>Different QSharedPointer and <a href="qweakpointer.html" translate="no">QWeakPointer</a> objects can safely be accessed by multiple threads at the same time. This includes the case where they hold pointers to the same object; the reference counting mechanism is atomic, and no manual synchronization is required.</p>
<p>It should be noted that, while the pointer value can be accessed in this manner (that is, by multiple threads at the same time, without synchronization), QSharedPointer and <a href="qweakpointer.html" translate="no">QWeakPointer</a> provide no guarantee about the object being pointed to. The specific thread-safety and reentrancy rules for that object still apply.</p>
<h3 id="other-pointer-classes">Other Pointer Classes</h3>
<p>Qt also provides two other pointer wrapper classes: <a href="qpointer.html" translate="no">QPointer</a> and <a href="qshareddatapointer.html" translate="no">QSharedDataPointer</a>. They are incompatible with one another, since each has its very different use case.</p>
<p>QSharedPointer holds a shared pointer by means of an external reference count (i.e., a reference counter placed outside the object). Like its name indicates, the pointer value is shared among all instances of QSharedPointer and <a href="qweakpointer.html" translate="no">QWeakPointer</a>. The contents of the object pointed to by the pointer should not be considered shared, however: there is only one object. For that reason, QSharedPointer does not provide a way to detach or make copies of the pointed object.</p>
<p><a href="qshareddatapointer.html" translate="no">QSharedDataPointer</a>, on the other hand, holds a pointer to shared data (i.e., a class derived from <a href="qshareddata.html" translate="no">QSharedData</a>). It does so by means of an internal reference count, placed in the <a href="qshareddata.html" translate="no">QSharedData</a> base class. This class can, therefore, detach based on the type of access made to the data being guarded: if it's a non-const access, it creates a copy atomically for the operation to complete.</p>
<p><a href="qexplicitlyshareddatapointer.html" translate="no">QExplicitlySharedDataPointer</a> is a variant of <a href="qshareddatapointer.html" translate="no">QSharedDataPointer</a>, except that it only detaches if <a href="qexplicitlyshareddatapointer.html#detach" translate="no">QExplicitlySharedDataPointer::detach</a>() is explicitly called (hence the name).</p>
<p><a href="qscopedpointer.html" translate="no">QScopedPointer</a> simply holds a pointer to a heap allocated object and deletes it in its destructor. This class is useful when an object needs to be heap allocated and deleted, but no more. <a href="qscopedpointer.html" translate="no">QScopedPointer</a> is lightweight, it makes no use of additional structure or reference counting.</p>
<p>Finally, <a href="qpointer.html" translate="no">QPointer</a> holds a pointer to a <a href="qobject.html" translate="no">QObject</a>-derived object, but it does so weakly. <a href="qweakpointer.html" translate="no">QWeakPointer</a> has the same functionality, but its use for that function is deprecated.</p>
<h3 id="optional-pointer-tracking">Optional Pointer Tracking</h3>
<p>A feature of QSharedPointer that can be enabled at compile-time for debugging purposes is a pointer tracking mechanism. When enabled, QSharedPointer registers in a global set all the pointers that it tracks. This allows one to catch mistakes like assigning the same pointer to two QSharedPointer objects.</p>
<p>This function is enabled by defining the <code translate="no">QT_SHAREDPOINTER_TRACK_POINTERS</code> macro before including the QSharedPointer header.</p>
<p>It is safe to use this feature even with code compiled without the feature. QSharedPointer will ensure that the pointer is removed from the tracker even from code compiled without pointer tracking.</p>
<p>Note, however, that the pointer tracking feature has limitations on multiple- or virtual-inheritance (that is, in cases where two different pointer addresses can refer to the same object). In that case, if a pointer is cast to a different type and its value changes, QSharedPointer's pointer tracking mechanism may fail to detect that the object being tracked is the same.</p>
</div>
<p><b>See also </b><a href="qshareddatapointer.html" translate="no">QSharedDataPointer</a>, <a href="qweakpointer.html" translate="no">QWeakPointer</a>, <a href="qscopedpointer.html" translate="no">QScopedPointer</a>, and <a href="qenablesharedfromthis.html" translate="no">QEnableSharedFromThis</a>.</p>
<!-- @@@QSharedPointer -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="owner_before"><code class="details extra" translate="no">[noexcept, since 6.7]</code> template &lt;typename X&gt; <span class="type">bool</span> QSharedPointer::<span class="name">owner_before</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>other</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="owner_before-1"><code class="details extra" translate="no">[noexcept, since 6.7]</code> template &lt;typename X&gt; <span class="type">bool</span> QSharedPointer::<span class="name">owner_before</span>(const <span class="type"><a href="qweakpointer.html" translate="no">QWeakPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>other</i>) const</h3></div>
<p>Returns <code translate="no">true</code> if and only if this smart pointer precedes <i translate="no">other</i> in an implementation-defined owner-based ordering. The ordering is such that two smart pointers are considered equivalent if they are both empty or if they both own the same object (even if their apparent type and pointer are different).</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qsharedpointer.html#owner_equal" translate="no">owner_equal</a>.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="owner_equal"><code class="details extra" translate="no">[noexcept, since 6.7]</code> template &lt;typename X&gt; <span class="type">bool</span> QSharedPointer::<span class="name">owner_equal</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>other</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="owner_equal-1"><code class="details extra" translate="no">[noexcept, since 6.7]</code> template &lt;typename X&gt; <span class="type">bool</span> QSharedPointer::<span class="name">owner_equal</span>(const <span class="type"><a href="qweakpointer.html" translate="no">QWeakPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>other</i>) const</h3></div>
<p>Returns <code translate="no">true</code> if and only if this smart pointer and <i translate="no">other</i> share ownership.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qsharedpointer.html#owner_before" translate="no">owner_before</a> and <a href="qsharedpointer.html#owner_hash" translate="no">owner_hash</a>.</p>
<!-- @@@ -->
<!-- $$$ -->
<h3 class="fn fngroupitem" translate="no" id="owner_hash"><code class="details extra" translate="no">[noexcept, since 6.7]</code> <span class="type">size_t</span> QSharedPointer::<span class="name">owner_hash</span>() const</h3>
<p>Returns a owner-based hash value for this smart pointer object. Smart pointers that compare equal (as per <code translate="no">owner_equal</code>) will have an identical owner-based hash.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qsharedpointer.html#owner_equal" translate="no">owner_equal</a>.</p>
<!-- @@@ -->
<!-- $$$QSharedPointer[overload1]$$$QSharedPointer -->
<h3 class="fn" translate="no" id="QSharedPointer">QSharedPointer::<span class="name">QSharedPointer</span>()</h3>
<p>Creates a QSharedPointer that is null (the object is holding a reference to <code translate="no">nullptr</code>).</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerX* -->
<h3 class="fn" translate="no" id="QSharedPointer-1"><code class="details extra" translate="no">[explicit]</code> template &lt;typename X&gt; QSharedPointer::<span class="name">QSharedPointer</span>(<span class="type">X</span> *<i>ptr</i>)</h3>
<p>Creates a QSharedPointer that points to <i translate="no">ptr</i>. The pointer <i translate="no">ptr</i> becomes managed by this QSharedPointer and must not be passed to another QSharedPointer object or deleted outside this object.</p>
<p>Since Qt 5.8, when the last reference to this QSharedPointer gets destroyed, <i translate="no">ptr</i> will be deleted by calling <code translate="no">X</code>'s destructor (even if <code translate="no">X</code> is not the same as QSharedPointer's template parameter <code translate="no">T</code>). Previously, the destructor for <code translate="no">T</code> was called.</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerX*Deleter -->
<h3 class="fn" translate="no" id="QSharedPointer-2">template &lt;typename X, typename Deleter&gt; QSharedPointer::<span class="name">QSharedPointer</span>(<span class="type">X</span> *<i>ptr</i>, <span class="type">Deleter</span> <i>d</i>)</h3>
<p>Creates a QSharedPointer that points to <i translate="no">ptr</i>. The pointer <i translate="no">ptr</i> becomes managed by this QSharedPointer and must not be passed to another QSharedPointer object or deleted outside this object.</p>
<p>The deleter parameter <i translate="no">d</i> specifies the custom deleter for this object. The custom deleter is called, instead of the operator delete(), when the strong reference count drops to 0. This is useful, for instance, for calling <a href="qobject.html#deleteLater" translate="no">deleteLater</a>() on a <a href="qobject.html" translate="no">QObject</a> instead:</p>
<pre class="cpp" translate="no">
     <span class="keyword">static</span> <span class="type">void</span> doDeleteLater(MyObject <span class="operator">*</span>obj)
     {
         obj<span class="operator">-</span><span class="operator">&gt;</span>deleteLater();
     }

     <span class="type">void</span> otherFunction()
     {
         <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span><span class="operator">&lt;</span>MyObject<span class="operator">&gt;</span> obj <span class="operator">=</span>
             <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span><span class="operator">&lt;</span>MyObject<span class="operator">&gt;</span>(<span class="keyword">new</span> MyObject<span class="operator">,</span> doDeleteLater);

         <span class="comment">// continue using obj</span>
         obj<span class="operator">.</span>clear();    <span class="comment">// calls obj-&gt;deleteLater();</span>
     }
</pre>
<p>Note that the custom deleter function will be called with a pointer to type <code translate="no">X</code>, even if the QSharedPointer template parameter <code translate="no">T</code> is not the same.</p>
<p>It is also possible to specify a member function directly, as in:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span><span class="operator">&lt;</span>MyObject<span class="operator">&gt;</span> obj <span class="operator">=</span>
         <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span><span class="operator">&lt;</span>MyObject<span class="operator">&gt;</span>(<span class="keyword">new</span> MyObject<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qobject.html" translate="no">QObject</a></span><span class="operator">::</span>deleteLater);
</pre>
<p><b>See also </b><a href="qsharedpointer.html#clear" translate="no">clear</a>().</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerstd::nullptr_t -->
<h3 class="fn" translate="no" id="QSharedPointer-3">QSharedPointer::<span class="name">QSharedPointer</span>(<span class="type">std::nullptr_t</span>)</h3>
<p>Creates a QSharedPointer that is null. This is equivalent to the QSharedPointer default constructor.</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerstd::nullptr_tDeleter -->
<h3 class="fn" translate="no" id="QSharedPointer-4">template &lt;typename Deleter&gt; QSharedPointer::<span class="name">QSharedPointer</span>(<span class="type">std::nullptr_t</span>, <span class="type">Deleter</span> <i>d</i>)</h3>
<p>Creates a QSharedPointer that is null. This is equivalent to the QSharedPointer default constructor.</p>
<p>The deleter parameter <i translate="no">d</i> specifies the custom deleter for this object. The custom deleter is called, instead of the operator delete(), when the strong reference count drops to 0.</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerconstQWeakPointer<T>& -->
<h3 class="fn" translate="no" id="QSharedPointer-6">QSharedPointer::<span class="name">QSharedPointer</span>(const <span class="type"><a href="qweakpointer.html" translate="no">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Creates a QSharedPointer by promoting the weak reference <i translate="no">other</i> to strong reference and sharing its pointer.</p>
<p>If <code translate="no">T</code> is a derived type of the template parameter of this class, QSharedPointer will perform an automatic cast. Otherwise, you will get a compiler error.</p>
<p><b>See also </b><a href="qweakpointer.html#toStrongRef" translate="no">QWeakPointer::toStrongRef</a>().</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerQSharedPointer<X>&& -->
<h3 class="fn" translate="no" id="QSharedPointer-8"><code class="details extra" translate="no">[noexcept]</code> template &lt;typename X&gt; QSharedPointer::<span class="name">QSharedPointer</span>(<span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a QSharedPointer instance, making it point at the same object that <i translate="no">other</i> was pointing to.</p>
<p>This constructor participates in overload resolution only if <code translate="no">X*</code> implicitly converts to <code translate="no">T*</code>.</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerconstQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="QSharedPointer-5">QSharedPointer::<span class="name">QSharedPointer</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Creates a QSharedPointer object that shares <i translate="no">other</i>'s pointer.</p>
<p>If <code translate="no">T</code> is a derived type of the template parameter of this class, QSharedPointer will perform an automatic cast. Otherwise, you will get a compiler error.</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerQSharedPointer<T>&& -->
<h3 class="fn" translate="no" id="QSharedPointer-7"><code class="details extra" translate="no">[noexcept]</code> QSharedPointer::<span class="name">QSharedPointer</span>(<span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a QSharedPointer instance, making it point at the same object that <i translate="no">other</i> was pointing to.</p>
<!-- @@@QSharedPointer -->
<!-- $$$~QSharedPointer[overload1]$$$~QSharedPointer -->
<h3 class="fn" translate="no" id="dtor.QSharedPointer">QSharedPointer::<span class="name">~QSharedPointer</span>()</h3>
<p>Destroys this <a href="qsharedpointer.html" translate="no">QSharedPointer</a> object. If it is the last reference to the pointer stored, this will delete the pointer as well.</p>
<!-- @@@~QSharedPointer -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QSharedPointer::<span class="name">clear</span>()</h3>
<p>Clears this <a href="qsharedpointer.html" translate="no">QSharedPointer</a> object, dropping the reference that it may have had to the pointer. If this was the last reference, then the pointer itself will be deleted.</p>
<!-- @@@clear -->
<!-- $$$constCast[overload1]$$$constCast -->
<h3 class="fn" translate="no" id="constCast">template &lt;typename X&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; QSharedPointer::<span class="name">constCast</span>() const</h3>
<p>Performs a <code translate="no">const_cast</code> from this pointer's type to <code translate="no">X</code> and returns a <a href="qsharedpointer.html" translate="no">QSharedPointer</a> that shares the reference. This function can be used for up- and for down-casting, but is more useful for up-casting.</p>
<p><b>See also </b><a href="qsharedpointer.html#isNull" translate="no">isNull</a>() and <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a>().</p>
<!-- @@@constCast -->
<!-- $$$create[overload1]$$$createArgs&&... -->
<h3 class="fn" translate="no" id="create"><code class="details extra" translate="no">[static]</code> template &lt;typename... Args&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; QSharedPointer::<span class="name">create</span>(<span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>This is an overloaded function.</p>
<p>Creates a <a href="qsharedpointer.html" translate="no">QSharedPointer</a> object and allocates a new item of type <code translate="no">T</code>. The <a href="qsharedpointer.html" translate="no">QSharedPointer</a> internals and the object are allocated in one single memory allocation, which could help reduce memory fragmentation in a long-running application.</p>
<p>This function will attempt to call a constructor for type <code translate="no">T</code> that can accept all the arguments passed (<i translate="no">args</i>). Arguments will be perfectly-forwarded.</p>
<!-- @@@create -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" translate="no" id="data"><span class="type">T</span> *QSharedPointer::<span class="name">data</span>() const</h3>
<p>Returns the value of the pointer referenced by this object.</p>
<p>Note: do not delete the pointer returned by this function or pass it to another function that could delete it, including creating <a href="qsharedpointer.html" translate="no">QSharedPointer</a> or <a href="qweakpointer.html" translate="no">QWeakPointer</a> objects.</p>
<!-- @@@data -->
<!-- $$$dynamicCast[overload1]$$$dynamicCast -->
<h3 class="fn" translate="no" id="dynamicCast">template &lt;typename X&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; QSharedPointer::<span class="name">dynamicCast</span>() const</h3>
<p>Performs a dynamic cast from this pointer's type to <code translate="no">X</code> and returns a <a href="qsharedpointer.html" translate="no">QSharedPointer</a> that shares the reference. If this function is used to up-cast, then <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will perform a <code translate="no">dynamic_cast</code>, which means that if the object being pointed by this <a href="qsharedpointer.html" translate="no">QSharedPointer</a> is not of type <code translate="no">X</code>, the returned object will be null.</p>
<p>Note: the template type <code translate="no">X</code> must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use <a href="qsharedpointer.html#constCast" translate="no">constCast</a>() if you need to drop those qualifiers.</p>
<p><b>See also </b><a href="qsharedpointer.html#qSharedPointerDynamicCast" translate="no">qSharedPointerDynamicCast</a>().</p>
<!-- @@@dynamicCast -->
<!-- $$$get[overload1]$$$get -->
<h3 class="fn" translate="no" id="get"><span class="type">T</span> *QSharedPointer::<span class="name">get</span>() const</h3>
<p>Same as <a href="qsharedpointer.html#data" translate="no">data</a>().</p>
<p>This function is provided for API compatibility with <code translate="no">std::shared_ptr</code>.</p>
<!-- @@@get -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" translate="no" id="isNull"><span class="type">bool</span> QSharedPointer::<span class="name">isNull</span>() const</h3>
<p>Returns <code translate="no">true</code> if this object refers to <code translate="no">nullptr</code>.</p>
<!-- @@@isNull -->
<!-- $$$objectCast[overload1]$$$objectCast -->
<h3 class="fn" translate="no" id="objectCast">template &lt;typename X&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; QSharedPointer::<span class="name">objectCast</span>() const</h3>
<p>Performs a <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>() from this pointer's type to <code translate="no">X</code> and returns a <a href="qsharedpointer.html" translate="no">QSharedPointer</a> that shares the reference. If this function is used to up-cast, then <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will perform a <code translate="no">qobject_cast</code>, which means that if the object being pointed by this <a href="qsharedpointer.html" translate="no">QSharedPointer</a> is not of type <code translate="no">X</code>, the returned object will be null.</p>
<p>Note: the template type <code translate="no">X</code> must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use <a href="qsharedpointer.html#constCast" translate="no">constCast</a>() if you need to drop those qualifiers.</p>
<p><b>See also </b><a href="qsharedpointer.html#qSharedPointerObjectCast" translate="no">qSharedPointerObjectCast</a>().</p>
<!-- @@@objectCast -->
<!-- $$$reset[overload1]$$$reset -->
<h3 class="fn" translate="no" id="reset"><span class="type">void</span> QSharedPointer::<span class="name">reset</span>()</h3>
<p>Same as <a href="qsharedpointer.html#clear" translate="no">clear</a>(). For std::shared_ptr compatibility.</p>
<!-- @@@reset -->
<!-- $$$reset$$$resetT* -->
<h3 class="fn" translate="no" id="reset-1"><span class="type">void</span> QSharedPointer::<span class="name">reset</span>(<span class="type">T</span> *<i>t</i>)</h3>
<p>Resets this <a href="qsharedpointer.html" translate="no">QSharedPointer</a> object to point to <i translate="no">t</i> instead. Equivalent to:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span><span class="operator">&lt;</span>T<span class="operator">&gt;</span> other(t); <span class="keyword">this</span><span class="operator">-</span><span class="operator">&gt;</span>swap(other);
</pre>
<!-- @@@reset -->
<!-- $$$reset$$$resetT*Deleter -->
<h3 class="fn" translate="no" id="reset-2">template &lt;typename Deleter&gt; <span class="type">void</span> QSharedPointer::<span class="name">reset</span>(<span class="type">T</span> *<i>t</i>, <span class="type">Deleter</span> <i>deleter</i>)</h3>
<p>Resets this <a href="qsharedpointer.html" translate="no">QSharedPointer</a> object to point to <i translate="no">t</i> instead, with the Deleter <i translate="no">deleter</i>. Equivalent to:</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span><span class="operator">&lt;</span>T<span class="operator">&gt;</span> other(t<span class="operator">,</span> deleter); <span class="keyword">this</span><span class="operator">-</span><span class="operator">&gt;</span>swap(other);
</pre>
<!-- @@@reset -->
<!-- $$$staticCast[overload1]$$$staticCast -->
<h3 class="fn" translate="no" id="staticCast">template &lt;typename X&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; QSharedPointer::<span class="name">staticCast</span>() const</h3>
<p>Performs a static cast from this pointer's type to <code translate="no">X</code> and returns a <a href="qsharedpointer.html" translate="no">QSharedPointer</a> that shares the reference. This function can be used for up- and for down-casting, but is more useful for up-casting.</p>
<p>Note: the template type <code translate="no">X</code> must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use <a href="qsharedpointer.html#constCast" translate="no">constCast</a>() if you need to drop those qualifiers.</p>
<p><b>See also </b><a href="qsharedpointer.html#dynamicCast" translate="no">dynamicCast</a>(), <a href="qsharedpointer.html#constCast" translate="no">constCast</a>(), and <a href="qsharedpointer.html#qSharedPointerCast" translate="no">qSharedPointerCast</a>().</p>
<!-- @@@staticCast -->
<!-- $$$swap[overload1]$$$swapQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QSharedPointer::<span class="name">swap</span>(<span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Swaps this shared pointer instance with <i translate="no">other</i>. This function is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$toWeakRef[overload1]$$$toWeakRef -->
<h3 class="fn" translate="no" id="toWeakRef"><span class="type"><a href="qweakpointer.html" translate="no">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; QSharedPointer::<span class="name">toWeakRef</span>() const</h3>
<p>Returns a weak reference object that shares the pointer referenced by this object.</p>
<p><b>See also </b><a href="qweakpointer.html#QWeakPointer" translate="no">QWeakPointer::QWeakPointer</a>().</p>
<!-- @@@toWeakRef -->
<!-- $$$operator bool[overload1]$$$operator bool -->
<h3 class="fn" translate="no" id="operator-bool"><span class="type">bool</span> QSharedPointer::<span class="name">operator bool</span>() const</h3>
<p>Returns <code translate="no">true</code> if the contained pointer is not <code translate="no">nullptr</code>. This function is suitable for use in <code translate="no">if-constructs</code>, like:</p>
<pre class="cpp" translate="no">
     <span class="keyword">if</span> (sharedptr) { <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> }
</pre>
<p><b>See also </b><a href="qsharedpointer.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@operator bool -->
<!-- $$$operator![overload1]$$$operator! -->
<h3 class="fn" translate="no" id="operator-not"><span class="type">bool</span> QSharedPointer::<span class="name">operator!</span>() const</h3>
<p>Returns <code translate="no">true</code> if this object refers to <code translate="no">nullptr</code>. This function is suitable for use in <code translate="no">if-constructs</code>, like:</p>
<pre class="cpp" translate="no">
     <span class="keyword">if</span> (<span class="operator">!</span>sharedptr) { <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> }
</pre>
<p><b>See also </b><a href="qsharedpointer.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@operator! -->
<!-- $$$operator*[overload1]$$$operator* -->
<h3 class="fn" translate="no" id="operator-2a"><span class="type">T</span> &amp;QSharedPointer::<span class="name">operator*</span>() const</h3>
<p>Provides access to the shared pointer's members.</p>
<p>If the contained pointer is <code translate="no">nullptr</code>, behavior is undefined.</p>
<p><b>See also </b><a href="qsharedpointer.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@operator* -->
<!-- $$$operator->[overload1]$$$operator-> -->
<h3 class="fn" translate="no" id="operator--gt"><span class="type">T</span> *QSharedPointer::<span class="name">operator-&gt;</span>() const</h3>
<p>Provides access to the shared pointer's members.</p>
<p>If the contained pointer is <code translate="no">nullptr</code>, behavior is undefined.</p>
<p><b>See also </b><a href="qsharedpointer.html#isNull" translate="no">isNull</a>().</p>
<!-- @@@operator-> -->
<!-- $$$operator=[overload1]$$$operator=constQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="operator-eq"><span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QSharedPointer::<span class="name">operator=</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Makes this object share <i translate="no">other</i>'s pointer. The current pointer reference is discarded and, if it was the last, the pointer will be deleted.</p>
<p>If <code translate="no">T</code> is a derived type of the template parameter of this class, <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QSharedPointer<T>&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QSharedPointer::<span class="name">operator=</span>(<span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qsharedpointer.html" translate="no">QSharedPointer</a> instance.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=constQWeakPointer<T>& -->
<h3 class="fn" translate="no" id="operator-eq-2"><span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QSharedPointer::<span class="name">operator=</span>(const <span class="type"><a href="qweakpointer.html" translate="no">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Promotes <i translate="no">other</i> to a strong reference and makes this object share a reference to the pointer referenced by it. The current pointer reference is discarded and, if it was the last, the pointer will be deleted.</p>
<p>If <code translate="no">T</code> is a derived type of the template parameter of this class, <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QSharedPointer<X>&& -->
<h3 class="fn" translate="no" id="operator-eq-3"><code class="details extra" translate="no">[noexcept]</code> template &lt;typename X&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QSharedPointer::<span class="name">operator=</span>(<span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qsharedpointer.html" translate="no">QSharedPointer</a> instance.</p>
<p>This assignment operator participates in overload resolution only if <code translate="no">X*</code> implicitly converts to <code translate="no">T*</code>.</p>
<!-- @@@operator= -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash$$$qHashconstQSharedPointer<T>&size_t -->
<h3 class="fn" translate="no" id="qHash-39"><code class="details extra" translate="no">[noexcept]</code> template &lt;typename T&gt; <span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>key</i>, <span class="type">size_t</span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for <i translate="no">key</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<!-- @@@qHash -->
<!-- $$$qSharedPointerCast[overload1]$$$qSharedPointerCastconstQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="qSharedPointerCast">template &lt;typename X, typename T&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerCast</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i translate="no">other</i>, cast to type <code translate="no">X</code>. The types <code translate="no">T</code> and <code translate="no">X</code> must belong to one hierarchy for the <code translate="no">static_cast</code> to succeed.</p>
<p>Note that <code translate="no">X</code> must have the same cv-qualifiers (<code translate="no">const</code> and <code translate="no">volatile</code>) that <code translate="no">T</code> has, or the code will fail to compile. Use <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a> to cast away the constness.</p>
<p><b>See also </b><a href="qsharedpointer.html#staticCast" translate="no">QSharedPointer::staticCast</a>(), <a href="qsharedpointer.html#qSharedPointerDynamicCast" translate="no">qSharedPointerDynamicCast</a>(), and <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a>().</p>
<!-- @@@qSharedPointerCast -->
<!-- $$$qSharedPointerCast$$$qSharedPointerCastconstQWeakPointer<T>& -->
<h3 class="fn" translate="no" id="qSharedPointerCast-1">template &lt;typename X, typename T&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerCast</span>(const <span class="type"><a href="qweakpointer.html" translate="no">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i translate="no">other</i>, cast to type <code translate="no">X</code>. The types <code translate="no">T</code> and <code translate="no">X</code> must belong to one hierarchy for the <code translate="no">static_cast</code> to succeed.</p>
<p>The <i translate="no">other</i> object is converted first to a strong reference. If that conversion fails (because the object it's pointing to has already been deleted), this function returns a null <a href="qsharedpointer.html" translate="no">QSharedPointer</a>.</p>
<p>Note that <code translate="no">X</code> must have the same cv-qualifiers (<code translate="no">const</code> and <code translate="no">volatile</code>) that <code translate="no">T</code> has, or the code will fail to compile. Use <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a> to cast away the constness.</p>
<p><b>See also </b><a href="qweakpointer.html#toStrongRef" translate="no">QWeakPointer::toStrongRef</a>(), <a href="qsharedpointer.html#qSharedPointerDynamicCast" translate="no">qSharedPointerDynamicCast</a>(), and <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a>().</p>
<!-- @@@qSharedPointerCast -->
<!-- $$$qSharedPointerConstCast[overload1]$$$qSharedPointerConstCastconstQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="qSharedPointerConstCast">template &lt;typename X, typename T&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerConstCast</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i translate="no">src</i>, cast to type <code translate="no">X</code>. The types <code translate="no">T</code> and <code translate="no">X</code> must belong to one hierarchy for the <code translate="no">const_cast</code> to succeed. The <code translate="no">const</code> and <code translate="no">volatile</code> differences between <code translate="no">T</code> and <code translate="no">X</code> are ignored.</p>
<p><b>See also </b><a href="qsharedpointer.html#constCast" translate="no">QSharedPointer::constCast</a>(), <a href="qsharedpointer.html#qSharedPointerCast" translate="no">qSharedPointerCast</a>(), and <a href="qsharedpointer.html#qSharedPointerDynamicCast" translate="no">qSharedPointerDynamicCast</a>().</p>
<!-- @@@qSharedPointerConstCast -->
<!-- $$$qSharedPointerConstCast$$$qSharedPointerConstCastconstQWeakPointer<T>& -->
<h3 class="fn" translate="no" id="qSharedPointerConstCast-1">template &lt;typename X, typename T&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerConstCast</span>(const <span class="type"><a href="qweakpointer.html" translate="no">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i translate="no">src</i>, cast to type <code translate="no">X</code>. The types <code translate="no">T</code> and <code translate="no">X</code> must belong to one hierarchy for the <code translate="no">const_cast</code> to succeed. The <code translate="no">const</code> and <code translate="no">volatile</code> differences between <code translate="no">T</code> and <code translate="no">X</code> are ignored.</p>
<p>The <i translate="no">src</i> object is converted first to a strong reference. If that conversion fails (because the object it's pointing to has already been deleted), this function returns a null <a href="qsharedpointer.html" translate="no">QSharedPointer</a>.</p>
<p><b>See also </b><a href="qweakpointer.html#toStrongRef" translate="no">QWeakPointer::toStrongRef</a>(), <a href="qsharedpointer.html#qSharedPointerCast" translate="no">qSharedPointerCast</a>(), and <a href="qsharedpointer.html#qSharedPointerDynamicCast" translate="no">qSharedPointerDynamicCast</a>().</p>
<!-- @@@qSharedPointerConstCast -->
<!-- $$$qSharedPointerDynamicCast[overload1]$$$qSharedPointerDynamicCastconstQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="qSharedPointerDynamicCast">template &lt;typename X, typename T&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerDynamicCast</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i translate="no">src</i>, using a dynamic cast to type <code translate="no">X</code> to obtain an internal pointer of the appropriate type. If the <code translate="no">dynamic_cast</code> fails, the object returned will be null.</p>
<p>Note that <code translate="no">X</code> must have the same cv-qualifiers (<code translate="no">const</code> and <code translate="no">volatile</code>) that <code translate="no">T</code> has, or the code will fail to compile. Use <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a> to cast away the constness.</p>
<p><b>See also </b><a href="qsharedpointer.html#dynamicCast" translate="no">QSharedPointer::dynamicCast</a>(), <a href="qsharedpointer.html#qSharedPointerCast" translate="no">qSharedPointerCast</a>(), and <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a>().</p>
<!-- @@@qSharedPointerDynamicCast -->
<!-- $$$qSharedPointerDynamicCast$$$qSharedPointerDynamicCastconstQWeakPointer<T>& -->
<h3 class="fn" translate="no" id="qSharedPointerDynamicCast-1">template &lt;typename X, typename T&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerDynamicCast</span>(const <span class="type"><a href="qweakpointer.html" translate="no">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i translate="no">src</i>, using a dynamic cast to type <code translate="no">X</code> to obtain an internal pointer of the appropriate type. If the <code translate="no">dynamic_cast</code> fails, the object returned will be null.</p>
<p>The <i translate="no">src</i> object is converted first to a strong reference. If that conversion fails (because the object it's pointing to has already been deleted), this function also returns a null <a href="qsharedpointer.html" translate="no">QSharedPointer</a>.</p>
<p>Note that <code translate="no">X</code> must have the same cv-qualifiers (<code translate="no">const</code> and <code translate="no">volatile</code>) that <code translate="no">T</code> has, or the code will fail to compile. Use <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a> to cast away the constness.</p>
<p><b>See also </b><a href="qweakpointer.html#toStrongRef" translate="no">QWeakPointer::toStrongRef</a>(), <a href="qsharedpointer.html#qSharedPointerCast" translate="no">qSharedPointerCast</a>(), and <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a>().</p>
<!-- @@@qSharedPointerDynamicCast -->
<!-- $$$qSharedPointerObjectCast[overload1]$$$qSharedPointerObjectCastconstQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="qSharedPointerObjectCast">template &lt;typename X, typename T&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerObjectCast</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>The qSharedPointerObjectCast function is for casting a shared pointer.</p>
<p>Returns a shared pointer to the pointer held by <i translate="no">src</i>, using a <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>() to type <code translate="no">X</code> to obtain an internal pointer of the appropriate type. If the <code translate="no">qobject_cast</code> fails, the object returned will be null.</p>
<p>Note that <code translate="no">X</code> must have the same cv-qualifiers (<code translate="no">const</code> and <code translate="no">volatile</code>) that <code translate="no">T</code> has, or the code will fail to compile. Use <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a> to cast away the constness.</p>
<p><b>See also </b><a href="qsharedpointer.html#objectCast" translate="no">QSharedPointer::objectCast</a>(), <a href="qsharedpointer.html#qSharedPointerCast" translate="no">qSharedPointerCast</a>(), and <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a>().</p>
<!-- @@@qSharedPointerObjectCast -->
<!-- $$$qSharedPointerObjectCast$$$qSharedPointerObjectCastconststd::shared_ptr<T>& -->
<h3 class="fn" translate="no" id="qSharedPointerObjectCast-1">template &lt;typename X, typename T&gt; <span class="type">std::shared_ptr</span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerObjectCast</span>(const <span class="type">std::shared_ptr</span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i translate="no">src</i>, using a <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>() to type <code translate="no">X</code> to obtain an internal pointer of the appropriate type. If the <code translate="no">qobject_cast</code> fails, the object returned will be null.</p>
<p>Note that <code translate="no">X</code> must have the same cv-qualifiers (<code translate="no">const</code> and <code translate="no">volatile</code>) that <code translate="no">T</code> has, or the code will fail to compile. Use const_pointer_cast to cast away the constness.</p>
<!-- @@@qSharedPointerObjectCast -->
<!-- $$$qSharedPointerObjectCast$$$qSharedPointerObjectCaststd::shared_ptr<T>&& -->
<h3 class="fn" translate="no" id="qSharedPointerObjectCast-2">template &lt;typename X, typename T&gt; <span class="type">std::shared_ptr</span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerObjectCast</span>(<span class="type">std::shared_ptr</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>src</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i translate="no">src</i>, using a <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>() to type <code translate="no">X</code> to obtain an internal pointer of the appropriate type.</p>
<p>If the <code translate="no">qobject_cast</code> succeeds, the function will return a valid shared pointer, and <i translate="no">src</i> is reset to null. If the <code translate="no">qobject_cast</code> fails, the object returned will be null, and <i translate="no">src</i> will not be modified.</p>
<p>Note that <code translate="no">X</code> must have the same cv-qualifiers (<code translate="no">const</code> and <code translate="no">volatile</code>) that <code translate="no">T</code> has, or the code will fail to compile. Use const_pointer_cast to cast away the constness.</p>
<!-- @@@qSharedPointerObjectCast -->
<!-- $$$qSharedPointerObjectCast$$$qSharedPointerObjectCastconstQWeakPointer<T>& -->
<h3 class="fn" translate="no" id="qSharedPointerObjectCast-3">template &lt;typename X, typename T&gt; <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerObjectCast</span>(const <span class="type"><a href="qweakpointer.html" translate="no">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>The qSharedPointerObjectCast function is for casting a shared pointer.</p>
<p>Returns a shared pointer to the pointer held by <i translate="no">src</i>, using a <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a>() to type <code translate="no">X</code> to obtain an internal pointer of the appropriate type. If the <code translate="no">qobject_cast</code> fails, the object returned will be null.</p>
<p>The <i translate="no">src</i> object is converted first to a strong reference. If that conversion fails (because the object it's pointing to has already been deleted), this function also returns a null <a href="qsharedpointer.html" translate="no">QSharedPointer</a>.</p>
<p>Note that <code translate="no">X</code> must have the same cv-qualifiers (<code translate="no">const</code> and <code translate="no">volatile</code>) that <code translate="no">T</code> has, or the code will fail to compile. Use <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a> to cast away the constness.</p>
<p><b>See also </b><a href="qweakpointer.html#toStrongRef" translate="no">QWeakPointer::toStrongRef</a>(), <a href="qsharedpointer.html#qSharedPointerCast" translate="no">qSharedPointerCast</a>(), and <a href="qsharedpointer.html#qSharedPointerConstCast" translate="no">qSharedPointerConstCast</a>().</p>
<!-- @@@qSharedPointerObjectCast -->
<!-- $$$qobject_pointer_cast[overload1]$$$qobject_pointer_castconststd::shared_ptr<T>& -->
<h3 class="fn" translate="no" id="qobject_pointer_cast">template &lt;typename X, typename T&gt; <span class="type">std::shared_ptr</span>&lt;<span class="type">X</span>&gt; <span class="name">qobject_pointer_cast</span>(const <span class="type">std::shared_ptr</span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i translate="no">src</i>.</p>
<p>Same as <a href="qsharedpointer.html#qSharedPointerObjectCast" translate="no">qSharedPointerObjectCast</a>(). This function is provided for STL compatibility.</p>
<!-- @@@qobject_pointer_cast -->
<!-- $$$qobject_pointer_cast$$$qobject_pointer_caststd::shared_ptr<T>&& -->
<h3 class="fn" translate="no" id="qobject_pointer_cast-1">template &lt;typename X, typename T&gt; <span class="type">std::shared_ptr</span>&lt;<span class="type">X</span>&gt; <span class="name">qobject_pointer_cast</span>(<span class="type">std::shared_ptr</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>src</i>)</h3>
<p>Same as <a href="qsharedpointer.html#qSharedPointerObjectCast" translate="no">qSharedPointerObjectCast</a>(). This function is provided for STL compatibility.</p>
<!-- @@@qobject_pointer_cast -->
<!-- $$$operator!=$$$operator!=constQSharedPointer<T>&constQSharedPointer<X>& -->
<h3 class="fn" translate="no" id="operator-not-eq-2">template &lt;typename T, typename X&gt; <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr1</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>ptr2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">ptr1</i> and <i translate="no">ptr2</i> refer to distinct pointers.</p>
<p>If <i translate="no">ptr2</i>'s template parameter is different from <i translate="no">ptr1</i>'s, <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will attempt to perform an automatic <code translate="no">static_cast</code> to ensure that the pointers being compared are equal. If <i translate="no">ptr2</i>'s template parameter is not a base or a derived type from <i translate="no">ptr1</i>'s, you will get a compiler error.</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQSharedPointer<T>&constX* -->
<h3 class="fn" translate="no" id="operator-not-eq-3">template &lt;typename T, typename X&gt; <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr1</i>, const <span class="type">X</span> *<i>ptr2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">ptr1</i> and <i translate="no">ptr2</i> refer to distinct pointers.</p>
<p>If <i translate="no">ptr2</i>'s type is different from <i translate="no">ptr1</i>'s, <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will attempt to perform an automatic <code translate="no">static_cast</code> to ensure that the pointers being compared are equal. If <i translate="no">ptr2</i>'s type is not a base or a derived type from this <i translate="no">ptr1</i>'s, you will get a compiler error.</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constT*constQSharedPointer<X>& -->
<h3 class="fn" translate="no" id="operator-not-eq-4">template &lt;typename T, typename X&gt; <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type">T</span> *<i>ptr1</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>ptr2</i>)</h3>
<p>Returns <code translate="no">true</code> if the pointer <i translate="no">ptr1</i> is not the same pointer as that referenced by <i translate="no">ptr2</i>.</p>
<p>If <i translate="no">ptr2</i>'s template parameter is different from <i translate="no">ptr1</i>'s type, <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will attempt to perform an automatic <code translate="no">static_cast</code> to ensure that the pointers being compared are equal. If <i translate="no">ptr2</i>'s template parameter is not a base or a derived type from <i translate="no">ptr1</i>'s type, you will get a compiler error.</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQSharedPointer<T>&std::nullptr_t -->
<h3 class="fn" translate="no" id="operator-not-eq-6">template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, <span class="type">std::nullptr_t</span>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">lhs</i> refers to a valid (i.e. non-null) pointer.</p>
<p><b>See also </b><a href="qsharedpointer.html#isNull" translate="no">QSharedPointer::isNull</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=std::nullptr_tconstQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="operator-not-eq-7">template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator!=</span>(<span class="type">std::nullptr_t</span>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">rhs</i> refers to a valid (i.e. non-null) pointer.</p>
<p><b>See also </b><a href="qsharedpointer.html#isNull" translate="no">QSharedPointer::isNull</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator<<$$$operator<<QDebugconstQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="operator-lt-lt-48">template &lt;typename T&gt; <span class="type"><a href="qdebug.html" translate="no">QDebug</a></span> <span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdebug.html" translate="no">QDebug</a></span> <i>debug</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr</i>)</h3>
<p>Writes the pointer tracked by <i translate="no">ptr</i> into the debug object <i translate="no">debug</i> for debugging purposes.</p>
<p><b>See also </b><a href="../qtdoc/debug.html" translate="no">Debugging Techniques</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator==$$$operator==constQSharedPointer<T>&constQSharedPointer<X>& -->
<h3 class="fn" translate="no" id="operator-eq-eq-3">template &lt;typename T, typename X&gt; <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr1</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>ptr2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">ptr1</i> and <i translate="no">ptr2</i> refer to the same pointer.</p>
<p>If <i translate="no">ptr2</i>'s template parameter is different from <i translate="no">ptr1</i>'s, <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will attempt to perform an automatic <code translate="no">static_cast</code> to ensure that the pointers being compared are equal. If <i translate="no">ptr2</i>'s template parameter is not a base or a derived type from <i translate="no">ptr1</i>'s, you will get a compiler error.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQSharedPointer<T>&constX* -->
<h3 class="fn" translate="no" id="operator-eq-eq-4">template &lt;typename T, typename X&gt; <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr1</i>, const <span class="type">X</span> *<i>ptr2</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">ptr1</i> and <i translate="no">ptr2</i> refer to the same pointer.</p>
<p>If <i translate="no">ptr2</i>'s type is different from <i translate="no">ptr1</i>'s, <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will attempt to perform an automatic <code translate="no">static_cast</code> to ensure that the pointers being compared are equal. If <i translate="no">ptr2</i>'s type is not a base or a derived type from this <i translate="no">ptr1</i>'s, you will get a compiler error.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constT*constQSharedPointer<X>& -->
<h3 class="fn" translate="no" id="operator-eq-eq-5">template &lt;typename T, typename X&gt; <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type">T</span> *<i>ptr1</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>ptr2</i>)</h3>
<p>Returns <code translate="no">true</code> if the pointer <i translate="no">ptr1</i> is the same pointer as that referenced by <i translate="no">ptr2</i>.</p>
<p>If <i translate="no">ptr2</i>'s template parameter is different from <i translate="no">ptr1</i>'s type, <a href="qsharedpointer.html" translate="no">QSharedPointer</a> will attempt to perform an automatic <code translate="no">static_cast</code> to ensure that the pointers being compared are equal. If <i translate="no">ptr2</i>'s template parameter is not a base or a derived type from <i translate="no">ptr1</i>'s type, you will get a compiler error.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQSharedPointer<T>&std::nullptr_t -->
<h3 class="fn" translate="no" id="operator-eq-eq-8">template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, <span class="type">std::nullptr_t</span>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">lhs</i> refers to <code translate="no">nullptr</code>.</p>
<p><b>See also </b><a href="qsharedpointer.html#isNull" translate="no">QSharedPointer::isNull</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==std::nullptr_tconstQSharedPointer<T>& -->
<h3 class="fn" translate="no" id="operator-eq-eq-9">template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator==</span>(<span class="type">std::nullptr_t</span>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer" translate="no">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">rhs</i> refers to <code translate="no">nullptr</code>.</p>
<p><b>See also </b><a href="qsharedpointer.html#isNull" translate="no">QSharedPointer::isNull</a>().</p>
<!-- @@@operator== -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
