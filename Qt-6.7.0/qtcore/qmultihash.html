<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qhash.cpp -->
  <meta name="description" content="The QMultiHash class is a convenience QHash subclass that provides multi-valued hashes.">
  <title>QMultiHash Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QMultiHash</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QMultiHash Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename Key, typename T&gt; class QMultiHash</span>
<!-- $$$QMultiHash-brief -->
<p>The QMultiHash class is a convenience <a href="qhash.html#qhash" translate="no">QHash</a> subclass that provides multi-valued hashes. <a href="#details">More...</a></p>
<!-- @@@QMultiHash -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QMultiHash&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qmultihash-members.html">List of all members, including inherited members</a></li>
<li>QMultiHash is part of <a href="shared.html">Implicitly Shared Classes</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmultihash-const-iterator.html" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmultihash-iterator.html" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmultihash-key-iterator.html" translate="no">key_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#const_key_value_iterator-typedef" translate="no">const_key_value_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#key_value_iterator-typedef" translate="no">key_value_iterator</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#QMultiHash-1" translate="no">QMultiHash</a></b>(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#QMultiHash-2" translate="no">QMultiHash</a></b>(InputIterator <i>begin</i>, InputIterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#QMultiHash-5" translate="no">QMultiHash</a></b>(const QHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> auto </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#asKeyValueRange" translate="no">asKeyValueRange</a></b>() &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> auto </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#asKeyValueRange-1" translate="no">asKeyValueRange</a></b>() const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> auto </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#asKeyValueRange-2" translate="no">asKeyValueRange</a></b>() &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> auto </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#asKeyValueRange-3" translate="no">asKeyValueRange</a></b>() const &&</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constFind-1" translate="no">constFind</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constKeyValueBegin" translate="no">constKeyValueBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constKeyValueEnd" translate="no">constKeyValueEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#contains-1" translate="no">contains</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#count-2" translate="no">count</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#emplace" translate="no">emplace</a></b>(const Key &amp;<i>key</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#emplace-1" translate="no">emplace</a></b>(Key &amp;&amp;<i>key</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#emplaceReplace" translate="no">emplaceReplace</a></b>(const Key &amp;<i>key</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#emplaceReplace-1" translate="no">emplaceReplace</a></b>(Key &amp;&amp;<i>key</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::pair&lt;QMultiHash&lt;Key, T&gt;::iterator, QMultiHash&lt;Key, T&gt;::iterator&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#equal_range" translate="no">equal_range</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::pair&lt;QMultiHash&lt;Key, T&gt;::const_iterator, QMultiHash&lt;Key, T&gt;::const_iterator&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#equal_range-1" translate="no">equal_range</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#find-2" translate="no">find</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#find-3" translate="no">find</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#insert" translate="no">insert</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Key </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#key" translate="no">key</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Key </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#key-1" translate="no">key</a></b>(const T &amp;<i>value</i>, const Key &amp;<i>defaultKey</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::key_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyBegin" translate="no">keyBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::key_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyEnd" translate="no">keyEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyValueBegin" translate="no">keyValueBegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyValueBegin-1" translate="no">keyValueBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyValueEnd" translate="no">keyValueEnd</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyValueEnd-1" translate="no">keyValueEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keys" translate="no">keys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#remove" translate="no">remove</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#remove-1" translate="no">remove</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#removeIf" translate="no">removeIf</a></b>(Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#replace" translate="no">replace</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#swap" translate="no">swap</a></b>(QMultiHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#take" translate="no">take</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#uniqueKeys" translate="no">uniqueKeys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#unite" translate="no">unite</a></b>(const QMultiHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QMultiHash&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#unite-1" translate="no">unite</a></b>(const QHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#value" translate="no">value</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#value-1" translate="no">value</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>defaultValue</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#values" translate="no">values</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#values-1" translate="no">values</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-2b" translate="no">operator+</a></b>(const QMultiHash&lt;Key, T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-2b-eq" translate="no">operator+=</a></b>(const QMultiHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-5b-5d" translate="no">operator[]</a></b>(const Key &amp;<i>key</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#erase_if" translate="no">erase_if</a></b>(QMultiHash&lt;Key, T&gt; &amp;<i>hash</i>, Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#qHash" translate="no">qHash</a></b>(const QMultiHash&lt;Key, T&gt; &amp;<i>key</i>, size_t <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-lt-lt-3" translate="no">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QMultiHash&lt;Key, T&gt; &amp;<i>hash</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-gt-gt-2" translate="no">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QMultiHash&lt;Key, T&gt; &amp;<i>hash</i>)</td></tr>
</table></div>
<!-- $$$QMultiHash-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QMultiHash&lt;Key, T&gt; is one of Qt's generic <a href="containers.html" translate="no">container classes</a>. It inherits <a href="qhash.html#qhash" translate="no">QHash</a> and extends it with a few convenience functions that make it more suitable than <a href="qhash.html#qhash" translate="no">QHash</a> for storing multi-valued hashes. A multi-valued hash is a hash that allows multiple values with the same key.</p>
<p>QMultiHash mostly mirrors <a href="qhash.html#qhash" translate="no">QHash</a>'s API. For example, you can use isEmpty() to test whether the hash is empty, and you can traverse a QMultiHash using <a href="qhash.html#qhash" translate="no">QHash</a>'s iterator classes (for example, <a href="qhashiterator.html" translate="no">QHashIterator</a>). But opposed to <a href="qhash.html#qhash" translate="no">QHash</a>, it provides an <a href="qmultihash.html#insert" translate="no">insert</a>() function that allows the insertion of multiple items with the same key. The <a href="qmultihash.html#replace" translate="no">replace</a>() function corresponds to <a href="qhash.html#insert" translate="no">QHash::insert</a>(). It also provides convenient operator+() and operator+=().</p>
<p>Unlike <a href="qmultimap.html" translate="no">QMultiMap</a>, QMultiHash does not provide and ordering of the inserted items. The only guarantee is that items that share the same key will appear consecutively, from the most recently to the least recently inserted value.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> hash1<span class="operator">,</span> hash2<span class="operator">,</span> hash3;

 hash1<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">100</span>);
 hash1<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">2000</span>);
 <span class="comment">// hash1.size() == 2</span>

 hash2<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">5000</span>);
 <span class="comment">// hash2.size() == 1</span>

 hash3 <span class="operator">=</span> hash1 <span class="operator">+</span> hash2;
 <span class="comment">// hash3.size() == 3</span>
</pre>
<p>Unlike <a href="qhash.html#qhash" translate="no">QHash</a>, QMultiHash provides no operator[]. Use <a href="qmultihash.html#value" translate="no">value</a>() or <a href="qmultihash.html#replace" translate="no">replace</a>() if you want to access the most recently inserted item with a certain key.</p>
<p>If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <a href="qlist.html" translate="no">QList</a>&lt;T&gt;:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> values <span class="operator">=</span> hash<span class="operator">.</span>values(<span class="string">&quot;plenty&quot;</span>);
 <span class="keyword">for</span> (<span class="keyword">auto</span> i : std<span class="operator">::</span>as_const(values))
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
</pre>
<p>The items that share the same key are available from most recently to least recently inserted.</p>
<p>A more efficient approach is to call <a href="qmultihash.html#find-2" translate="no">find</a>() to get the STL-style iterator for the first item with a key and iterate from there:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> i <span class="operator">=</span> hash<span class="operator">.</span>constFind(<span class="string">&quot;plenty&quot;</span>);
 <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> hash<span class="operator">.</span>cend() <span class="operator">&amp;</span><span class="operator">&amp;</span> i<span class="operator">.</span>key() <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;plenty&quot;</span>) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">+</span><span class="operator">+</span>i;
 }
</pre>
<p>QMultiHash's key and value data types must be <a href="containers.html#assignable-data-types" translate="no">assignable data types</a>. You cannot, for example, store a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> as a value; instead, store a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> *. In addition, QMultiHash's key type must provide operator==(), and there must also be a <a href="qmultihash.html#qHash" translate="no">qHash</a>() function in the type's namespace that returns a hash value for an argument of the key's type. See the <a href="qhash.html#qhash" translate="no">QHash</a> documentation for details.</p>
</div>
<p><b>See also </b><a href="qhash.html#qhash" translate="no">QHash</a>, <a href="qhashiterator.html" translate="no">QHashIterator</a>, <a href="qmutablehashiterator.html" translate="no">QMutableHashIterator</a>, and <a href="qmultimap.html" translate="no">QMultiMap</a>.</p>
<!-- @@@QMultiHash -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$const_key_value_iterator -->
<h3 class="fn" translate="no" id="const_key_value_iterator-typedef">QMultiHash::<span class="name">const_key_value_iterator</span></h3>
<p>The <a href="qmap.html#const_key_value_iterator-typedef" translate="no">QMap::const_key_value_iterator</a> typedef provides an STL-style const iterator for <a href="qmultihash.html" translate="no">QMultiHash</a> and <a href="qmultihash.html" translate="no">QMultiHash</a>.</p>
<p>QMultiHash::const_key_value_iterator is essentially the same as <a href="qmultihash-const-iterator.html" translate="no">QMultiHash::const_iterator</a> with the difference that operator*() returns a key/value pair instead of a value.</p>
<p><b>See also </b><a href="qkeyvalueiterator.html" translate="no">QKeyValueIterator</a>.</p>
<!-- @@@const_key_value_iterator -->
<!-- $$$key_value_iterator -->
<h3 class="fn" translate="no" id="key_value_iterator-typedef">QMultiHash::<span class="name">key_value_iterator</span></h3>
<p>The <a href="qmap.html#key_value_iterator-typedef" translate="no">QMap::key_value_iterator</a> typedef provides an STL-style iterator for <a href="qmultihash.html" translate="no">QMultiHash</a> and <a href="qmultihash.html" translate="no">QMultiHash</a>.</p>
<p>QMultiHash::key_value_iterator is essentially the same as <a href="qmultihash-iterator.html" translate="no">QMultiHash::iterator</a> with the difference that operator*() returns a key/value pair instead of a value.</p>
<p><b>See also </b><a href="qkeyvalueiterator.html" translate="no">QKeyValueIterator</a>.</p>
<!-- @@@key_value_iterator -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="emplace-1">template &lt;typename... Args&gt; <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiHash::<span class="name">emplace</span>(<span class="type">Key</span> &amp;&amp;<i>key</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3><h3 class="fn fngroupitem" translate="no" id="emplace">template &lt;typename... Args&gt; <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiHash::<span class="name">emplace</span>(const <span class="type">Key</span> &amp;<i>key</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3></div>
<p>Inserts a new element into the container. This new element is constructed in-place using <i translate="no">args</i> as the arguments for its construction.</p>
<p>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <a href="qmultihash.html#replace" translate="no">replace</a>(), which overwrites the value of an existing item.)</p>
<p>Returns an iterator pointing to the new element.</p>
<p><b>See also </b><a href="qmultihash.html#insert" translate="no">insert</a>.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="emplaceReplace-1">template &lt;typename... Args&gt; <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiHash::<span class="name">emplaceReplace</span>(<span class="type">Key</span> &amp;&amp;<i>key</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3><h3 class="fn fngroupitem" translate="no" id="emplaceReplace">template &lt;typename... Args&gt; <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiHash::<span class="name">emplaceReplace</span>(const <span class="type">Key</span> &amp;<i>key</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3></div>
<p>Inserts a new element into the container. This new element is constructed in-place using <i translate="no">args</i> as the arguments for its construction.</p>
<p>If there is already an item with the same key in the hash, that item's value is replaced with a value constructed from <i translate="no">args</i>.</p>
<p>Returns an iterator pointing to the new element.</p>
<p><b>See also </b><a href="qmultihash.html#replace" translate="no">replace</a> and <a href="qmultihash.html#emplace" translate="no">emplace</a>.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="value"><code class="details extra" translate="no">[noexcept]</code> <span class="type">T</span> QMultiHash::<span class="name">value</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="value-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">T</span> QMultiHash::<span class="name">value</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>defaultValue</i>) const</h3></div>
<p>Returns the value associated with the <i translate="no">key</i>.</p>
<p>If the hash contains no item with the <i translate="no">key</i>, the function returns <i translate="no">defaultValue</i>, or a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a> if this parameter has not been supplied.</p>
<p>If there are multiple items for the <i translate="no">key</i> in the hash, the value of the most recently inserted one is returned.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="key"><code class="details extra" translate="no">[noexcept]</code> <span class="type">Key</span> QMultiHash::<span class="name">key</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="key-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">Key</span> QMultiHash::<span class="name">key</span>(const <span class="type">T</span> &amp;<i>value</i>, const <span class="type">Key</span> &amp;<i>defaultKey</i>) const</h3></div>
<p>Returns the first key mapped to <i translate="no">value</i>. If the hash contains no item mapped to <i translate="no">value</i>, returns <i translate="no">defaultKey</i>, or a <a href="containers.html#default-constructed-value" translate="no">default-constructed key</a> if this parameter has not been supplied.</p>
<p>This function can be slow (<a href="containers.html#linear-time" translate="no">linear time</a>), because <a href="qmultihash.html" translate="no">QMultiHash</a>'s internal data structure is optimized for fast lookup by key, not by value.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="asKeyValueRange"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">auto</span> QMultiHash::<span class="name">asKeyValueRange</span>() &</h3><h3 class="fn fngroupitem" translate="no" id="asKeyValueRange-2"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">auto</span> QMultiHash::<span class="name">asKeyValueRange</span>() &&</h3><h3 class="fn fngroupitem" translate="no" id="asKeyValueRange-1"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">auto</span> QMultiHash::<span class="name">asKeyValueRange</span>() const &</h3><h3 class="fn fngroupitem" translate="no" id="asKeyValueRange-3"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">auto</span> QMultiHash::<span class="name">asKeyValueRange</span>() const &&</h3></div>
<p>Returns a range object that allows iteration over this hash as key/value pairs. For instance, this range object can be used in a range-based for loop, in combination with a structured binding declaration:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> hash;
 hash<span class="operator">.</span>insert(<span class="string">&quot;January&quot;</span><span class="operator">,</span> <span class="number">1</span>);
 hash<span class="operator">.</span>insert(<span class="string">&quot;February&quot;</span><span class="operator">,</span> <span class="number">2</span>);
 <span class="comment">// ...</span>
 hash<span class="operator">.</span>insert(<span class="string">&quot;December&quot;</span><span class="operator">,</span> <span class="number">12</span>);

 <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="operator">[</span>key<span class="operator">,</span> value<span class="operator">]</span> : hash<span class="operator">.</span>asKeyValueRange()) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <a href="qstring.html#qPrintable" translate="no">qPrintable</a>(key) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;: &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> value <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
     <span class="operator">-</span><span class="operator">-</span>value; <span class="comment">// convert to JS month indexing</span>
 }
</pre>
<p>Note that both the key and the value obtained this way are references to the ones in the hash. Specifically, mutating the value will modify the hash itself.</p>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qkeyvalueiterator.html" translate="no">QKeyValueIterator</a>.</p>
<!-- @@@ -->
<!-- $$$QMultiHash[overload1]$$$QMultiHash -->
<h3 class="fn" translate="no" id="QMultiHash"><code class="details extra" translate="no">[noexcept]</code> QMultiHash::<span class="name">QMultiHash</span>()</h3>
<p>Constructs an empty hash.</p>
<!-- @@@QMultiHash -->
<!-- $$$QMultiHash$$$QMultiHashstd::initializer_list<std::pair<Key,T>> -->
<h3 class="fn" translate="no" id="QMultiHash-1">QMultiHash::<span class="name">QMultiHash</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">std::pair</span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;&gt; <i>list</i>)</h3>
<p>Constructs a multi-hash with a copy of each of the elements in the initializer list <i translate="no">list</i>.</p>
<!-- @@@QMultiHash -->
<!-- $$$QMultiHash$$$QMultiHashInputIteratorInputIterator -->
<h3 class="fn" translate="no" id="QMultiHash-2">template &lt;typename InputIterator&gt; QMultiHash::<span class="name">QMultiHash</span>(<span class="type">InputIterator</span> <i>begin</i>, <span class="type">InputIterator</span> <i>end</i>)</h3>
<p>Constructs a multi-hash with a copy of each of the elements in the iterator range [<i translate="no">begin</i>, <i translate="no">end</i>). Either the elements iterated by the range must be objects with <code translate="no">first</code> and <code translate="no">second</code> data members (like <code translate="no">std::pair</code>), convertible to <code translate="no">Key</code> and to <code translate="no">T</code> respectively; or the iterators must have <code translate="no">key()</code> and <code translate="no">value()</code> member functions, returning a key convertible to <code translate="no">Key</code> and a value convertible to <code translate="no">T</code> respectively.</p>
<!-- @@@QMultiHash -->
<!-- $$$QMultiHash$$$QMultiHashconstQHash<Key,T>& -->
<h3 class="fn" translate="no" id="QMultiHash-5"><code class="details extra" translate="no">[explicit]</code> QMultiHash::<span class="name">QMultiHash</span>(const <span class="type"><a href="qhash.html" translate="no">QHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i translate="no">other</i> (which can be a <a href="qhash.html#qhash" translate="no">QHash</a> or a QMultiHash).</p>
<!-- @@@QMultiHash -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" translate="no" id="begin"><span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiHash::<span class="name">begin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#constBegin" translate="no">constBegin</a>() and <a href="qmultihash.html#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" translate="no" id="begin-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiHash::<span class="name">begin</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@begin -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" translate="no" id="cbegin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiHash::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#begin" translate="no">begin</a>() and <a href="qmultihash.html#cend" translate="no">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" translate="no" id="cend"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiHash::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#cbegin" translate="no">cbegin</a>() and <a href="qmultihash.html#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><code class="details extra" translate="no">[noexcept(...)]</code> <span class="type">void</span> QMultiHash::<span class="name">clear</span>()</h3>
<p>Removes all items from the hash and frees up all memory used by it.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;std::is_nothrow_destructible&lt;Node&gt;::value&quot; is true.</p>
</div>
<p><b>See also </b><a href="qmultihash.html#remove" translate="no">remove</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" translate="no" id="constBegin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiHash::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#begin" translate="no">begin</a>() and <a href="qmultihash.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" translate="no" id="constEnd"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiHash::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#constBegin" translate="no">constBegin</a>() and <a href="qmultihash.html#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind$$$constFindconstKey&constT& -->
<h3 class="fn" translate="no" id="constFind-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiHash::<span class="name">constFind</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns an iterator pointing to the item with the <i translate="no">key</i> and the <i translate="no">value</i> in the hash.</p>
<p>If the hash contains no such item, the function returns <a href="qmultihash.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constFind -->
<!-- $$$constKeyValueBegin[overload1]$$$constKeyValueBegin -->
<h3 class="fn" translate="no" id="constKeyValueBegin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_key_value_iterator</span> QMultiHash::<span class="name">constKeyValueBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first entry in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueBegin" translate="no">keyValueBegin</a>().</p>
<!-- @@@constKeyValueBegin -->
<!-- $$$constKeyValueEnd[overload1]$$$constKeyValueEnd -->
<h3 class="fn" translate="no" id="constKeyValueEnd"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_key_value_iterator</span> QMultiHash::<span class="name">constKeyValueEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary entry after the last entry in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#constKeyValueBegin" translate="no">constKeyValueBegin</a>().</p>
<!-- @@@constKeyValueEnd -->
<!-- $$$contains$$$containsconstKey&constT& -->
<h3 class="fn" translate="no" id="contains-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QMultiHash::<span class="name">contains</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns <code translate="no">true</code> if the hash contains an item with the <i translate="no">key</i> and <i translate="no">value</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b>contains().</p>
<!-- @@@contains -->
<!-- $$$count$$$countconstKey&constT& -->
<h3 class="fn" translate="no" id="count-2"><code class="details extra" translate="no">[noexcept]</code> <span class="type">qsizetype</span> QMultiHash::<span class="name">count</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns the number of items with the <i translate="no">key</i> and <i translate="no">value</i>.</p>
<p><b>See also </b>count().</p>
<!-- @@@count -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiHash::<span class="name">end</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#begin" translate="no">begin</a>() and <a href="qmultihash.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" translate="no" id="end-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiHash::<span class="name">end</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@end -->
<!-- $$$equal_range[overload1]$$$equal_rangeconstKey& -->
<h3 class="fn" translate="no" id="equal_range"><span class="type">std::pair</span>&lt;<span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span>, <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span>&gt; QMultiHash::<span class="name">equal_range</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Returns a pair of iterators delimiting the range of values <code translate="no">[first, second)</code>, that are stored under <i translate="no">key</i>. If the range is empty then both iterators will be equal to <a href="qmultihash.html#end" translate="no">end</a>().</p>
<!-- @@@equal_range -->
<!-- $$$equal_range$$$equal_rangeconstKey& -->
<h3 class="fn" translate="no" id="equal_range-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type">std::pair</span>&lt;<span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span>, <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span>&gt; QMultiHash::<span class="name">equal_range</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@equal_range -->
<!-- $$$find$$$findconstKey&constT& -->
<h3 class="fn" translate="no" id="find-2"><span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiHash::<span class="name">find</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Returns an iterator pointing to the item with the <i translate="no">key</i> and <i translate="no">value</i>. If the hash contains no such item, the function returns <a href="qmultihash.html#end" translate="no">end</a>().</p>
<p>If the hash contains multiple items with the <i translate="no">key</i> and <i translate="no">value</i>, the iterator returned points to the most recently inserted item.</p>
<!-- @@@find -->
<!-- $$$find$$$findconstKey&constT& -->
<h3 class="fn" translate="no" id="find-3"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_iterator</span> QMultiHash::<span class="name">find</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@find -->
<!-- $$$insert[overload1]$$$insertconstKey&constT& -->
<h3 class="fn" translate="no" id="insert"><span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiHash::<span class="name">insert</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts a new item with the <i translate="no">key</i> and a value of <i translate="no">value</i>.</p>
<p>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <a href="qmultihash.html#replace" translate="no">replace</a>(), which overwrites the value of an existing item.)</p>
<p>Returns an iterator pointing to the new element.</p>
<p><b>See also </b><a href="qmultihash.html#replace" translate="no">replace</a>().</p>
<!-- @@@insert -->
<!-- $$$keyBegin[overload1]$$$keyBegin -->
<h3 class="fn" translate="no" id="keyBegin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::key_iterator</span> QMultiHash::<span class="name">keyBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first key in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#keyEnd" translate="no">keyEnd</a>().</p>
<!-- @@@keyBegin -->
<!-- $$$keyEnd[overload1]$$$keyEnd -->
<h3 class="fn" translate="no" id="keyEnd"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::key_iterator</span> QMultiHash::<span class="name">keyEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last key in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#keyBegin" translate="no">keyBegin</a>().</p>
<!-- @@@keyEnd -->
<!-- $$$keyValueBegin[overload1]$$$keyValueBegin -->
<h3 class="fn" translate="no" id="keyValueBegin"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::key_value_iterator</span> QMultiHash::<span class="name">keyValueBegin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first entry in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueEnd" translate="no">keyValueEnd</a>().</p>
<!-- @@@keyValueBegin -->
<!-- $$$keyValueBegin$$$keyValueBegin -->
<h3 class="fn" translate="no" id="keyValueBegin-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_key_value_iterator</span> QMultiHash::<span class="name">keyValueBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first entry in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueEnd" translate="no">keyValueEnd</a>().</p>
<!-- @@@keyValueBegin -->
<!-- $$$keyValueEnd[overload1]$$$keyValueEnd -->
<h3 class="fn" translate="no" id="keyValueEnd"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::key_value_iterator</span> QMultiHash::<span class="name">keyValueEnd</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary entry after the last entry in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueBegin" translate="no">keyValueBegin</a>().</p>
<!-- @@@keyValueEnd -->
<!-- $$$keyValueEnd$$$keyValueEnd -->
<h3 class="fn" translate="no" id="keyValueEnd-1"><code class="details extra" translate="no">[noexcept]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::const_key_value_iterator</span> QMultiHash::<span class="name">keyValueEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary entry after the last entry in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueBegin" translate="no">keyValueBegin</a>().</p>
<!-- @@@keyValueEnd -->
<!-- $$$keys[overload1]$$$keys -->
<h3 class="fn" translate="no" id="keys"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">Key</span>&gt; QMultiHash::<span class="name">keys</span>() const</h3>
<p>Returns a list containing all the keys in the hash, in an arbitrary order. Keys that occur multiple times in the hash also occur multiple times in the list.</p>
<p>The order is guaranteed to be the same as that used by <a href="qmultihash.html#values" translate="no">values</a>().</p>
<p>This function creates a new list, in <a href="containers.html#linear-time" translate="no">linear time</a>. The time and memory use that entails can be avoided by iterating from <a href="qmultihash.html#keyBegin" translate="no">keyBegin</a>() to <a href="qmultihash.html#keyEnd" translate="no">keyEnd</a>().</p>
<p><b>See also </b><a href="qmultihash.html#values" translate="no">values</a>() and <a href="qmultihash.html#key" translate="no">key</a>().</p>
<!-- @@@keys -->
<!-- $$$remove[overload1]$$$removeconstKey& -->
<h3 class="fn" translate="no" id="remove"><span class="type">qsizetype</span> QMultiHash::<span class="name">remove</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Removes all the items that have the <i translate="no">key</i> from the hash. Returns the number of items removed.</p>
<p><b>See also </b>remove().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstKey&constT& -->
<h3 class="fn" translate="no" id="remove-1"><span class="type">qsizetype</span> QMultiHash::<span class="name">remove</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Removes all the items that have the <i translate="no">key</i> and the value <i translate="no">value</i> from the hash. Returns the number of items removed.</p>
<p><b>See also </b><a href="qmultihash.html#remove" translate="no">remove</a>().</p>
<!-- @@@remove -->
<!-- $$$removeIf[overload1]$$$removeIfPredicate -->
<h3 class="fn" translate="no" id="removeIf"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Predicate&gt; <span class="type">qsizetype</span> QMultiHash::<span class="name">removeIf</span>(<span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i translate="no">pred</i> returns true from the multi hash.</p>
<p>The function supports predicates which take either an argument of type <code translate="no">QMultiHash&lt;Key, T&gt;::iterator</code>, or an argument of type <code translate="no">std::pair&lt;const Key &amp;, T &amp;&gt;</code>.</p>
<p>Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qmultihash.html#clear" translate="no">clear</a>() and <a href="qmultihash.html#take" translate="no">take</a>().</p>
<!-- @@@removeIf -->
<!-- $$$replace[overload1]$$$replaceconstKey&constT& -->
<h3 class="fn" translate="no" id="replace"><span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;<span class="type">::iterator</span> QMultiHash::<span class="name">replace</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts a new item with the <i translate="no">key</i> and a value of <i translate="no">value</i>.</p>
<p>If there is already an item with the <i translate="no">key</i>, that item's value is replaced with <i translate="no">value</i>.</p>
<p>If there are multiple items with the <i translate="no">key</i>, the most recently inserted item's value is replaced with <i translate="no">value</i>.</p>
<p>Returns an iterator pointing to the new/updated element.</p>
<p><b>See also </b><a href="qmultihash.html#insert" translate="no">insert</a>().</p>
<!-- @@@replace -->
<!-- $$$swap[overload1]$$$swapQMultiHash<Key,T>& -->
<h3 class="fn" translate="no" id="swap"><code class="details extra" translate="no">[noexcept]</code> <span class="type">void</span> QMultiHash::<span class="name">swap</span>(<span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Swaps hash <i translate="no">other</i> with this hash. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$take[overload1]$$$takeconstKey& -->
<h3 class="fn" translate="no" id="take"><span class="type">T</span> QMultiHash::<span class="name">take</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Removes the item with the <i translate="no">key</i> from the hash and returns the value associated with it.</p>
<p>If the item does not exist in the hash, the function simply returns a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a>. If there are multiple items for <i translate="no">key</i> in the hash, only the most recently inserted one is removed.</p>
<p>If you don't use the return value, <a href="qmultihash.html#remove" translate="no">remove</a>() is more efficient.</p>
<p><b>See also </b><a href="qmultihash.html#remove" translate="no">remove</a>().</p>
<!-- @@@take -->
<!-- $$$uniqueKeys[overload1]$$$uniqueKeys -->
<h3 class="fn" translate="no" id="uniqueKeys"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">Key</span>&gt; QMultiHash::<span class="name">uniqueKeys</span>() const</h3>
<p>Returns a list containing all the keys in the map. Keys that occur multiple times in the map occur only once in the returned list.</p>
<p><b>See also </b><a href="qmultihash.html#keys" translate="no">keys</a>() and <a href="qmultihash.html#values" translate="no">values</a>().</p>
<!-- @@@uniqueKeys -->
<!-- $$$unite[overload1]$$$uniteconstQMultiHash<Key,T>& -->
<h3 class="fn" translate="no" id="unite"><span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiHash::<span class="name">unite</span>(const <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Inserts all the items in the <i translate="no">other</i> hash into this hash and returns a reference to this hash.</p>
<p><b>See also </b><a href="qmultihash.html#insert" translate="no">insert</a>().</p>
<!-- @@@unite -->
<!-- $$$unite$$$uniteconstQHash<Key,T>& -->
<h3 class="fn" translate="no" id="unite-1"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiHash::<span class="name">unite</span>(const <span class="type"><a href="qhash.html" translate="no">QHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Inserts all the items in the <i translate="no">other</i> hash into this hash and returns a reference to this hash.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qmultihash.html#insert" translate="no">insert</a>().</p>
<!-- @@@unite -->
<!-- $$$values[overload1]$$$values -->
<h3 class="fn" translate="no" id="values"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QMultiHash::<span class="name">values</span>() const</h3>
<p>Returns a list containing all the values in the hash, in an arbitrary order. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</p>
<p>The order is guaranteed to be the same as that used by <a href="qmultihash.html#keys" translate="no">keys</a>().</p>
<p>This function creates a new list, in <a href="containers.html#linear-time" translate="no">linear time</a>. The time and memory use that entails can be avoided by iterating from <a href="qmultihash.html#keyValueBegin" translate="no">keyValueBegin</a>() to <a href="qmultihash.html#keyValueEnd" translate="no">keyValueEnd</a>().</p>
<p><b>See also </b><a href="qmultihash.html#keys" translate="no">keys</a>() and <a href="qmultihash.html#value" translate="no">value</a>().</p>
<!-- @@@values -->
<!-- $$$values$$$valuesconstKey& -->
<h3 class="fn" translate="no" id="values-1"><span class="type"><a href="qlist.html" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QMultiHash::<span class="name">values</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a list of all the values associated with the <i translate="no">key</i>, from the most recently inserted to the least recently inserted.</p>
<p><b>See also </b><a href="qmultihash.html#count-2" translate="no">count</a>() and <a href="qmultihash.html#insert" translate="no">insert</a>().</p>
<!-- @@@values -->
<!-- $$$operator+[overload1]$$$operator+constQMultiHash<Key,T>& -->
<h3 class="fn" translate="no" id="operator-2b"><span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; QMultiHash::<span class="name">operator+</span>(const <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns a hash that contains all the items in this hash in addition to all the items in <i translate="no">other</i>. If a key is common to both hashes, the resulting hash will contain the key multiple times.</p>
<p><b>See also </b><a href="qmultihash.html#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+=[overload1]$$$operator+=constQMultiHash<Key,T>& -->
<h3 class="fn" translate="no" id="operator-2b-eq"><span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiHash::<span class="name">operator+=</span>(const <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Inserts all the items in the <i translate="no">other</i> hash into this hash and returns a reference to this hash.</p>
<p><b>See also </b><a href="qmultihash.html#unite" translate="no">unite</a>() and <a href="qmultihash.html#insert" translate="no">insert</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator[][overload1]$$$operator[]constKey& -->
<h3 class="fn" translate="no" id="operator-5b-5d"><span class="type">T</span> &amp;QMultiHash::<span class="name">operator[]</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Returns the value associated with the <i translate="no">key</i> as a modifiable reference.</p>
<p>If the hash contains no item with the <i translate="no">key</i>, the function inserts a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a> into the hash with the <i translate="no">key</i>, and returns a reference to it.</p>
<p>If the hash contains multiple items with the <i translate="no">key</i>, this function returns a reference to the most recently inserted value.</p>
<p><b>See also </b><a href="qmultihash.html#insert" translate="no">insert</a>() and <a href="qmultihash.html#value" translate="no">value</a>().</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$erase_if[overload1]$$$erase_ifQMultiHash<Key,T>&Predicate -->
<h3 class="fn" translate="no" id="erase_if"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Key, typename T, typename Predicate&gt; <span class="type">qsizetype</span> <span class="name">erase_if</span>(<span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>hash</i>, <span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i translate="no">pred</i> returns true from the multi hash <i translate="no">hash</i>.</p>
<p>The function supports predicates which take either an argument of type <code translate="no">QMultiHash&lt;Key, T&gt;::iterator</code>, or an argument of type <code translate="no">std::pair&lt;const Key &amp;, T &amp;&gt;</code>.</p>
<p>Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@erase_if -->
<!-- $$$qHash[overload1]$$$qHashconstQMultiHash<Key,T>&size_t -->
<h3 class="fn" translate="no" id="qHash"><code class="details extra" translate="no">[noexcept(...)]</code> template &lt;typename Key, typename T&gt; <span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>key</i>, <span class="type">size_t</span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for the <i translate="no">key</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<p>Type <code translate="no">T</code> must be supported by qHash().</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;noexcept(qHash(std::declval&lt;Key&amp;&gt;())) &amp;&amp; noexcept(qHash(std::declval&lt;T&amp;&gt;()))&quot; is true.</p>
</div>
<!-- @@@qHash -->
<!-- $$$operator<<$$$operator<<QDataStream&constQMultiHash<Key,T>& -->
<h3 class="fn" translate="no" id="operator-lt-lt-3">template &lt;typename Key, typename T&gt; <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>hash</i>)</h3>
<p>Writes the hash <i translate="no">hash</i> to stream <i translate="no">out</i>.</p>
<p>This function requires the key and value types to implement <code translate="no">operator&lt;&lt;()</code>.</p>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator>>$$$operator>>QDataStream&QMultiHash<Key,T>& -->
<h3 class="fn" translate="no" id="operator-gt-gt-2">template &lt;typename Key, typename T&gt; <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qmultihash.html#QMultiHash" translate="no">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>hash</i>)</h3>
<p>Reads a hash from stream <i translate="no">in</i> into <i translate="no">hash</i>.</p>
<p>This function requires the key and value types to implement <code translate="no">operator&gt;&gt;()</code>.</p>
<p><b>See also </b><a href="datastreamformat.html" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator>> -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
