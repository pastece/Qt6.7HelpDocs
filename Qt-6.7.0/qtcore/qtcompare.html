<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qcompare.cpp -->
  <meta name="description" content="The &lt;QtCompare&gt; header file defines &lt;@type&gt;Qt&lt;/@type&gt;&lt;@op&gt;::&lt;/@op&gt;&lt;@op&gt;*&lt;/@op&gt;_ordering types and helper macros for defining comparison operators.">
  <title>&lt;QtCompare&gt; - Classes and helpers for defining comparison operators | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li>&lt;QtCompare&gt; - Classes and helpers for defining comparison operators</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">&lt;QtCompare&gt; - Classes and helpers for defining comparison operators</h1>
<!-- $$$<QtCompare>-brief -->
<p>The &lt;<a href="qtcompare.html" translate="no">QtCompare</a>&gt; header file defines <code translate="no">Qt::*_ordering</code> types and helper macros for defining comparison operators. <a href="#details">More...</a></p>
<!-- @@@<QtCompare> -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QtCompare&gt;</span></td></tr>
</table></div>
<h2 id="functions">Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> Qt::strong_ordering </td><td class="memItemRight bottomAlign"><b><a href="qtcompare.html#compareThreeWay" translate="no">compareThreeWay</a></b>(LeftInt <i>lhs</i>, RightInt <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> Qt::partial_ordering </td><td class="memItemRight bottomAlign"><b><a href="qtcompare.html#compareThreeWay-1" translate="no">compareThreeWay</a></b>(LeftFloat <i>lhs</i>, RightFloat <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> Qt::partial_ordering </td><td class="memItemRight bottomAlign"><b><a href="qtcompare.html#compareThreeWay-2" translate="no">compareThreeWay</a></b>(IntType <i>lhs</i>, FloatType <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> Qt::partial_ordering </td><td class="memItemRight bottomAlign"><b><a href="qtcompare.html#compareThreeWay-3" translate="no">compareThreeWay</a></b>(FloatType <i>lhs</i>, IntType <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> Qt::strong_ordering </td><td class="memItemRight bottomAlign"><b><a href="qtcompare.html#compareThreeWay-4" translate="no">compareThreeWay</a></b>(const LeftType *<i>lhs</i>, const RightType *<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> Qt::strong_ordering </td><td class="memItemRight bottomAlign"><b><a href="qtcompare.html#compareThreeWay-5" translate="no">compareThreeWay</a></b>(Enum <i>lhs</i>, Enum <i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> auto </td><td class="memItemRight bottomAlign"><b><a href="qtcompare.html#qCompareThreeWay" translate="no">qCompareThreeWay</a></b>(const LeftType &amp;<i>lhs</i>, const RightType &amp;<i>rhs</i>)</td></tr>
</table></div>
<!-- $$$<QtCompare>-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>This header introduces the <a href="qt-partial-ordering.html" translate="no">Qt::partial_ordering</a>, <a href="qt-weak-ordering.html" translate="no">Qt::weak_ordering</a>, and <a href="qt-strong-ordering.html" translate="no">Qt::strong_ordering</a> types, which are Qt's C++17 backports of <code translate="no">std::*_ordering</code> types.</p>
<p>This header also contains functions for implementing three-way comparison in C++17.</p>
<p>The <code translate="no">Qt::compareThreeWay()</code> function overloads provide three-way comparison for built-in C++ types.</p>
<p>The <a href="qtcompare.html#qCompareThreeWay" translate="no">qCompareThreeWay</a>() template serves as a generic three-way comparison implementation. It relies on <code translate="no">Qt::compareThreeWay()</code> and free <code translate="no">compareThreeWay()</code> functions in its implementation.</p>
</div>
<!-- @@@<QtCompare> -->
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$compareThreeWay[overload1]$$$compareThreeWayLeftIntRightInt -->
<h3 class="fn" translate="no" id="compareThreeWay"><code class="details extra" translate="no">[constexpr noexcept, since 6.7]</code> template &lt;typename LeftInt, typename RightInt, Qt::if_integral&lt;LeftInt&gt; = true, Qt::if_integral<RightInt> = true> <span class="type"><a href="qt-strong-ordering.html" translate="no">Qt::strong_ordering</a></span> <span class="name">compareThreeWay</span>(<span class="type">LeftInt</span> <i>lhs</i>, <span class="type">RightInt</span> <i>rhs</i>)</h3>
<p>This is an overloaded function.</p>
<p>Implements three-way comparison of integral types.</p>
<div class="admonition note">
<p><b>Note: </b>This function participates in overload resolution only if both <code translate="no">LeftInt</code> and <code translate="no">RightInt</code> are built-in integral types.</p>
</div>
<p>Returns <code translate="no">lhs &lt;=&gt; rhs</code>, provided <code translate="no">LeftInt</code> and <code translate="no">RightInt</code> are built-in integral types. Unlike <code translate="no">operator&lt;=&gt;()</code>, this function template is also available in C++17. See <a href="https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison" translate="no">cppreference</a> for more details.</p>
<p>This function can also be used in custom <code translate="no">compareThreeWay()</code> functions, when ordering members of a custom class represented by built-in types:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass {
 <span class="keyword">public</span>:
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">private</span>:
     <span class="type">int</span> value;
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">friend</span> <span class="type">Qt</span><span class="operator">::</span>strong_ordering
     compareThreeWay(<span class="keyword">const</span> MyClass <span class="operator">&amp;</span>lhs<span class="operator">,</span> <span class="keyword">const</span> MyClass <span class="operator">&amp;</span>rhs) noexcept
     { <span class="keyword">return</span> <span class="type">Qt</span><span class="operator">::</span>compareThreeWay(lhs<span class="operator">.</span>value<span class="operator">,</span> rhs<span class="operator">.</span>value); }
     Q_DECLARE_STRONGLY_ORDERED(MyClass)
 };
</pre>
<p>Returns an instance of <a href="qt-strong-ordering.html" translate="no">Qt::strong_ordering</a> that represents the relation between <i translate="no">lhs</i> and <i translate="no">rhs</i>.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@compareThreeWay -->
<!-- $$$compareThreeWay$$$compareThreeWayLeftFloatRightFloat -->
<h3 class="fn" translate="no" id="compareThreeWay-1"><code class="details extra" translate="no">[constexpr noexcept, since 6.7]</code> template &lt;typename LeftFloat, typename RightFloat, Qt::if_floating_point&lt;LeftFloat&gt; = true, Qt::if_floating_point<RightFloat> = true> <span class="type"><a href="qt-partial-ordering.html" translate="no">Qt::partial_ordering</a></span> <span class="name">compareThreeWay</span>(<span class="type">LeftFloat</span> <i>lhs</i>, <span class="type">RightFloat</span> <i>rhs</i>)</h3>
<p>This is an overloaded function.</p>
<p>Implements three-way comparison of floating point types.</p>
<div class="admonition note">
<p><b>Note: </b>This function participates in overload resolution only if both <code translate="no">LeftFloat</code> and <code translate="no">RightFloat</code> are built-in floating-point types.</p>
</div>
<p>Returns <code translate="no">lhs &lt;=&gt; rhs</code>, provided <code translate="no">LeftFloat</code> and <code translate="no">RightFloat</code> are built-in floating-point types. Unlike <code translate="no">operator&lt;=&gt;()</code>, this function template is also available in C++17. See <a href="https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison" translate="no">cppreference</a> for more details.</p>
<p>This function can also be used in custom <code translate="no">compareThreeWay()</code> functions, when ordering members of a custom class represented by built-in types:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyClass {
 <span class="keyword">public</span>:
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">private</span>:
     <span class="type">double</span> value;
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">friend</span> <span class="type">Qt</span><span class="operator">::</span>partial_ordering
     compareThreeWay(<span class="keyword">const</span> MyClass <span class="operator">&amp;</span>lhs<span class="operator">,</span> <span class="keyword">const</span> MyClass <span class="operator">&amp;</span>rhs) noexcept
     { <span class="keyword">return</span> <span class="type">Qt</span><span class="operator">::</span>compareThreeWay(lhs<span class="operator">.</span>value<span class="operator">,</span> rhs<span class="operator">.</span>value); }
     Q_DECLARE_PARTIALLY_ORDERED(MyClass)
 };
</pre>
<p>Returns an instance of <a href="qt-partial-ordering.html" translate="no">Qt::partial_ordering</a> that represents the relation between <i translate="no">lhs</i> and <i translate="no">rhs</i>. If <i translate="no">lhs</i> or <i translate="no">rhs</i> is not a number (NaN), <a href="qt-partial-ordering.html#unordered-var" translate="no">Qt::partial_ordering::unordered</a> is returned.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@compareThreeWay -->
<!-- $$$compareThreeWay$$$compareThreeWayIntTypeFloatType -->
<h3 class="fn" translate="no" id="compareThreeWay-2"><code class="details extra" translate="no">[constexpr noexcept, since 6.7]</code> template &lt;typename IntType, typename FloatType, Qt::if_integral&lt;IntType&gt; = true, Qt::if_floating_point<FloatType> = true> <span class="type"><a href="qt-partial-ordering.html" translate="no">Qt::partial_ordering</a></span> <span class="name">compareThreeWay</span>(<span class="type">IntType</span> <i>lhs</i>, <span class="type">FloatType</span> <i>rhs</i>)</h3>
<p>This is an overloaded function.</p>
<p>Implements three-way comparison of integral and floating point types.</p>
<div class="admonition note">
<p><b>Note: </b>This function participates in overload resolution only if <code translate="no">IntType</code> is a built-in integral type and <code translate="no">FloatType</code> is a built-in floating-point type.</p>
</div>
<p>This function converts <i translate="no">lhs</i> to <code translate="no">FloatType</code> and calls the overload for floating-point types.</p>
<p>Returns an instance of <a href="qt-partial-ordering.html" translate="no">Qt::partial_ordering</a> that represents the relation between <i translate="no">lhs</i> and <i translate="no">rhs</i>. If <i translate="no">rhs</i> is not a number (NaN), <a href="qt-partial-ordering.html#unordered-var" translate="no">Qt::partial_ordering::unordered</a> is returned.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@compareThreeWay -->
<!-- $$$compareThreeWay$$$compareThreeWayFloatTypeIntType -->
<h3 class="fn" translate="no" id="compareThreeWay-3"><code class="details extra" translate="no">[constexpr noexcept, since 6.7]</code> template &lt;typename FloatType, typename IntType, Qt::if_floating_point&lt;FloatType&gt; = true, Qt::if_integral<IntType> = true> <span class="type"><a href="qt-partial-ordering.html" translate="no">Qt::partial_ordering</a></span> <span class="name">compareThreeWay</span>(<span class="type">FloatType</span> <i>lhs</i>, <span class="type">IntType</span> <i>rhs</i>)</h3>
<p>This is an overloaded function.</p>
<p>Implements three-way comparison of floating point and integral types.</p>
<div class="admonition note">
<p><b>Note: </b>This function participates in overload resolution only if <code translate="no">FloatType</code> is a built-in floating-point type and <code translate="no">IntType</code> is a built-in integral type.</p>
</div>
<p>This function converts <i translate="no">rhs</i> to <code translate="no">FloatType</code> and calls the overload for floating-point types.</p>
<p>Returns an instance of <a href="qt-partial-ordering.html" translate="no">Qt::partial_ordering</a> that represents the relation between <i translate="no">lhs</i> and <i translate="no">rhs</i>. If <i translate="no">lhs</i> is not a number (NaN), <a href="qt-partial-ordering.html#unordered-var" translate="no">Qt::partial_ordering::unordered</a> is returned.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@compareThreeWay -->
<!-- $$$compareThreeWay$$$compareThreeWayconstLeftType*constRightType* -->
<h3 class="fn" translate="no" id="compareThreeWay-4"><code class="details extra" translate="no">[constexpr noexcept, since 6.7]</code> template &lt;typename LeftType, typename RightType, Qt::if_compatible_pointers&lt;LeftType, RightType&gt; = true> <span class="type"><a href="qt-strong-ordering.html" translate="no">Qt::strong_ordering</a></span> <span class="name">compareThreeWay</span>(const <span class="type">LeftType</span> *<i>lhs</i>, const <span class="type">RightType</span> *<i>rhs</i>)</h3>
<p>This is an overloaded function.</p>
<p>Implements three-way comparison of pointers.</p>
<div class="admonition note">
<p><b>Note: </b>This function participates in overload resolution if <code translate="no">LeftType</code> and <code translate="no">RightType</code> are the same type, or base and derived types. It is also used to compare any pointer to <code translate="no">std::nullptr_t</code>.</p>
</div>
<p>Returns an instance of <a href="qt-strong-ordering.html" translate="no">Qt::strong_ordering</a> that represents the relation between <i translate="no">lhs</i> and <i translate="no">rhs</i>.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@compareThreeWay -->
<!-- $$$compareThreeWay$$$compareThreeWayEnumEnum -->
<h3 class="fn" translate="no" id="compareThreeWay-5"><code class="details extra" translate="no">[constexpr noexcept, since 6.7]</code> template &lt;typename Enum, Qt::if_enum&lt;Enum&gt; = true> <span class="type"><a href="qt-strong-ordering.html" translate="no">Qt::strong_ordering</a></span> <span class="name">compareThreeWay</span>(<span class="type">Enum</span> <i>lhs</i>, <span class="type">Enum</span> <i>rhs</i>)</h3>
<p>This is an overloaded function.</p>
<p>Implements three-way comparison of enum types.</p>
<div class="admonition note">
<p><b>Note: </b>This function participates in overload resolution only if <code translate="no">Enum</code> is an enum type.</p>
</div>
<p>This function converts <code translate="no">Enum</code> to its underlying type and calls the overload for integral types.</p>
<p>Returns an instance of <a href="qt-strong-ordering.html" translate="no">Qt::strong_ordering</a> that represents the relation between <i translate="no">lhs</i> and <i translate="no">rhs</i>.</p>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@compareThreeWay -->
<!-- $$$qCompareThreeWay[overload1]$$$qCompareThreeWayconstLeftType&constRightType& -->
<h3 class="fn" translate="no" id="qCompareThreeWay"><code class="details extra" translate="no">[since 6.7]</code> template &lt;typename LeftType, typename RightType&gt; <span class="type">auto</span> <span class="name">qCompareThreeWay</span>(const <span class="type">LeftType</span> &amp;<i>lhs</i>, const <span class="type">RightType</span> &amp;<i>rhs</i>)</h3>
<p>Performs the three-way comparison on <i translate="no">lhs</i> and <i translate="no">rhs</i> and returns one of the Qt ordering types as a result. This function is available for both C++17 and C++20.</p>
<p>The actual returned type depends on <code translate="no">LeftType</code> and <code translate="no">RightType</code>.</p>
<div class="admonition note">
<p><b>Note: </b>This function template is only available when <code translate="no">compareThreeWay()</code> is implemented for the <code translate="no">(LeftType, RightType)</code> pair or the reversed <code translate="no">(RightType, LeftType)</code> pair.</p>
</div>
<p>This method is equivalent to</p>
<pre class="cpp" translate="no">
 <span class="keyword">using</span> <span class="type">Qt</span><span class="operator">::</span>compareThreeWay;
 <span class="keyword">return</span> compareThreeWay(lhs<span class="operator">,</span> rhs);
</pre>
<p>where <code translate="no">Qt::compareThreeWay</code> is the Qt implementation of three-way comparison for built-in types.</p>
<p>The free <code translate="no">compareThreeWay</code> functions should provide three-way comparison for custom types. The functions should return one of the Qt ordering types.</p>
<p>Qt provides <code translate="no">compareThreeWay</code> implementation for some of its types.</p>
<div class="admonition note">
<p><b>Note: </b><b>Do not</b> re-implement <code translate="no">compareThreeWay()</code> for Qt types, as more Qt types will get support for it in future Qt releases.</p>
</div>
<p>Use this function primarly in generic code, when you know nothing about <code translate="no">LeftType</code> and <code translate="no">RightType</code>.</p>
<p>If you know the types, use</p>
<ul>
<li><code translate="no">Qt::compareThreeWay</code> for built-in types</li>
<li><code translate="no">compareThreeWay</code> for custom types</li>
</ul>
<p>Use <code translate="no">operator&lt;=&gt;()</code> directly in code that will only be compiled with C++20 or later.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qt-partial-ordering.html" translate="no">Qt::partial_ordering</a>, <a href="qt-weak-ordering.html" translate="no">Qt::weak_ordering</a>, and <a href="qt-strong-ordering.html" translate="no">Qt::strong_ordering</a>.</p>
<!-- @@@qCompareThreeWay -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
