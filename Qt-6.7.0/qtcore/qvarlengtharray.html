<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qvarlengtharray.qdoc -->
  <meta name="description" content="The QVarLengthArray class provides a low-level variable-length array.">
  <title>QVarLengthArray Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QVarLengthArray</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QVarLengthArray Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T, qsizetype Prealloc = QVarLengthArrayDefaultPrealloc&gt; class QVarLengthArray</span>
<!-- $$$QVarLengthArray-brief -->
<p>The QVarLengthArray class provides a low-level variable-length array. <a href="#details">More...</a></p>
<!-- @@@QVarLengthArray -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QVarLengthArray&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> QVLABase and QVLAStorage</td></tr>
</table></div>
<ul>
<li><a href="qvarlengtharray-members.html">List of all members, including inherited members</a></li>
<li><a href="qvarlengtharray-obsolete.html">Deprecated members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#const_iterator-typedef" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#const_pointer-typedef" translate="no">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#const_reference-typedef" translate="no">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#iterator-typedef" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#pointer-typedef" translate="no">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#reference-typedef" translate="no">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#reverse_iterator-typedef" translate="no">reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#value_type-typedef" translate="no">value_type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#QVarLengthArray-1" translate="no">QVarLengthArray</a></b>(qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#QVarLengthArray-2" translate="no">QVarLengthArray</a></b>(qsizetype <i>size</i>, const T &amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#QVarLengthArray-5" translate="no">QVarLengthArray</a></b>(std::initializer_list&lt;T&gt; <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#QVarLengthArray-3" translate="no">QVarLengthArray</a></b>(const QVarLengthArray&lt;T, Prealloc&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#QVarLengthArray-4" translate="no">QVarLengthArray</a></b>(QVarLengthArray&lt;T, Prealloc&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#dtor.QVarLengthArray" translate="no">~QVarLengthArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#append" translate="no">append</a></b>(const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#append-1" translate="no">append</a></b>(T &amp;&amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#append-2" translate="no">append</a></b>(const T *<i>buf</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QVarLengthArray&lt;T, Prealloc&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#assign" translate="no">assign</a></b>(qsizetype <i>n</i>, const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QVarLengthArray&lt;T, Prealloc&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#assign-2" translate="no">assign</a></b>(std::initializer_list&lt;T&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#at" translate="no">at</a></b>(qsizetype <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#back" translate="no">back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#back-1" translate="no">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#capacity" translate="no">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T *</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#constData" translate="no">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#contains" translate="no">contains</a></b>(const AT &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#count" translate="no">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#crbegin" translate="no">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#crend" translate="no">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#data" translate="no">data</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T *</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#data-1" translate="no">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> QVarLengthArray&lt;T, Prealloc&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#emplace" translate="no">emplace</a></b>(QVarLengthArray&lt;T, Prealloc&gt;::const_iterator <i>pos</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#emplace_back" translate="no">emplace_back</a></b>(Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#erase" translate="no">erase</a></b>(QVarLengthArray&lt;T, Prealloc&gt;::const_iterator <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#erase-1" translate="no">erase</a></b>(QVarLengthArray&lt;T, Prealloc&gt;::const_iterator <i>begin</i>, QVarLengthArray&lt;T, Prealloc&gt;::const_iterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#first" translate="no">first</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#first-1" translate="no">first</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#front" translate="no">front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#front-1" translate="no">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#indexOf" translate="no">indexOf</a></b>(const AT &amp;<i>value</i>, qsizetype <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#insert" translate="no">insert</a></b>(qsizetype <i>i</i>, T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#insert-1" translate="no">insert</a></b>(qsizetype <i>i</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#insert-2" translate="no">insert</a></b>(qsizetype <i>i</i>, qsizetype <i>count</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#insert-3" translate="no">insert</a></b>(QVarLengthArray&lt;T, Prealloc&gt;::const_iterator <i>before</i>, qsizetype <i>count</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#insert-4" translate="no">insert</a></b>(QVarLengthArray&lt;T, Prealloc&gt;::const_iterator <i>before</i>, T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#insert-5" translate="no">insert</a></b>(QVarLengthArray&lt;T, Prealloc&gt;::const_iterator <i>before</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#last" translate="no">last</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#last-1" translate="no">last</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#lastIndexOf" translate="no">lastIndexOf</a></b>(const AT &amp;<i>value</i>, qsizetype <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#length" translate="no">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#pop_back" translate="no">pop_back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#push_back" translate="no">push_back</a></b>(const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#push_back-1" translate="no">push_back</a></b>(T &amp;&amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#rbegin" translate="no">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#rbegin-1" translate="no">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#remove" translate="no">remove</a></b>(qsizetype <i>i</i>, qsizetype <i>count</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#removeAll" translate="no">removeAll</a></b>(const AT &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#removeIf" translate="no">removeIf</a></b>(Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#removeLast" translate="no">removeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#removeOne" translate="no">removeOne</a></b>(const AT &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#rend" translate="no">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt;::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#rend-1" translate="no">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#replace" translate="no">replace</a></b>(qsizetype <i>i</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#reserve" translate="no">reserve</a></b>(qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#resize" translate="no">resize</a></b>(qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#resize-1" translate="no">resize</a></b>(qsizetype <i>size</i>, const T &amp;<i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#shrink_to_fit" translate="no">shrink_to_fit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#squeeze" translate="no">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#value" translate="no">value</a></b>(qsizetype <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#value-1" translate="no">value</a></b>(qsizetype <i>i</i>, const T &amp;<i>defaultValue</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-2b-eq" translate="no">operator+=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-2b-eq-1" translate="no">operator+=</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-lt-lt" translate="no">operator&lt;&lt;</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-lt-lt-1" translate="no">operator&lt;&lt;</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-eq" translate="no">operator=</a></b>(const QVarLengthArray&lt;T, Prealloc&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QVarLengthArray&lt;T, Prealloc&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-eq-1" translate="no">operator=</a></b>(QVarLengthArray&lt;T, Prealloc&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVarLengthArray&lt;T, Prealloc&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-eq-2" translate="no">operator=</a></b>(std::initializer_list&lt;T&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-5b-5d" translate="no">operator[]</a></b>(qsizetype <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-5b-5d-1" translate="no">operator[]</a></b>(qsizetype <i>i</i>) const</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#erase-2" translate="no">erase</a></b>(QVarLengthArray&lt;T, Prealloc&gt; &amp;<i>array</i>, const AT &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#erase_if" translate="no">erase_if</a></b>(QVarLengthArray&lt;T, Prealloc&gt; &amp;<i>array</i>, Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#qHash-41" translate="no">qHash</a></b>(const QVarLengthArray&lt;T, Prealloc&gt; &amp;<i>key</i>, size_t <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-not-eq-11" translate="no">operator!=</a></b>(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<i>left</i>, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<i>right</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-lt-1" translate="no">operator&lt;</a></b>(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<i>lhs</i>, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-lt-eq-1" translate="no">operator&lt;=</a></b>(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<i>lhs</i>, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-eq-eq-12" translate="no">operator==</a></b>(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<i>left</i>, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<i>right</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-gt-1" translate="no">operator&gt;</a></b>(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<i>lhs</i>, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvarlengtharray.html#operator-gt-eq-1" translate="no">operator&gt;=</a></b>(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<i>lhs</i>, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<i>rhs</i>)</td></tr>
</table></div>
<!-- $$$QVarLengthArray-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The C++ language doesn't support variable-length arrays on the stack. For example, the following code won't compile:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> myfunc(<span class="type">int</span> n)
 {
     <span class="type">int</span> table<span class="operator">[</span>n <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span>;  <span class="comment">// WRONG</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">return</span> table<span class="operator">[</span>n<span class="operator">]</span>;
 }
</pre>
<p>The alternative is to allocate the array on the heap (with <code translate="no">new</code>):</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> myfunc(<span class="type">int</span> n)
 {
     <span class="type">int</span> <span class="operator">*</span>table <span class="operator">=</span> <span class="keyword">new</span> <span class="type">int</span><span class="operator">[</span>n <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span>;
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="type">int</span> ret <span class="operator">=</span> table<span class="operator">[</span>n<span class="operator">]</span>;
     <span class="keyword">delete</span><span class="operator">[</span><span class="operator">]</span> table;
     <span class="keyword">return</span> ret;
 }
</pre>
<p>However, if myfunc() is called very frequently from the application's inner loop, heap allocation can be a major source of slowdown.</p>
<p>QVarLengthArray is an attempt to work around this gap in the C++ language. It allocates a certain number of elements on the stack, and if you resize the array to a larger size, it automatically uses the heap instead. Stack allocation has the advantage that it is much faster than heap allocation.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> myfunc(<span class="type">int</span> n)
 {
     <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="number">1024</span><span class="operator">&gt;</span> array(n <span class="operator">+</span> <span class="number">1</span>);
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">return</span> array<span class="operator">[</span>n<span class="operator">]</span>;
 }
</pre>
<p>In the example above, QVarLengthArray will preallocate 1024 elements on the stack and use them unless <code translate="no">n + 1</code> is greater than 1024. If you omit the second template argument, QVarLengthArray's default of 256 is used.</p>
<p>QVarLengthArray's value type must be an <a href="containers.html#assignable-data-type" translate="no">assignable data type</a>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> as a value; instead, store a <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> *.</p>
<p>QVarLengthArray, like <a href="qlist.html" translate="no">QList</a>, provides a resizable array data structure. The main differences between the two classes are:</p>
<ul>
<li>QVarLengthArray's API is much more low-level and it lacks some of <a href="qlist.html" translate="no">QList</a>'s functionality.</li>
<li>QVarLengthArray doesn't initialize the memory if the value is a basic type. (<a href="qlist.html" translate="no">QList</a> always does.)</li>
<li><a href="qlist.html" translate="no">QList</a> uses <a href="implicit-sharing.html" translate="no">implicit sharing</a> as a memory optimization. QVarLengthArray doesn't provide that feature; however, it usually produces slightly better performance due to reduced overhead, especially in tight loops.</li>
</ul>
<p>In summary, QVarLengthArray is a low-level optimization class that only makes sense in very specific cases. It is used a few places inside Qt and was added to Qt's public API for the convenience of advanced users.</p>
</div>
<p><b>See also </b><a href="qlist.html" translate="no">QList</a>.</p>
<!-- @@@QVarLengthArray -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$const_iterator -->
<h3 class="fn" translate="no" id="const_iterator-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">const_iterator</span></h3>
<p>Typedef for const T *. Provided for STL compatibility.</p>
<!-- @@@const_iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" translate="no" id="const_pointer-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">const_pointer</span></h3>
<p>Typedef for const T *. Provided for STL compatibility.</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" translate="no" id="const_reference-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">const_reference</span></h3>
<p>Typedef for const T &amp;. Provided for STL compatibility.</p>
<!-- @@@const_reference -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" translate="no" id="const_reverse_iterator-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">const_reverse_iterator</span></h3>
<p>Typedef for <code translate="no">std::reverse_iterator&lt;const T*&gt;</code>. Provided for STL compatibility.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" translate="no" id="difference_type-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">difference_type</span></h3>
<p>Typedef for ptrdiff_t. Provided for STL compatibility.</p>
<!-- @@@difference_type -->
<!-- $$$iterator -->
<h3 class="fn" translate="no" id="iterator-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">iterator</span></h3>
<p>Typedef for T *. Provided for STL compatibility.</p>
<!-- @@@iterator -->
<!-- $$$pointer -->
<h3 class="fn" translate="no" id="pointer-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">pointer</span></h3>
<p>Typedef for T *. Provided for STL compatibility.</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" translate="no" id="reference-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">reference</span></h3>
<p>Typedef for T &amp;. Provided for STL compatibility.</p>
<!-- @@@reference -->
<!-- $$$reverse_iterator -->
<h3 class="fn" translate="no" id="reverse_iterator-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">reverse_iterator</span></h3>
<p>Typedef for <code translate="no">std::reverse_iterator&lt;T*&gt;</code>. Provided for STL compatibility.</p>
<!-- @@@reverse_iterator -->
<!-- $$$size_type -->
<h3 class="fn" translate="no" id="size_type-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">size_type</span></h3>
<p>Typedef for int. Provided for STL compatibility.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" translate="no" id="value_type-typedef"><code class="details extra" translate="no">[alias]</code> QVarLengthArray::<span class="name">value_type</span></h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="insert"><span class="type">void</span> QVarLengthArray::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">T</span> &amp;&amp;<i>value</i>)</h3><h3 class="fn fngroupitem" translate="no" id="insert-1"><span class="type">void</span> QVarLengthArray::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3></div>
<p>Inserts <i translate="no">value</i> at index position <i translate="no">i</i> in the array. If <i translate="no">i</i> is 0, the value is prepended to the vector. If <i translate="no">i</i> is <a href="qvarlengtharray.html#size" translate="no">size</a>(), the value is appended to the vector.</p>
<p>For large arrays, this operation can be slow (<a href="containers.html#linear-time" translate="no">linear time</a>), because it requires moving all the items at indexes <i translate="no">i</i> and above by one position further in memory. If you want a container class that provides a fast <a href="qvarlengtharray.html#insert" translate="no">insert</a>() function, use std::list instead.</p>
<p><b>See also </b><a href="qvarlengtharray.html#remove" translate="no">remove</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="insert-4"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::iterator</span> QVarLengthArray::<span class="name">insert</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> <i>before</i>, <span class="type">T</span> &amp;&amp;<i>value</i>)</h3><h3 class="fn fngroupitem" translate="no" id="insert-5"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::iterator</span> QVarLengthArray::<span class="name">insert</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> <i>before</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3></div>
<p>This is an overloaded function.</p>
<p>Inserts <i translate="no">value</i> in front of the item pointed to by the iterator <i translate="no">before</i>. Returns an iterator pointing at the inserted item.</p>
<!-- @@@ -->
<!-- $$$QVarLengthArray[overload1]$$$QVarLengthArray -->
<h3 class="fn" translate="no" id="QVarLengthArray"><code class="details extra" translate="no">[noexcept]</code> QVarLengthArray::<span class="name">QVarLengthArray</span>()</h3>
<p>Constructs an array with an initial size of zero.</p>
<!-- @@@QVarLengthArray -->
<!-- $$$QVarLengthArray$$$QVarLengthArrayqsizetype -->
<h3 class="fn" translate="no" id="QVarLengthArray-1"><code class="details extra" translate="no">[explicit]</code> QVarLengthArray::<span class="name">QVarLengthArray</span>(<span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Constructs an array with an initial size of <i translate="no">size</i> elements.</p>
<p>If the value type is a primitive type (e.g., char, int, float) or a pointer type (e.g., <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> *), the elements are not initialized. For other types, the elements are initialized with a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a>.</p>
<!-- @@@QVarLengthArray -->
<!-- $$$QVarLengthArray$$$QVarLengthArrayqsizetypeconstT& -->
<h3 class="fn" translate="no" id="QVarLengthArray-2"><code class="details extra" translate="no">[explicit, since 6.4]</code> QVarLengthArray::<span class="name">QVarLengthArray</span>(<span class="type">qsizetype</span> <i>size</i>, const <span class="type">T</span> &amp;<i>v</i>)</h3>
<p>Constructs an array with an initial size of <i translate="no">size</i> elements filled with copies of <i translate="no">v</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This constructor is only available when <code translate="no">T</code> is copy-constructible.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qvarlengtharray.html#size" translate="no">size</a>() and <a href="qvarlengtharray.html#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@QVarLengthArray -->
<!-- $$$QVarLengthArray$$$QVarLengthArraystd::initializer_list<T> -->
<h3 class="fn" translate="no" id="QVarLengthArray-5">QVarLengthArray::<span class="name">QVarLengthArray</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">T</span>&gt; <i>args</i>)</h3>
<p>Constructs an array from the std::initializer_list given by <i translate="no">args</i>.</p>
<!-- @@@QVarLengthArray -->
<!-- $$$QVarLengthArray$$$QVarLengthArrayconstQVarLengthArray<T,Prealloc>& -->
<h3 class="fn" translate="no" id="QVarLengthArray-3">QVarLengthArray::<span class="name">QVarLengthArray</span>(const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<!-- @@@QVarLengthArray -->
<!-- $$$QVarLengthArray$$$QVarLengthArrayQVarLengthArray<T,Prealloc>&& -->
<h3 class="fn" translate="no" id="QVarLengthArray-4"><code class="details extra" translate="no">[noexcept(...), since 6.0]</code> QVarLengthArray::<span class="name">QVarLengthArray</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs this variable-length array from <i translate="no">other</i>. After the move, <i translate="no">other</i> is empty.</p>
<p>This function was introduced in Qt 6.0.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;std::is_nothrow_move_constructible_v&lt;T&gt;&quot; is true.</p>
</div>
<!-- @@@QVarLengthArray -->
<!-- $$$~QVarLengthArray[overload1]$$$~QVarLengthArray -->
<h3 class="fn" translate="no" id="dtor.QVarLengthArray">QVarLengthArray::<span class="name">~QVarLengthArray</span>()</h3>
<p>Destroys the array.</p>
<!-- @@@~QVarLengthArray -->
<!-- $$$append[overload1]$$$appendconstT& -->
<h3 class="fn" translate="no" id="append"><span class="type">void</span> QVarLengthArray::<span class="name">append</span>(const <span class="type">T</span> &amp;<i>t</i>)</h3>
<p>Appends item <i translate="no">t</i> to the array, extending the array if necessary.</p>
<p><b>See also </b><a href="qvarlengtharray.html#removeLast" translate="no">removeLast</a>().</p>
<!-- @@@append -->
<!-- $$$append$$$appendT&& -->
<h3 class="fn" translate="no" id="append-1"><span class="type">void</span> QVarLengthArray::<span class="name">append</span>(<span class="type">T</span> &amp;&amp;<i>t</i>)</h3>
<p>This function overloads append.</p>
<div class="admonition note">
<p><b>Note: </b>Unlike the lvalue overload of append(), passing a reference to an object that is already an element of <code translate="no">*this</code> leads to undefined behavior:</p>
</div>
<pre class="cpp" translate="no">
 vla<span class="operator">.</span>append(std<span class="operator">::</span>move(vla<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>)); <span class="comment">// BUG: passing an object that is already in the container</span>
</pre>
<!-- @@@append -->
<!-- $$$append$$$appendconstT*qsizetype -->
<h3 class="fn" translate="no" id="append-2"><span class="type">void</span> QVarLengthArray::<span class="name">append</span>(const <span class="type">T</span> *<i>buf</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Appends <i translate="no">size</i> amount of items referenced by <i translate="no">buf</i> to this array.</p>
<!-- @@@append -->
<!-- $$$assign[overload1]$$$assignqsizetypeconstT& -->
<h3 class="fn" translate="no" id="assign"><code class="details extra" translate="no">[since 6.6]</code> <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;QVarLengthArray::<span class="name">assign</span>(<span class="type">qsizetype</span> <i>n</i>, const <span class="type">T</span> &amp;<i>t</i>)</h3>
<p>Replaces the contents of this container with <i translate="no">n</i> copies of <i translate="no">t</i>.</p>
<p>The size of this container will be equal to <i translate="no">n</i>. This function will only allocate memory if <i translate="no">n</i> exceeds the capacity of the container.</p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@assign -->
<!-- $$$assign$$$assignstd::initializer_list<T> -->
<h3 class="fn" translate="no" id="assign-2"><code class="details extra" translate="no">[since 6.6]</code> <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;QVarLengthArray::<span class="name">assign</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">T</span>&gt; <i>list</i>)</h3>
<p>Replaces the contents of this container with a copy of the elements of <i translate="no">list</i>.</p>
<p>The size of this container will be equal to the number of elements in <i translate="no">list</i>.</p>
<p>This function only allocates memory if the number of elements in <i translate="no">list</i> exceeds the capacity of the container.</p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@assign -->
<!-- $$$at[overload1]$$$atqsizetype -->
<h3 class="fn" translate="no" id="at">const <span class="type">T</span> &amp;QVarLengthArray::<span class="name">at</span>(<span class="type">qsizetype</span> <i>i</i>) const</h3>
<p>Returns a reference to the item at index position <i translate="no">i</i>.</p>
<p><i translate="no">i</i> must be a valid index position in the array (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="qvarlengtharray.html#size" translate="no">size</a>()).</p>
<p><b>See also </b><a href="qvarlengtharray.html#value" translate="no">value</a>() and <a href="qvarlengtharray.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" translate="no" id="back"><span class="type">T</span> &amp;QVarLengthArray::<span class="name">back</span>()</h3>
<p>Same as <a href="qvarlengtharray.html#last" translate="no">last</a>(). Provided for STL-compatibility.</p>
<!-- @@@back -->
<!-- $$$back$$$back -->
<h3 class="fn" translate="no" id="back-1">const <span class="type">T</span> &amp;QVarLengthArray::<span class="name">back</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" translate="no" id="begin"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::iterator</span> QVarLengthArray::<span class="name">begin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the array.</p>
<p><b>See also </b><a href="qvarlengtharray.html#constBegin" translate="no">constBegin</a>() and <a href="qvarlengtharray.html#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" translate="no" id="begin-1"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> QVarLengthArray::<span class="name">begin</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" translate="no" id="capacity"><span class="type">qsizetype</span> QVarLengthArray::<span class="name">capacity</span>() const</h3>
<p>Returns the maximum number of elements that can be stored in the array without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qvarlengtharray.html" translate="no">QVarLengthArray</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the array, call <a href="qvarlengtharray.html#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="qvarlengtharray.html#reserve" translate="no">reserve</a>() and <a href="qvarlengtharray.html#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" translate="no" id="cbegin"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> QVarLengthArray::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the array.</p>
<p><b>See also </b><a href="qvarlengtharray.html#begin" translate="no">begin</a>() and <a href="qvarlengtharray.html#cend" translate="no">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" translate="no" id="cend"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> QVarLengthArray::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the array.</p>
<p><b>See also </b><a href="qvarlengtharray.html#cbegin" translate="no">cbegin</a>() and <a href="qvarlengtharray.html#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QVarLengthArray::<span class="name">clear</span>()</h3>
<p>Removes all the elements from the array.</p>
<p>Same as resize(0).</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" translate="no" id="constBegin"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> QVarLengthArray::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the array.</p>
<p><b>See also </b><a href="qvarlengtharray.html#begin" translate="no">begin</a>() and <a href="qvarlengtharray.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constData[overload1]$$$constData -->
<h3 class="fn" translate="no" id="constData">const <span class="type">T</span> *QVarLengthArray::<span class="name">constData</span>() const</h3>
<p>Returns a const pointer to the data stored in the array. The pointer can be used to access the items in the array. The pointer remains valid as long as the array isn't reallocated.</p>
<p>This function is mostly useful to pass an array to a function that accepts a plain C++ array.</p>
<p><b>See also </b><a href="qvarlengtharray.html#data" translate="no">data</a>() and <a href="qvarlengtharray.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@constData -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" translate="no" id="constEnd"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> QVarLengthArray::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the array.</p>
<p><b>See also </b><a href="qvarlengtharray.html#constBegin" translate="no">constBegin</a>() and <a href="qvarlengtharray.html#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$contains[overload1]$$$containsconstAT& -->
<h3 class="fn" translate="no" id="contains">template &lt;typename AT = T&gt; <span class="type">bool</span> QVarLengthArray::<span class="name">contains</span>(const <span class="type">AT</span> &amp;<i>value</i>) const</h3>
<p>Returns <code translate="no">true</code> if the array contains an occurrence of <i translate="no">value</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qvarlengtharray.html#indexOf" translate="no">indexOf</a>() and <a href="qvarlengtharray.html#lastIndexOf" translate="no">lastIndexOf</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$count -->
<h3 class="fn" translate="no" id="count"><span class="type">qsizetype</span> QVarLengthArray::<span class="name">count</span>() const</h3>
<p>Same as <a href="qvarlengtharray.html#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="qvarlengtharray.html#isEmpty" translate="no">isEmpty</a>() and <a href="qvarlengtharray.html#resize" translate="no">resize</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" translate="no" id="crbegin"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_reverse_iterator</span> QVarLengthArray::<span class="name">crbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first item in the variable length array, in reverse order.</p>
<p><b>See also </b><a href="qvarlengtharray.html#begin" translate="no">begin</a>(), <a href="qvarlengtharray.html#rbegin" translate="no">rbegin</a>(), and <a href="qvarlengtharray.html#rend" translate="no">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" translate="no" id="crend"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_reverse_iterator</span> QVarLengthArray::<span class="name">crend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to one past the last item in the variable length array, in reverse order.</p>
<p><b>See also </b><a href="qvarlengtharray.html#end" translate="no">end</a>(), <a href="qvarlengtharray.html#rend" translate="no">rend</a>(), and <a href="qvarlengtharray.html#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" translate="no" id="data"><span class="type">T</span> *QVarLengthArray::<span class="name">data</span>()</h3>
<p>Returns a pointer to the data stored in the array. The pointer can be used to access and modify the items in the array.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> array(<span class="number">10</span>);
 <span class="type">int</span> <span class="operator">*</span>data <span class="operator">=</span> array<span class="operator">.</span>data();
 <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">10</span>; <span class="operator">+</span><span class="operator">+</span>i)
     data<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> i;
</pre>
<p>The pointer remains valid as long as the array isn't reallocated.</p>
<p>This function is mostly useful to pass an array to a function that accepts a plain C++ array.</p>
<p><b>See also </b><a href="qvarlengtharray.html#constData" translate="no">constData</a>() and <a href="qvarlengtharray.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$data -->
<h3 class="fn" translate="no" id="data-1">const <span class="type">T</span> *QVarLengthArray::<span class="name">data</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@data -->
<!-- $$$emplace[overload1]$$$emplaceQVarLengthArray<T,Prealloc>::const_iteratorArgs&&... -->
<h3 class="fn" translate="no" id="emplace"><code class="details extra" translate="no">[since 6.3]</code> template &lt;typename... Args&gt; <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::iterator</span> QVarLengthArray::<span class="name">emplace</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> <i>pos</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>Inserts an item in front of the item pointed to by the iterator <i translate="no">pos</i>, passing <i translate="no">args</i> to its constructor.</p>
<p>Returns an iterator pointing at the emplaced item.</p>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@emplace -->
<!-- $$$emplace_back[overload1]$$$emplace_backArgs&&... -->
<h3 class="fn" translate="no" id="emplace_back"><code class="details extra" translate="no">[since 6.3]</code> template &lt;typename... Args&gt; <span class="type">T</span> &amp;QVarLengthArray::<span class="name">emplace_back</span>(<span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>Inserts an item at the back of this <a href="qvarlengtharray.html" translate="no">QVarLengthArray</a>, passing <i translate="no">args</i> to its constructor.</p>
<p>Returns a reference to the emplaced item.</p>
<p>This function was introduced in Qt 6.3.</p>
<!-- @@@emplace_back -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" translate="no" id="empty"><span class="type">bool</span> QVarLengthArray::<span class="name">empty</span>() const</h3>
<p>Returns <code translate="no">true</code> if the array has size 0; otherwise returns <code translate="no">false</code>.</p>
<p>Same as <a href="qvarlengtharray.html#isEmpty" translate="no">isEmpty</a>(). Provided for STL-compatibility.</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::iterator</span> QVarLengthArray::<span class="name">end</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the array.</p>
<p><b>See also </b><a href="qvarlengtharray.html#begin" translate="no">begin</a>() and <a href="qvarlengtharray.html#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" translate="no" id="end-1"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> QVarLengthArray::<span class="name">end</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@end -->
<!-- $$$erase[overload1]$$$eraseQVarLengthArray<T,Prealloc>::const_iterator -->
<h3 class="fn" translate="no" id="erase"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::iterator</span> QVarLengthArray::<span class="name">erase</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> <i>pos</i>)</h3>
<p>Removes the item pointed to by the iterator <i translate="no">pos</i> from the vector, and returns an iterator to the next item in the vector (which may be <a href="qvarlengtharray.html#end" translate="no">end</a>()).</p>
<p><b>See also </b><a href="qvarlengtharray.html#insert" translate="no">insert</a>() and <a href="qvarlengtharray.html#remove" translate="no">remove</a>().</p>
<!-- @@@erase -->
<!-- $$$erase$$$eraseQVarLengthArray<T,Prealloc>::const_iteratorQVarLengthArray<T,Prealloc>::const_iterator -->
<h3 class="fn" translate="no" id="erase-1"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::iterator</span> QVarLengthArray::<span class="name">erase</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> <i>begin</i>, <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> <i>end</i>)</h3>
<p>This is an overloaded function.</p>
<p>Removes all the items from <i translate="no">begin</i> up to (but not including) <i translate="no">end</i>. Returns an iterator to the same item that <i translate="no">end</i> referred to before the call.</p>
<!-- @@@erase -->
<!-- $$$first[overload1]$$$first -->
<h3 class="fn" translate="no" id="first"><span class="type">T</span> &amp;QVarLengthArray::<span class="name">first</span>()</h3>
<p>Returns a reference to the first item in the array. The array must not be empty. If the array can be empty, check <a href="qvarlengtharray.html#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p><b>See also </b><a href="qvarlengtharray.html#last" translate="no">last</a>() and <a href="qvarlengtharray.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@first -->
<!-- $$$first$$$first -->
<h3 class="fn" translate="no" id="first-1">const <span class="type">T</span> &amp;QVarLengthArray::<span class="name">first</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@first -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" translate="no" id="front"><span class="type">T</span> &amp;QVarLengthArray::<span class="name">front</span>()</h3>
<p>Same as <a href="qvarlengtharray.html#first" translate="no">first</a>(). Provided for STL-compatibility.</p>
<!-- @@@front -->
<!-- $$$front$$$front -->
<h3 class="fn" translate="no" id="front-1">const <span class="type">T</span> &amp;QVarLengthArray::<span class="name">front</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@front -->
<!-- $$$indexOf[overload1]$$$indexOfconstAT&qsizetype -->
<h3 class="fn" translate="no" id="indexOf">template &lt;typename AT = T&gt; <span class="type">qsizetype</span> QVarLengthArray::<span class="name">indexOf</span>(const <span class="type">AT</span> &amp;<i>value</i>, <span class="type">qsizetype</span> <i>from</i> = 0) const</h3>
<p>Returns the index position of the first occurrence of <i translate="no">value</i> in the array, searching forward from index position <i translate="no">from</i>. Returns -1 if no item matched.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qvarlengtharray.html#lastIndexOf" translate="no">lastIndexOf</a>() and <a href="qvarlengtharray.html#contains" translate="no">contains</a>().</p>
<!-- @@@indexOf -->
<!-- $$$insert$$$insertqsizetypeqsizetypeconstT& -->
<h3 class="fn" translate="no" id="insert-2"><span class="type">void</span> QVarLengthArray::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">qsizetype</span> <i>count</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts <i translate="no">count</i> copies of <i translate="no">value</i> at index position <i translate="no">i</i> in the vector.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertQVarLengthArray<T,Prealloc>::const_iteratorqsizetypeconstT& -->
<h3 class="fn" translate="no" id="insert-3"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::iterator</span> QVarLengthArray::<span class="name">insert</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_iterator</span> <i>before</i>, <span class="type">qsizetype</span> <i>count</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts <i translate="no">count</i> copies of <i translate="no">value</i> in front of the item pointed to by the iterator <i translate="no">before</i>. Returns an iterator pointing at the first of the inserted items.</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" translate="no" id="isEmpty"><span class="type">bool</span> QVarLengthArray::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code translate="no">true</code> if the array has size 0; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qvarlengtharray.html#size" translate="no">size</a>() and <a href="qvarlengtharray.html#resize" translate="no">resize</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$last[overload1]$$$last -->
<h3 class="fn" translate="no" id="last"><span class="type">T</span> &amp;QVarLengthArray::<span class="name">last</span>()</h3>
<p>Returns a reference to the last item in the array. The array must not be empty. If the array can be empty, check <a href="qvarlengtharray.html#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p><b>See also </b><a href="qvarlengtharray.html#first" translate="no">first</a>() and <a href="qvarlengtharray.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@last -->
<!-- $$$last$$$last -->
<h3 class="fn" translate="no" id="last-1">const <span class="type">T</span> &amp;QVarLengthArray::<span class="name">last</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@last -->
<!-- $$$lastIndexOf[overload1]$$$lastIndexOfconstAT&qsizetype -->
<h3 class="fn" translate="no" id="lastIndexOf">template &lt;typename AT = T&gt; <span class="type">qsizetype</span> QVarLengthArray::<span class="name">lastIndexOf</span>(const <span class="type">AT</span> &amp;<i>value</i>, <span class="type">qsizetype</span> <i>from</i> = -1) const</h3>
<p>Returns the index position of the last occurrence of the value <i translate="no">value</i> in the array, searching backward from index position <i translate="no">from</i>. If <i translate="no">from</i> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qvarlengtharray.html#indexOf" translate="no">indexOf</a>() and <a href="qvarlengtharray.html#contains" translate="no">contains</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" translate="no" id="length"><span class="type">qsizetype</span> QVarLengthArray::<span class="name">length</span>() const</h3>
<p>Same as <a href="qvarlengtharray.html#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="qvarlengtharray.html#isEmpty" translate="no">isEmpty</a>() and <a href="qvarlengtharray.html#resize" translate="no">resize</a>().</p>
<!-- @@@length -->
<!-- $$$pop_back[overload1]$$$pop_back -->
<h3 class="fn" translate="no" id="pop_back"><span class="type">void</span> QVarLengthArray::<span class="name">pop_back</span>()</h3>
<p>Same as <a href="qvarlengtharray.html#removeLast" translate="no">removeLast</a>(). Provided for STL-compatibility.</p>
<!-- @@@pop_back -->
<!-- $$$push_back[overload1]$$$push_backconstT& -->
<h3 class="fn" translate="no" id="push_back"><span class="type">void</span> QVarLengthArray::<span class="name">push_back</span>(const <span class="type">T</span> &amp;<i>t</i>)</h3>
<p>Appends item <i translate="no">t</i> to the array, extending the array if necessary. Provided for STL-compatibility.</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backT&& -->
<h3 class="fn" translate="no" id="push_back-1"><span class="type">void</span> QVarLengthArray::<span class="name">push_back</span>(<span class="type">T</span> &amp;&amp;<i>t</i>)</h3>
<p>This function overloads push_back.</p>
<div class="admonition note">
<p><b>Note: </b>Unlike the lvalue overload of push_back(), passing a reference to an object that is already an element of <code translate="no">*this</code> leads to undefined behavior:</p>
</div>
<pre class="cpp" translate="no">
 vla<span class="operator">.</span>push_back(std<span class="operator">::</span>move(vla<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>)); <span class="comment">// BUG: passing an object that is already in the container</span>
</pre>
<!-- @@@push_back -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" translate="no" id="rbegin"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::reverse_iterator</span> QVarLengthArray::<span class="name">rbegin</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first item in the variable length array, in reverse order.</p>
<p><b>See also </b><a href="qvarlengtharray.html#begin" translate="no">begin</a>(), <a href="qvarlengtharray.html#crbegin" translate="no">crbegin</a>(), and <a href="qvarlengtharray.html#rend" translate="no">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" translate="no" id="rbegin-1"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_reverse_iterator</span> QVarLengthArray::<span class="name">rbegin</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@rbegin -->
<!-- $$$remove[overload1]$$$removeqsizetypeqsizetype -->
<h3 class="fn" translate="no" id="remove"><span class="type">void</span> QVarLengthArray::<span class="name">remove</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">qsizetype</span> <i>count</i> = 1)</h3>
<p>This is an overloaded function.</p>
<p>Removes <i translate="no">count</i> elements from the middle of the array, starting at index position <i translate="no">i</i>.</p>
<p><b>See also </b><a href="qvarlengtharray.html#insert" translate="no">insert</a>() and <a href="qvarlengtharray.html#replace" translate="no">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$removeAll[overload1]$$$removeAllconstAT& -->
<h3 class="fn" translate="no" id="removeAll"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename AT = T&gt; <span class="type">qsizetype</span> QVarLengthArray::<span class="name">removeAll</span>(const <span class="type">AT</span> &amp;<i>t</i>)</h3>
<p>Removes all elements that compare equal to <i translate="no">t</i> from the array. Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qvarlengtharray.html#removeOne" translate="no">removeOne</a>().</p>
<!-- @@@removeAll -->
<!-- $$$removeIf[overload1]$$$removeIfPredicate -->
<h3 class="fn" translate="no" id="removeIf"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename Predicate&gt; <span class="type">qsizetype</span> QVarLengthArray::<span class="name">removeIf</span>(<span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i translate="no">pred</i> returns true from the array. Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qvarlengtharray.html#removeAll" translate="no">removeAll</a>().</p>
<!-- @@@removeIf -->
<!-- $$$removeLast[overload1]$$$removeLast -->
<h3 class="fn" translate="no" id="removeLast"><span class="type">void</span> QVarLengthArray::<span class="name">removeLast</span>()</h3>
<p>Decreases the size of the array by one. The allocated size is not changed.</p>
<p><b>See also </b><a href="qvarlengtharray.html#append" translate="no">append</a>().</p>
<!-- @@@removeLast -->
<!-- $$$removeOne[overload1]$$$removeOneconstAT& -->
<h3 class="fn" translate="no" id="removeOne"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename AT = T&gt; <span class="type">bool</span> QVarLengthArray::<span class="name">removeOne</span>(const <span class="type">AT</span> &amp;<i>t</i>)</h3>
<p>Removes the first element that compares equal to <i translate="no">t</i> from the array. Returns whether an element was, in fact, removed.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qvarlengtharray.html#removeAll" translate="no">removeAll</a>().</p>
<!-- @@@removeOne -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" translate="no" id="rend"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::reverse_iterator</span> QVarLengthArray::<span class="name">rend</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to one past the last item in the variable length array, in reverse order.</p>
<p><b>See also </b><a href="qvarlengtharray.html#end" translate="no">end</a>(), <a href="qvarlengtharray.html#crend" translate="no">crend</a>(), and <a href="qvarlengtharray.html#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" translate="no" id="rend-1"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt;<span class="type">::const_reverse_iterator</span> QVarLengthArray::<span class="name">rend</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@rend -->
<!-- $$$replace[overload1]$$$replaceqsizetypeconstT& -->
<h3 class="fn" translate="no" id="replace"><span class="type">void</span> QVarLengthArray::<span class="name">replace</span>(<span class="type">qsizetype</span> <i>i</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Replaces the item at index position <i translate="no">i</i> with <i translate="no">value</i>.</p>
<p><i translate="no">i</i> must be a valid index position in the array (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="qvarlengtharray.html#size" translate="no">size</a>()).</p>
<p><b>See also </b><a href="qvarlengtharray.html#operator-5b-5d" translate="no">operator[]</a>() and <a href="qvarlengtharray.html#remove" translate="no">remove</a>().</p>
<!-- @@@replace -->
<!-- $$$reserve[overload1]$$$reserveqsizetype -->
<h3 class="fn" translate="no" id="reserve"><span class="type">void</span> QVarLengthArray::<span class="name">reserve</span>(<span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Attempts to allocate memory for at least <i translate="no">size</i> elements. If you know in advance how large the array can get, you can call this function and if you call <a href="qvarlengtharray.html#resize" translate="no">resize</a>() often, you are likely to get better performance. If <i translate="no">size</i> is an underestimate, the worst that will happen is that the <a href="qvarlengtharray.html" translate="no">QVarLengthArray</a> will be a bit slower.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qvarlengtharray.html" translate="no">QVarLengthArray</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the array, call <a href="qvarlengtharray.html#resize" translate="no">resize</a>().</p>
<p><b>See also </b><a href="qvarlengtharray.html#capacity" translate="no">capacity</a>() and <a href="qvarlengtharray.html#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@reserve -->
<!-- $$$resize[overload1]$$$resizeqsizetype -->
<h3 class="fn" translate="no" id="resize"><span class="type">void</span> QVarLengthArray::<span class="name">resize</span>(<span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Sets the size of the array to <i translate="no">size</i>. If <i translate="no">size</i> is greater than the current size, elements are added to the end. If <i translate="no">size</i> is less than the current size, elements are removed from the end.</p>
<p>If the value type is a primitive type (e.g., char, int, float) or a pointer type (e.g., <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a> *), new elements are not initialized. For other types, the elements are initialized with a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a>.</p>
<p><b>See also </b><a href="qvarlengtharray.html#size" translate="no">size</a>() and <a href="qvarlengtharray.html#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@resize -->
<!-- $$$resize$$$resizeqsizetypeconstT& -->
<h3 class="fn" translate="no" id="resize-1"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">void</span> QVarLengthArray::<span class="name">resize</span>(<span class="type">qsizetype</span> <i>size</i>, const <span class="type">T</span> &amp;<i>v</i>)</h3>
<p>Sets the size of the array to <i translate="no">size</i>. If <i translate="no">size</i> is greater than the current size, copies of <i translate="no">v</i> are added to the end. If <i translate="no">size</i> is less than the current size, elements are removed from the end.</p>
<div class="admonition note">
<p><b>Note: </b>This function is only available when <code translate="no">T</code> is copy-constructible.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qvarlengtharray.html#size" translate="no">size</a>() and <a href="qvarlengtharray.html#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@resize -->
<!-- $$$shrink_to_fit[overload1]$$$shrink_to_fit -->
<h3 class="fn" translate="no" id="shrink_to_fit"><span class="type">void</span> QVarLengthArray::<span class="name">shrink_to_fit</span>()</h3>
<p>Same as <a href="qvarlengtharray.html#squeeze" translate="no">squeeze</a>(). Provided for STL-compatibility.</p>
<!-- @@@shrink_to_fit -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><span class="type">qsizetype</span> QVarLengthArray::<span class="name">size</span>() const</h3>
<p>Returns the number of elements in the array.</p>
<p><b>See also </b><a href="qvarlengtharray.html#isEmpty" translate="no">isEmpty</a>() and <a href="qvarlengtharray.html#resize" translate="no">resize</a>().</p>
<!-- @@@size -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" translate="no" id="squeeze"><span class="type">void</span> QVarLengthArray::<span class="name">squeeze</span>()</h3>
<p>Releases any memory not required to store the items. If the container can fit its storage on the stack allocation, it will free the heap allocation and copy the elements back to the stack.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qvarlengtharray.html" translate="no">QVarLengthArray</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b>See also </b><a href="qvarlengtharray.html#reserve" translate="no">reserve</a>(), <a href="qvarlengtharray.html#capacity" translate="no">capacity</a>(), and <a href="qvarlengtharray.html#resize" translate="no">resize</a>().</p>
<!-- @@@squeeze -->
<!-- $$$value[overload1]$$$valueqsizetype -->
<h3 class="fn" translate="no" id="value"><span class="type">T</span> QVarLengthArray::<span class="name">value</span>(<span class="type">qsizetype</span> <i>i</i>) const</h3>
<p>Returns the value at index position <i translate="no">i</i>.</p>
<p>If the index <i translate="no">i</i> is out of bounds, the function returns a <a href="containers.html#default-constructed-value" translate="no">default-constructed value</a>. If you are certain that <i translate="no">i</i> is within bounds, you can use <a href="qvarlengtharray.html#at" translate="no">at</a>() instead, which is slightly faster.</p>
<p><b>See also </b><a href="qvarlengtharray.html#at" translate="no">at</a>() and <a href="qvarlengtharray.html#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@value -->
<!-- $$$value$$$valueqsizetypeconstT& -->
<h3 class="fn" translate="no" id="value-1"><span class="type">T</span> QVarLengthArray::<span class="name">value</span>(<span class="type">qsizetype</span> <i>i</i>, const <span class="type">T</span> &amp;<i>defaultValue</i>) const</h3>
<p>This is an overloaded function.</p>
<p>If the index <i translate="no">i</i> is out of bounds, the function returns <i translate="no">defaultValue</i>.</p>
<!-- @@@value -->
<!-- $$$operator+=[overload1]$$$operator+=constT& -->
<h3 class="fn" translate="no" id="operator-2b-eq"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;QVarLengthArray::<span class="name">operator+=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Appends <i translate="no">value</i> to the array and returns a reference to this vector.</p>
<p><b>See also </b><a href="qvarlengtharray.html#append" translate="no">append</a>() and <a href="qvarlengtharray.html#operator-lt-lt" translate="no">operator&lt;&lt;</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=T&& -->
<h3 class="fn" translate="no" id="operator-2b-eq-1"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;QVarLengthArray::<span class="name">operator+=</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qvarlengtharray.html#append" translate="no">append</a>() and <a href="qvarlengtharray.html#operator-lt-lt" translate="no">operator&lt;&lt;</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator<<[overload1]$$$operator<<constT& -->
<h3 class="fn" translate="no" id="operator-lt-lt"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;QVarLengthArray::<span class="name">operator&lt;&lt;</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Appends <i translate="no">value</i> to the array and returns a reference to this vector.</p>
<p><b>See also </b><a href="qvarlengtharray.html#append" translate="no">append</a>() and <a href="qvarlengtharray.html#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@operator<< -->
<!-- $$$operator<<$$$operator<<T&& -->
<h3 class="fn" translate="no" id="operator-lt-lt-1"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;QVarLengthArray::<span class="name">operator&lt;&lt;</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qvarlengtharray.html#append" translate="no">append</a>() and <a href="qvarlengtharray.html#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@operator<< -->
<!-- $$$operator=[overload1]$$$operator=constQVarLengthArray<T,Prealloc>& -->
<h3 class="fn" translate="no" id="operator-eq"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;QVarLengthArray::<span class="name">operator=</span>(const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;<i>other</i>)</h3>
<p>Assigns <i translate="no">other</i> to this array and returns a reference to this array.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QVarLengthArray<T,Prealloc>&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[noexcept(...), since 6.0]</code> <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;QVarLengthArray::<span class="name">operator=</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this array and returns a reference to this array. After the move, <i translate="no">other</i> is empty.</p>
<p>This function was introduced in Qt 6.0.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;std::is_nothrow_move_constructible_v&lt;T&gt;&quot; is true.</p>
</div>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=std::initializer_list<T> -->
<h3 class="fn" translate="no" id="operator-eq-2"><span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;QVarLengthArray::<span class="name">operator=</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">T</span>&gt; <i>list</i>)</h3>
<p>Assigns the values of <i translate="no">list</i> to this array, and returns a reference to this array.</p>
<!-- @@@operator= -->
<!-- $$$operator[][overload1]$$$operator[]qsizetype -->
<h3 class="fn" translate="no" id="operator-5b-5d"><span class="type">T</span> &amp;QVarLengthArray::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>i</i>)</h3>
<p>Returns a reference to the item at index position <i translate="no">i</i>.</p>
<p><i translate="no">i</i> must be a valid index position in the array (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="qvarlengtharray.html#size" translate="no">size</a>()).</p>
<p><b>See also </b><a href="qvarlengtharray.html#data" translate="no">data</a>() and <a href="qvarlengtharray.html#at" translate="no">at</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]qsizetype -->
<h3 class="fn" translate="no" id="operator-5b-5d-1">const <span class="type">T</span> &amp;QVarLengthArray::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>i</i>) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$erase$$$eraseQVarLengthArray<T,Prealloc>&constAT& -->
<h3 class="fn" translate="no" id="erase-2"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename T, qsizetype Prealloc, typename AT&gt; <span class="type">qsizetype</span> <span class="name">erase</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;<i>array</i>, const <span class="type">AT</span> &amp;<i>t</i>)</h3>
<p>Removes all elements that compare equal to <i translate="no">t</i> from the array <i translate="no">array</i>. Returns the number of elements removed, if any.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">t</i> is not allowed to be a reference to an element inside <i translate="no">array</i>. If you cannot be sure that this is not the case, take a copy of <i translate="no">t</i> and call this function with the copy.</p>
</div>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qvarlengtharray.html#erase_if" translate="no">erase_if</a>().</p>
<!-- @@@erase -->
<!-- $$$erase_if[overload1]$$$erase_ifQVarLengthArray<T,Prealloc>&Predicate -->
<h3 class="fn" translate="no" id="erase_if"><code class="details extra" translate="no">[since 6.1]</code> template &lt;typename T, qsizetype Prealloc, typename Predicate&gt; <span class="type">qsizetype</span> <span class="name">erase_if</span>(<span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;<i>array</i>, <span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i translate="no">pred</i> returns true from the list <i translate="no">array</i>. Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qvarlengtharray.html#erase" translate="no">erase</a>().</p>
<!-- @@@erase_if -->
<!-- $$$qHash$$$qHashconstQVarLengthArray<T,Prealloc>&size_t -->
<h3 class="fn" translate="no" id="qHash-41"><code class="details extra" translate="no">[noexcept(...)]</code> template &lt;typename T, qsizetype Prealloc&gt; <span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc</span>&gt; &amp;<i>key</i>, <span class="type">size_t</span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for <i translate="no">key</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;QtPrivate::QNothrowHashable_v&lt;T&gt;&quot; is true.</p>
</div>
<!-- @@@qHash -->
<!-- $$$operator!=$$$operator!=constQVarLengthArray<T,Prealloc1>&constQVarLengthArray<T,Prealloc2>& -->
<h3 class="fn" translate="no" id="operator-not-eq-11">template &lt;typename T, qsizetype Prealloc1, qsizetype Prealloc2&gt; <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc1</span>&gt; &amp;<i>left</i>, const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc2</span>&gt; &amp;<i>right</i>)</h3>
<p>Returns <code translate="no">true</code> if the two arrays, specified by <i translate="no">left</i> and <i translate="no">right</i>, are <i>not</i> equal.</p>
<p>Two arrays are considered equal if they contain the same values in the same order.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qvarlengtharray.html#operator-eq-eq-12" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator<$$$operator<constQVarLengthArray<T,Prealloc1>&constQVarLengthArray<T,Prealloc2>& -->
<h3 class="fn" translate="no" id="operator-lt-1">template &lt;typename T, qsizetype Prealloc1, qsizetype Prealloc2&gt; <span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc1</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc2</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if variable length array <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically less than</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<!-- @@@operator< -->
<!-- $$$operator<=$$$operator<=constQVarLengthArray<T,Prealloc1>&constQVarLengthArray<T,Prealloc2>& -->
<h3 class="fn" translate="no" id="operator-lt-eq-1">template &lt;typename T, qsizetype Prealloc1, qsizetype Prealloc2&gt; <span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc1</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc2</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if variable length array <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically less than or equal to</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<!-- @@@operator<= -->
<!-- $$$operator==$$$operator==constQVarLengthArray<T,Prealloc1>&constQVarLengthArray<T,Prealloc2>& -->
<h3 class="fn" translate="no" id="operator-eq-eq-12">template &lt;typename T, qsizetype Prealloc1, qsizetype Prealloc2&gt; <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc1</span>&gt; &amp;<i>left</i>, const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc2</span>&gt; &amp;<i>right</i>)</h3>
<p>Returns <code translate="no">true</code> if the two arrays, specified by <i translate="no">left</i> and <i translate="no">right</i>, are equal.</p>
<p>Two arrays are considered equal if they contain the same values in the same order.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="qvarlengtharray.html#operator-not-eq-11" translate="no">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator>$$$operator>constQVarLengthArray<T,Prealloc1>&constQVarLengthArray<T,Prealloc2>& -->
<h3 class="fn" translate="no" id="operator-gt-1">template &lt;typename T, qsizetype Prealloc1, qsizetype Prealloc2&gt; <span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc1</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc2</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if variable length array <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically greater than</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<!-- @@@operator> -->
<!-- $$$operator>=$$$operator>=constQVarLengthArray<T,Prealloc1>&constQVarLengthArray<T,Prealloc2>& -->
<h3 class="fn" translate="no" id="operator-gt-eq-1">template &lt;typename T, qsizetype Prealloc1, qsizetype Prealloc2&gt; <span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc1</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qvarlengtharray.html#QVarLengthArray" translate="no">QVarLengthArray</a></span>&lt;<span class="type">T</span>, <span class="type">Prealloc2</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code translate="no">true</code> if variable length array <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically greater than or equal to</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<!-- @@@operator>= -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
