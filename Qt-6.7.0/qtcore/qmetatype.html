<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qmetatype.cpp -->
  <meta name="description" content="The QMetaType class manages named types in the meta-object system.">
  <title>QMetaType Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QMetaType</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QMetaType Class</h1>
<!-- $$$QMetaType-brief -->
<p>The QMetaType class manages named types in the meta-object system. <a href="#details">More...</a></p>
<!-- @@@QMetaType -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QMetaType&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
</table></div>
<ul>
<li><a href="qmetatype-members.html">List of all members, including inherited members</a></li>
<li><a href="qmetatype-obsolete.html">Deprecated members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">thread-safe</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#Type-enum" translate="no">Type</a></b> { Void, Bool, Int, UInt, Double, &hellip;, UnknownType }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#TypeFlag-enum" translate="no">TypeFlag</a></b> { NeedsConstruction, NeedsCopyConstruction, NeedsMoveConstruction, NeedsDestruction, RelocatableType, &hellip;, IsConst }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#TypeFlag-enum" translate="no">TypeFlags</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></b>(int <i>typeId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#QMetaType-2" translate="no">QMetaType</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#alignOf" translate="no">alignOf</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> QPartialOrdering </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#compare" translate="no">compare</a></b>(const void *<i>lhs</i>, const void *<i>rhs</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void *</td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#construct-1" translate="no">construct</a></b>(void *<i>where</i>, const void *<i>copy</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void *</td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#create-1" translate="no">create</a></b>(const void *<i>copy</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#debugStream" translate="no">debugStream</a></b>(QDebug &amp;<i>dbg</i>, const void *<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#destroy-1" translate="no">destroy</a></b>(void *<i>data</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#destruct-1" translate="no">destruct</a></b>(void *<i>data</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#equals" translate="no">equals</a></b>(const void *<i>lhs</i>, const void *<i>rhs</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaType::TypeFlags </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#hasRegisteredDataStreamOperators" translate="no">hasRegisteredDataStreamOperators</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#hasRegisteredDebugStreamOperator" translate="no">hasRegisteredDebugStreamOperator</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#id" translate="no">id</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#isCopyConstructible" translate="no">isCopyConstructible</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#isDefaultConstructible" translate="no">isDefaultConstructible</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#isDestructible" translate="no">isDestructible</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#isEqualityComparable" translate="no">isEqualityComparable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#isMoveConstructible" translate="no">isMoveConstructible</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#isOrdered" translate="no">isOrdered</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#isRegistered-1" translate="no">isRegistered</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#load" translate="no">load</a></b>(QDataStream &amp;<i>stream</i>, void *<i>data</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject *</td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#metaObject" translate="no">metaObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#name" translate="no">name</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#registerType" translate="no">registerType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#save" translate="no">save</a></b>(QDataStream &amp;<i>stream</i>, const void *<i>data</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#sizeOf-1" translate="no">sizeOf</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QMetaType </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#underlyingType" translate="no">underlyingType</a></b>() const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#canConvert" translate="no">canConvert</a></b>(QMetaType <i>fromType</i>, QMetaType <i>toType</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#canView" translate="no">canView</a></b>(QMetaType <i>fromType</i>, QMetaType <i>toType</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#convert" translate="no">convert</a></b>(QMetaType <i>fromType</i>, const void *<i>from</i>, QMetaType <i>toType</i>, void *<i>to</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaType </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#fromName" translate="no">fromName</a></b>(QByteArrayView <i>typeName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaType </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#fromType" translate="no">fromType</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#hasRegisteredConverterFunction" translate="no">hasRegisteredConverterFunction</a></b>(QMetaType <i>fromType</i>, QMetaType <i>toType</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#hasRegisteredConverterFunction-1" translate="no">hasRegisteredConverterFunction</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#hasRegisteredMutableViewFunction" translate="no">hasRegisteredMutableViewFunction</a></b>(QMetaType <i>fromType</i>, QMetaType <i>toType</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#hasRegisteredMutableViewFunction-1" translate="no">hasRegisteredMutableViewFunction</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#isRegistered" translate="no">isRegistered</a></b>(int <i>type</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#registerConverter" translate="no">registerConverter</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#registerConverter-1" translate="no">registerConverter</a></b>(To (From::*)() const <i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#registerConverter-2" translate="no">registerConverter</a></b>(To (From::*)(bool *) const <i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#registerConverter-3" translate="no">registerConverter</a></b>(UnaryFunction <i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#registerMutableView" translate="no">registerMutableView</a></b>(To (From::*)() <i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#registerMutableView-1" translate="no">registerMutableView</a></b>(UnaryFunction <i>function</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#view" translate="no">view</a></b>(QMetaType <i>fromType</i>, void *<i>from</i>, QMetaType <i>toType</i>, void *<i>to</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> size_t </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#qHash-3" translate="no">qHash</a></b>(QMetaType <i>type</i>, size_t <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#qMetaTypeId" translate="no">qMetaTypeId</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> int </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#qRegisterMetaType-3" translate="no">qRegisterMetaType</a></b>(QMetaType <i>meta</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#operator-not-eq" translate="no">operator!=</a></b>(QMetaType <i>a</i>, QMetaType <i>b</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> QDebug </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#operator-lt-lt" translate="no">operator&lt;&lt;</a></b>(QDebug <i>d</i>, QMetaType <i>m</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#operator-eq-eq" translate="no">operator==</a></b>(QMetaType <i>a</i>, QMetaType <i>b</i>)</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE" translate="no">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</a></b>(<i>Container</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a></b>(<i>Type</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#Q_DECLARE_OPAQUE_POINTER" translate="no">Q_DECLARE_OPAQUE_POINTER</a></b>(<i>PointerType</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE" translate="no">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a></b>(<i>Container</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmetatype.html#Q_DECLARE_SMART_POINTER_METATYPE" translate="no">Q_DECLARE_SMART_POINTER_METATYPE</a></b>(<i>SmartPointer</i>)</td></tr>
</table></div>
<!-- $$$QMetaType-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The class is used as a helper to marshall types in <a href="qmetatype.html#Type-enum" translate="no">QVariant</a> and in queued signals and slots connections. It associates a type name to a type so that it can be created and destructed dynamically at run-time.</p>
<p>Type names can be registered with QMetaType by using either <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>() or <a href="qmetatype.html#registerType" translate="no">registerType</a>(). Registration is not required for most operations; it's only required for operations that attempt to resolve a type name in string form back to a QMetaType object or the type's ID. Those include some old-style signal-slot connections using <a href="qobject.html#connect" translate="no">QObject::connect</a>(), reading user-types from <a href="qdatastream.html" translate="no">QDataStream</a> to <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>, or binding to other languages and IPC mechanisms, like QML, D-Bus, JavaScript, etc.</p>
<p>The following code allocates and destructs an instance of <code translate="no">MyClass</code> by its name, which requires that <code translate="no">MyClass</code> have been previously registered:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> type <span class="operator">=</span> <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span><span class="operator">::</span>fromName(<span class="string">&quot;MyClass&quot;</span>);
 <span class="keyword">if</span> (type<span class="operator">.</span>isValid()) {
     <span class="type">void</span> <span class="operator">*</span>myClassPtr <span class="operator">=</span> type<span class="operator">.</span>create();
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     type<span class="operator">.</span>destroy(myClassPtr);
     myClassPtr <span class="operator">=</span> nullptr;
 }
</pre>
<p>If we want the stream operators <code translate="no">operator&lt;&lt;()</code> and <code translate="no">operator&gt;&gt;()</code> to work on <a href="qmetatype.html#Type-enum" translate="no">QVariant</a> objects that store custom types, the custom type must provide <code translate="no">operator&lt;&lt;()</code> and <code translate="no">operator&gt;&gt;()</code> operators.</p>
</div>
<p><b>See also </b><a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>(), <a href="qvariant.html#setValue" translate="no">QVariant::setValue</a>(), <a href="qvariant.html#value" translate="no">QVariant::value</a>(), and <a href="qvariant.html#fromValue" translate="no">QVariant::fromValue</a>().</p>
<!-- @@@QMetaType -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Type$$$UnknownType$$$Bool$$$Int$$$UInt$$$LongLong$$$ULongLong$$$Double$$$Long$$$Short$$$Char$$$ULong$$$UShort$$$UChar$$$Float$$$VoidStar$$$QChar$$$QString$$$QStringList$$$QByteArray$$$QBitArray$$$QDate$$$QTime$$$QDateTime$$$QUrl$$$QLocale$$$QRect$$$QRectF$$$QSize$$$QSizeF$$$QLine$$$QLineF$$$QPoint$$$QPointF$$$QEasingCurve$$$QUuid$$$QVariant$$$QModelIndex$$$QPersistentModelIndex$$$QRegularExpression$$$QJsonValue$$$QJsonObject$$$QJsonArray$$$QJsonDocument$$$QByteArrayList$$$QObjectStar$$$SChar$$$Void$$$Nullptr$$$QVariantMap$$$QVariantList$$$QVariantHash$$$QVariantPair$$$QCborSimpleType$$$QCborValue$$$QCborArray$$$QCborMap$$$Char16$$$Char32$$$Int128$$$UInt128$$$Float128$$$BFloat16$$$Float16$$$QFont$$$QPixmap$$$QBrush$$$QColor$$$QPalette$$$QIcon$$$QImage$$$QPolygon$$$QRegion$$$QBitmap$$$QCursor$$$QKeySequence$$$QPen$$$QTextLength$$$QTextFormat$$$QTransform$$$QMatrix4x4$$$QVector2D$$$QVector3D$$$QVector4D$$$QQuaternion$$$QPolygonF$$$QColorSpace$$$QSizePolicy$$$User -->
<h3 class="fn" translate="no" id="Type-enum">enum QMetaType::<span class="name">Type</span></h3>
<p>These are the built-in types supported by <a href="qmetatype.html" translate="no">QMetaType</a>:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Void</code></td><td class="topAlign tblval"><code translate="no">43</code></td><td class="topAlign"><code translate="no">void</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Bool</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign"><code translate="no">bool</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Int</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign"><code translate="no">int</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::UInt</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign"><code translate="no">unsigned int</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Double</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign"><code translate="no">double</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QChar</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">QChar</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QString</code></td><td class="topAlign tblval"><code translate="no">10</code></td><td class="topAlign">QString</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QByteArray</code></td><td class="topAlign tblval"><code translate="no">12</code></td><td class="topAlign">QByteArray</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Nullptr</code></td><td class="topAlign tblval"><code translate="no">51</code></td><td class="topAlign"><code translate="no">std::nullptr_t</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::VoidStar</code></td><td class="topAlign tblval"><code translate="no">31</code></td><td class="topAlign"><code translate="no">void *</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Long</code></td><td class="topAlign tblval"><code translate="no">32</code></td><td class="topAlign"><code translate="no">long</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::LongLong</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">LongLong</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Short</code></td><td class="topAlign tblval"><code translate="no">33</code></td><td class="topAlign"><code translate="no">short</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Char</code></td><td class="topAlign tblval"><code translate="no">34</code></td><td class="topAlign"><code translate="no">char</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Char16</code></td><td class="topAlign tblval"><code translate="no">56</code></td><td class="topAlign"><code translate="no">char16_t</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Char32</code></td><td class="topAlign tblval"><code translate="no">57</code></td><td class="topAlign"><code translate="no">char32_t</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::ULong</code></td><td class="topAlign tblval"><code translate="no">35</code></td><td class="topAlign"><code translate="no">unsigned long</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::ULongLong</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">ULongLong</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::UShort</code></td><td class="topAlign tblval"><code translate="no">36</code></td><td class="topAlign"><code translate="no">unsigned short</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::SChar</code></td><td class="topAlign tblval"><code translate="no">40</code></td><td class="topAlign"><code translate="no">signed char</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::UChar</code></td><td class="topAlign tblval"><code translate="no">37</code></td><td class="topAlign"><code translate="no">unsigned char</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Float</code></td><td class="topAlign tblval"><code translate="no">38</code></td><td class="topAlign"><code translate="no">float</code></td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::Float16</code></td><td class="topAlign tblval"><code translate="no">63</code></td><td class="topAlign">qfloat16</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QObjectStar</code></td><td class="topAlign tblval"><code translate="no">39</code></td><td class="topAlign"><a href="qobject.html" translate="no">QObject</a> *</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QCursor</code></td><td class="topAlign tblval"><code translate="no">0x100a</code></td><td class="topAlign">QCursor</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QDate</code></td><td class="topAlign tblval"><code translate="no">14</code></td><td class="topAlign">QDate</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QSize</code></td><td class="topAlign tblval"><code translate="no">21</code></td><td class="topAlign">QSize</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QTime</code></td><td class="topAlign tblval"><code translate="no">15</code></td><td class="topAlign">QTime</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QVariantList</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">QVariantList</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QPolygon</code></td><td class="topAlign tblval"><code translate="no">0x1007</code></td><td class="topAlign">QPolygon</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QPolygonF</code></td><td class="topAlign tblval"><code translate="no">0x1016</code></td><td class="topAlign">QPolygonF</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QColor</code></td><td class="topAlign tblval"><code translate="no">0x1003</code></td><td class="topAlign">QColor</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QColorSpace</code></td><td class="topAlign tblval"><code translate="no">0x1017</code></td><td class="topAlign">QColorSpace (introduced in Qt 5.15)</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QSizeF</code></td><td class="topAlign tblval"><code translate="no">22</code></td><td class="topAlign">QSizeF</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QRectF</code></td><td class="topAlign tblval"><code translate="no">20</code></td><td class="topAlign">QRectF</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QLine</code></td><td class="topAlign tblval"><code translate="no">23</code></td><td class="topAlign">QLine</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QTextLength</code></td><td class="topAlign tblval"><code translate="no">0x100d</code></td><td class="topAlign">QTextLength</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QStringList</code></td><td class="topAlign tblval"><code translate="no">11</code></td><td class="topAlign">QStringList</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QVariantMap</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">QVariantMap</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QVariantHash</code></td><td class="topAlign tblval"><code translate="no">28</code></td><td class="topAlign">QVariantHash</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QVariantPair</code></td><td class="topAlign tblval"><code translate="no">58</code></td><td class="topAlign">QVariantPair</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QIcon</code></td><td class="topAlign tblval"><code translate="no">0x1005</code></td><td class="topAlign">QIcon</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QPen</code></td><td class="topAlign tblval"><code translate="no">0x100c</code></td><td class="topAlign">QPen</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QLineF</code></td><td class="topAlign tblval"><code translate="no">24</code></td><td class="topAlign">QLineF</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QTextFormat</code></td><td class="topAlign tblval"><code translate="no">0x100e</code></td><td class="topAlign">QTextFormat</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QRect</code></td><td class="topAlign tblval"><code translate="no">19</code></td><td class="topAlign">QRect</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QPoint</code></td><td class="topAlign tblval"><code translate="no">25</code></td><td class="topAlign">QPoint</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QUrl</code></td><td class="topAlign tblval"><code translate="no">17</code></td><td class="topAlign">QUrl</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QRegularExpression</code></td><td class="topAlign tblval"><code translate="no">44</code></td><td class="topAlign">QRegularExpression</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QDateTime</code></td><td class="topAlign tblval"><code translate="no">16</code></td><td class="topAlign">QDateTime</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QPointF</code></td><td class="topAlign tblval"><code translate="no">26</code></td><td class="topAlign">QPointF</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QPalette</code></td><td class="topAlign tblval"><code translate="no">0x1004</code></td><td class="topAlign">QPalette</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QFont</code></td><td class="topAlign tblval"><code translate="no">0x1000</code></td><td class="topAlign">QFont</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QBrush</code></td><td class="topAlign tblval"><code translate="no">0x1002</code></td><td class="topAlign">QBrush</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QRegion</code></td><td class="topAlign tblval"><code translate="no">0x1008</code></td><td class="topAlign">QRegion</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QBitArray</code></td><td class="topAlign tblval"><code translate="no">13</code></td><td class="topAlign">QBitArray</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QImage</code></td><td class="topAlign tblval"><code translate="no">0x1006</code></td><td class="topAlign">QImage</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QKeySequence</code></td><td class="topAlign tblval"><code translate="no">0x100b</code></td><td class="topAlign">QKeySequence</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QSizePolicy</code></td><td class="topAlign tblval"><code translate="no">0x2000</code></td><td class="topAlign">QSizePolicy</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QPixmap</code></td><td class="topAlign tblval"><code translate="no">0x1001</code></td><td class="topAlign">QPixmap</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QLocale</code></td><td class="topAlign tblval"><code translate="no">18</code></td><td class="topAlign">QLocale</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QBitmap</code></td><td class="topAlign tblval"><code translate="no">0x1009</code></td><td class="topAlign">QBitmap</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QTransform</code></td><td class="topAlign tblval"><code translate="no">0x1010</code></td><td class="topAlign">QTransform</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QMatrix4x4</code></td><td class="topAlign tblval"><code translate="no">0x1011</code></td><td class="topAlign">QMatrix4x4</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QVector2D</code></td><td class="topAlign tblval"><code translate="no">0x1012</code></td><td class="topAlign">QVector2D</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QVector3D</code></td><td class="topAlign tblval"><code translate="no">0x1013</code></td><td class="topAlign">QVector3D</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QVector4D</code></td><td class="topAlign tblval"><code translate="no">0x1014</code></td><td class="topAlign">QVector4D</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QQuaternion</code></td><td class="topAlign tblval"><code translate="no">0x1015</code></td><td class="topAlign">QQuaternion</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QEasingCurve</code></td><td class="topAlign tblval"><code translate="no">29</code></td><td class="topAlign">QEasingCurve</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QJsonValue</code></td><td class="topAlign tblval"><code translate="no">45</code></td><td class="topAlign">QJsonValue</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QJsonObject</code></td><td class="topAlign tblval"><code translate="no">46</code></td><td class="topAlign">QJsonObject</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QJsonArray</code></td><td class="topAlign tblval"><code translate="no">47</code></td><td class="topAlign">QJsonArray</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QJsonDocument</code></td><td class="topAlign tblval"><code translate="no">48</code></td><td class="topAlign">QJsonDocument</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QCborValue</code></td><td class="topAlign tblval"><code translate="no">53</code></td><td class="topAlign">QCborValue</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QCborArray</code></td><td class="topAlign tblval"><code translate="no">54</code></td><td class="topAlign">QCborArray</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QCborMap</code></td><td class="topAlign tblval"><code translate="no">55</code></td><td class="topAlign">QCborMap</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QCborSimpleType</code></td><td class="topAlign tblval"><code translate="no">52</code></td><td class="topAlign">QCborSimpleType</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QModelIndex</code></td><td class="topAlign tblval"><code translate="no">42</code></td><td class="topAlign">QModelIndex</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QPersistentModelIndex</code></td><td class="topAlign tblval"><code translate="no">50</code></td><td class="topAlign">QPersistentModelIndex (introduced in Qt 5.5)</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QUuid</code></td><td class="topAlign tblval"><code translate="no">30</code></td><td class="topAlign">QUuid</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QByteArrayList</code></td><td class="topAlign tblval"><code translate="no">49</code></td><td class="topAlign">QByteArrayList</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::QVariant</code></td><td class="topAlign tblval"><code translate="no">41</code></td><td class="topAlign">QVariant</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::User</code></td><td class="topAlign tblval"><code translate="no">65536</code></td><td class="topAlign">Base value for user types</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::UnknownType</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">This is an invalid type id. It is returned from <a href="qmetatype.html" translate="no">QMetaType</a> for types that are not registered</td></tr>
</table></div>
<p>Additional types can be registered using <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>() or by calling <a href="qmetatype.html#registerType" translate="no">registerType</a>().</p>
<p><b>See also </b><a href="qmetatype-obsolete.html#type" translate="no">type</a>() and <a href="qmetatype-obsolete.html#typeName" translate="no">typeName</a>().</p>
<!-- @@@Type -->
<!-- $$$TypeFlag$$$NeedsConstruction$$$NeedsDestruction$$$RelocatableType$$$MovableType$$$PointerToQObject$$$IsEnumeration$$$SharedPointerToQObject$$$WeakPointerToQObject$$$TrackingPointerToQObject$$$IsUnsignedEnumeration$$$IsGadget$$$PointerToGadget$$$IsPointer$$$IsQmlList$$$IsConst$$$NeedsCopyConstruction$$$NeedsMoveConstruction -->
<h3 class="flags" id="TypeFlag-enum">enum QMetaType::<span class="name">TypeFlag</span><br/>flags QMetaType::<span class="name">TypeFlags</span></h3>
<p>The enum describes attributes of a type supported by <a href="qmetatype.html" translate="no">QMetaType</a>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::NeedsConstruction</code></td><td class="topAlign tblval"><code translate="no">0x1</code></td><td class="topAlign">This type has a default constructor. If the flag is not set, instances can be safely initialized with memset to 0.</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::NeedsCopyConstruction</code></td><td class="topAlign tblval"><code translate="no">0x4000</code></td><td class="topAlign">(since 6.5) This type has a non-trivial copy constructor. If the flag is not set, instances can be copied with memcpy.</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::NeedsMoveConstruction</code></td><td class="topAlign tblval"><code translate="no">0x8000</code></td><td class="topAlign">(since 6.5) This type has a non-trivial move constructor. If the flag is not set, instances can be moved with memcpy.</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::NeedsDestruction</code></td><td class="topAlign tblval"><code translate="no">0x2</code></td><td class="topAlign">This type has a non-trivial destructor. If the flag is not set, calls to the destructor are not necessary before discarding objects.</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::RelocatableType</code></td><td class="topAlign tblval"><code translate="no">0x4</code></td><td class="topAlign">An instance of a type having this attribute can be safely moved to a different memory location using memcpy.</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::IsEnumeration</code></td><td class="topAlign tblval"><code translate="no">0x10</code></td><td class="topAlign">This type is an enumeration.</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::IsUnsignedEnumeration</code></td><td class="topAlign tblval"><code translate="no">0x100</code></td><td class="topAlign">If the type is an Enumeration, its underlying type is unsigned.</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::PointerToQObject</code></td><td class="topAlign tblval"><code translate="no">0x8</code></td><td class="topAlign">This type is a pointer to a class derived from <a href="qobject.html" translate="no">QObject</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::IsPointer</code></td><td class="topAlign tblval"><code translate="no">0x800</code></td><td class="topAlign">This type is a pointer to another type.</td></tr>
<tr><td class="topAlign"><code translate="no">QMetaType::IsConst</code></td><td class="topAlign tblval"><code translate="no">0x2000</code></td><td class="topAlign">Indicates that values of this type are immutable; for instance, because they are pointers to const objects.</td></tr>
</table></div>
<div class="admonition note">
<p><b>Note: </b>Before Qt 6.5, both the NeedsConstruction and NeedsDestruction flags were incorrectly set if the either copy construtor or destructor were non-trivial (that is, if the type was not trivial).</p>
</div>
<p>Note that the Needs flags may be set but the meta type may not have a publicly-accessible constructor of the relevant type or a publicly-accessible destructor.</p>
<p>The TypeFlags type is a typedef for <a href="qflags.html">QFlags</a>&lt;TypeFlag&gt;. It stores an OR combination of TypeFlag values.</p>
<!-- @@@TypeFlag -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QMetaType[overload1]$$$QMetaTypeint -->
<h3 class="fn" translate="no" id="QMetaType"><code class="details extra" translate="no">[explicit]</code> QMetaType::<span class="name">QMetaType</span>(<span class="type">int</span> <i>typeId</i>)</h3>
<p>Constructs a QMetaType object that contains all information about type <i translate="no">typeId</i>.</p>
<!-- @@@QMetaType -->
<!-- $$$QMetaType$$$QMetaType -->
<h3 class="fn" translate="no" id="QMetaType-2"><code class="details extra" translate="no">[constexpr noexcept, since 6.0]</code> QMetaType::<span class="name">QMetaType</span>()</h3>
<p>Constructs a default, invalid, QMetaType object.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@QMetaType -->
<!-- $$$alignOf[overload1]$$$alignOf -->
<h3 class="fn" translate="no" id="alignOf"><code class="details extra" translate="no">[constexpr, since 6.0]</code> <span class="type">qsizetype</span> QMetaType::<span class="name">alignOf</span>() const</h3>
<p>Returns the alignment of the type in bytes (i.e. alignof(T), where T is the actual type for which this <a href="qmetatype.html" translate="no">QMetaType</a> instance was constructed for).</p>
<p>This function is typically used together with construct() to perform low-level management of the memory used by a type.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qmetatype-obsolete.html#construct" translate="no">QMetaType::construct</a>() and <a href="qmetatype.html#sizeOf-1" translate="no">QMetaType::sizeOf</a>().</p>
<!-- @@@alignOf -->
<!-- $$$canConvert[overload1]$$$canConvertQMetaTypeQMetaType -->
<h3 class="fn" translate="no" id="canConvert"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QMetaType::<span class="name">canConvert</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>fromType</i>, <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>toType</i>)</h3>
<p>Returns <code translate="no">true</code> if <a href="qmetatype.html#convert" translate="no">QMetaType::convert</a> can convert from <i translate="no">fromType</i> to <i translate="no">toType</i>.</p>
<p>The following conversions are supported by Qt:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Type</th><th >Automatically Cast To</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a></td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QUuid</a></td></tr>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a></td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QColor</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a></td></tr>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDate</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDateTime</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a></td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDateTime</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDate</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QTime</a></td></tr>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a></td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QFont</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a></td></tr>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a></td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QKeySequence</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a></td></tr>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QVariantList</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QStringList</a> (if the list's items can be converted to QStrings)</td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a></td></tr>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QPoint</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QPointF</a></td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QRect</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QRectF</a></td></tr>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QColor</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDate</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QDateTime</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QFont</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QKeySequence</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QStringList</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QTime</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QUuid</a></td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QStringList</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QVariantList</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a> (if the list contains exactly one item)</td></tr>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QTime</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a></td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a></td></tr>
<tr valign="top" class="odd"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::ULongLong</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::UInt</a></td></tr>
<tr valign="top" class="even"><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QUuid</a></td><td ><a href="qmetatype.html#Type-enum" translate="no">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum" translate="no">QMetaType::QString</a></td></tr>
</table></div>
<p>Casting between primitive type (int, float, bool etc.) is supported.</p>
<p>Converting between pointers of types derived from <a href="qobject.html" translate="no">QObject</a> will also return true for this function if a <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a> from the type described by <i translate="no">fromType</i> to the type described by <i translate="no">toType</i> would succeed.</p>
<p>A cast from a sequential container will also return true for this function if the <i translate="no">toType</i> is <a href="qmetatype.html#Type-enum" translate="no">QVariantList</a>.</p>
<p>Similarly, a cast from an associative container will also return true for this function the <i translate="no">toType</i> is <a href="qmetatype.html#Type-enum" translate="no">QVariantHash</a> or <a href="qmetatype.html#Type-enum" translate="no">QVariantMap</a>.</p>
<p><b>See also </b><a href="qmetatype.html#convert" translate="no">convert</a>(), <a href="qsequentialiterable.html" translate="no">QSequentialIterable</a>, <a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE" translate="no">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a>(), <a href="qassociativeiterable.html" translate="no">QAssociativeIterable</a>, and <a href="qmetatype.html#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE" translate="no">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</a>().</p>
<!-- @@@canConvert -->
<!-- $$$canView[overload1]$$$canViewQMetaTypeQMetaType -->
<h3 class="fn" translate="no" id="canView"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QMetaType::<span class="name">canView</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>fromType</i>, <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>toType</i>)</h3>
<p>Returns <code translate="no">true</code> if <a href="qmetatype.html#view" translate="no">QMetaType::view</a> can create a mutable view of type <i translate="no">toType</i> on type <i translate="no">fromType</i>.</p>
<p>Converting between pointers of types derived from <a href="qobject.html" translate="no">QObject</a> will return true for this function if a <a href="qobject.html#qobject_cast" translate="no">qobject_cast</a> from the type described by <i translate="no">fromType</i> to the type described by <i translate="no">toType</i> would succeed.</p>
<p>You can create a mutable view of type <a href="qsequentialiterable.html" translate="no">QSequentialIterable</a> on any container registered with <a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE" translate="no">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a>().</p>
<p>Similarly you can create a mutable view of type <a href="qassociativeiterable.html" translate="no">QAssociativeIterable</a> on any container registered with <a href="qmetatype.html#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE" translate="no">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</a>().</p>
<p><b>See also </b><a href="qmetatype.html#convert" translate="no">convert</a>(), <a href="qsequentialiterable.html" translate="no">QSequentialIterable</a>, <a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE" translate="no">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a>(), <a href="qassociativeiterable.html" translate="no">QAssociativeIterable</a>, and <a href="qmetatype.html#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE" translate="no">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</a>().</p>
<!-- @@@canView -->
<!-- $$$compare[overload1]$$$compareconstvoid*constvoid* -->
<h3 class="fn" translate="no" id="compare"><code class="details extra" translate="no">[since 6.0]</code> <span class="type"><a href="qpartialordering.html" translate="no">QPartialOrdering</a></span> QMetaType::<span class="name">compare</span>(const <span class="type">void</span> *<i>lhs</i>, const <span class="type">void</span> *<i>rhs</i>) const</h3>
<p>Compares the objects at <i translate="no">lhs</i> and <i translate="no">rhs</i> for ordering.</p>
<p>Returns <a href="qpartialordering.html#Unordered-var" translate="no">QPartialOrdering::Unordered</a> if comparison is not supported or the values are unordered. Otherwise, returns <a href="qpartialordering.html#Less-var" translate="no">QPartialOrdering::Less</a>, <a href="qpartialordering.html#Equivalent-var" translate="no">QPartialOrdering::Equivalent</a> or <a href="qpartialordering.html#Greater-var" translate="no">QPartialOrdering::Greater</a> if <i translate="no">lhs</i> is less than, equivalent to or greater than <i translate="no">rhs</i>, respectively.</p>
<p>Both objects must be of the type described by this metatype. If either <i translate="no">lhs</i> or <i translate="no">rhs</i> is <code translate="no">nullptr</code>, the values are unordered. Comparison is only supported if the type's less than operator was visible to the metatype declaration.</p>
<p>If the type's equality operator was also visible, values will only compare equal if the equality operator says they are. In the absence of an equality operator, when neither value is less than the other, values are considered equal; if equality is also available and two such values are not equal, they are considered unordered, just as NaN (not a number) values of a floating point type lie outside its ordering.</p>
<div class="admonition note">
<p><b>Note: </b>If no less than operator was visible to the metatype declaration, values are unordered even if an equality operator visible to the declaration considers them equal: <code translate="no">compare() == 0</code> only agrees with <a href="qmetatype.html#equals" translate="no">equals</a>() if the less than operator was visible.</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qmetatype.html#equals" translate="no">equals</a>() and <a href="qmetatype.html#isOrdered" translate="no">isOrdered</a>().</p>
<!-- @@@compare -->
<!-- $$$construct$$$constructvoid*constvoid* -->
<h3 class="fn" translate="no" id="construct-1"><span class="type">void</span> *QMetaType::<span class="name">construct</span>(<span class="type">void</span> *<i>where</i>, const <span class="type">void</span> *<i>copy</i> = nullptr) const</h3>
<p>Constructs a value of the type that this <a href="qmetatype.html" translate="no">QMetaType</a> instance was constructed for in the existing memory addressed by <i translate="no">where</i>, that is a copy of <i translate="no">copy</i>, and returns <i translate="no">where</i>. If <i translate="no">copy</i> is zero, the value is default constructed.</p>
<p>This is a low-level function for explicitly managing the memory used to store the type. Consider calling create() if you don't need this level of control (that is, use &quot;new&quot; rather than &quot;placement new&quot;).</p>
<p>You must ensure that <i translate="no">where</i> points to a location where the new value can be stored and that <i translate="no">where</i> is suitably aligned. The type's size can be queried by calling <a href="qmetatype.html#sizeOf-1" translate="no">sizeOf</a>().</p>
<p>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</p>
<!-- @@@construct -->
<!-- $$$convert[overload1]$$$convertQMetaTypeconstvoid*QMetaTypevoid* -->
<h3 class="fn" translate="no" id="convert"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QMetaType::<span class="name">convert</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>fromType</i>, const <span class="type">void</span> *<i>from</i>, <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>toType</i>, <span class="type">void</span> *<i>to</i>)</h3>
<p>Converts the object at <i translate="no">from</i> from <i translate="no">fromType</i> to the preallocated space at <i translate="no">to</i> typed <i translate="no">toType</i>. Returns <code translate="no">true</code>, if the conversion succeeded, otherwise false.</p>
<p>Both <i translate="no">from</i> and <i translate="no">to</i> have to be valid pointers.</p>
<!-- @@@convert -->
<!-- $$$create$$$createconstvoid* -->
<h3 class="fn" translate="no" id="create-1"><span class="type">void</span> *QMetaType::<span class="name">create</span>(const <span class="type">void</span> *<i>copy</i> = nullptr) const</h3>
<p>Returns a copy of <i translate="no">copy</i>, assuming it is of the type that this <a href="qmetatype.html" translate="no">QMetaType</a> instance was created for. If <i translate="no">copy</i> is <code translate="no">nullptr</code>, creates a default constructed instance.</p>
<p><b>See also </b><a href="qmetatype-obsolete.html#destroy" translate="no">QMetaType::destroy</a>().</p>
<!-- @@@create -->
<!-- $$$debugStream[overload1]$$$debugStreamQDebug&constvoid* -->
<h3 class="fn" translate="no" id="debugStream"><span class="type">bool</span> QMetaType::<span class="name">debugStream</span>(<span class="type"><a href="qdebug.html" translate="no">QDebug</a></span> &amp;<i>dbg</i>, const <span class="type">void</span> *<i>rhs</i>)</h3>
<p>Streams the object at <i translate="no">rhs</i> to the debug stream <i translate="no">dbg</i>. Returns <code translate="no">true</code> on success, otherwise false.</p>
<!-- @@@debugStream -->
<!-- $$$destroy$$$destroyvoid* -->
<h3 class="fn" translate="no" id="destroy-1"><span class="type">void</span> QMetaType::<span class="name">destroy</span>(<span class="type">void</span> *<i>data</i>) const</h3>
<p>Destroys the <i translate="no">data</i>, assuming it is of the type that this <a href="qmetatype.html" translate="no">QMetaType</a> instance was created for.</p>
<p><b>See also </b><a href="qmetatype-obsolete.html#create" translate="no">QMetaType::create</a>().</p>
<!-- @@@destroy -->
<!-- $$$destruct$$$destructvoid* -->
<h3 class="fn" translate="no" id="destruct-1"><span class="type">void</span> QMetaType::<span class="name">destruct</span>(<span class="type">void</span> *<i>data</i>) const</h3>
<p>Destructs the value, located at <i translate="no">data</i>, assuming that it is of the type for which this <a href="qmetatype.html" translate="no">QMetaType</a> instance was constructed for.</p>
<p>Unlike destroy(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</p>
<p><b>See also </b><a href="qmetatype-obsolete.html#construct" translate="no">QMetaType::construct</a>().</p>
<!-- @@@destruct -->
<!-- $$$equals[overload1]$$$equalsconstvoid*constvoid* -->
<h3 class="fn" translate="no" id="equals"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">bool</span> QMetaType::<span class="name">equals</span>(const <span class="type">void</span> *<i>lhs</i>, const <span class="type">void</span> *<i>rhs</i>) const</h3>
<p>Compares the objects at <i translate="no">lhs</i> and <i translate="no">rhs</i> for equality.</p>
<p>Both objects must be of the type described by this metatype. Can only compare the two objects if a less than or equality operator for the type was visible to the metatype declaration. Otherwise, the metatype never considers values equal. When an equality operator was visible to the metatype declaration, it is authoritative; otherwise, if less than is visible, when neither value is less than the other, the two are considered equal. If values are unordered (see <a href="qmetatype.html#compare" translate="no">compare</a>() for details) they are not equal.</p>
<p>Returns true if the two objects compare equal, otherwise false.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qmetatype.html#isEqualityComparable" translate="no">isEqualityComparable</a>() and <a href="qmetatype.html#compare" translate="no">compare</a>().</p>
<!-- @@@equals -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><code class="details extra" translate="no">[constexpr]</code> <span class="type"><a href="qmetatype.html#TypeFlag-enum" translate="no">QMetaType::TypeFlags</a></span> QMetaType::<span class="name">flags</span>() const</h3>
<p>Returns flags of the type for which this <a href="qmetatype.html" translate="no">QMetaType</a> instance was constructed. To inspect specific type traits, prefer using one of the &quot;is-&quot; functions rather than the flags directly.</p>
<p><b>See also </b><a href="qmetatype.html#TypeFlag-enum" translate="no">QMetaType::TypeFlags</a>, QMetaType::flags(), <a href="qmetatype.html#isDefaultConstructible" translate="no">isDefaultConstructible</a>(), <a href="qmetatype.html#isCopyConstructible" translate="no">isCopyConstructible</a>(), <a href="qmetatype.html#isMoveConstructible" translate="no">isMoveConstructible</a>(), <a href="qmetatype.html#isDestructible" translate="no">isDestructible</a>(), <a href="qmetatype.html#isEqualityComparable" translate="no">isEqualityComparable</a>(), and <a href="qmetatype.html#isOrdered" translate="no">isOrdered</a>().</p>
<!-- @@@flags -->
<!-- $$$fromName[overload1]$$$fromNameQByteArrayView -->
<h3 class="fn" translate="no" id="fromName"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> QMetaType::<span class="name">fromName</span>(<span class="type"><a href="qbytearrayview.html" translate="no">QByteArrayView</a></span> <i>typeName</i>)</h3>
<p>Returns a <a href="qmetatype.html" translate="no">QMetaType</a> matching <i translate="no">typeName</i>. The returned object is not valid if the typeName is not known to <a href="qmetatype.html" translate="no">QMetaType</a></p>
<!-- @@@fromName -->
<!-- $$$fromType[overload1]$$$fromType -->
<h3 class="fn" translate="no" id="fromType"><code class="details extra" translate="no">[static constexpr]</code> template &lt;typename T&gt; <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> QMetaType::<span class="name">fromType</span>()</h3>
<p>Returns the <a href="qmetatype.html" translate="no">QMetaType</a> corresponding to the type in the template parameter.</p>
<!-- @@@fromType -->
<!-- $$$hasRegisteredConverterFunction[overload1]$$$hasRegisteredConverterFunctionQMetaTypeQMetaType -->
<h3 class="fn" translate="no" id="hasRegisteredConverterFunction"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QMetaType::<span class="name">hasRegisteredConverterFunction</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>fromType</i>, <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>toType</i>)</h3>
<p>Returns <code translate="no">true</code>, if the meta type system has a registered conversion from meta type id <i translate="no">fromType</i> to <i translate="no">toType</i></p>
<!-- @@@hasRegisteredConverterFunction -->
<!-- $$$hasRegisteredConverterFunction$$$hasRegisteredConverterFunction -->
<h3 class="fn" translate="no" id="hasRegisteredConverterFunction-1"><code class="details extra" translate="no">[static]</code> template &lt;typename From, typename To&gt; <span class="type">bool</span> QMetaType::<span class="name">hasRegisteredConverterFunction</span>()</h3>
<p>Returns <code translate="no">true</code>, if the meta type system has a registered conversion from type From to type To.</p>
<p>This is an overloaded function.</p>
<!-- @@@hasRegisteredConverterFunction -->
<!-- $$$hasRegisteredDataStreamOperators[overload1]$$$hasRegisteredDataStreamOperators -->
<h3 class="fn" translate="no" id="hasRegisteredDataStreamOperators"><code class="details extra" translate="no">[since 6.1]</code> <span class="type">bool</span> QMetaType::<span class="name">hasRegisteredDataStreamOperators</span>() const</h3>
<p>Returns <code translate="no">true</code>, if the meta type system has registered data stream operators for this meta type.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@hasRegisteredDataStreamOperators -->
<!-- $$$hasRegisteredDebugStreamOperator[overload1]$$$hasRegisteredDebugStreamOperator -->
<h3 class="fn" translate="no" id="hasRegisteredDebugStreamOperator"><code class="details extra" translate="no">[since 6.0]</code> <span class="type">bool</span> QMetaType::<span class="name">hasRegisteredDebugStreamOperator</span>() const</h3>
<p>Returns <code translate="no">true</code>, if the meta type system has a registered debug stream operator for this meta type.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@hasRegisteredDebugStreamOperator -->
<!-- $$$hasRegisteredMutableViewFunction[overload1]$$$hasRegisteredMutableViewFunctionQMetaTypeQMetaType -->
<h3 class="fn" translate="no" id="hasRegisteredMutableViewFunction"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QMetaType::<span class="name">hasRegisteredMutableViewFunction</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>fromType</i>, <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>toType</i>)</h3>
<p>Returns <code translate="no">true</code>, if the meta type system has a registered mutable view on meta type id <i translate="no">fromType</i> of meta type id <i translate="no">toType</i>.</p>
<!-- @@@hasRegisteredMutableViewFunction -->
<!-- $$$hasRegisteredMutableViewFunction$$$hasRegisteredMutableViewFunction -->
<h3 class="fn" translate="no" id="hasRegisteredMutableViewFunction-1"><code class="details extra" translate="no">[static, since 6.0]</code> template &lt;typename From, typename To&gt; <span class="type">bool</span> QMetaType::<span class="name">hasRegisteredMutableViewFunction</span>()</h3>
<p>Returns <code translate="no">true</code>, if the meta type system has a registered mutable view on type From of type To.</p>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@hasRegisteredMutableViewFunction -->
<!-- $$$id[overload1]$$$id -->
<h3 class="fn" translate="no" id="id"><span class="type">int</span> QMetaType::<span class="name">id</span>() const</h3>
<p>Returns id type held by this QMetatype instance.</p>
<!-- @@@id -->
<!-- $$$isCopyConstructible[overload1]$$$isCopyConstructible -->
<h3 class="fn" translate="no" id="isCopyConstructible"><code class="details extra" translate="no">[noexcept, since 6.5]</code> <span class="type">bool</span> QMetaType::<span class="name">isCopyConstructible</span>() const</h3>
<p>Returns true if this type can be copy-constructed. If it can be, then construct() and create() can be used with a <code translate="no">copy</code> parameter that is not null.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qmetatype.html#flags" translate="no">flags</a>(), <a href="qmetatype.html#isDefaultConstructible" translate="no">isDefaultConstructible</a>(), <a href="qmetatype.html#isMoveConstructible" translate="no">isMoveConstructible</a>(), and <a href="qmetatype.html#isDestructible" translate="no">isDestructible</a>().</p>
<!-- @@@isCopyConstructible -->
<!-- $$$isDefaultConstructible[overload1]$$$isDefaultConstructible -->
<h3 class="fn" translate="no" id="isDefaultConstructible"><code class="details extra" translate="no">[noexcept, since 6.5]</code> <span class="type">bool</span> QMetaType::<span class="name">isDefaultConstructible</span>() const</h3>
<p>Returns true if this type can be default-constructed. If it can be, then construct() and create() can be used with a <code translate="no">copy</code> parameter that is null.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qmetatype.html#flags" translate="no">flags</a>(), <a href="qmetatype.html#isCopyConstructible" translate="no">isCopyConstructible</a>(), <a href="qmetatype.html#isMoveConstructible" translate="no">isMoveConstructible</a>(), and <a href="qmetatype.html#isDestructible" translate="no">isDestructible</a>().</p>
<!-- @@@isDefaultConstructible -->
<!-- $$$isDestructible[overload1]$$$isDestructible -->
<h3 class="fn" translate="no" id="isDestructible"><code class="details extra" translate="no">[noexcept, since 6.5]</code> <span class="type">bool</span> QMetaType::<span class="name">isDestructible</span>() const</h3>
<p>Returns true if this type can be destroyed. If it can be, then destroy() and destruct() can be called.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qmetatype.html#flags" translate="no">flags</a>(), <a href="qmetatype.html#isDefaultConstructible" translate="no">isDefaultConstructible</a>(), <a href="qmetatype.html#isCopyConstructible" translate="no">isCopyConstructible</a>(), and <a href="qmetatype.html#isMoveConstructible" translate="no">isMoveConstructible</a>().</p>
<!-- @@@isDestructible -->
<!-- $$$isEqualityComparable[overload1]$$$isEqualityComparable -->
<h3 class="fn" translate="no" id="isEqualityComparable"><span class="type">bool</span> QMetaType::<span class="name">isEqualityComparable</span>() const</h3>
<p>Returns <code translate="no">true</code> if a less than or equality operator for the type described by this metatype was visible to the metatype declaration, otherwise <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qmetatype.html#equals" translate="no">equals</a>() and <a href="qmetatype.html#isOrdered" translate="no">isOrdered</a>().</p>
<!-- @@@isEqualityComparable -->
<!-- $$$isMoveConstructible[overload1]$$$isMoveConstructible -->
<h3 class="fn" translate="no" id="isMoveConstructible"><code class="details extra" translate="no">[noexcept, since 6.5]</code> <span class="type">bool</span> QMetaType::<span class="name">isMoveConstructible</span>() const</h3>
<p>Returns true if this type can be move-constructed. <a href="qmetatype.html" translate="no">QMetaType</a> currently does not have an API to make use of this trait.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qmetatype.html#flags" translate="no">flags</a>(), <a href="qmetatype.html#isDefaultConstructible" translate="no">isDefaultConstructible</a>(), <a href="qmetatype.html#isCopyConstructible" translate="no">isCopyConstructible</a>(), and <a href="qmetatype.html#isDestructible" translate="no">isDestructible</a>().</p>
<!-- @@@isMoveConstructible -->
<!-- $$$isOrdered[overload1]$$$isOrdered -->
<h3 class="fn" translate="no" id="isOrdered"><span class="type">bool</span> QMetaType::<span class="name">isOrdered</span>() const</h3>
<p>Returns <code translate="no">true</code> if a less than operator for the type described by this metatype was visible to the metatype declaration, otherwise <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qmetatype.html#compare" translate="no">compare</a>() and <a href="qmetatype.html#isEqualityComparable" translate="no">isEqualityComparable</a>().</p>
<!-- @@@isOrdered -->
<!-- $$$isRegistered[overload1]$$$isRegisteredint -->
<h3 class="fn" translate="no" id="isRegistered"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QMetaType::<span class="name">isRegistered</span>(<span class="type">int</span> <i>type</i>)</h3>
<p>Returns <code translate="no">true</code> if the datatype with ID <i translate="no">type</i> is registered; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qmetatype-obsolete.html#type" translate="no">type</a>(), <a href="qmetatype-obsolete.html#typeName" translate="no">typeName</a>(), and <a href="qmetatype.html#Type-enum" translate="no">Type</a>.</p>
<!-- @@@isRegistered -->
<!-- $$$isRegistered$$$isRegistered -->
<h3 class="fn" translate="no" id="isRegistered-1"><span class="type">bool</span> QMetaType::<span class="name">isRegistered</span>() const</h3>
<p>Returns <code translate="no">true</code> if this <a href="qmetatype.html" translate="no">QMetaType</a> object has been registered with the Qt global metatype registry. Registration allows the type to be found by its name (using <a href="qmetatype.html#fromName" translate="no">QMetaType::fromName</a>()) or by its ID (using the constructor).</p>
<p><b>See also </b><a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>() and <a href="qmetatype.html#isValid" translate="no">isValid</a>().</p>
<!-- @@@isRegistered -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QMetaType::<span class="name">isValid</span>() const</h3>
<p>Returns <code translate="no">true</code> if this <a href="qmetatype.html" translate="no">QMetaType</a> object contains valid information about a type, false otherwise.</p>
<p><b>See also </b><a href="qmetatype.html#isRegistered-1" translate="no">isRegistered</a>().</p>
<!-- @@@isValid -->
<!-- $$$load[overload1]$$$loadQDataStream&void* -->
<h3 class="fn" translate="no" id="load"><span class="type">bool</span> QMetaType::<span class="name">load</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>stream</i>, <span class="type">void</span> *<i>data</i>) const</h3>
<p>Reads the object of this type from the given <i translate="no">stream</i> into <i translate="no">data</i>. Returns <code translate="no">true</code> if the object is loaded successfully; otherwise returns <code translate="no">false</code>.</p>
<p>Normally, you should not need to call this function directly. Instead, use <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>'s <code translate="no">operator&gt;&gt;()</code>, which relies on load() to stream custom types.</p>
<p><b>See also </b><a href="qmetatype.html#save" translate="no">save</a>().</p>
<!-- @@@load -->
<!-- $$$metaObject[overload1]$$$metaObject -->
<h3 class="fn" translate="no" id="metaObject"><code class="details extra" translate="no">[constexpr]</code> const <span class="type"><a href="qmetaobject.html" translate="no">QMetaObject</a></span> *QMetaType::<span class="name">metaObject</span>() const</h3>
<p>Returns a <a href="qmetaobject.html" translate="no">QMetaObject</a> relative to this type.</p>
<p>If the type is a pointer type to a subclass of <a href="qobject.html" translate="no">QObject</a>, <a href="qmetatype.html#flags" translate="no">flags</a>() contains <a href="qmetatype.html#TypeFlag-enum" translate="no">QMetaType::PointerToQObject</a> and this function returns the corresponding <a href="qmetaobject.html" translate="no">QMetaObject</a>. This can be used in combination with QMetaObject::newInstance() to create QObjects of this type.</p>
<p>If the type is a <a href="qobject.html#Q_GADGET" translate="no">Q_GADGET</a>, <a href="qmetatype.html#flags" translate="no">flags</a>() contains <a href="qmetatype.html#TypeFlag-enum" translate="no">QMetaType::IsGadget</a>. If the type is a pointer to a <a href="qobject.html#Q_GADGET" translate="no">Q_GADGET</a>, <a href="qmetatype.html#flags" translate="no">flags</a>() contains <a href="qmetatype.html#TypeFlag-enum" translate="no">QMetaType::PointerToGadget</a>. In both cases, this function returns its <a href="qmetaobject.html" translate="no">QMetaObject</a>. This can be used to retrieve <a href="qmetamethod.html" translate="no">QMetaMethod</a> and <a href="qmetaproperty.html" translate="no">QMetaProperty</a> and use them on a pointer of this type for example, as given by <a href="qvariant.html#data" translate="no">QVariant::data</a>().</p>
<p>If the type is an enumeration, <a href="qmetatype.html#flags" translate="no">flags</a>() contains <a href="qmetatype.html#TypeFlag-enum" translate="no">QMetaType::IsEnumeration</a>. In this case, this function returns the <a href="qmetaobject.html" translate="no">QMetaObject</a> of the enclosing object if the enum was registered as a <a href="qobject.html#Q_ENUM" translate="no">Q_ENUM</a> or <code translate="no">nullptr</code> otherwise.</p>
<p><b>See also </b><a href="qmetatype.html#flags" translate="no">QMetaType::flags</a>().</p>
<!-- @@@metaObject -->
<!-- $$$name[overload1]$$$name -->
<h3 class="fn" translate="no" id="name"><code class="details extra" translate="no">[constexpr]</code> const <span class="type">char</span> *QMetaType::<span class="name">name</span>() const</h3>
<p>Returns the type name associated with this <a href="qmetatype.html" translate="no">QMetaType</a>, or a null pointer if no matching type was found. The returned pointer must not be deleted.</p>
<p><b>See also </b><a href="qmetatype-obsolete.html#typeName" translate="no">typeName</a>().</p>
<!-- @@@name -->
<!-- $$$registerConverter[overload1]$$$registerConverter -->
<h3 class="fn" translate="no" id="registerConverter"><code class="details extra" translate="no">[static]</code> template &lt;typename From, typename To&gt; <span class="type">bool</span> QMetaType::<span class="name">registerConverter</span>()</h3>
<p>Registers the possibility of an implicit conversion from type From to type To in the meta type system. Returns <code translate="no">true</code> if the registration succeeded, otherwise false.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Counter {
   <span class="type">int</span> number <span class="operator">=</span> <span class="number">0</span>;
 <span class="keyword">public</span>:
   <span class="type">int</span> value() <span class="keyword">const</span> { <span class="keyword">return</span> number; }
   <span class="keyword">operator</span> <span class="type">int</span>() <span class="keyword">const</span> { <span class="keyword">return</span> value(); }
   <span class="type">void</span> increment() {<span class="operator">+</span><span class="operator">+</span>number;}
 };
 <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span><span class="operator">::</span>registerConverter<span class="operator">&lt;</span>Counter<span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span>();
</pre>
<!-- @@@registerConverter -->
<!-- $$$registerConverter$$$registerConverterTo(From::*)()const -->
<h3 class="fn" translate="no" id="registerConverter-1"><code class="details extra" translate="no">[static]</code> template &lt;typename From, typename To&gt; <span class="type">bool</span> QMetaType::<span class="name">registerConverter</span>(<span class="type">To</span> (<span class="type">From::</span>*)() const <i>function</i>)</h3>
<p>This is an overloaded function.</p>
<p>Registers a method <i translate="no">function</i> like To From::function() const as converter from type From to type To in the meta type system. Returns <code translate="no">true</code> if the registration succeeded, otherwise false.</p>
<pre class="cpp" translate="no">
 <span class="keyword">struct</span> Coordinates {
   <span class="type">int</span> x;
   <span class="type">int</span> y;
   <span class="type">int</span> z;

   <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QString</a></span> toString() <span class="keyword">const</span> { <span class="keyword">return</span> u<span class="string">&quot;[x: %1; y: %2, z: %3]&quot;</span>_s<span class="operator">.</span>arg(<span class="type"><a href="qmetatype.html#Type-enum" translate="no">QString</a></span><span class="operator">::</span>number(x)<span class="operator">,</span>
     <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QString</a></span><span class="operator">::</span>number(y)<span class="operator">,</span>
     <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QString</a></span><span class="operator">::</span>number(z)); }
 };
 <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span><span class="operator">::</span>registerConverter<span class="operator">&lt;</span>Coordinates<span class="operator">,</span> <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QString</a></span><span class="operator">&gt;</span>(<span class="operator">&amp;</span>Coordinates<span class="operator">::</span>toString);
</pre>
<!-- @@@registerConverter -->
<!-- $$$registerConverter$$$registerConverterTo(From::*)(bool*)const -->
<h3 class="fn" translate="no" id="registerConverter-2"><code class="details extra" translate="no">[static]</code> template &lt;typename From, typename To&gt; <span class="type">bool</span> QMetaType::<span class="name">registerConverter</span>(<span class="type">To</span> (<span class="type">From::</span>*)(<span class="type">bool</span> *) const <i>function</i>)</h3>
<p>This is an overloaded function.</p>
<p>Registers a method <i translate="no">function</i> like To From::function(bool *ok) const as converter from type From to type To in the meta type system. Returns <code translate="no">true</code> if the registration succeeded, otherwise false.</p>
<p>The <code translate="no">ok</code> pointer can be used by the function to indicate whether the conversion succeeded.</p>
<pre class="cpp" translate="no">
 <span class="keyword">struct</span> BigNumber {
     <span class="type">long</span> <span class="type">long</span> l;

     <span class="type">int</span> toInt(<span class="type">bool</span> <span class="operator">*</span>ok <span class="operator">=</span> nullptr) <span class="keyword">const</span> {
       <span class="keyword">const</span> <span class="type">bool</span> canConvertSafely <span class="operator">=</span> l <span class="operator">&lt;</span> std<span class="operator">::</span>numeric_limits<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>max();
       <span class="keyword">if</span> (ok)
         <span class="operator">*</span>ok <span class="operator">=</span> canConvertSafely;
       <span class="keyword">return</span> l;
     }
 };
 <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span><span class="operator">::</span>registerConverter<span class="operator">&lt;</span>BigNumber<span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span>(<span class="operator">&amp;</span>BigNumber<span class="operator">::</span>toInt);
</pre>
<!-- @@@registerConverter -->
<!-- $$$registerConverter$$$registerConverterUnaryFunction -->
<h3 class="fn" translate="no" id="registerConverter-3"><code class="details extra" translate="no">[static]</code> template &lt;typename From, typename To, typename UnaryFunction&gt; <span class="type">bool</span> QMetaType::<span class="name">registerConverter</span>(<span class="type">UnaryFunction</span> <i>function</i>)</h3>
<p>This is an overloaded function.</p>
<p>Registers a unary function object <i translate="no">function</i> as converter from type From to type To in the meta type system. Returns <code translate="no">true</code> if the registration succeeded, otherwise false.</p>
<p><i translate="no">function</i> must take an instance of type <code translate="no">From</code> and return an instance of <code translate="no">To</code>. It can be a function pointer, a lambda or a functor object. Since Qt 6.5, the <i translate="no">function</i> can also return an instance of <code translate="no">std::optional&lt;To&gt;</code> to be able to indicate failed conversions.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span><span class="operator">::</span>registerConverter<span class="operator">&lt;</span>CustomStringType<span class="operator">,</span> <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QString</a></span><span class="operator">&gt;</span>(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> CustomStringType <span class="operator">&amp;</span>str) {
     <span class="keyword">return</span> <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QString</a></span><span class="operator">::</span>fromUtf8(str<span class="operator">.</span>data());
 });
 <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span><span class="operator">::</span>registerConverter<span class="operator">&lt;</span><span class="type"><a href="qmetatype.html#Type-enum" translate="no">QJsonValue</a></span><span class="operator">,</span> <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QPointF</a></span><span class="operator">&gt;</span>(
           <span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QJsonValue</a></span> <span class="operator">&amp;</span>value) <span class="operator">-</span><span class="operator">&gt;</span> std<span class="operator">::</span>optional<span class="operator">&lt;</span><span class="type"><a href="qmetatype.html#Type-enum" translate="no">QPointF</a></span><span class="operator">&gt;</span> {
     <span class="keyword">const</span> <span class="keyword">auto</span> object <span class="operator">=</span> value<span class="operator">.</span>toObject();
     <span class="keyword">if</span> (<span class="operator">!</span>object<span class="operator">.</span>contains(<span class="string">&quot;x&quot;</span>) <span class="operator">|</span><span class="operator">|</span> <span class="operator">!</span>object<span class="operator">.</span>contains(<span class="string">&quot;y&quot;</span>))
         <span class="keyword">return</span> std<span class="operator">::</span>nullopt;  <span class="comment">// The conversion fails if the required properties are missing</span>
     <span class="keyword">return</span> <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QPointF</a></span>{object<span class="operator">[</span><span class="string">&quot;x&quot;</span><span class="operator">]</span><span class="operator">.</span>toDouble()<span class="operator">,</span> object<span class="operator">[</span><span class="string">&quot;y&quot;</span><span class="operator">]</span><span class="operator">.</span>toDouble()};
 });
</pre>
<!-- @@@registerConverter -->
<!-- $$$registerMutableView[overload1]$$$registerMutableViewTo(From::*)() -->
<h3 class="fn" translate="no" id="registerMutableView"><code class="details extra" translate="no">[static, since 6.0]</code> template &lt;typename From, typename To&gt; <span class="type">bool</span> QMetaType::<span class="name">registerMutableView</span>(<span class="type">To</span> (<span class="type">From::</span>*)() <i>function</i>)</h3>
<p>This is an overloaded function.</p>
<p>Registers a method <i translate="no">function</i> like <code translate="no">To From::function()</code> as mutable view of type <code translate="no">To</code> on type <code translate="no">From</code> in the meta type system. Returns <code translate="no">true</code> if the registration succeeded, otherwise <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@registerMutableView -->
<!-- $$$registerMutableView$$$registerMutableViewUnaryFunction -->
<h3 class="fn" translate="no" id="registerMutableView-1"><code class="details extra" translate="no">[static, since 6.0]</code> template &lt;typename From, typename To, typename UnaryFunction&gt; <span class="type">bool</span> QMetaType::<span class="name">registerMutableView</span>(<span class="type">UnaryFunction</span> <i>function</i>)</h3>
<p>This is an overloaded function.</p>
<p>Registers a unary function object <i translate="no">function</i> as mutable view of type To on type From in the meta type system. Returns <code translate="no">true</code> if the registration succeeded, otherwise <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@registerMutableView -->
<!-- $$$registerType[overload1]$$$registerType -->
<h3 class="fn" translate="no" id="registerType"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> QMetaType::<span class="name">registerType</span>() const</h3>
<p>Registers this <a href="qmetatype.html" translate="no">QMetaType</a> with the type registry so it can be found by name, using <a href="qmetatype.html#fromName" translate="no">QMetaType::fromName</a>().</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>().</p>
<!-- @@@registerType -->
<!-- $$$save[overload1]$$$saveQDataStream&constvoid* -->
<h3 class="fn" translate="no" id="save"><span class="type">bool</span> QMetaType::<span class="name">save</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>stream</i>, const <span class="type">void</span> *<i>data</i>) const</h3>
<p>Writes the object pointed to by <i translate="no">data</i> to the given <i translate="no">stream</i>. Returns <code translate="no">true</code> if the object is saved successfully; otherwise returns <code translate="no">false</code>.</p>
<p>Normally, you should not need to call this function directly. Instead, use <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>'s <code translate="no">operator&lt;&lt;()</code>, which relies on save() to stream custom types.</p>
<p><b>See also </b><a href="qmetatype.html#load" translate="no">load</a>().</p>
<!-- @@@save -->
<!-- $$$sizeOf$$$sizeOf -->
<h3 class="fn" translate="no" id="sizeOf-1"><code class="details extra" translate="no">[constexpr]</code> <span class="type">qsizetype</span> QMetaType::<span class="name">sizeOf</span>() const</h3>
<p>Returns the size of the type in bytes (i.e. sizeof(T), where T is the actual type for which this <a href="qmetatype.html" translate="no">QMetaType</a> instance was constructed for).</p>
<p>This function is typically used together with construct() to perform low-level management of the memory used by a type.</p>
<p><b>See also </b><a href="qmetatype-obsolete.html#construct" translate="no">QMetaType::construct</a>(), QMetaType::sizeOf(), and <a href="qmetatype.html#alignOf" translate="no">QMetaType::alignOf</a>().</p>
<!-- @@@sizeOf -->
<!-- $$$underlyingType[overload1]$$$underlyingType -->
<h3 class="fn" translate="no" id="underlyingType"><code class="details extra" translate="no">[since 6.6]</code> <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> QMetaType::<span class="name">underlyingType</span>() const</h3>
<p>If this metatype represents an enumeration, this method returns a metatype of a numeric class of the same signedness and size as the enums underlying type. If it represents a <a href="qflags.html" translate="no">QFlags</a> type, it returns <a href="qmetatype.html#Type-enum" translate="no">QMetaType::Int</a>. In all other cases an invalid <a href="qmetatype.html" translate="no">QMetaType</a> is returned.</p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@underlyingType -->
<!-- $$$view[overload1]$$$viewQMetaTypevoid*QMetaTypevoid* -->
<h3 class="fn" translate="no" id="view"><code class="details extra" translate="no">[static, since 6.0]</code> <span class="type">bool</span> QMetaType::<span class="name">view</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>fromType</i>, <span class="type">void</span> *<i>from</i>, <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>toType</i>, <span class="type">void</span> *<i>to</i>)</h3>
<p>Creates a mutable view on the object at <i translate="no">from</i> of <i translate="no">fromType</i> in the preallocated space at <i translate="no">to</i> typed <i translate="no">toType</i>. Returns <code translate="no">true</code> if the conversion succeeded, otherwise false.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@view -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash$$$qHashQMetaTypesize_t -->
<h3 class="fn" translate="no" id="qHash-3"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">size_t</span> <span class="name">qHash</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>type</i>, <span class="type">size_t</span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for the <i translate="no">type</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@qHash -->
<!-- $$$qMetaTypeId[overload1]$$$qMetaTypeId -->
<h3 class="fn" translate="no" id="qMetaTypeId"><code class="details extra" translate="no">[constexpr]</code> template &lt;typename T&gt; <span class="type">int</span> <span class="name">qMetaTypeId</span>()</h3>
<p>Returns the meta type id of type <code translate="no">T</code> at compile time. If the type was not declared with <a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>(), compilation will fail.</p>
<p>Typical usage:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> id <span class="operator">=</span> qMetaTypeId<span class="operator">&lt;</span><span class="type"><a href="qmetatype.html#Type-enum" translate="no">QString</a></span><span class="operator">&gt;</span>();    <span class="comment">// id is now QMetaType::QString</span>
 id <span class="operator">=</span> qMetaTypeId<span class="operator">&lt;</span>MyStruct<span class="operator">&gt;</span>();       <span class="comment">// compile error if MyStruct not declared</span>
</pre>
<p>QMetaType::type() returns the same ID as qMetaTypeId(), but does a lookup at runtime based on the name of the type. QMetaType::type() is a bit slower, but compilation succeeds if a type is not registered.</p>
<p><b>See also </b><a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>() and <a href="qmetatype-obsolete.html#type" translate="no">QMetaType::type</a>().</p>
<!-- @@@qMetaTypeId -->
<!-- $$$qRegisterMetaType$$$qRegisterMetaType -->
<h3 class="fn" translate="no" id="qRegisterMetaType-2"><code class="details extra" translate="no">[constexpr]</code> template &lt;typename T&gt; <span class="type">int</span> <span class="name">qRegisterMetaType</span>()</h3>
<p>Call this function to register the type <code translate="no">T</code>. Returns the meta type Id.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> id <span class="operator">=</span> qRegisterMetaType<span class="operator">&lt;</span>MyStruct<span class="operator">&gt;</span>();
</pre>
<p>This function requires that <code translate="no">T</code> is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <a href="qmetatype.html#Q_DECLARE_OPAQUE_POINTER" translate="no">Q_DECLARE_OPAQUE_POINTER</a>() to be able to register pointers to forward declared types.</p>
<p>To use the type <code translate="no">T</code> in <a href="qmetatype.html" translate="no">QMetaType</a>, <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>, or with the <a href="qobject.html#property" translate="no">QObject::property</a>() API, registration is not necessary.</p>
<p>To use the type <code translate="no">T</code> in queued signal and slot connections, <code translate="no">qRegisterMetaType&lt;T&gt;()</code> must be called before the first connection is established. That is typically done in the constructor of the class that uses <code translate="no">T</code>, or in the <code translate="no">main()</code> function.</p>
<p>After a type has been registered, it can be found by its name using <a href="qmetatype.html#fromName" translate="no">QMetaType::fromName</a>().</p>
<p><b>See also </b><a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>().</p>
<!-- @@@qRegisterMetaType -->
<!-- $$$qRegisterMetaType$$$qRegisterMetaTypeQMetaType -->
<h3 class="fn" translate="no" id="qRegisterMetaType-3"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">int</span> <span class="name">qRegisterMetaType</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>meta</i>)</h3>
<p>Registers the meta type <i translate="no">meta</i> and returns its type Id.</p>
<p>This function requires that <code translate="no">T</code> is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <a href="qmetatype.html#Q_DECLARE_OPAQUE_POINTER" translate="no">Q_DECLARE_OPAQUE_POINTER</a>() to be able to register pointers to forward declared types.</p>
<p>To use the type <code translate="no">T</code> in <a href="qmetatype.html" translate="no">QMetaType</a>, <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>, or with the <a href="qobject.html#property" translate="no">QObject::property</a>() API, registration is not necessary.</p>
<p>To use the type <code translate="no">T</code> in queued signal and slot connections, <code translate="no">qRegisterMetaType&lt;T&gt;()</code> must be called before the first connection is established. That is typically done in the constructor of the class that uses <code translate="no">T</code>, or in the <code translate="no">main()</code> function.</p>
<p>After a type has been registered, it can be found by its name using <a href="qmetatype.html#fromName" translate="no">QMetaType::fromName</a>().</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@qRegisterMetaType -->
<!-- $$$operator!=[overload1]$$$operator!=QMetaTypeQMetaType -->
<h3 class="fn" translate="no" id="operator-not-eq"><span class="type">bool</span> <span class="name">operator!=</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>a</i>, <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>b</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if the <a href="qmetatype.html" translate="no">QMetaType</a> <i translate="no">a</i> represents a different type than the <a href="qmetatype.html" translate="no">QMetaType</a> <i translate="no">b</i>, otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator!= -->
<!-- $$$operator<<[overload1]$$$operator<<QDebugQMetaType -->
<h3 class="fn" translate="no" id="operator-lt-lt"><code class="details extra" translate="no">[since 6.5]</code> <span class="type"><a href="qdebug.html" translate="no">QDebug</a></span> <span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdebug.html" translate="no">QDebug</a></span> <i>d</i>, <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>m</i>)</h3>
<p>Writes the <a href="qmetatype.html" translate="no">QMetaType</a> <i translate="no">m</i> to the stream <i translate="no">d</i>, and returns the stream.</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@operator<< -->
<!-- $$$operator==[overload1]$$$operator==QMetaTypeQMetaType -->
<h3 class="fn" translate="no" id="operator-eq-eq"><span class="type">bool</span> <span class="name">operator==</span>(<span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>a</i>, <span class="type"><a href="qmetatype.html#QMetaType" translate="no">QMetaType</a></span> <i>b</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if the <a href="qmetatype.html" translate="no">QMetaType</a> <i translate="no">a</i> represents the same type as the <a href="qmetatype.html" translate="no">QMetaType</a> <i translate="no">b</i>, otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator== -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE[overload1]$$$Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE -->
<h3 class="fn" translate="no" id="Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE"><span class="name">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</span>(<i>Container</i>)</h3>
<p>This macro makes the container <i translate="no">Container</i> known to <a href="qmetatype.html" translate="no">QMetaType</a> as an associative container. This makes it possible to put an instance of Container&lt;T, U&gt; into a <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>, if T and U are themselves known to <a href="qmetatype.html" translate="no">QMetaType</a>.</p>
<p>Note that all of the Qt associative containers already have built-in support, and it is not necessary to use this macro with them. The std::map container also has built-in support.</p>
<p>This example shows a typical use of Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE():</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;unordered_list&gt;</span>

 Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(std<span class="operator">::</span>unordered_map)

 <span class="type">void</span> someFunc()
 {
     std<span class="operator">::</span>unordered_map<span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type">bool</span><span class="operator">&gt;</span> container;
     <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QVariant</a></span> var <span class="operator">=</span> <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QVariant</a></span><span class="operator">::</span>fromValue(container);
     <span class="comment">// ...</span>
 }
</pre>
<!-- @@@Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE -->
<!-- $$$Q_DECLARE_METATYPE[overload1]$$$Q_DECLARE_METATYPE -->
<h3 class="fn" translate="no" id="Q_DECLARE_METATYPE"><span class="name">Q_DECLARE_METATYPE</span>(<i>Type</i>)</h3>
<p>This macro makes the type <i translate="no">Type</i> known to <a href="qmetatype.html" translate="no">QMetaType</a> as long as it provides a public default constructor, a public copy constructor and a public destructor. It is needed to use the type <i translate="no">Type</i> as a custom type in <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>.</p>
<p>This macro requires that <i translate="no">Type</i> is a fully defined type at the point where it is used. For pointer types, it also requires that the pointed to type is fully defined. Use in conjunction with <a href="qmetatype.html#Q_DECLARE_OPAQUE_POINTER" translate="no">Q_DECLARE_OPAQUE_POINTER</a>() to register pointers to forward declared types.</p>
<p>Ideally, this macro should be placed below the declaration of the class or struct. If that is not possible, it can be put in a private header file which has to be included every time that type is used in a <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>.</p>
<p>Adding a Q_DECLARE_METATYPE() makes the type known to all template based functions, including <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>. Note that if you intend to use the type in <i>queued</i> signal and slot connections or in <a href="qobject.html" translate="no">QObject</a>'s property system, you also have to call <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>() since the names are resolved at runtime.</p>
<p>This example shows a typical use case of Q_DECLARE_METATYPE():</p>
<pre class="cpp" translate="no">
 <span class="keyword">struct</span> MyStruct
 {
     <span class="type">int</span> i;
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 };

 Q_DECLARE_METATYPE(MyStruct)
</pre>
<p>If <code translate="no">MyStruct</code> is in a namespace, the Q_DECLARE_METATYPE() macro has to be outside the namespace:</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> MyNamespace
 {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 }

 Q_DECLARE_METATYPE(MyNamespace<span class="operator">::</span>MyStruct)
</pre>
<p>Since <code translate="no">MyStruct</code> is now known to <a href="qmetatype.html" translate="no">QMetaType</a>, it can be used in <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>:</p>
<pre class="cpp" translate="no">
 MyStruct s;
 <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QVariant</a></span> var;
 var<span class="operator">.</span>setValue(s); <span class="comment">// copy s into the variant</span>

 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

 <span class="comment">// retrieve the value</span>
 MyStruct s2 <span class="operator">=</span> var<span class="operator">.</span>value<span class="operator">&lt;</span>MyStruct<span class="operator">&gt;</span>();
</pre>
<p>Some types are registered automatically and do not need this macro:</p>
<ul>
<li>Pointers to classes derived from <a href="qobject.html" translate="no">QObject</a></li>
<li><a href="qlist.html" translate="no">QList</a>&lt;T&gt;, <a href="qqueue.html" translate="no">QQueue</a>&lt;T&gt;, <a href="qstack.html" translate="no">QStack</a>&lt;T&gt; or <a href="qset.html" translate="no">QSet</a>&lt;T&gt; where T is a registered meta type</li>
<li><a href="qhash.html#qhash" translate="no">QHash</a>&lt;T1, T2&gt;, <a href="qmap.html" translate="no">QMap</a>&lt;T1, T2&gt; or std::pair&lt;T1, T2&gt; where T1 and T2 are registered meta types</li>
<li><a href="qpointer.html" translate="no">QPointer</a>&lt;T&gt;, <a href="qsharedpointer.html" translate="no">QSharedPointer</a>&lt;T&gt;, <a href="qweakpointer.html" translate="no">QWeakPointer</a>&lt;T&gt;, where T is a class that derives from <a href="qobject.html" translate="no">QObject</a></li>
<li>Enumerations registered with <a href="qobject.html#Q_ENUM" translate="no">Q_ENUM</a> or <a href="qobject.html#Q_FLAG" translate="no">Q_FLAG</a></li>
<li>Classes that have a <a href="qobject.html#Q_GADGET" translate="no">Q_GADGET</a> macro</li>
</ul>
<div class="admonition note">
<p><b>Note: </b>This method also registers the stream and debug operators for the type if they are visible at registration time. As this is done automatically in some places, it is strongly recommended to declare the stream operators for a type directly after the type itself. Because of the argument dependent lookup rules of C++, it is also strongly recommended to declare the operators in the same namespace as the type itself.</p>
</div>
<p>The stream operators should have the following signatures:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> <span class="operator">&amp;</span><span class="keyword">operator</span><span class="operator">&lt;</span><span class="operator">&lt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> <span class="operator">&amp;</span>out<span class="operator">,</span> <span class="keyword">const</span> MyClass <span class="operator">&amp;</span>myObj);
 <span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> <span class="operator">&amp;</span><span class="keyword">operator</span><span class="operator">&gt;</span><span class="operator">&gt;</span>(<span class="type"><a href="qdatastream.html" translate="no">QDataStream</a></span> <span class="operator">&amp;</span>in<span class="operator">,</span> MyClass <span class="operator">&amp;</span>myObj);
</pre>
<p><b>See also </b><a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>().</p>
<!-- @@@Q_DECLARE_METATYPE -->
<!-- $$$Q_DECLARE_OPAQUE_POINTER[overload1]$$$Q_DECLARE_OPAQUE_POINTER -->
<h3 class="fn" translate="no" id="Q_DECLARE_OPAQUE_POINTER"><span class="name">Q_DECLARE_OPAQUE_POINTER</span>(<i>PointerType</i>)</h3>
<p>This macro enables pointers to forward-declared types (<i translate="no">PointerType</i>) to be registered with <a href="qmetatype.html" translate="no">QMetaType</a> using either <a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>() or <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>().</p>
<p><b>See also </b><a href="qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>() and <a href="qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>().</p>
<!-- @@@Q_DECLARE_OPAQUE_POINTER -->
<!-- $$$Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE[overload1]$$$Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE -->
<h3 class="fn" translate="no" id="Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE"><span class="name">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</span>(<i>Container</i>)</h3>
<p>This macro makes the container <i translate="no">Container</i> known to <a href="qmetatype.html" translate="no">QMetaType</a> as a sequential container. This makes it possible to put an instance of Container&lt;T&gt; into a <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>, if T itself is known to <a href="qmetatype.html" translate="no">QMetaType</a>.</p>
<p>Note that all of the Qt sequential containers already have built-in support, and it is not necessary to use this macro with them. The std::vector and std::list containers also have built-in support.</p>
<p>This example shows a typical use of Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE():</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;deque&gt;</span>

 Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std<span class="operator">::</span>deque)

 <span class="type">void</span> someFunc()
 {
     std<span class="operator">::</span>deque<span class="operator">&lt;</span><span class="type"><a href="qfile.html" translate="no">QFile</a></span><span class="operator">*</span><span class="operator">&gt;</span> container;
     <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QVariant</a></span> var <span class="operator">=</span> <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QVariant</a></span><span class="operator">::</span>fromValue(container);
     <span class="comment">// ...</span>
 }
</pre>
<!-- @@@Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE -->
<!-- $$$Q_DECLARE_SMART_POINTER_METATYPE[overload1]$$$Q_DECLARE_SMART_POINTER_METATYPE -->
<h3 class="fn" translate="no" id="Q_DECLARE_SMART_POINTER_METATYPE"><span class="name">Q_DECLARE_SMART_POINTER_METATYPE</span>(<i>SmartPointer</i>)</h3>
<p>This macro makes the smart pointer <i translate="no">SmartPointer</i> known to <a href="qmetatype.html" translate="no">QMetaType</a> as a smart pointer. This makes it possible to put an instance of SmartPointer&lt;T&gt; into a <a href="qmetatype.html#Type-enum" translate="no">QVariant</a>, if T is a type which inherits <a href="qobject.html" translate="no">QObject</a>.</p>
<p>Note that the <a href="qweakpointer.html" translate="no">QWeakPointer</a>, <a href="qsharedpointer.html" translate="no">QSharedPointer</a> and <a href="qpointer.html" translate="no">QPointer</a> already have built-in support, and it is not necessary to use this macro with them.</p>
<p>This example shows a typical use of Q_DECLARE_SMART_POINTER_METATYPE():</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;memory&gt;</span>

 Q_DECLARE_SMART_POINTER_METATYPE(std<span class="operator">::</span>shared_ptr)

 <span class="type">void</span> someFunc()
 {
     <span class="keyword">auto</span> smart_ptr <span class="operator">=</span> std<span class="operator">::</span>make_shared<span class="operator">&lt;</span><span class="type"><a href="qfile.html" translate="no">QFile</a></span><span class="operator">&gt;</span>();
     <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QVariant</a></span> var <span class="operator">=</span> <span class="type"><a href="qmetatype.html#Type-enum" translate="no">QVariant</a></span><span class="operator">::</span>fromValue(smart_ptr);
     <span class="comment">// ...</span>
     <span class="keyword">if</span> (var<span class="operator">.</span>canConvert<span class="operator">&lt;</span><span class="type"><a href="qobject.html" translate="no">QObject</a></span><span class="operator">*</span><span class="operator">&gt;</span>()) {
         <span class="type"><a href="qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>sp <span class="operator">=</span> var<span class="operator">.</span>value<span class="operator">&lt;</span><span class="type"><a href="qobject.html" translate="no">QObject</a></span><span class="operator">*</span><span class="operator">&gt;</span>();
         <a href="qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> sp<span class="operator">-</span><span class="operator">&gt;</span>metaObject()<span class="operator">-</span><span class="operator">&gt;</span>className(); <span class="comment">// Prints 'QFile'.</span>
     }
 }
</pre>
<!-- @@@Q_DECLARE_SMART_POINTER_METATYPE -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
