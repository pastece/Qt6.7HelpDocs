<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qspan.qdoc -->
  <meta name="description" content="A non-owning container over contiguous data.">
  <title>QSpan Class | Qt Core 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtcore-index.html" translate="no">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QSpan</li>
<li id="buildversion"><a href="qtcore-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#qspan-vs-std-span">QSpan vs. std::span</a></li>
<li class="level2"><a href="#compatible-iterators">Compatible Iterators</a></li>
<li class="level2"><a href="#compatible-ranges">Compatible Ranges</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QSpan Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T, std::size_t E = std::size_t(-1)&gt; class QSpan</span>
<!-- $$$QSpan-brief -->
<p>A non-owning container over contiguous data. <a href="#details">More...</a></p>
<!-- @@@QSpan -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QSpan&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.7</td></tr>
</table></div>
<ul>
<li><a href="qspan-members.html">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#const_iterator-typedef" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#const_pointer-typedef" translate="no">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#const_reference-typedef" translate="no">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#iterator-typedef" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#pointer-typedef" translate="no">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#reference-typedef" translate="no">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#reverse_iterator-typedef" translate="no">reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#value_type-typedef" translate="no">value_type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#QSpan-2" translate="no">QSpan</a></b>(q20::type_identity_t&lt;T&gt; (&amp;)[N] <i>arr</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#QSpan-8" translate="no">QSpan</a></b>(std::initializer_list&lt;QSpan&lt;T, E&gt;::value_type&gt; <i>il</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#QSpan-9" translate="no">QSpan</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#QSpan-10" translate="no">QSpan</a></b>(const QSpan&lt;T, E&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#QSpan-11" translate="no">QSpan</a></b>(QSpan&lt;T, E&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#dtor.QSpan" translate="no">~QSpan</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::reference </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#back" translate="no">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#begin" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#crbegin" translate="no">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#crend" translate="no">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::pointer </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#data" translate="no">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::iterator </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#end" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, Count&gt; </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#first" translate="no">first</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#first-1" translate="no">first</a></b>(QSpan&lt;T, E&gt;::size_type <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::reference </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#front" translate="no">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, Count&gt; </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#last" translate="no">last</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#last-1" translate="no">last</a></b>(QSpan&lt;T, E&gt;::size_type <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#rbegin" translate="no">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#rend" translate="no">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::size_type </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::size_type </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#size_bytes" translate="no">size_bytes</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#sliced" translate="no">sliced</a></b>(QSpan&lt;T, E&gt;::size_type <i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#sliced-1" translate="no">sliced</a></b>(QSpan&lt;T, E&gt;::size_type <i>pos</i>, QSpan&lt;T, E&gt;::size_type <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> auto </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#subspan" translate="no">subspan</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#subspan-2" translate="no">subspan</a></b>(QSpan&lt;T, E&gt;::size_type <i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#subspan-3" translate="no">subspan</a></b>(QSpan&lt;T, E&gt;::size_type <i>pos</i>, QSpan&lt;T, E&gt;::size_type <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qspan.html#operator-eq" translate="no">operator=</a></b>(const QSpan&lt;T, E&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qspan.html#operator-eq-1" translate="no">operator=</a></b>(QSpan&lt;T, E&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSpan&lt;T, E&gt;::reference </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#operator-5b-5d" translate="no">operator[]</a></b>(QSpan&lt;T, E&gt;::size_type <i>idx</i>) const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> const std::size_t </td><td class="memItemRight bottomAlign"><b><a href="qspan.html#extent-var" translate="no">extent</a></b></td></tr>
</table></div>
<!-- $$$QSpan-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>A QSpan references a contiguous portion of another contiguous container. It acts as an interface type for all kinds of contiguous containers, without the need to construct an owning container such as <a href="qlist.html" translate="no">QList</a> or std::vector first.</p>
<p>The data referenced by a QSpan may be represented as an array (or array-compatible data-structure such as <a href="qlist.html" translate="no">QList</a>, std::vector, <a href="qvarlengtharray.html" translate="no">QVarLengthArray</a>, etc.). QSpan itself merely stores a pointer to the data, so users must ensure that QSpan objects do not outlive the data they reference.</p>
<p>Unlike views such as <a href="qstringview.html" translate="no">QStringView</a>, <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> and <a href="qutf8stringview.html" translate="no">QUtf8StringView</a>, referenced data can be modified through a QSpan object. To prevent this, construct a QSpan over a <code translate="no">const T</code>:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> numbers<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span>};
 <span class="type">QSpan</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> span <span class="operator">=</span> numbers;
 span<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">42</span>;
 <span class="comment">// numbers == {42, 1, 2};</span>
 <span class="type">QSpan</span><span class="operator">&lt;</span><span class="keyword">const</span> <span class="type">int</span><span class="operator">&gt;</span> cspan <span class="operator">=</span> numbers;
 cspan<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// ERROR: cspan[0] is read-only</span>
</pre>
<p>A QSpan can be <i>fixed-size</i> or <i>variable-sized</i>.</p>
<p>A variable-sized span is formed by omitting the second template argument (or setting it to <code translate="no">std::dynamic_extent</code>, which is, however, only available in C++20 builds), as seen in the example above.</p>
<p>A fixed-size span is formed by passing a number as the second template argument:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> numbers<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span>};
 <span class="type">QSpan</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="number">3</span><span class="operator">&gt;</span> span <span class="operator">=</span> numbers;
 <span class="type">QSpan</span><span class="operator">&lt;</span><span class="keyword">const</span> <span class="type">int</span><span class="operator">,</span> <span class="number">3</span><span class="operator">&gt;</span> <span class="operator">=</span> numbers; <span class="comment">// also OK</span>
</pre>
<p>As the name suggests, a fixed-size span's <a href="qspan.html#size" translate="no">size</a>() is fixed at compile-time whereas the <a href="qspan.html#size" translate="no">size</a>() of a variable-sized span is determined only at run-time.</p>
<p>A fixed-size span is not default-constructible (unless its <a href="qspan.html#extent-var" translate="no">extent</a> is zero (0)). A variable-sized span <i>is</i> default-constructible and will have <code translate="no">data() == nullptr</code> and <code translate="no">size() == 0</code>.</p>
<p>A fixed-size span can be implicitly converted into a variable-sized one. The opposite direction (variable-length into fixed-length) has the precondition that both span's sizes must match.</p>
<p>Unlike with owning containers, <code translate="no">const</code> is <i>shallow</i> in QSpan: you can still modify the data through a const QSpan (but not through a <code translate="no">QSpan&lt;const T&gt;</code>), and <a href="qspan.html#begin" translate="no">begin</a>() and <a href="qspan.html#end" translate="no">end</a>() are not overloaded on <code translate="no">const</code>/non-<code translate="no">const</code>. There are <a href="qspan.html#cbegin" translate="no">cbegin</a>() and <a href="qspan.html#cend" translate="no">cend</a>(), though, that return const_iterators which prevent modification of the data even though <code translate="no">T</code> is not const:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> numbers<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span>};
 <span class="keyword">const</span> <span class="type">QSpan</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> span <span class="operator">=</span> numbers;
 span<span class="operator">.</span>front() <span class="operator">=</span> <span class="number">42</span>;   <span class="comment">// OK, numbers[0] == 42 now</span>
 <span class="operator">*</span>span<span class="operator">.</span>begin() <span class="operator">=</span> <span class="number">31</span>;  <span class="comment">// OK, numbers[0] == 31 now</span>
 <span class="operator">*</span>span<span class="operator">.</span>cbegin() <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>; <span class="comment">// ERROR: cannot assign through a const_iterator</span>
</pre>
<p>QSpan should be passed by value, not by reference-to-const:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> consume(<span class="type">QSpan</span><span class="operator">&lt;</span><span class="keyword">const</span> <span class="type">int</span><span class="operator">&gt;</span> data); <span class="comment">// OK</span>
 <span class="type">void</span> consume(<span class="keyword">const</span> <span class="type">QSpan</span><span class="operator">&lt;</span><span class="keyword">const</span> <span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span>data); <span class="comment">// works, but is non-idiomatic and less efficient</span>
</pre>
<p><code translate="no">QSpan&lt;T,N&gt;</code> is a <i>Literal Type</i>, regardless of whether <code translate="no">T</code> is a Literal Type or not.</p>
<h4 id="qspan-vs-std-span">QSpan vs. std::span</h4>
<span id="span-stl"></span><p>QSpan is closely modelled after <a href="https://en.cppreference.com/w/cpp/container/span" translate="no">std::span</a>, but has a few differences which we'll discuss here. Since they both implicitly convert into each other, you're free to choose whichever one you like best in your own code.</p>
<ul>
<li>QSpan is using the signed qsizetype as <code translate="no">size_type</code> whereas <code translate="no">std::span</code> uses <code translate="no">size_t</code>.</li>
<li>All QSpan constructors are implicit; many <code translate="no">std::span</code> ones are <code translate="no">explicit</code>.</li>
<li>QSpan can be constructed from rvalue owning containers, <code translate="no">std::span</code> can not.</li>
</ul>
<p>The last two are required for source-compatibility when functions that took owning containers are converted to take QSpan instead, which is a vitally-important use-case in Qt. The use of qsizetype is for consistency with the rest of Qt containers. QSpan template arguments still use size_t to avoid introducing unnecessary error conditions (negative sizes).</p>
<h4 id="compatible-iterators">Compatible Iterators</h4>
<span id="span-compatible-iterators"></span><p>QSpan can be constructed from an iterator and size or from an iterator pair, provided the iterators are <i>compatible</i> ones. Eventually, this should mean C++20 <code translate="no">std::contiguous_iterator</code> and <code translate="no">std::sentinel_for</code>, but while Qt still supports C++17, only raw pointers are considered contiguous iterators.</p>
<h4 id="compatible-ranges">Compatible Ranges</h4>
<span id="span-compatible-ranges"></span><p>QSpan can also be constructed from a <i>compatible</i> range. A range is compatible if it has <a href="qspan.html#span-compatible-iterators" translate="no">compatible iterators</a>.</p>
</div>
<p><b>See also </b><a href="qlist.html" translate="no">QList</a>, <a href="qstringview.html" translate="no">QStringView</a>, <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>, and <a href="qutf8stringview.html" translate="no">QUtf8StringView</a>.</p>
<!-- @@@QSpan -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$const_iterator -->
<h3 class="fn" translate="no" id="const_iterator-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">const_iterator</span></h3>
<p>An alias for <code translate="no">const T*</code> and <code translate="no">const_pointer</code>, respectively.</p>
<p><b>See also </b><a href="qspan.html#const_pointer-typedef" translate="no">const_pointer</a>, <a href="qspan.html#iterator-typedef" translate="no">iterator</a>, and <a href="qspan.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" translate="no" id="const_pointer-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">const_pointer</span></h3>
<p>An alias for <code translate="no">const T*</code> and <code translate="no">const element_type*</code>, respectively.</p>
<p>This alias is provided for compatbility with the STL.</p>
<p><b>See also </b>element_type, <a href="qspan.html#pointer-typedef" translate="no">pointer</a>, <a href="qspan.html#const_reference-typedef" translate="no">const_reference</a>, and <a href="qspan.html#const_iterator-typedef" translate="no">const_iterator</a>.</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" translate="no" id="const_reference-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">const_reference</span></h3>
<p>An alias for <code translate="no">const T&amp;</code> and <code translate="no">const element_type&amp;</code>, respectively.</p>
<p>This alias is provided for compatbility with the STL.</p>
<p><b>See also </b>element_type, <a href="qspan.html#reference-typedef" translate="no">reference</a>, and <a href="qspan.html#const_pointer-typedef" translate="no">const_pointer</a>.</p>
<!-- @@@const_reference -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" translate="no" id="const_reverse_iterator-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">const_reverse_iterator</span></h3>
<p>An alias for <code translate="no">std::reverse_iterator&lt;const_iterator&gt;</code>.</p>
<p><b>See also </b><a href="qspan.html#const_iterator-typedef" translate="no">const_iterator</a> and <a href="qspan.html#reverse_iterator-typedef" translate="no">reverse_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" translate="no" id="difference_type-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">difference_type</span></h3>
<p>An alias for qptrdiff. This <a href="qspan.html#span-stl" translate="no">differs from <code translate="no">std::span</code></a>.</p>
<p>This alias is provided for compatbility with the STL.</p>
<!-- @@@difference_type -->
<!-- $$$iterator -->
<h3 class="fn" translate="no" id="iterator-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">iterator</span></h3>
<p>An alias for <code translate="no">T*</code> and <code translate="no">pointer</code>, respectively. Includes the <code translate="no">const</code>, if any.</p>
<p><b>See also </b><a href="qspan.html#pointer-typedef" translate="no">pointer</a>, <a href="qspan.html#const_iterator-typedef" translate="no">const_iterator</a>, and <a href="qspan.html#reverse_iterator-typedef" translate="no">reverse_iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$pointer -->
<h3 class="fn" translate="no" id="pointer-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">pointer</span></h3>
<p>An alias for <code translate="no">T*</code> and <code translate="no">element_type*</code>, respectively. Includes the <code translate="no">const</code>, if any.</p>
<p>This alias is provided for compatbility with the STL.</p>
<p><b>See also </b>element_type, <a href="qspan.html#const_pointer-typedef" translate="no">const_pointer</a>, <a href="qspan.html#reference-typedef" translate="no">reference</a>, and <a href="qspan.html#iterator-typedef" translate="no">iterator</a>.</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" translate="no" id="reference-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">reference</span></h3>
<p>An alias for <code translate="no">T&amp;</code> and <code translate="no">element_type&amp;</code>, respectively. Includes the <code translate="no">const</code>, if any.</p>
<p>This alias is provided for compatbility with the STL.</p>
<p><b>See also </b>element_type, <a href="qspan.html#const_reference-typedef" translate="no">const_reference</a>, and <a href="qspan.html#pointer-typedef" translate="no">pointer</a>.</p>
<!-- @@@reference -->
<!-- $$$reverse_iterator -->
<h3 class="fn" translate="no" id="reverse_iterator-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">reverse_iterator</span></h3>
<p>An alias for <code translate="no">std::reverse_iterator&lt;iterator&gt;</code>. Includes the <code translate="no">const</code>, if any.</p>
<p><b>See also </b><a href="qspan.html#iterator-typedef" translate="no">iterator</a> and <a href="qspan.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a>.</p>
<!-- @@@reverse_iterator -->
<!-- $$$size_type -->
<h3 class="fn" translate="no" id="size_type-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">size_type</span></h3>
<p>An alias for qsizetype. This <a href="qspan.html#span-stl" translate="no">differs from <code translate="no">std::span</code></a>.</p>
<p>This alias is provided for compatbility with the STL.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" translate="no" id="value_type-typedef"><code class="details extra" translate="no">[alias]</code> QSpan::<span class="name">value_type</span></h3>
<p>An alias for <code translate="no">T</code>. Excludes the <code translate="no">const</code>, if any.</p>
<p>This alias is provided for compatbility with the STL.</p>
<p><b>See also </b>element_type.</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="QSpan-11"><code class="details extra" translate="no">[default]</code> QSpan::<span class="name">QSpan</span>(<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt; &amp;&amp;<i>other</i>)</h3><h3 class="fn fngroupitem" translate="no" id="QSpan-10"><code class="details extra" translate="no">[default]</code> QSpan::<span class="name">QSpan</span>(const <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt; &amp;<i>other</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-eq-1"><code class="details extra" translate="no">[default]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt; &amp;QSpan::<span class="name">operator=</span>(<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt; &amp;&amp;<i>other</i>)</h3><h3 class="fn fngroupitem" translate="no" id="operator-eq"><code class="details extra" translate="no">[default]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt; &amp;QSpan::<span class="name">operator=</span>(const <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt; &amp;<i>other</i>)</h3><h3 class="fn fngroupitem" translate="no" id="dtor.QSpan"><code class="details extra" translate="no">[default]</code> QSpan::<span class="name">~QSpan</span>()</h3></div>
<p>These Special Member Functions are implicitly-defined.</p>
<div class="admonition note">
<p><b>Note: </b>Moves are equivalent to copies. Only <a href="qspan.html#data" translate="no">data</a>() and <a href="qspan.html#size" translate="no">size</a>() are copied from span to span, not the referenced data.</p>
</div>
<!-- @@@ -->
<!-- $$$ -->
<h3 class="fn fngroupitem" translate="no" id="QSpan-2"><code class="details extra" translate="no">[constexpr noexcept]</code> template &lt;size_t N&gt; QSpan::<span class="name">QSpan</span>(<span class="type">q20::type_identity_t</span>&lt;<span class="type">T</span>&gt; (&amp;)[<span class="type">N</span>] <i>arr</i>)</h3>
<p>Constructs a <a href="qspan.html" translate="no">QSpan</a> referencing the data in the supplied array <i translate="no">arr</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This constructor participates in overload resolution only if</p>
</div>
<ul>
<li>either <code translate="no">N</code> or <a href="qspan.html#extent-var" translate="no">extent</a> are <code translate="no">std::dynamic_extent</code> or otherwise <a href="qspan.html#extent-var" translate="no">extent</a> <code translate="no">==</code> <code translate="no">N</code></li>
<li>and either <code translate="no">S</code> or <code translate="no">const S</code> are the same as <code translate="no">T</code>.</li>
</ul>
<div class="admonition note">
<p><b>Note: </b><code translate="no">q20::type_identity_t</code> is a C++17 backport of C++20's <a href="https://en.cppreference.com/w/cpp/types/type_identity" translate="no"><code translate="no">std::type_identity_t</code></a>.</p>
</div>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="empty"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">bool</span> QSpan::<span class="name">empty</span>() const</h3><h3 class="fn fngroupitem" translate="no" id="isEmpty"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QSpan::<span class="name">isEmpty</span>() const</h3></div>
<p>Returns whether the span is empty, that is, whether <code translate="no">size() == 0</code>.</p>
<p>These functions do the same thing: <a href="qspan.html#empty" translate="no">empty</a>() is provided for STL compatibility and <a href="qspan.html#isEmpty" translate="no">isEmpty</a>() is provided for Qt compatibility.</p>
<p><b>See also </b><a href="qspan.html#size" translate="no">size</a>() and <a href="qspan.html#size_bytes" translate="no">size_bytes</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="sliced"><code class="details extra" translate="no">[constexpr]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>&gt; QSpan::<span class="name">sliced</span>(<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> <i>pos</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="subspan-2"><code class="details extra" translate="no">[constexpr]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>&gt; QSpan::<span class="name">subspan</span>(<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> <i>pos</i>) const</h3></div>
<p>Returns a variable-sized span of size <code translate="no">size() - pos</code> referencing the remainder of this span after dropping the first <i translate="no">pos</i> elements.</p>
<p><i translate="no">pos</i> must be non-negative.</p>
<p>This span must hold at least <i translate="no">pos</i> elements (<code translate="no">E</code> &gt;= <i translate="no">pos</i> <i>and</i> <a href="qspan.html#size" translate="no">size</a>() &gt;= <i translate="no">pos</i>), otherwise the behavior is undefined.</p>
<p>These functions do the same thing: <a href="qspan.html#subspan" translate="no">subspan</a>() is provided for STL compatibility and <a href="qspan.html#sliced" translate="no">sliced</a>() is provided for Qt compatibility.</p>
<p><b>See also </b><a href="qspan.html#subspan" translate="no">subspan</a>(), <a href="qspan.html#first-1" translate="no">first</a>(QSpan&lt;T,E&gt;::size_type), and <a href="qspan.html#last-1" translate="no">last</a>(QSpan&lt;T,E&gt;::size_type).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="sliced-1"><code class="details extra" translate="no">[constexpr]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>&gt; QSpan::<span class="name">sliced</span>(<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> <i>pos</i>, <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> <i>n</i>) const</h3><h3 class="fn fngroupitem" translate="no" id="subspan-3"><code class="details extra" translate="no">[constexpr]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>&gt; QSpan::<span class="name">subspan</span>(<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> <i>pos</i>, <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> <i>n</i>) const</h3></div>
<p>Returns a variable-sized span of size <i translate="no">n</i> referencing the <i translate="no">n</i> elements of this span starting at <i translate="no">pos</i>.</p>
<p>Both <i translate="no">pos</i> and <i translate="no">n</i> must be non-negative.</p>
<p>This span must hold at least <code translate="no">pos + n</code> elements (<code translate="no">E</code> &gt;= <code translate="no">pos + n</code> <i>and</i> <a href="qspan.html#size" translate="no">size</a>() &gt;= <code translate="no">pos + n</code>), otherwise the behavior is undefined.</p>
<p>These functions do the same thing: <a href="qspan.html#subspan" translate="no">subspan</a>() is provided for STL compatibility and <a href="qspan.html#sliced" translate="no">sliced</a>() is provided for Qt compatibility.</p>
<p><b>See also </b><a href="qspan.html#subspan" translate="no">subspan</a>(), <a href="qspan.html#first-1" translate="no">first</a>(QSpan&lt;T,E&gt;::size_type), and <a href="qspan.html#last-1" translate="no">last</a>(QSpan&lt;T,E&gt;::size_type).</p>
<!-- @@@ -->
<!-- $$$QSpan$$$QSpanstd::initializer_list<QSpan<T,E>::value_type> -->
<h3 class="fn" translate="no" id="QSpan-8"><code class="details extra" translate="no">[constexpr]</code> QSpan::<span class="name">QSpan</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::value_type</span>&gt; <i>il</i>)</h3>
<p>Constructs a QSpan referencing the data in the supplied initializer list <i translate="no">il</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This constructor participates in overload resolution only if <code translate="no">T</code> is <code translate="no">const</code>-qualified.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This constructor is <code translate="no">noexcept</code> only if <code translate="no">E</code> is <code translate="no">std::dynamic_extent</code>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If <code translate="no">E</code> is not <code translate="no">std::dynamic_extent</code> and the size of <i translate="no">il</i> is not <code translate="no">E</code>, the behavior is undefined.</p>
</div>
<!-- @@@QSpan -->
<!-- $$$QSpan$$$QSpan -->
<h3 class="fn" translate="no" id="QSpan-9"><code class="details extra" translate="no">[default]</code> QSpan::<span class="name">QSpan</span>()</h3>
<p>Default constructor.</p>
<p>This constructor is only present if <code translate="no">E</code> is either zero (0) or <code translate="no">std::dynamic_extent</code>. In other words: only fixed-zero-sized or variable-sized spans are default-constructible.</p>
<p><b>See also </b><a href="qspan.html#extent-var" translate="no">extent</a>.</p>
<!-- @@@QSpan -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" translate="no" id="back"><code class="details extra" translate="no">[constexpr]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::reference</span> QSpan::<span class="name">back</span>() const</h3>
<p>Returns a reference to the last element in the span.</p>
<p>The span must not be empty, otherwise the behavior is undefined.</p>
<p><b>See also </b><a href="qspan.html#operator-5b-5d" translate="no">operator[]</a>(), <a href="qspan.html#front" translate="no">front</a>(), <a href="qspan.html#size" translate="no">size</a>(), and <a href="qspan.html#empty" translate="no">empty</a>().</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" translate="no" id="begin"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::iterator</span> QSpan::<span class="name">begin</span>() const</h3>
<p>Returns an interator pointing at the beginning of the span.</p>
<p>Because <a href="qspan.html" translate="no">QSpan</a> iterators are just pointers, this is the same as calling <a href="qspan.html#data" translate="no">data</a>().</p>
<p><b>See also </b><a href="qspan.html#end" translate="no">end</a>(), <a href="qspan.html#cbegin" translate="no">cbegin</a>(), <a href="qspan.html#rbegin" translate="no">rbegin</a>(), <a href="qspan.html#crbegin" translate="no">crbegin</a>(), and <a href="qspan.html#data" translate="no">data</a>().</p>
<!-- @@@begin -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" translate="no" id="cbegin"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::const_iterator</span> QSpan::<span class="name">cbegin</span>() const</h3>
<p>Returns a <a href="qspan.html#const_iterator-typedef" translate="no">const_iterator</a> pointing to the beginning of the span.</p>
<p>This will return a read-only iterator even if <code translate="no">T</code> is not <code translate="no">const</code>:</p>
<pre class="cpp" translate="no">
 <span class="type">QSpan</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> span <span class="operator">=</span> <span class="operator">~</span><span class="operator">~</span><span class="operator">~</span>;
 <span class="operator">*</span>span<span class="operator">.</span>begin() <span class="operator">=</span> <span class="number">42</span>; <span class="comment">// OK</span>
 <span class="operator">*</span>span<span class="operator">.</span>cbegin() <span class="operator">=</span> <span class="number">42</span>; <span class="comment">// ERROR: cannot assign through a const_iterator</span>
</pre>
<p><b>See also </b><a href="qspan.html#cend" translate="no">cend</a>(), <a href="qspan.html#begin" translate="no">begin</a>(), <a href="qspan.html#crbegin" translate="no">crbegin</a>(), <a href="qspan.html#rbegin" translate="no">rbegin</a>(), and <a href="qspan.html#data" translate="no">data</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" translate="no" id="cend"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::const_iterator</span> QSpan::<span class="name">cend</span>() const</h3>
<p>Returns a <a href="qspan.html#const_iterator-typedef" translate="no">const_iterator</a> pointing to one past the end of the span.</p>
<p><b>See also </b><a href="qspan.html#cbegin" translate="no">cbegin</a>(), <a href="qspan.html#end" translate="no">end</a>(), <a href="qspan.html#crend" translate="no">crend</a>(), <a href="qspan.html#rend" translate="no">rend</a>(), <a href="qspan.html#data" translate="no">data</a>(), and <a href="qspan.html#size" translate="no">size</a>().</p>
<!-- @@@cend -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" translate="no" id="crbegin"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::const_reverse_iterator</span> QSpan::<span class="name">crbegin</span>() const</h3>
<p>Returns a <a href="qspan.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a> pointing to the beginning of the reversed span.</p>
<p><b>See also </b><a href="qspan.html#crend" translate="no">crend</a>(), <a href="qspan.html#rbegin" translate="no">rbegin</a>(), <a href="qspan.html#cbegin" translate="no">cbegin</a>(), and <a href="qspan.html#begin" translate="no">begin</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" translate="no" id="crend"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::const_reverse_iterator</span> QSpan::<span class="name">crend</span>() const</h3>
<p>Returns a <a href="qspan.html#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a> pointing to one past the end of the reversed span.</p>
<p><b>See also </b><a href="qspan.html#crbegin" translate="no">crbegin</a>(), <a href="qspan.html#rend" translate="no">rend</a>(), <a href="qspan.html#cend" translate="no">cend</a>(), and <a href="qspan.html#end" translate="no">end</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" translate="no" id="data"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::pointer</span> QSpan::<span class="name">data</span>() const</h3>
<p>Returns a pointer to the beginning of the span.</p>
<p>The same as calling <a href="qspan.html#begin" translate="no">begin</a>().</p>
<p><b>See also </b><a href="qspan.html#begin" translate="no">begin</a>() and <a href="qspan.html#front" translate="no">front</a>().</p>
<!-- @@@data -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" translate="no" id="end"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::iterator</span> QSpan::<span class="name">end</span>() const</h3>
<p>Returns an iterator pointing to one past the end of the span.</p>
<p>Because <a href="qspan.html" translate="no">QSpan</a> iterators are just pointers, this it the same as calling <code translate="no">data() + size()</code>.</p>
<p><b>See also </b><a href="qspan.html#begin" translate="no">begin</a>(), <a href="qspan.html#cend" translate="no">cend</a>(), <a href="qspan.html#rend" translate="no">rend</a>(), <a href="qspan.html#crend" translate="no">crend</a>(), <a href="qspan.html#data" translate="no">data</a>(), and <a href="qspan.html#size" translate="no">size</a>().</p>
<!-- @@@end -->
<!-- $$$first[overload1]$$$first -->
<h3 class="fn" translate="no" id="first"><code class="details extra" translate="no">[constexpr noexcept(...)]</code> template &lt;std::size_t Count&gt; <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">Count</span>&gt; QSpan::<span class="name">first</span>() const</h3>
<p>Returns a fixed-sized span of size <code translate="no">Count</code> referencing the first <code translate="no">Count</code> elements of <code translate="no">*this</code>.</p>
<p>The span must hold at least <code translate="no">Count</code> elements (<code translate="no">E</code> &gt;= <code translate="no">Count</code> <i>and</i> <a href="qspan.html#size" translate="no">size</a>() &gt;= <code translate="no">Count</code>), otherwise the behavior is undefined.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;subspan_always_succeeds_v&lt;Count&gt;&quot; is true.</p>
</div>
<p><b>See also </b><a href="qspan.html#first-1" translate="no">first</a>(QSpan&lt;T,E&gt;::size_type), <a href="qspan.html#last" translate="no">last</a>(), and <a href="qspan.html#subspan" translate="no">subspan</a>().</p>
<!-- @@@first -->
<!-- $$$first$$$firstQSpan<T,E>::size_type -->
<h3 class="fn" translate="no" id="first-1"><code class="details extra" translate="no">[constexpr]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>&gt; QSpan::<span class="name">first</span>(<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> <i>n</i>) const</h3>
<p>Returns a variable-sized span of size <i translate="no">n</i> referencing the first <i translate="no">n</i> elements of <code translate="no">*this</code>.</p>
<p><i translate="no">n</i> must be non-negative.</p>
<p>The span must hold at least <i translate="no">n</i> elements (<code translate="no">E</code> &gt;= <i translate="no">n</i> <i>and</i> <a href="qspan.html#size" translate="no">size</a>() &gt;= <i translate="no">n</i>), otherwise the behavior is undefined.</p>
<p><b>See also </b><a href="qspan.html#first" translate="no">first&lt;N&gt;</a>(), <a href="qspan.html#last-1" translate="no">last</a>(QSpan&lt;T,E&gt;::size_type), <a href="qspan.html#subspan-2" translate="no">subspan</a>(QSpan&lt;T,E&gt;::size_type), <a href="qspan.html#subspan-3" translate="no">subspan</a>(QSpan&lt;T,E&gt;::size_type, QSpan&lt;T,E&gt;::size_type), and <a href="qspan.html#sliced" translate="no">sliced</a>().</p>
<!-- @@@first -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" translate="no" id="front"><code class="details extra" translate="no">[constexpr]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::reference</span> QSpan::<span class="name">front</span>() const</h3>
<p>Returns a reference to the first element in the span.</p>
<p>The span must not be empty, otherwise the behavior is undefined.</p>
<p><b>See also </b><a href="qspan.html#operator-5b-5d" translate="no">operator[]</a>(), <a href="qspan.html#back" translate="no">back</a>(), <a href="qspan.html#size" translate="no">size</a>(), and <a href="qspan.html#empty" translate="no">empty</a>().</p>
<!-- @@@front -->
<!-- $$$last[overload1]$$$last -->
<h3 class="fn" translate="no" id="last"><code class="details extra" translate="no">[constexpr noexcept(...)]</code> template &lt;std::size_t Count&gt; <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">Count</span>&gt; QSpan::<span class="name">last</span>() const</h3>
<p>Returns a fixed-sized span of size <code translate="no">Count</code> referencing the last <code translate="no">Count</code> elements of <code translate="no">*this</code>.</p>
<p>The span must hold at least <code translate="no">Count</code> elements (<code translate="no">E</code> &gt;= <code translate="no">Count</code> <i>and</i> <a href="qspan.html#size" translate="no">size</a>() &gt;= <code translate="no">Count</code>), otherwise the behavior is undefined.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;subspan_always_succeeds_v&lt;Count&gt;&quot; is true.</p>
</div>
<p><b>See also </b><a href="qspan.html#last-1" translate="no">last</a>(QSpan&lt;T,E&gt;::size_type), <a href="qspan.html#first" translate="no">first</a>(), and <a href="qspan.html#subspan" translate="no">subspan</a>().</p>
<!-- @@@last -->
<!-- $$$last$$$lastQSpan<T,E>::size_type -->
<h3 class="fn" translate="no" id="last-1"><code class="details extra" translate="no">[constexpr]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>&gt; QSpan::<span class="name">last</span>(<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> <i>n</i>) const</h3>
<p>Returns a variable-sized span of size <i translate="no">n</i> referencing the last <i translate="no">n</i> elements of <code translate="no">*this</code>.</p>
<p><i translate="no">n</i> must be non-negative.</p>
<p>The span must hold at least <i translate="no">n</i> elements (<code translate="no">E</code> &gt;= <i translate="no">n</i> <i>and</i> <a href="qspan.html#size" translate="no">size</a>() &gt;= <i translate="no">n</i>), otherwise the behavior is undefined.</p>
<p><b>See also </b><a href="qspan.html#last" translate="no">last</a>(), <a href="qspan.html#first-1" translate="no">first</a>(QSpan&lt;T,E&gt;::size_type), <a href="qspan.html#subspan-2" translate="no">subspan</a>(QSpan&lt;T,E&gt;::size_type), <a href="qspan.html#subspan-3" translate="no">subspan</a>(QSpan&lt;T,E&gt;::size_type, QSpan&lt;T,E&gt;::size_type), and <a href="qspan.html#sliced" translate="no">sliced</a>().</p>
<!-- @@@last -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" translate="no" id="rbegin"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::reverse_iterator</span> QSpan::<span class="name">rbegin</span>() const</h3>
<p>Returns a <a href="qspan.html#reverse_iterator-typedef" translate="no">reverse_iterator</a> pointing to the beginning of the reversed span.</p>
<p><b>See also </b><a href="qspan.html#rend" translate="no">rend</a>(), <a href="qspan.html#crbegin" translate="no">crbegin</a>(), <a href="qspan.html#begin" translate="no">begin</a>(), and <a href="qspan.html#cbegin" translate="no">cbegin</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" translate="no" id="rend"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::reverse_iterator</span> QSpan::<span class="name">rend</span>() const</h3>
<p>Returns a <a href="qspan.html#reverse_iterator-typedef" translate="no">reverse_iterator</a> pointing to one past the end of the reversed span.</p>
<p><b>See also </b><a href="qspan.html#rbegin" translate="no">rbegin</a>(), <a href="qspan.html#crend" translate="no">crend</a>(), <a href="qspan.html#end" translate="no">end</a>(), and <a href="qspan.html#cend" translate="no">cend</a>().</p>
<!-- @@@rend -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> QSpan::<span class="name">size</span>() const</h3>
<p>Returns the size of the span, that is, the number of elements it references.</p>
<p><b>See also </b><a href="qspan.html#size_bytes" translate="no">size_bytes</a>(), <a href="qspan.html#empty" translate="no">empty</a>(), and <a href="qspan.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@size -->
<!-- $$$size_bytes[overload1]$$$size_bytes -->
<h3 class="fn" translate="no" id="size_bytes"><code class="details extra" translate="no">[constexpr noexcept]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> QSpan::<span class="name">size_bytes</span>() const</h3>
<p>Returns the size of the span in bytes, that is, the number of elements multiplied by <code translate="no">sizeof(T)</code>.</p>
<p><b>See also </b><a href="qspan.html#size" translate="no">size</a>(), <a href="qspan.html#empty" translate="no">empty</a>(), and <a href="qspan.html#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@size_bytes -->
<!-- $$$subspan[overload1]$$$subspan -->
<h3 class="fn" translate="no" id="subspan"><code class="details extra" translate="no">[constexpr noexcept(...)]</code> template &lt;std::size_t Offset&gt; <span class="type">auto</span> QSpan::<span class="name">subspan</span>() const</h3>
<p>Returns a span of size <code translate="no">E - Offset</code> referencing the remainder of this span after dropping the first <code translate="no">Offset</code> elements.</p>
<p>If <code translate="no">*this</code> is a variable-sized span, the return type is a variable-sized span, otherwise it is a fixed-sized span.</p>
<p>This span must hold at least <code translate="no">Offset</code> elements (<code translate="no">E</code> &gt;= <code translate="no">Offset</code> <i>and</i> <a href="qspan.html#size" translate="no">size</a>() &gt;= <code translate="no">Offset</code>), otherwise the behavior is undefined.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not throw any exception when &quot;subspan_always_succeeds_v&lt;Offset&gt;&quot; is true.</p>
</div>
<p><b>See also </b><a href="qspan.html#subspan-2" translate="no">subspan</a>(QSpan&lt;T,E&gt;::size_type), subspan(), <a href="qspan.html#first" translate="no">first</a>(), and <a href="qspan.html#last" translate="no">last</a>().</p>
<!-- @@@subspan -->
<!-- $$$operator[][overload1]$$$operator[]QSpan<T,E>::size_type -->
<h3 class="fn" translate="no" id="operator-5b-5d"><code class="details extra" translate="no">[constexpr]</code> <span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::reference</span> QSpan::<span class="name">operator[]</span>(<span class="type">QSpan</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;<span class="type">::size_type</span> <i>idx</i>) const</h3>
<p>Returns a reference to the element at index <i translate="no">idx</i> in the span.</p>
<p>The index must be in range, that is, <i translate="no">idx</i> &gt;= 0 and <i translate="no">idx</i> &lt; <a href="qspan.html#size" translate="no">size</a>(), otherwise the behavior is undefined.</p>
<p><b>See also </b><a href="qspan.html#front" translate="no">front</a>(), <a href="qspan.html#back" translate="no">back</a>(), <a href="qspan.html#size" translate="no">size</a>(), and <a href="qspan.html#empty" translate="no">empty</a>().</p>
<!-- @@@operator[] -->
</div>
<div class="vars">
<h2>Member Variable Documentation</h2>
<!-- $$$extent -->
<h3 class="fn" translate="no" id="extent-var">const <span class="type">std::size_t</span> QSpan::<span class="name">extent</span></h3>
<p>The second template argument of <code translate="no">QSpan&lt;T, E&gt;</code>, that is, <code translate="no">E</code>. This is <code translate="no">std::dynamic_extent</code> for variable-sized spans.</p>
<div class="admonition note">
<p><b>Note: </b>While all other sizes and indexes in <a href="qspan.html" translate="no">QSpan</a> use qsizetype, this variable, like <code translate="no">E</code>, is actually of type <code translate="no">size_t</code>, for compatibility with <code translate="no">std::span</code> and <code translate="no">std::dynamic_extent</code>.</p>
</div>
<p><b>See also </b><a href="qspan.html#size" translate="no">size</a>().</p>
<!-- @@@extent -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
