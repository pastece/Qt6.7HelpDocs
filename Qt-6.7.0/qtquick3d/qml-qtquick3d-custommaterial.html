<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquick3dcustommaterial.cpp -->
  <meta name="description" content="Base component for creating custom materials used to shade models.">
  <title>CustomMaterial QML Type | Qt Quick 3D 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick3d-index.html" translate="no">Qt Quick 3D</a></li>
<li><a href="qtquick3d-qmlmodule.html" translate="no">QML Types</a></li>
<li>CustomMaterial</li>
<li id="buildversion"><a href="qtquick3d-index.html" translate="no">Qt Quick 3D | Commercial or GPLv3</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#introduction">Introduction</a></li>
<li class="level2"><a href="#two-flavors-of-custom-materials">Two flavors of custom materials</a></li>
<li class="level2"><a href="#exposing-data-to-the-shaders">Exposing data to the shaders</a></li>
<li class="level2"><a href="#unshaded-custom-materials">Unshaded custom materials</a></li>
<li class="level2"><a href="#shaded-custom-materials">Shaded custom materials</a></li>
<li class="level2"><a href="#screen-depth-and-other-textures">Screen, depth, and other textures</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">CustomMaterial QML Type</h1>
<!-- $$$CustomMaterial-brief -->
<p>Base component for creating custom materials used to shade models. <a href="#details">More...</a></p>
<!-- @@@CustomMaterial -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Import Statement:</td><td class="memItemRight bottomAlign"> import QtQuick3D</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <p><a href="qml-qtquick3d-material.html" translate="no">Material</a></p>
</td></tr></table></div><ul>
<li><a href="qml-qtquick3d-custommaterial-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="properties">Properties</h2>
<ul>
<li class="fn" translate="no"><b><a href="qml-qtquick3d-custommaterial.html#alwaysDirty-prop" translate="no">alwaysDirty</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qml-qtquick3d-custommaterial.html#destinationAlphaBlend-prop" translate="no">destinationAlphaBlend</a></b> : enumeration <code class="summary extra" translate="no">(since 6.7)</code></li>
<li class="fn" translate="no"><b><a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a></b> : enumeration</li>
<li class="fn" translate="no"><b><a href="qml-qtquick3d-custommaterial.html#fragmentShader-prop" translate="no">fragmentShader</a></b> : url</li>
<li class="fn" translate="no"><b><a href="qml-qtquick3d-custommaterial.html#lineWidth-prop" translate="no">lineWidth</a></b> : real</li>
<li class="fn" translate="no"><b><a href="qml-qtquick3d-custommaterial.html#shadingMode-prop" translate="no">shadingMode</a></b> : enumeration</li>
<li class="fn" translate="no"><b><a href="qml-qtquick3d-custommaterial.html#sourceAlphaBlend-prop" translate="no">sourceAlphaBlend</a></b> : enumeration <code class="summary extra" translate="no">(since 6.7)</code></li>
<li class="fn" translate="no"><b><a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a></b> : enumeration</li>
<li class="fn" translate="no"><b><a href="qml-qtquick3d-custommaterial.html#vertexShader-prop" translate="no">vertexShader</a></b> : url</li>
</ul>
<!-- $$$CustomMaterial-description -->
<h2 id="details">Detailed Description</h2>
<p>The custom material allows using custom shader code for a material, enabling programmability on graphics shader level. A vertex, fragment, or both shaders can be provided. The <a href="qml-qtquick3d-custommaterial.html#vertexShader-prop" translate="no">vertexShader</a> and <a href="qml-qtquick3d-custommaterial.html#fragmentShader-prop" translate="no">fragmentShader</a> properties are URLs, referencing files containing shader snippets, and work very similarly to <a href="../qtquick/qml-qtquick-shadereffect.html" translate="no">ShaderEffect</a> or <a href="../qtquick/qml-qtquick-image.html#source-prop" translate="no">Image.source</a>. Only the <code translate="no">file</code> and <code translate="no">qrc</code> schemes are supported with custom materials. It is also possible to omit the <code translate="no">file</code> scheme, allowing to specify a relative path in a convenient way. Such a path is resolved relative to the component's (the <code translate="no">.qml</code> file's) location.</p>
<p>For a getting started guide to custom materials, see the page <a href="qtquick3d-custom.html" translate="no">Programmable Materials, Effects, Geometry, and Texture data</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>Consider the following versions of the same scene. On the left, the cylinder is using a built-in, non-programmable material. Such materials are configurable through a wide range of properties, but there is no further control given over the shaders that are generated under the hood. On the right, the same cylinder is now associated with a CustomMaterial referencing application-provided vertex and fragment shader snippets. This allows inserting custom, application-specific logic into the vertex shader to transform the geometry, and to determine certain color properties in a custom manner in the fragment shader. As this is a <a href="qml-qtquick3d-custommaterial.html#shadingMode-prop" translate="no">shaded</a> custom material, the cylinder still participates in the scene lighting normally.</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick3d-view3d.html" translate="no">View3D</a></span> {
     <span class="name">anchors</span>.fill: <span class="name">parent</span>
     <span class="type"><a href="qml-qtquick3d-perspectivecamera.html" translate="no">PerspectiveCamera</a></span> {
         <span class="name">id</span>: <span class="name">camera</span>
         <span class="name">position</span>: <span class="name">Qt</span>.<span class="name">vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>)
     }
     <span class="name">camera</span>: <span class="name">camera</span>
     <span class="type"><a href="qml-qtquick3d-directionallight.html" translate="no">DirectionalLight</a></span> {
         <span class="name">position</span>: <span class="name">Qt</span>.<span class="name">vector3d</span>(-<span class="number">500</span>, <span class="number">500</span>, -<span class="number">100</span>)
         <span class="name">color</span>: <span class="name">Qt</span>.<span class="name">rgba</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.0</span>)
         <span class="name">ambientColor</span>: <span class="name">Qt</span>.<span class="name">rgba</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">1.0</span>)
     }
     <span class="type"><a href="qml-qtquick3d-model.html" translate="no">Model</a></span> {
         <span class="name">source</span>: <span class="string">&quot;#Cylinder&quot;</span>
         <span class="name">eulerRotation</span>: <span class="name">Qt</span>.<span class="name">vector3d</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>)
         <span class="name">scale</span>: <span class="name">Qt</span>.<span class="name">vector3d</span>(<span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>)
         <span class="name">materials</span>: [
             <span class="type"><a href="qml-qtquick3d-defaultmaterial.html" translate="no">DefaultMaterial</a></span> {
                 <span class="name">diffuseColor</span>: <span class="name">Qt</span>.<span class="name">rgba</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)
             }
         ]
     }
 }
</pre>
</td><td ><pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick3d-view3d.html" translate="no">View3D</a></span> {
     <span class="name">anchors</span>.fill: <span class="name">parent</span>
     <span class="type"><a href="qml-qtquick3d-perspectivecamera.html" translate="no">PerspectiveCamera</a></span> {
         <span class="name">id</span>: <span class="name">camera</span>
         <span class="name">position</span>: <span class="name">Qt</span>.<span class="name">vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>)
     }
     <span class="name">camera</span>: <span class="name">camera</span>
     <span class="type"><a href="qml-qtquick3d-directionallight.html" translate="no">DirectionalLight</a></span> {
         <span class="name">position</span>: <span class="name">Qt</span>.<span class="name">vector3d</span>(-<span class="number">500</span>, <span class="number">500</span>, -<span class="number">100</span>)
         <span class="name">color</span>: <span class="name">Qt</span>.<span class="name">rgba</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.0</span>)
         <span class="name">ambientColor</span>: <span class="name">Qt</span>.<span class="name">rgba</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">1.0</span>)
     }
     <span class="type"><a href="qml-qtquick3d-model.html" translate="no">Model</a></span> {
         <span class="name">source</span>: <span class="string">&quot;#Cylinder&quot;</span>
         <span class="name">eulerRotation</span>: <span class="name">Qt</span>.<span class="name">vector3d</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>)
         <span class="name">scale</span>: <span class="name">Qt</span>.<span class="name">vector3d</span>(<span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>)
         <span class="name">materials</span>: [
             <span class="type"><a href="qml-qtquick3d-custommaterial.html" translate="no">CustomMaterial</a></span> {
                 <span class="name">vertexShader</span>: <span class="string">&quot;material.vert&quot;</span>
                 <span class="name">fragmentShader</span>: <span class="string">&quot;material.frag&quot;</span>
                 property <span class="type"><a href="../qtqml/qml-real.html" translate="no">real</a></span> <span class="name">uTime</span>
                 property <span class="type"><a href="../qtqml/qml-real.html" translate="no">real</a></span> <span class="name">uAmplitude</span>: <span class="number">50</span>
                 NumberAnimation on <span class="name">uTime</span> { <span class="name">from</span>: <span class="number">0</span>; <span class="name">to</span>: <span class="number">100</span>; <span class="name">duration</span>: <span class="number">10000</span>; <span class="name">loops</span>: -<span class="number">1</span> }
             }
         ]
     }
 }
</pre>
</td></tr>
</table></div>
<p>Let's assume that the shader snippets in <code translate="no">material.vert</code> and <code translate="no">material.frag</code> are the following:</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><pre class="cpp plain" translate="no">
 void MAIN()
 {
     VERTEX.x += sin(uTime + VERTEX.y) * uAmplitude;
 }
</pre>
</td><td ><pre class="cpp plain" translate="no">
 void MAIN()
 {
     BASE_COLOR = vec4(0.0, 1.0, 0.0, 1.0);
 }
</pre>
</td></tr>
</table></div>
<p>Notice how <code translate="no">uTime</code> and <code translate="no">uAmplitude</code> are properties of the CustomMaterial element. They can change values and get animated normally, the values will be exposed to the shaders automatically without any further action from the developer.</p>
<p>The result is a cylinder that animates its vertices:</p>
<p class="centerAlign"><img src="images/custommaterial_cylinder.png" alt="" /></p><h2 id="two-flavors-of-custom-materials">Two flavors of custom materials</h2>
<p>There are two main types of custom materials. This is specified by the <a href="qml-qtquick3d-custommaterial.html#shadingMode-prop" translate="no">shadingMode</a> property. In <a href="qml-qtquick3d-custommaterial.html#shadingMode-prop" translate="no">unshaded</a> custom materials the fragment shader outputs a single <code translate="no">vec4</code> color, ignoring lights, light probes, shadowing in the scene. In <a href="qml-qtquick3d-custommaterial.html#shadingMode-prop" translate="no">shaded</a> materials the shader is expected to implement certain functions and work with built-in variables to take lighting and shadow contribution into account.</p>
<p>The default choice is typically a shaded material, this is reflected in the default value of the <a href="qml-qtquick3d-custommaterial.html#shadingMode-prop" translate="no">shadingMode</a> property. This fits materials that needs to transform vertices or other incoming data from the geometry, or determine values like <code translate="no">BASE_COLOR</code> or <code translate="no">EMISSIVE_COLOR</code> in a custom manner, perhaps by sampling <code translate="no">SCREEN_TEXTURE</code> or <code translate="no">DEPTH_TEXTURE</code>, while still reciving light and shadow contributions from the scene. Additionally, such materials can also override and reimplement the equations used to calculate the contributions from directional, point, and other lights. The application-provided shader snippets are heavily amended by the Qt Quick 3D engine under the hood, in order to provide the features, such as lighting, the standard materials have.</p>
<p>Unshaded materials are useful when the object's appearance is determined completely by the custom shader code. The shaders for such materials receive minimal additions by the engine, and therefore it is completely up to the shader to determine the final fragment color. This gives more freedom, but also limits possiblities to integrate with other elements of the scene, such as lights.</p>
<div class="admonition note">
<p><b>Note: </b>Shader code is always provided using Vulkan-style GLSL, regardless of the graphics API used by Qt at run time.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The vertex and fragment shader code provided by the material are not full, complete GLSL shaders on their own. Rather, they provide a set of functions, which are then amended with further shader code by the engine.</p>
</div>
<h2 id="exposing-data-to-the-shaders">Exposing data to the shaders</h2>
<p>The dynamic properties of the CustomMaterial can be changed and animated using QML and Qt Quick facilities, and the values are exposed to the shaders automatically. This in practice is very similar <a href="../qtquick/qml-qtquick-shadereffect.html" translate="no">ShaderEffect</a>. The following list shows how properties are mapped:</p>
<ul>
<li>bool, int, real -&gt; bool, int, float</li>
<li><a href="../qtgui/qcolor.html" translate="no">QColor</a>, <a href="../qtqml/qml-qtqml-qt.html#rgba-method" translate="no">color</a> -&gt; vec4, and the color gets converted to linear, assuming sRGB space for the color value specified in QML. The built-in Qt colors, such as <code translate="no">&quot;green&quot;</code> are in sRGB color space as well, and the same conversion is performed for all color properties of DefaultMaterial and <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a>, so this behavior of CustomMaterial matches those. Unlike Qt Quick, for Qt Quick 3D linearizing is essential as there will typically be tonemapping performed on the 3D scene.</li>
<li><a href="../qtcore/qrect.html" translate="no">QRect</a>, <a href="../qtcore/qrectf.html" translate="no">QRectF</a>, <a href="../qtqml/qml-qtqml-qt.html#rect-method" translate="no">rect</a> -&gt; vec4</li>
<li><a href="../qtcore/qpoint.html" translate="no">QPoint</a>, <a href="../qtcore/qpointf.html" translate="no">QPointF</a>, <a href="../qtqml/qml-qtqml-qt.html#point-method" translate="no">point</a>, <a href="../qtcore/qsize.html" translate="no">QSize</a>, <a href="../qtcore/qsizef.html" translate="no">QSizeF</a>, <a href="../qtqml/qml-qtqml-qt.html#size-method" translate="no">size</a> -&gt; vec2</li>
<li><a href="../qtgui/qvector2d.html" translate="no">QVector2D</a>, <a href="../qtqml/qml-qtqml-qt.html#vector2d-method" translate="no">vector2d</a> -&gt; vec2</li>
<li><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a>, <a href="../qtqml/qml-qtqml-qt.html#vector3d-method" translate="no">vector3d</a> -&gt; vec3</li>
<li><a href="../qtgui/qvector4d.html" translate="no">QVector4D</a>, <a href="../qtqml/qml-qtqml-qt.html#vector4d-method" translate="no">vector4d</a> -&gt; vec4</li>
<li><a href="../qtgui/qmatrix4x4.html" translate="no">QMatrix4x4</a>, <a href="../qtqml/qml-qtqml-qt.html#matrix4x4-method" translate="no">matrix4x4</a> -&gt; mat4</li>
<li><a href="../qtgui/qquaternion.html" translate="no">QQuaternion</a>, <a href="../qtqml/qml-qtqml-qt.html#quaternion-method" translate="no">quaternion</a> -&gt; vec4, scalar value is <code translate="no">w</code></li>
<li><a href="qml-qtquick3d-textureinput.html" translate="no">TextureInput</a> -&gt; sampler2D or samplerCube, depending on whether <a href="qml-qtquick3d-texture.html" translate="no">Texture</a> or <a href="qml-qtquick3d-cubemaptexture.html" translate="no">CubeMapTexture</a> is used in the texture property of the <a href="qml-qtquick3d-textureinput.html" translate="no">TextureInput</a>. Setting the <a href="qml-qtquick3d-textureinput.html#enabled-prop" translate="no">enabled</a> property to false leads to exposing a dummy texture to the shader, meaning the shaders are still functional but will sample a texture with opaque black image content. Pay attention to the fact that properties for samplers must always reference a <a href="qml-qtquick3d-textureinput.html" translate="no">TextureInput</a> object, not a <a href="qml-qtquick3d-texture.html" translate="no">Texture</a> directly. When it comes to the <a href="qml-qtquick3d-texture.html" translate="no">Texture</a> properties, the source, tiling, and filtering related ones are the only ones that are taken into account implicitly with custom materials, as the rest (such as, UV transformations) is up to the custom shaders to implement as they see fit.</li>
</ul>
<div class="admonition note">
<p><b>Note: </b>When a uniform referenced in the shader code does not have a corresponding property, it will cause a shader compilation error when processing the material at run time. There are some exceptions to this, such as, sampler uniforms, that get a dummy texture bound when no corresponding QML property is present, but as a general rule, all uniforms and samplers must have a corresponding property declared in the CustomMaterial object.</p>
</div>
<h2 id="unshaded-custom-materials">Unshaded custom materials</h2>
<p>The following is an example of an <a href="qml-qtquick3d-custommaterial.html#shadingMode-prop" translate="no">unshaded</a> custom material.</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick3d-custommaterial.html" translate="no">CustomMaterial</a></span> {
     <span class="comment">// These properties are automatically exposed to the shaders</span>
     property <span class="type"><a href="../qtqml/qml-real.html" translate="no">real</a></span> <span class="name">time</span>: <span class="number">0.0</span>
     property <span class="type"><a href="../qtqml/qml-real.html" translate="no">real</a></span> <span class="name">amplitude</span>: <span class="number">5.0</span>
     property <span class="type"><a href="../qtqml/qml-real.html" translate="no">real</a></span> <span class="name">alpha</span>: <span class="number">1.0</span>
     property <span class="type"><a href="qml-qtquick3d-textureinput.html" translate="no">TextureInput</a></span> <span class="name">tex</span>: <span class="name">TextureInput</span> {
         <span class="name">enabled</span>: <span class="number">true</span>
         <span class="name">texture</span>: <span class="name">Texture</span> { <span class="name">source</span>: <span class="string">&quot;image.png&quot;</span> }
     }

     <span class="name">shadingMode</span>: <span class="name">CustomMaterial</span>.<span class="name">Unshaded</span>
     <span class="name">sourceBlend</span>: <span class="name">alpha</span> <span class="operator">&lt;</span> <span class="number">1.0</span> ? <span class="name">CustomMaterial</span>.<span class="name">SrcAlpha</span> : <span class="name">CustomMaterial</span>.<span class="name">NoBlend</span>
     <span class="name">destinationBlend</span>: <span class="name">alpha</span> <span class="operator">&lt;</span> <span class="number">1.0</span> ? <span class="name">CustomMaterial</span>.<span class="name">OneMinusSrcAlpha</span> : <span class="name">CustomMaterial</span>.<span class="name">NoBlend</span>
     <span class="name">cullMode</span>: <span class="name">CustomMaterial</span>.<span class="name">BackFaceCulling</span>

     <span class="name">vertexShader</span>: <span class="string">&quot;customshader.vert&quot;</span>
     <span class="name">fragmentShader</span>: <span class="string">&quot;customshader.frag&quot;</span>
 }
</pre>
<p>With the above example, the <a href="qml-qtquick3d-custommaterial.html#shadingMode-prop" translate="no">unshaded</a> vertex and fragment shaders snippets could look like the following. Note how the shaders do not, and must not, declare uniforms or vertex inputs as that is taken care of by Qt when assembling the final shader code.</p>
<pre class="cpp plain" translate="no">
 VARYING vec3 pos;
 VARYING vec2 texcoord;

 void MAIN()
 {
     pos = VERTEX;
     pos.x += sin(time * 4.0 + pos.y) * amplitude;
     texcoord = UV0;
     POSITION = MODELVIEWPROJECTION_MATRIX * vec4(pos, 1.0);
 }
</pre>
<pre class="cpp plain" translate="no">
 VARYING vec3 pos;
 VARYING vec2 texcoord;

 void MAIN()
 {
     vec4 c = texture(tex, texcoord);
     FRAGCOLOR = vec4(pos.x * 0.02, pos.y * 0.02, pos.z * 0.02, alpha) * c;
 }
</pre>
<p>The following special, uppercase keywords are available:</p>
<ul>
<li>MAIN -&gt; the name of the entry point in the vertex or fragment shader snippet must always be <code translate="no">MAIN</code>. Providing this function is mandatory in shader snippets for unshaded custom materials.</li>
<li>VARYING -&gt; declares an output from the vertex shader or an input to the fragment shader</li>
<li>POSITION -&gt; vec4, the output from the vertex shader</li>
<li>FRAGCOLOR -&gt; vec4, the output from the fragment shader. Available only for unshaded custom materials.</li>
<li>VERTEX -&gt; vec3, the vertex position in the vertex shader.</li>
<li>NORMAL -&gt; vec3, the vertex normal in the vertex shader. When the mesh for the associated model does not provide normals, the value is vec3(0.0).</li>
<li>UV0 -&gt; vec2, the first set of texture coordinates in the vertex shader. When the mesh for the associated model does not provide texture coordinates, the value is vec2(0.0).</li>
<li>UV1 -&gt; vec2, the second set of texture coordinates in the vertex shader. When the mesh for the associated model does not provide a second set of texture coordinates, the value is vec2(0.0).</li>
<li>COLOR -&gt; vec4, the vertex color in the vertex shader. When the mesh for the associated model does not provide per-vertex colors, the value is vec4(1.0).</li>
<li>TANGENT -&gt; vec3, tangent in the vertex shader. When the mesh for the associated model does not provide tangent data, the value is vec3(0.0).</li>
<li>BINORMAL -&gt; vec3, binormal in the vertex shader. When the mesh for the associated model does not provide binormal data, the value is vec3(0.0).</li>
<li>JOINTS -&gt; ivec4, joint indexes in the vertex shader. When the mesh for the associated model does not provide joint indexes data, the value is ivec4(0).</li>
<li>WEIGHTS -&gt; vec4, joint weights in the vertex shader. When the mesh for the associated model does not provide joint weights data, the value is vec4(0.0).</li>
<li>MORPH_POSITION(<i>n</i>) -&gt; vec3, the <i>n+1</i>th morph target position in the vertex shader. The associated model should provide proper data.</li>
<li>MORPH_NORMAL(<i>n</i>) -&gt; vec3, the <i>n+1</i>th morph target normal in the vertex shader. The associated model should provide proper data.</li>
<li>MORPH_TANGENT(<i>n</i>) -&gt; vec3, the <i>n+1</i>th morph target tangent in the vertex shader. The associated model should provide proper data.</li>
<li>MORPH_BINORMAL(<i>n</i>) -&gt; vec3, the <i>n+1</i>th morph target binormal in the vertex shader. The associated model should provide proper data.</li>
<li>MODELVIEWPROJECTION_MATRIX -&gt; mat4, the model-view-projection matrix. Projection matrices always follow OpenGL conventions, with a baked-in transformation for the Y axis direction and clip depth, depending on the graphics API used at run time.</li>
<li>VIEWPROJECTION_MATRIX -&gt; mat4, the view-projection matrix</li>
<li>PROJECTION_MATRIX -&gt; mat4, the projection matrix</li>
<li>INVERSE_PROJECTION_MATRIX -&gt; mat4, the inverse projection matrix</li>
<li>VIEW_MATRIX -&gt; mat4, the view (camera) matrix</li>
<li>MODEL_MATRIX -&gt; mat4, the model (world) matrix</li>
<li>NORMAL_MATRIX -&gt; mat3, the normal matrix (the transpose of the inverse of the top-left 3x3 part of the model matrix)</li>
<li>BONE_TRANSFORMS -&gt; mat4[], the array of the model's bone matrixes</li>
<li>BONE_NORMAL_TRANSFORMS -&gt; mat3[], the array of the model's bone normal matrixes (the transpose of the inverse of the top-left 3x3 part of the each bone matrixes)</li>
<li>MORPH_WEIGHTS -&gt; float[], the array of the morph weights. The associated model should provide proper data. For safety, <b>QT_MORPH_MAX_COUNT</b> is defined to the size of this array.</li>
<li>CAMERA_POSITION -&gt; vec3, the camera position in world space</li>
<li>CAMERA_DIRECTION -&gt; vec3, the camera direction vector</li>
<li>CAMERA_PROPERTIES -&gt; vec2, the near and far clip values for the camera</li>
<li>POINT_SIZE -&gt; float, writable in the vertex shader only. When rendering geometry with a topology of points, the custom vertex shader must set this to either 1.0 or another value, both in shaded and unshaded custom materials. See <a href="qml-qtquick3d-principledmaterial.html#pointSize-prop" translate="no">PrincipledMaterial::pointSize</a> for further notes on support for sizes other than 1.</li>
</ul>
<h2 id="shaded-custom-materials">Shaded custom materials</h2>
<p>A <a href="qml-qtquick3d-custommaterial.html#shadingMode-prop" translate="no">shaded</a> material <code translate="no">augments</code> the shader code that would be generated by a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a>. Unlike unshaded materials, that provide almost all logic for the vertex and fragment shader main functions on their own, preventing adding generated code for lighting, shadowing, global illumination, etc., shaded materials let shader generation happen normally, as if the CustomMaterial was a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a>. The vertex and fragment shader snippets are expected to provide optional functions that are then invoked at certain points, giving them the possibility to customize the colors and other values that are then used for calculating lighting and the final fragment color.</p>
<p>Rather than implementing just a <code translate="no">MAIN</code> function, the fragment shader for a shaded custom material can implement multiple functions. All functions, including <code translate="no">MAIN</code>, are optional to implement in shaded custom materials. An empty shader snippet, or, even, not specifying the <a href="qml-qtquick3d-custommaterial.html#vertexShader-prop" translate="no">vertexShader</a> or <a href="qml-qtquick3d-custommaterial.html#fragmentShader-prop" translate="no">fragmentShader</a> properties at all can be perfectly valid too.</p>
<h3 id="vertex-shader-snippets-in-a-shaded-custom-material">Vertex shader snippets in a shaded custom material</h3>
<p>The following functions can be implemented in a vertex shader snippet:</p>
<ul>
<li><code translate="no">void MAIN()</code> When present, this function is called in order to set the value of <code translate="no">POSITION</code>, the vec4 output from the vertex shader, and, optionally, to modify the values of <code translate="no">VERTEX</code>, <code translate="no">COLOR</code>, <code translate="no">NORMAL</code>, <code translate="no">UV0</code>, <code translate="no">UV1</code>, <code translate="no">TANGENT</code>, <code translate="no">BINORMAL</code>, <code translate="no">JOINTS</code>, and <code translate="no">WEIGHTS</code>. Unlike in unshaded materials, writing to these makes sense because the modified values are then taken into account in the rest of the generated shader code (whereas for unshaded materials there is no additional shader code generated). For example, if the custom vertex shader displaces the vertices or the normals, it will want to store the modified values to <code translate="no">VERTEX</code> or <code translate="no">NORMAL</code>, to achieve correct lighting calculations afterwards. Additionally, the function can write to variables defined with <code translate="no">VARYING</code> in order to pass interpolated data to the fragment shader. When this function or a redefinition of <code translate="no">POSITION</code> is not present, <code translate="no">POSITION</code> is calculated based on <code translate="no">VERTEX</code> and <code translate="no">MODELVIEWPROJECTION_MATRIX</code>, just like a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a> would do.<p>Example, with relying both on QML properties exposed as uniforms, and also passing data to the fragment shader:</p>
<pre class="cpp plain" translate="no">
 VARYING vec3 vNormal;
 VARYING vec3 vViewVec;

 void MAIN()
 {
     VERTEX.x += sin(uTime * 4.0 + VERTEX.y) * uAmplitude;
     vNormal = normalize(NORMAL_MATRIX * NORMAL);
     vViewVec = CAMERA_POSITION - (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
     POSITION = MODELVIEWPROJECTION_MATRIX * vec4(VERTEX, 1.0);
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>In the above example, assigning a value to <code translate="no">POSITION</code> is optional as the usage in this case is identical to the default behavior.</p>
</div>
</li>
</ul>
<h3 id="fragment-shader-snippets-in-a-shaded-custom-material">Fragment shader snippets in a shaded custom material</h3>
<p>The following functions can be implemented in a fragment shader snippet:</p>
<ul>
<li><code translate="no">void MAIN()</code> When present, this function is called to set the values of the special writable variables <code translate="no">BASE_COLOR</code>, <code translate="no">METALNESS</code>, <code translate="no">ROUGHNESS</code>, <code translate="no">SPECULAR_AMOUNT</code>, NORMAL, and <code translate="no">FRESNEL_POWER</code>.<p>One common use case is to set the value of <code translate="no">BASE_COLOR</code> based on sampling a texture, be it a base color map, <code translate="no">SCREEN_TEXTURE</code>, or some other kind of source. This can be relevant and convenient especially when no custom light processor functions are implemented. Setting <code translate="no">BASE_COLOR.a</code> to something other than the default 1.0 allows affecting the final alpha value of the fragment. (note that this will often require also enabling alpha blending in <a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a> and <a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a>)</p>
<p>Another scenario is when there is no custom <code translate="no">SPECULAR_LIGHT</code> function provided, or when there is a light probe set in the <a href="qml-qtquick3d-sceneenvironment.html" translate="no">SceneEnvironment</a>. The metalness, roughness, and other values that affect the specular contribution calculation can be set in <code translate="no">MAIN</code> to their desired custom values.</p>
<p>The function can write to the following special variables. The values written to these will typically be either hardcoded or be calculated based on QML properties mapped to uniforms. The semantics are identical to <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a>.</p>
<ul>
<li>vec4 <code translate="no">BASE_COLOR</code> - The base color and material alpha value. Corresponds to the <a href="qml-qtquick3d-principledmaterial.html#baseColor-prop" translate="no">built-in materials' color property</a>. When light processor functions are not implemented, it can be convenient to set a custom base color in <code translate="no">MAIN</code> because that is then taken into account in the default lighting calculations. The default value is <code translate="no">vec4(1.0)</code>, meaning white with an alpha of 1.0. The alpha value effects the final alpha of the fragment. The final alpha value is the object (model) opacity multiplied by the base color alpha. When specifying the value directly in shader code, not relying on uniform values exposed from <b>color</b> properties in QML, be aware that it is up to the shader to perform the sRGB to linear conversion, if needed. For example, assuming a <code translate="no">vec3 color</code> and <code translate="no">float alpha</code> this can be achieved like the following:<pre class="cpp plain" translate="no">
 float C1 = 0.305306011;
 vec3 C2 = vec3(0.682171111, 0.682171111, 0.682171111);
 vec3 C3 = vec3(0.012522878, 0.012522878, 0.012522878);
 BASE_COLOR = vec4(rgb * (rgb * (rgb * C1 + C2) + C3), alpha);
</pre>
</li>
<li>vec3 <code translate="no">EMISSIVE_COLOR</code> - The color of self-illumination. Corresponds to the built-in materials' emissive color which is combined by <a href="qml-qtquick3d-principledmaterial.html#emissiveFactor-prop" translate="no">built-in materials's emissiveFactor property</a> and <a href="qml-qtquick3d-principledmaterial.html#emissiveMap-prop" translate="no">built-in materials's emissiveMap property</a>. The default value is <code translate="no">vec3(0.0)</code>. When specifying the value directly in shader code, not relying on uniform values exposed from <b>color</b> properties in QML, be aware that it is up to the shader to perform the sRGB to linear conversion, if needed.</li>
<li>float <code translate="no">METALNESS</code> Metalness amount in range 0.0 - 1.0. The default value is 0. Must be set to a non-zero value to have effect.</li>
<li>float <code translate="no">ROUGHNESS</code> Roughness value in range 0.0 - 1.0. The default value is 0.</li>
<li>float <code translate="no">FRESNEL_POWER</code> Specifies the fresnel power. A typical value, and also the default, is <code translate="no">5.0</code> as that is what a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a> would use.</li>
<li>float <code translate="no">SPECULAR_AMOUNT</code> Specular amount in range 0.0 - 1.0. The default value is <code translate="no">0.5</code>, matching <a href="qml-qtquick3d-principledmaterial.html#specularAmount-prop" translate="no">PrincipledMaterial::specularAmount</a>. Must be set to a non-zero value to have effect.</li>
<li>vec3 <code translate="no">NORMAL</code> - The normal that comes from the vertex shader in world space. While this property has the same initial value as <code translate="no">VAR_WORLD_NORMAL</code>, only changing the value of <code translate="no">NORMAL</code> will have an effect on lighting.</li>
<li>vec3 <code translate="no">TANGENT</code> - The tanget that comes from the vertex shader in world space. This value is potentially adjusted for double-sidedness.</li>
<li>vec3 <code translate="no">BINORMAL</code> - The binormal that comes from the vertex shader in world space. This value is potentially adjusted for double-sidedness.</li>
<li>vec2 <code translate="no">UV0</code> - The first set of texture coordinates from the vertex shader. This property is readonly in the fragment shader.</li>
<li>vec2 <code translate="no">UV1</code> - The second set of texture coordinates from the vertex shader. This property is readonly in the fragment shader.</li>
</ul>
<div class="admonition note">
<p><b>Note: </b>Unlike with unshaded materials, the fragment <code translate="no">MAIN</code> for a shaded material has no direct control over <code translate="no">FRAGCOLOR</code>. Rather, it is the <code translate="no">DIFFUSE</code> and <code translate="no">SPECULAR</code> values written in the light processor functions that decide what the final fragment color is. When a light processor function is not implemented, the relevant default shading calculations are performed as with a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a>, taking <code translate="no">BASE_COLOR</code> and other values from the list above into account.</p>
</div>
<p>An example of a simple, metallic custom material shader could be the following:</p>
<pre class="cpp plain" translate="no">
 void MAIN()
 {
     METALNESS = 1.0;
     ROUGHNESS = 0.5;
     FRESNEL_POWER = 5.0;
 }
</pre>
<p>Another example, where the base color and alpha are set by sampling a texture:</p>
<pre class="cpp plain" translate="no">
 VARYING vec2 texcoord;
 void MAIN()
 {
     BASE_COLOR = texture(uColorMap, texcoord);
 }
</pre>
</li>
<li><code translate="no">void AMBIENT_LIGHT()</code> When present, this function is called once for each fragment. The task of the function is to add the total ambient contribution to a writable special variable <code translate="no">DIFFUSE</code>. It can of course choose to calculate a different value, or not touch <code translate="no">DIFFUSE</code> at all (to ignore ambient lighting completely). When this function is not present at all, the ambient contribution is calculated normally, like a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p>
<ul>
<li>vec3 <code translate="no">DIFFUSE</code> Accumulates the diffuse light contributions, per fragment. The light processor functions will typically add (<code translate="no">+=</code>) to it, since overwriting the value would lose the contribution from other lights.</li>
</ul>
<p>The function can read the following special variables, in addition to the matrix (such as, <code translate="no">MODEL_MATRIX</code>) and vector (such as, <code translate="no">CAMERA_POSITION</code>) uniforms from the table above:</p>
<ul>
<li>vec3 <code translate="no">TOTAL_AMBIENT_COLOR</code> The total ambient contribution in the scene.</li>
</ul>
<p>Example:</p>
<pre class="cpp plain" translate="no">
 void AMBIENT_LIGHT()
 {
     DIFFUSE += TOTAL_AMBIENT_COLOR;
 }
</pre>
</li>
<li><code translate="no">void DIRECTIONAL_LIGHT()</code> When present, this function is called for each active directional light in the scene for each fragment. The task of the function is to add the diffuse contribution to a writable special variable <code translate="no">DIFFUSE</code>. The function can also choose to do nothing, in which case diffuse contributions from directional lights are ignored. When the function is not present at all, the diffuse contributions from directional lights are accumulated normally, like a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p>
<ul>
<li>vec3 <code translate="no">DIFFUSE</code> Accumulates the diffuse light contributions, per fragment. The light processor functions will typically add (<code translate="no">+=</code>) to it, since overwriting the value would lose the contribution from other lights.</li>
</ul>
<p>The function can read the following special variables, in addition to the matrix (such as, <code translate="no">MODEL_MATRIX</code>) and vector (such as, <code translate="no">CAMERA_POSITION</code>) uniforms from the table above:</p>
<ul>
<li>vec3 <code translate="no">LIGHT_COLOR</code> Diffuse light color.</li>
<li>float <code translate="no">SHADOW_CONTRIB</code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</li>
<li>vec3 <code translate="no">TO_LIGHT_DIR</code> Vector pointing towards the light source.</li>
<li>vec3 <code translate="no">NORMAL</code> The normal vector in world space.</li>
<li>vec4 <code translate="no">BASE_COLOR</code> The base color and material alpha value.</li>
<li>float <code translate="no">METALNESS</code> The Metalness amount.</li>
<li>float <code translate="no">ROUGHNESS</code> The Roughness amount.</li>
</ul>
<p>Example:</p>
<pre class="cpp plain" translate="no">
 void DIRECTIONAL_LIGHT()
 {
     DIFFUSE += LIGHT_COLOR * SHADOW_CONTRIB * vec3(max(0.0, dot(normalize(VAR_WORLD_NORMAL), TO_LIGHT_DIR)));
 }
</pre>
</li>
<li><code translate="no">void POINT_LIGHT()</code> When present, this function is called for each active point light in the scene for each fragment. The task of the function is to add the diffuse contribution to a writable special variable <code translate="no">DIFFUSE</code>. The function can also choose to do nothing, in which case diffuse contributions from point lights are ignored. When the function is not present at all, the diffuse contributions from point lights are accumulated normally, like a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p>
<ul>
<li>vec3 <code translate="no">DIFFUSE</code> Accumulates the diffuse light contributions, per fragment.</li>
</ul>
<p>The function can read the following special variables, in addition to the matrix (such as, <code translate="no">MODEL_MATRIX</code>) and vector (such as, <code translate="no">CAMERA_POSITION</code>) uniforms from the table above:</p>
<ul>
<li>vec3 <code translate="no">LIGHT_COLOR</code> Diffuse light color.</li>
<li>float <code translate="no">LIGHT_ATTENUATION</code> Light attenuation.</li>
<li>float <code translate="no">SHADOW_CONTRIB</code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</li>
<li>vec3 <code translate="no">TO_LIGHT_DIR</code> Vector pointing towards the light source.</li>
<li>vec3 <code translate="no">NORMAL</code> The normal vector in world space.</li>
<li>vec4 <code translate="no">BASE_COLOR</code> The base color and material alpha value.</li>
<li>float <code translate="no">METALNESS</code> The Metalness amount.</li>
<li>float <code translate="no">ROUGHNESS</code> The Roughness amount.</li>
</ul>
<p>Example:</p>
<pre class="cpp plain" translate="no">
 void POINT_LIGHT()
 {
     DIFFUSE += LIGHT_COLOR * LIGHT_ATTENUATION * SHADOW_CONTRIB * vec3(max(0.0, dot(normalize(VAR_WORLD_NORMAL), TO_LIGHT_DIR)));
 }
</pre>
</li>
<li><code translate="no">void SPOT_LIGHT()</code> When present, this function is called for each active spot light in the scene for each fragment. The task of the function is to add the diffuse contribution to a writable special variable <code translate="no">DIFFUSE</code>. The function can also choose to do nothing, in which case diffuse contributions from spot lights are ignored. When the function is not present at all, the diffuse contributions from spot lights are accumulated normally, like a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p>
<ul>
<li>vec3 <code translate="no">DIFFUSE</code> Accumulates the diffuse light contributions, per fragment.</li>
</ul>
<p>The function can read the following special variables, in addition to the matrix (such as, <code translate="no">MODEL_MATRIX</code>) and vector (such as, <code translate="no">CAMERA_POSITION</code>) uniforms from the table above:</p>
<ul>
<li>vec3 <code translate="no">LIGHT_COLOR</code> Diffuse light color.</li>
<li>float <code translate="no">LIGHT_ATTENUATION</code> Light attenuation.</li>
<li>float <code translate="no">SHADOW_CONTRIB</code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</li>
<li>vec3 <code translate="no">TO_LIGHT_DIR</code> Vector pointing towards the light source.</li>
<li>float <code translate="no">SPOT_FACTOR</code> Spot light factor.</li>
<li>vec3 <code translate="no">NORMAL</code> The normal vector in world space.</li>
<li>vec4 <code translate="no">BASE_COLOR</code> The base color and material alpha value.</li>
<li>float <code translate="no">METALNESS</code> The Metalness amount.</li>
<li>float <code translate="no">ROUGHNESS</code> The Roughness amount.</li>
</ul>
<p>Example:</p>
<pre class="cpp plain" translate="no">
 void SPOT_LIGHT()
 {
     DIFFUSE += LIGHT_COLOR * LIGHT_ATTENUATION * SPOT_FACTOR * SHADOW_CONTRIB * vec3(max(0.0, dot(normalize(VAR_WORLD_NORMAL), TO_LIGHT_DIR)));
 }
</pre>
</li>
<li><code translate="no">void SPECULAR_LIGHT()</code> When present, this function is called for each active light in the scene for each fragment. The task of the function is to add the specular contribution to a writable special variable <code translate="no">SPECULAR</code>. The function can also choose to do nothing, in which case specular contributions from lights are ignored. When the function is not present at all, the specular contributions from lights are accumulated normally, like a <a href="qml-qtquick3d-principledmaterial.html" translate="no">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p>
<ul>
<li>vec3 <code translate="no">SPECULAR</code> Accumulates the specular light contributions, per frament. The light processor functions will typically add (<code translate="no">+=</code>) to it, since overwriting the value would lose the contribution from other lights.</li>
</ul>
<p>The function can read the following special variables, in addition to the matrix (such as, <code translate="no">MODEL_MATRIX</code>) and vector (such as, <code translate="no">CAMERA_POSITION</code>) uniforms from the table above:</p>
<ul>
<li>vec3 <code translate="no">LIGHT_COLOR</code> Specular light color.</li>
<li>float <code translate="no">LIGHT_ATTENUATION</code> Light attenuation. For directional lights the value is 1.0. For spot lights the value is the same as <code translate="no">LIGHT_ATTENUATION * SPOT_FACTOR</code> of <code translate="no">void SPOT_LIGHT()</code>.</li>
<li>float <code translate="no">SHADOW_CONTRIB</code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</li>
<li>vec3 <code translate="no">FRESNEL_CONTRIB</code> Fresnel contribution from built in Fresnel calculation.</li>
<li>vec3 <code translate="no">TO_LIGHT_DIR</code> Vector pointing towards the light source.</li>
<li>vec3 <code translate="no">NORMAL</code> The normal vector in world space.</li>
<li>vec4 <code translate="no">BASE_COLOR</code> The base color and material alpha value.</li>
<li>float <code translate="no">METALNESS</code> The Metalness amount.</li>
<li>float <code translate="no">ROUGHNESS</code> The Roughness amount.</li>
<li>float <code translate="no">SPECULAR_AMOUNT</code> The specular amount. This value will be between 0.0 and 1.0 will be the same value set in the custom <code translate="no">MAIN</code> function. This value will useful for calculating Fresnel contributions when not using the built-in Fresnel contribution provided by <code translate="no">FRESNEL_CONTRIB</code>.</li>
</ul>
<pre class="cpp plain" translate="no">
 void SPECULAR_LIGHT()
 {
     vec3 H = normalize(VIEW_VECTOR + TO_LIGHT_DIR);
     float cosAlpha = max(0.0, dot(H, normalize(NORMAL)));
     float shine = pow(cosAlpha, exp2(15.0 * (1.0 - ROUGHNESS) + 1.0) * 0.25);
     SPECULAR += shine * LIGHT_COLOR * FRESNEL_CONTRIB * SHADOW_CONTRIB * LIGHT_ATTENUATION;
 }
</pre>
</li>
<li><code translate="no">void POST_PROCESS()</code> When present, this function is called at the end of the fragment pipeline. The task of the function is to finalize <code translate="no">COLOR_SUM</code> with final diffuse, specular and emissive terms. Unlike <code translate="no">FRAGCOLOR</code> for a unshaded material, <code translate="no">COLOR_SUM</code> will be automatically tonemapped before written to the framebuffer. For debugging purposes it is sometimes useful to output a value that should not be treated as a color. To avoid the tonemapping distorting this value it can be disabled by setting the <a href="qml-qtquick3d-sceneenvironment.html#tonemapMode-prop" translate="no">tonemapMode</a> property to <code translate="no">TonemapModeNone</code><p>The function can write to the following special variables:</p>
<ul>
<li>vec4 <code translate="no">COLOR_SUM</code> the output from the fragment shader. The default value is vec4(DIFFUSE.rgb + SPECULAR + EMISSIVE, DIFFUSE.a)</li>
</ul>
<p>The function can read the following special variables.</p>
<ul>
<li>vec4 <code translate="no">DIFFUSE</code> The final diffuse term of the fragment pipeline.</li>
<li>vec3 <code translate="no">SPECULAR</code> The final specular term of the fragment pipeline.</li>
<li>vec3 <code translate="no">EMISSIVE</code> The final emissive term of the fragment pipeline.</li>
<li>vec2 <code translate="no">UV0</code> - The first set of texture coordinates from the vertex shader.</li>
<li>vec2 <code translate="no">UV1</code> - The second set of texture coordinates from the vertex shader.</li>
</ul>
<pre class="cpp plain" translate="no">
 void POST_PROCESS()
 {
     float center_x = textureSize(SCREEN_TEXTURE, 0).x * 0.5;
     if (gl_FragCoord.x &gt; center_x)
         COLOR_SUM = DIFFUSE;
     else
         COLOR_SUM = vec4(EMISSIVE, DIFFUSE.a);
 }
</pre>
</li>
<li><code translate="no">void IBL_PROBE()</code> When present, this function is called for IBL (Image-Based Lighting). The task of the function is to add both the diffuse and the specular contributions of IBL to writable special variables <code translate="no">DIFFUSE</code> and <code translate="no">SPECULAR</code>.<p>The function can write to the following special variables:</p>
<ul>
<li>vec3 <code translate="no">DIFFUSE</code> Accumulates the diffuse light contributions, per fragment.</li>
<li>vec3 <code translate="no">SPECULAR</code> Accumulates the specular light contributions, per frament.</li>
</ul>
<p>The function can read the following special variables.</p>
<ul>
<li>vec4 <code translate="no">BASE_COLOR</code> The base color and material alpha value.</li>
<li>float <code translate="no">AO_FACTOR</code> The screen space occlusion factor.</li>
<li>float <code translate="no">SPECULAR_AMOUNT</code> The specular amount.</li>
<li>float <code translate="no">ROUGHNESS</code> The final emissive term of the fragment pipeline.</li>
<li>vec3 <code translate="no">NORMAL</code> The normal vector in world space.</li>
<li>vec3 <code translate="no">VIEW_VECTOR</code> Points towards the camera.</li>
<li>mat3 <code translate="no">IBL_ORIENTATION</code> The orientation of the light probe. It comes from <a href="qml-qtquick3d-sceneenvironment.html#probeOrientation-prop" translate="no">SceneEnvironment::probeOrientation</a>.</li>
</ul>
<pre class="cpp plain" translate="no">
 void IBL_PROBE()
 {
     vec3 smpDir = IBL_ORIENTATION * NORMAL;
     DIFFUSE += AO_FACTOR * BASE_COLOR.rgb * textureLod(IBL_TEXTURE, smpDir, IBL_MAXMIPMAP).rgb;
 }
</pre>
</li>
</ul>
<h3 id="custom-variables-between-functions">Custom variables between functions</h3>
<p>Additional variables can be delivered from the MAIN function to the others. The <code translate="no">SHARED_VARS</code> keyword can be used for defining new custom variables. These user-defined variables can be accessed with SHARED.&lt;variable name&gt;.</p>
<p>For example, a shaded custom material can fetch a shared value in the MAIN and use it in other functions.</p>
<pre class="cpp plain" translate="no">
 SHARED_VARS {
     vec3 colorThreshold;
 };
 void MAIN()
 {
     BASE_COLOR = texture(baseColorMap, UV0);
     SHARED.colorThreshold = texture(thresholdMap, UV0).rgb;
 }
 void DIRECTIONAL_LIGHT()
 {
     if (DIFFUSE &gt;= SHARED.colorThreshold) {
         DIFFUSE = SHARED.colorThreshold;
         return;
     }
     DIFFUSE += LIGHT_COLOR * SHADOW_CONTRIB;
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>SHARED can be written on all the functions without POST_PROCESS but it is safe to write it on MAIN and read on the other functions.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>A recommended use case to write SHARED on LIGHT functions is reseting it on MAIN first and then accumulating it on each LIGHT functions.</p>
</div>
<pre class="cpp plain" translate="no">
 SHARED_VARS {
     float sheenIntensity;
     float sheenRoughness;
     vec3 sheenColor;
     vec3 outSheenColor;
 };
 void MAIN()
 {
     ...
     vec4 tex = texture(uSheenMap, UV0);
     SHARED.sheenColor = tex.rgb;
     SHARED.sheenIntensity = tex.a;
     SHARED.sheenRoughness = uSheenRoughness;
     SHARED.outSheenColor = vec3(0.0);
 }
 void SPECULAR_LIGHT()
 {
     SHARED.outSheenColor += ...;
 }
 void POST_PROCESS()
 {
     COLOR_SUM = DIFFUSE + SPECULAR + EMISSIVE + SHARED.outSheenColor;
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>MAIN is called before others, and POST_PROCESS after all others, but that there is no guarantee for any other ordering for light processors.</p>
</div>
<h3 id="additional-special-keywords">Additional special keywords</h3>
<p>The custom fragment shader code can freely access uniforms (such as, <code translate="no">CAMERA_DIRECTION</code> or <code translate="no">CAMERA_POSITION</code>), and varyings passed on from the custom vertex shader. Additionally, there are a number of built-in varyings available as special keywords. Some of these are optional in the sense that a vertex <code translate="no">MAIN</code> could calculate and pass on these on its own, but to reduce duplicated data fragment shaders can also rely on these built-ins instead. These built-ins are available in light processor functions and in the fragment MAIN.</p>
<ul>
<li>vec3 <code translate="no">VAR_WORLD_NORMAL</code> - Interpolated normal transformed by <code translate="no">NORMAL_MATRIX</code>.</li>
<li>vec3 <code translate="no">VAR_WORLD_TANGENT</code> - Interpolated tangent transformed by <code translate="no">MODEL_MATRIX</code>.</li>
<li>vec3 <code translate="no">VAR_WORLD_BINORMAL</code> - Interpolated binormal transformed by <code translate="no">MODEL_MATRIX</code></li>
<li>vec3 <code translate="no">NORMAL</code> - Unlike <code translate="no">VAR_WORLD_NORMAL</code>, which is the interpolated normal as-is, this value is potentially adjusted for double-sidedness: when rendering with culling disabled, the normal will get inverted as necessary. Therefore lighting and other calculations are recommended to use <code translate="no">NORMAL</code> instead of <code translate="no">VAR_WORLD_NORMAL</code> in order behave correctly with all culling modes.</li>
<li>vec3 <code translate="no">TANGENT</code> - Like <code translate="no">NORMAL</code>, this value is potentially adjusted for double-sidedness: when rendering with culling disabled, the tangent will get inverted as necessary.</li>
<li>vec3 <code translate="no">BINORMAL</code> - Like <code translate="no">NORMAL</code>, this value is potentially adjusted for double-sidedness: when rendering with culling disabled, the binormal will get inverted as necessary.</li>
<li>vec3 <code translate="no">VAR_WORLD_POSITION</code> - Interpolated world space vertex position (<code translate="no">(MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz</code>)</li>
<li>vec4 <code translate="no">VAR_COLOR</code> - The interpolated vertex color when colors are provided in the mesh. <code translate="no">vec4(1.0)</code> otherwise.</li>
<li>vec3 <code translate="no">VIEW_VECTOR</code> - Points towards the camera. This is effectively the <code translate="no">CAMERA_POSITION - VAR_WORLD_POSITION</code> vector normalized.</li>
<li>vec4 <code translate="no">FRAGCOORD</code> - Contains the window-relative coordinates of the current fragment.</li>
<li>float <code translate="no">FRAMEBUFFER_Y_UP</code> - The value is <code translate="no">1</code> when the Y axis points up in the coordinate system for framebuffers (textures), meaning <code translate="no">(0, 0)</code> is the bottom-left corner. The value is <code translate="no">-1</code> when the Y axis points down, <code translate="no">(0, 0)</code> being the top-left corner. Such differences in the underlying graphics APIs do not concern most custom materials. One notable exception is sampling <code translate="no">SCREEN_TEXTURE</code> with texture coordinates <b>not</b> based on <code translate="no">FRAGCOORD</code>. As the orientation of <code translate="no">SCREEN_TEXTURE</code> is tied to the underlying graphics API by nature, using texture coordinates from a mesh may need appropriate adjustments to the Y coordinate.<p>For example, the following fragment shader, suitable for Rectangle or Cube meshes, will display the opaque objects from the scene on the model:</p>
<pre class="cpp plain" translate="no">
 VARYING vec2 texcoord;
 void MAIN()
 {
     vec2 screencoord = texcoord;
     if (FRAMEBUFFER_Y_UP &lt; 0.0) // effectively: if not OpenGL
         screencoord.y = 1.0 - screencoord.y;
     BASE_COLOR = texture(SCREEN_TEXTURE, screencoord);
 }
</pre>
<p>When sampling textures other than <code translate="no">SCREEN_TEXTURE</code> and <code translate="no">DEPTH_TEXTURE</code>, or when <code translate="no">FRAGCOORD</code> is used to calculate the texture coordinate (which would be the typical use case for accessing the screen and depth textures), such an adjustment is not necessary.</p>
</li>
<li>float <code translate="no">NDC_Y_UP</code> - The value is <code translate="no">1</code> when the Y axis points up in normalized device coordinate space, and <code translate="no">-1</code> when the Y axis points down. Y pointing down is the case when rendering happens with Vulkan. Most materials do not need to be concerned by this, but being able to branch based on this can become useful in certain advanced use cases.</li>
<li>float <code translate="no">NEAR_CLIP_VALUE</code> - The value is <code translate="no">-1</code> for when the clipping plane range's starts at <code translate="no">-1</code> and goes to <code translate="no">1</code>. This is true when using OpenGL for rendering. For other rendering backends the value of this property will be <code translate="no">0</code> meaning the clipping plane range is <code translate="no">0</code> to <code translate="no">1</code>. This value is useful with certain techniques involving the <code translate="no">DEPTH_TEXTURE</code><p>For example, the following fragment shader demonstrates a technique for reconstructing the position of a value from the depth buffer to determine the distance from the current position being rendered. When used in combination with <code translate="no">INVERSE_PROJECTION_MATRIX</code> the value of depth needs to be in normalized device coordinates so it is important to make sure that the range of depth value reflects that. When the <code translate="no">NEAR_CLIP_VALUE</code> is <code translate="no">-1</code> then the depth value gets scaled to be between <code translate="no">-1</code> and <code translate="no">1</code>.</p>
<pre class="cpp plain" translate="no">
 void MAIN() {
     vec2 screen_uv = FRAGCOORD.xy / vec2(textureSize(SCREEN_TEXTURE, 0));
     float depth = texture(DEPTH_TEXTURE, screen_uv).r;

     if (NEAR_CLIP_VALUE &lt; 0.0) // effectively: if opengl
         depth = depth * 2.0 - 1.0;

     vec4 unproject = INVERSE_PROJECTION_MATRIX * vec4(screen_uv, depth, 1.0);
     depth = (unproject.xyz / unproject.w).z;
     float viewVectorZ = (VIEW_MATRIX * vec4(VAR_WORLD_POSITION, 1.0)).z;
     depth = viewVectorZ - depth;

     BASE_COLOR = vec4(depth, depth, depth, 1.0);
 }
</pre>
</li>
<li>float <code translate="no">IBL_EXPOSE</code> - The amount of light emitted by the light probe. It comes from <a href="qml-qtquick3d-sceneenvironment.html#probeExposure-prop" translate="no">SceneEnvironment::probeExposure</a>.<pre class="cpp plain" translate="no">
 DIFFUSE += AO_FACTOR * IBL_EXPOSE * BASE_COLOR.rgb * textureLod(IBL_TEXTURE, NORMAL, IBL_MAXMIPMAP).rgb;
</pre>
</li>
<li>float <code translate="no">IBL_HORIZON</code> - The horizontal cut-off value of reflections from the lower half environment. It comes from <a href="qml-qtquick3d-sceneenvironment.html#probeHorizon-prop" translate="no">Horizon Cut-Off</a> but remapped to [-1, 0).<pre class="cpp plain" translate="no">
 vec3 diffuse += AO_FACTOR * IBL_EXPOSE * BASE_COLOR.rgb * textureLod(IBL_TEXTURE, NORMAL, IBL_MAXMIPMAP).rgb;
 if (IBL_HORIZON &gt; -1.0) {
     float ctr = 0.5 + 0.5 * IBL_HORIZON;
     float vertWt = smoothstep(ctr * 0.25, ctr + 0.25, NORMAL.y);
     float wtScaled = mix(1.0, vertWt, IBL_HORIZON + 1.0);
     diffuse *= wtScaled;
 }
</pre>
</li>
<li>float <code translate="no">IBL_MAXMIPMAP</code> - The maximum mipmap level of IBL_TEXTURE.</li>
</ul>
<h3 id="instancing">Instancing</h3>
<p>When doing instanced rendering, some of the keywords above do not apply. The following keywords are only available with instancing:</p>
<ul>
<li><code translate="no">INSTANCE_MODEL_MATRIX</code> -&gt; mat4, replacement for <code translate="no">MODEL_MATRIX</code>, including the instancing transformation.</li>
<li><code translate="no">INSTANCE_MODELVIEWPROJECTION_MATRIX</code> -&gt; mat4, replacement for <code translate="no">MODELVIEWPROJECTION_MATRIX</code>, including the instancing transformation.</li>
<li><code translate="no">INSTANCE_COLOR</code> -&gt; vec4, the instance color: to be combined with <code translate="no">COLOR</code>.</li>
<li><code translate="no">INSTANCE_DATA</code> -&gt; vec4, instance custom data.</li>
<li><code translate="no">INSTANCE_INDEX</code> -&gt; int, the instance number, and index into the instancing table.</li>
</ul>
<h2 id="screen-depth-and-other-textures">Screen, depth, and other textures</h2>
<p>The rendering pipeline can expose a number of textures to the custom material shaders with content from special render passes. This applies both to shaded and unshaded custom materials.</p>
<p>For example, a shader may want access to a depth texture that contains the depth buffer contents for the opaque objects in the scene. This is achieved by sampling <code translate="no">DEPTH_TEXTURE</code>. Such a texture is not normally generated, unless there is a real need for it. Therefore, the presence of the following keywords in the vertex or fragment shader also acts as a toggle for opting in to the - potentially expensive - passes for generating the texture in question. (of course, it could be that some of these become already enabled due to other settings, such as the ambient occlusion parameters in <a href="qml-qtquick3d-sceneenvironment.html" translate="no">SceneEnvironment</a> or due to a post-processing effect relying on the depth texture, in which case the textures in question are generated regardless of the custom material and so sampling these special textures in the material comes at no extra cost apart from the texture access itself)</p>
<ul>
<li><code translate="no">SCREEN_TEXTURE</code> - When present, a texture (sampler2D) with the color buffer from a rendering pass containing the contents of the scene excluding any transparent materials or any materials also using the SCREEN_TEXTURE is exposed to the shader under this name. The texture can be used for techniques that require the contents of the framebuffer they are being rendered to. The SCREEN_TEXTURE texture uses the same clear mode as the <a href="qml-qtquick3d-view3d.html" translate="no">View3D</a>. The size of these textures matches the size of the <a href="qml-qtquick3d-view3d.html" translate="no">View3D</a> in pixels. For example, a fragment shader could contain the following:<pre class="cpp plain" translate="no">
 vec2 uv = FRAGCOORD.xy / vec2(textureSize(SCREEN_TEXTURE, 0));
 vec2 displace = vec2(0.1);
 vec4 c = texture(SCREEN_TEXTURE, uv + displace);
</pre>
<p>Be aware that using <code translate="no">SCREEN_TEXTURE</code> requires appropriate, conscious design of the scene. Objects using such materials have to be positioned carefully, typically above all other objects that are expected to be visible in the texture. Objects that employ semi-transparency in some form are never part of the <code translate="no">SCREEN_TEXTURE</code>. Often <code translate="no">SCREEN_TEXTURE</code> will be used in combination with <code translate="no">BASE_COLOR</code> in <code translate="no">MAIN</code>. For example, the following custom fragment shader applies an emboss effect, while keeping fragments not touched by opaque objects transparent. This assumes that the object with the material is placed in the front, and that it has blending enabled.</p>
<pre class="cpp plain" translate="no">
 void MAIN()
 {
     vec2 size = vec2(textureSize(SCREEN_TEXTURE, 0));
     vec2 uv = FRAGCOORD.xy / size;

     // basic emboss effect
     vec2 d = vec2(1.0 / size.x, 1.0 / size.y);
     vec4 diff = texture(SCREEN_TEXTURE, uv + d) - texture(SCREEN_TEXTURE, uv - d);
     float c = (diff.x + diff.y + diff.z) + 0.5;

     float alpha = texture(SCREEN_TEXTURE, uv).a;
     BASE_COLOR = vec4(vec3(c), alpha);
 }
</pre>
</li>
<li><code translate="no">SCREEN_MIP_TEXTURE</code> - Identical to <code translate="no">SCREEN_TEXTURE</code> in most ways, the difference being that this texture has mipmaps generated. This can be an expensive feature performance-wise, depending on the screen size, and due to having to generate the mipmaps every time the scene is rendered. Therefore, prefer using <code translate="no">SCREEN_TEXTURE</code> always, unless a technique relying on the texture mip levels (e.g. using <code translate="no">textureLod</code> in the shader) is implemented by the custom material.</li>
<li><code translate="no">DEPTH_TEXTURE</code> - When present, a texture (sampler2D) with the (non-linearized) depth buffer contents is exposed to the shader under this name. Only opaque objects are included. For example, a fragment shader could contain the following:<pre class="cpp plain" translate="no">
 ivec2 dtSize = textureSize(DEPTH_TEXTURE, 0);
 vec2 dtUV = (FRAGCOORD.xy) / vec2(dtSize);
 vec4 depthSample = texture(DEPTH_TEXTURE, dtUV);
 float zNear = CAMERA_PROPERTIES.x;
 float zFar = CAMERA_PROPERTIES.y;
 float zRange = zFar - zNear;
 float z_n = 2.0 * depthSample.r - 1.0;
 float d = 2.0 * zNear * zFar / (zFar + zNear - z_n * zRange);
 d /= zFar;
</pre>
</li>
<li><code translate="no">AO_TEXTURE</code> - When present and screen space ambient occlusion is enabled (meaning when the AO strength and distance are both non-zero) in <a href="qml-qtquick3d-sceneenvironment.html" translate="no">SceneEnvironment</a>, the SSAO texture (sampler2D) is exposed to the shader under this name. Sampling this texture can be useful in unshaded materials. Shaded materials have ambient occlusion support built in. This means that the ambient occlusion factor is taken into account automatically. Whereas in a fragment shader for an unshaded material one could write the following to achieve the same:<pre class="cpp plain" translate="no">
 ivec2 aoSize = textureSize(AO_TEXTURE, 0);
 vec2 aoUV = (FRAGCOORD.xy) / vec2(aoSize);
 float aoFactor = texture(AO_TEXTURE, aoUV).x;
</pre>
</li>
<li><code translate="no">IBL_TEXTURE</code> - It will not enable any special rendering pass, but it can be used when the material has <a href="qml-qtquick3d-material.html#lightProbe-prop" translate="no">Material::lightProbe</a> or the model is in the scope of <a href="qml-qtquick3d-sceneenvironment.html#lightProbe-prop" translate="no">SceneEnvironment::lightProbe</a>.<pre class="cpp plain" translate="no">
 void IBL_PROBE()
 {
     DIFFUSE += AO_FACTOR * BASE_COLOR.rgb * textureLod(IBL_TEXTURE, NORMAL, IBL_MAXMIPMAP).rgb;
 }
</pre>
</li>
</ul>
<p><b>See also </b><a href="qml-qtquick3d-sceneenvironment.html#tonemapMode-prop" translate="no">SceneEnvironment::tonemapMode</a>, <a href="quick3d-asset-conditioning-ibl.html" translate="no">Using Image-Based Lighting</a>, <a href="qtquick3d-customshaders-example.html" translate="no">Qt Quick 3D - Custom Shaders Example</a>, <a href="qtquick3d-custommaterial-example.html" translate="no">Qt Quick 3D - Custom Materials Example</a>, and <a href="qtquick3d-custom.html" translate="no">Programmable Materials, Effects, Geometry, and Texture data</a>.</p>
<!-- @@@CustomMaterial -->
<h2>Property Documentation</h2>
<!-- $$$alwaysDirty -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="alwaysDirty-prop">
<td class="tblQmlPropNode"><p>
<span class="name">alwaysDirty</span> : <span class="type"><a href="../qtqml/qml-bool.html" translate="no">bool</a></span></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Specifies that the material state is always dirty, which indicates that the material needs to be refreshed every time it is used by the <a href="qtquick3d-qmlmodule.html" translate="no">QtQuick3D</a>.</p>
</div></div><!-- @@@alwaysDirty -->
<br/>
<!-- $$$destinationAlphaBlend -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="destinationAlphaBlend-prop">
<td class="tblQmlPropNode"><p>
<span class="name">destinationAlphaBlend</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span> <code class="details extra" translate="no">[since 6.7]</code></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Specifies the destination alpha blend factor. The default value is <code translate="no">CustomMaterial.NoBlend</code>. This value is only actively used if <a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a> and <a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a> is set to a non-default value.</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.NoBlend</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.Zero</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.One</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusSrcColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.DstColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusDstColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusSrcAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.DstAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusDstAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.ConstantColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusConstantColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.ConstantAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusConstantAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcAlphaSaturate</code></td></tr>
</table></div>
<div class="admonition note">
<p><b>Note: </b>For backwards compatibility purposes, when left to its default value, will be assigned the same value as <a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a> when <a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a> and <a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a> is set to non-default values.</p>
</div>
<p>This property was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a>.</p>
</div></div><!-- @@@destinationAlphaBlend -->
<br/>
<!-- $$$destinationBlend -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="destinationBlend-prop">
<td class="tblQmlPropNode"><p>
<span class="name">destinationBlend</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Specifies the destination blend factor. The default value is <code translate="no">CustomMaterial.NoBlend</code>.</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.NoBlend</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.Zero</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.One</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusSrcColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.DstColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusDstColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusSrcAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.DstAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusDstAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.ConstantColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusConstantColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.ConstantAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusConstantAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcAlphaSaturate</code></td></tr>
</table></div>
<div class="admonition note">
<p><b>Note: </b>Both <a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a> and destinationBlend needs to be set to a non-default value before blending is enabled.</p>
</div>
<p><b>See also </b><a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a>.</p>
</div></div><!-- @@@destinationBlend -->
<br/>
<!-- $$$fragmentShader -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="fragmentShader-prop">
<td class="tblQmlPropNode"><p>
<span class="name">fragmentShader</span> : <span class="type"><a href="../qtqml/qml-url.html" translate="no">url</a></span></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Specfies the file with the snippet of custom fragment shader code.</p>
<p>The value is a URL and must either be a local file or use the qrc scheme to access files embedded via the Qt resource system. Relative file paths (without a scheme) are also accepted, in which case the file is treated as relative to the component (the <code translate="no">.qml</code> file).</p>
<p><b>See also </b><a href="qml-qtquick3d-custommaterial.html#vertexShader-prop" translate="no">vertexShader</a>.</p>
</div></div><!-- @@@fragmentShader -->
<br/>
<!-- $$$lineWidth -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="lineWidth-prop">
<td class="tblQmlPropNode"><p>
<span class="name">lineWidth</span> : <span class="type"><a href="../qtqml/qml-real.html" translate="no">real</a></span></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>This property determines the width of the lines rendered, when the geometry is using a primitive type of lines or line strips. The default value is 1.0. This property is not relevant when rendering other types of geometry, such as, triangle meshes.</p>
<div class="admonition warning">
<p><b>Warning: </b>Line widths other than 1 may not be suported at run time, depending on the underlying graphics API. When that is the case, the request to change the width is ignored. For example, none of the following can be expected to support wide lines: Direct3D, Metal, OpenGL with core profile contexts.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Unlike the line width, the value of which is part of the graphics pipeline object, the point size for geometries with a topology of points is controlled by the vertex shader (when supported), and has therefore no corresponding QML property.</p>
</div>
</div></div><!-- @@@lineWidth -->
<br/>
<!-- $$$shadingMode -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="shadingMode-prop">
<td class="tblQmlPropNode"><p>
<span class="name">shadingMode</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Specifies the type of the material. The default value is Shaded.</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.Unshaded</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.Shaded</code></td></tr>
</table></div>
</div></div><!-- @@@shadingMode -->
<br/>
<!-- $$$sourceAlphaBlend -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="sourceAlphaBlend-prop">
<td class="tblQmlPropNode"><p>
<span class="name">sourceAlphaBlend</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span> <code class="details extra" translate="no">[since 6.7]</code></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Specifies the source alpha blend factor. The default value is <code translate="no">CustomMaterial.NoBlend</code>. This value is only actively used if <a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a> and <a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a> is set to a non-default value.</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.NoBlend</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.Zero</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.One</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusSrcColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.DstColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusDstColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusSrcAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.DstAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusDstAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.ConstantColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusConstantColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.ConstantAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusConstantAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcAlphaSaturate</code></td></tr>
</table></div>
<div class="admonition note">
<p><b>Note: </b>For backwards compatibility purposes, when left to its default value, will be assigned the same value as <a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a> when <a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a> and <a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a> is set to non-default values.</p>
</div>
<p>This property was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qml-qtquick3d-custommaterial.html#sourceBlend-prop" translate="no">sourceBlend</a>.</p>
</div></div><!-- @@@sourceAlphaBlend -->
<br/>
<!-- $$$sourceBlend -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="sourceBlend-prop">
<td class="tblQmlPropNode"><p>
<span class="name">sourceBlend</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Specifies the source blend factor. The default value is <code translate="no">CustomMaterial.NoBlend</code>.</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.NoBlend</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.Zero</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.One</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusSrcColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.DstColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusDstColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusSrcAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.DstAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusDstAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.ConstantColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusConstantColor</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.ConstantAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.OneMinusConstantAlpha</code></td></tr>
<tr><td class="topAlign"><code translate="no">CustomMaterial.SrcAlphaSaturate</code></td></tr>
</table></div>
<div class="admonition note">
<p><b>Note: </b>Both sourceBlend and <a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a> needs to be set to a non-default value before blending is enabled.</p>
</div>
<p><b>See also </b><a href="qml-qtquick3d-custommaterial.html#destinationBlend-prop" translate="no">destinationBlend</a>.</p>
</div></div><!-- @@@sourceBlend -->
<br/>
<!-- $$$vertexShader -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="vertexShader-prop">
<td class="tblQmlPropNode"><p>
<span class="name">vertexShader</span> : <span class="type"><a href="../qtqml/qml-url.html" translate="no">url</a></span></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Specfies the file with the snippet of custom vertex shader code.</p>
<p>The value is a URL and must either be a local file or use the qrc scheme to access files embedded via the Qt resource system. Relative file paths (without a scheme) are also accepted, in which case the file is treated as relative to the component (the <code translate="no">.qml</code> file).</p>
<p><b>See also </b><a href="qml-qtquick3d-custommaterial.html#fragmentShader-prop" translate="no">fragmentShader</a>.</p>
</div></div><!-- @@@vertexShader -->
<br/>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
