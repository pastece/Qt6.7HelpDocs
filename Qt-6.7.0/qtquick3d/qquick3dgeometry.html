<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquick3dgeometry.cpp -->
  <meta name="description" content="Base class for defining custom geometry.">
  <title>QQuick3DGeometry Class | Qt Quick 3D 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick3d-index.html" translate="no">Qt Quick 3D</a></li>
<li><a href="qtquick3d-module.html" translate="no">C++ Classes</a></li>
<li>QQuick3DGeometry</li>
<li id="buildversion"><a href="qtquick3d-index.html" translate="no">Qt Quick 3D | Commercial or GPLv3</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QQuick3DGeometry Class</h1>
<!-- $$$QQuick3DGeometry-brief -->
<p>Base class for defining custom geometry. <a href="#details">More...</a></p>
<!-- @@@QQuick3DGeometry -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QQuick3DGeometry&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Instantiated By:</td><td class="memItemRight bottomAlign"> <a href="qml-qtquick3d-geometry.html" translate="no">Geometry</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qquick3dobject.html" translate="no">QQuick3DObject</a></td></tr>
</table></div>
<ul>
<li><a href="qquick3dgeometry-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#addAttribute" translate="no">addAttribute</a></b>(QQuick3DGeometry::Attribute::Semantic <i>semantic</i>, int <i>offset</i>, QQuick3DGeometry::Attribute::ComponentType <i>componentType</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#addAttribute-1" translate="no">addAttribute</a></b>(const QQuick3DGeometry::Attribute &amp;<i>attribute</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#addSubset" translate="no">addSubset</a></b>(int <i>offset</i>, int <i>count</i>, const QVector3D &amp;<i>boundsMin</i>, const QVector3D &amp;<i>boundsMax</i>, const QString &amp;<i>name</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#addTargetAttribute" translate="no">addTargetAttribute</a></b>(quint32 <i>targetId</i>, QQuick3DGeometry::Attribute::Semantic <i>semantic</i>, int <i>offset</i>, int <i>stride</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#addTargetAttribute-1" translate="no">addTargetAttribute</a></b>(const QQuick3DGeometry::TargetAttribute &amp;<i>attribute</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuick3DGeometry::Attribute </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#attribute" translate="no">attribute</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#attributeCount" translate="no">attributeCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector3D </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#boundsMax" translate="no">boundsMax</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector3D </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#boundsMin" translate="no">boundsMin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#indexData" translate="no">indexData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuick3DGeometry::PrimitiveType </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#primitiveType" translate="no">primitiveType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#setBounds" translate="no">setBounds</a></b>(const QVector3D &amp;<i>min</i>, const QVector3D &amp;<i>max</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#setIndexData" translate="no">setIndexData</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#setIndexData-1" translate="no">setIndexData</a></b>(int <i>offset</i>, const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#setPrimitiveType" translate="no">setPrimitiveType</a></b>(QQuick3DGeometry::PrimitiveType <i>type</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#setStride" translate="no">setStride</a></b>(int <i>stride</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#setTargetData" translate="no">setTargetData</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#setTargetData-1" translate="no">setTargetData</a></b>(int <i>offset</i>, const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#setVertexData" translate="no">setVertexData</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#setVertexData-1" translate="no">setVertexData</a></b>(int <i>offset</i>, const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#stride" translate="no">stride</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector3D </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#subsetBoundsMax" translate="no">subsetBoundsMax</a></b>(int <i>subset</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector3D </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#subsetBoundsMin" translate="no">subsetBoundsMin</a></b>(int <i>subset</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#subsetCount" translate="no">subsetCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#subsetCount-1" translate="no">subsetCount</a></b>(int <i>subset</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#subsetName" translate="no">subsetName</a></b>(int <i>subset</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#subsetOffset" translate="no">subsetOffset</a></b>(int <i>subset</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QQuick3DGeometry::TargetAttribute </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#targetAttribute" translate="no">targetAttribute</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> int </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#targetAttributeCount" translate="no">targetAttributeCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#targetData" translate="no">targetData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qquick3dgeometry.html#vertexData" translate="no">vertexData</a></b>() const</td></tr>
</table></div>
<!-- $$$QQuick3DGeometry-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QQuick3DGeometry can be used to specify custom geometry for a Model in the Qt Quick 3D scene.</p>
<p>While not strictly required, the typical usage is to inherit from this class. The subclass is then exposed to QML by registering it to the type system. The <a href="qml-qtquick3d-model.html#geometry-prop" translate="no">geometry</a> property of a Model can then be set to reference an instance of the registered type.</p>
<p>The high-level structure of such a class is typically similar to the following:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> CustomGeometry : <span class="keyword">public</span> QQuick3DGeometry
 {
 <span class="keyword">public</span>:
     CustomGeometry() { rebuildGeometry(); }

     <span class="type">void</span> setSomething() {
        <span class="comment">// Change relevant internal data.</span>
        <span class="comment">// ...</span>

        <span class="comment">// Then rebuild the vertex and index data and pass it to QQuick3DGeometry.</span>
        rebuildGeometry();

        <span class="comment">// Finally, trigger an update. This is relevant in case nothing else</span>
        <span class="comment">// is changing in the scene; this way we make sure a new frame will</span>
        <span class="comment">// be rendered.</span>
        update();
     }

 <span class="keyword">private</span>:
     <span class="type">void</span> rebuildGeometry()
     {
         <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> vertices;
         <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> indices;
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
         setPrimitiveType(Lines);
         setVertexBuffer(vertices);
         setIndexBuffer(indices);
         setStride(<span class="number">3</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>)); <span class="comment">// e.g. when having 3 components per vertex</span>
         setBounds(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>); <span class="comment">// minimum and maximum extents, for picking</span>
         addAttribute(PositionSemantic<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> F32Type);
         <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     }
 };
</pre>
<p>This class can then be registered as a QML type and used with <a href="qml-qtquick3d-model.html" translate="no">Model</a>.</p>
<p>In Qt 5 type registration happened with <a href="../qtqml/qqmlengine.html#qmlRegisterType" translate="no">qmlRegisterType</a>:</p>
<pre class="cpp" translate="no">
 qmlRegisterType<span class="operator">&lt;</span>CustomGeometry<span class="operator">&gt;</span>(<span class="string">&quot;Example&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;CustomGeometry&quot;</span>);
</pre>
<p>In Qt 6 the default approach is to use automatic registration with the help of the build system. Instead of calling <a href="../qtqml/qqmlengine.html#qmlRegisterType" translate="no">qmlRegisterType</a>, the <code translate="no">.pro</code> file can now contain:</p>
<pre class="cpp" translate="no">
 CONFIG <span class="operator">+</span><span class="operator">=</span> qmltypes
 QML_IMPORT_NAME <span class="operator">=</span> Example
 QML_IMPORT_MAJOR_VERSION <span class="operator">=</span> <span class="number">1</span>
</pre>
<p>With CMake, automatic registration is the default behavior, so no special settings are needed beyond basic QML module setup:</p>
<pre class="cpp" translate="no">
 qt_add_qml_module(application
     URI Example
     VERSION <span class="number">1.0</span>
 )
</pre>
<p>The class implementation should add <a href="../qtqml/qqmlengine.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> CustomGeometry : <span class="keyword">public</span> QQuick3DGeometry
 {
     Q_OBJECT
     QML_NAMED_ELEMENT(CustomGeometry)
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 };
</pre>
<p>The QML code can then use the custom type:</p>
<pre class="cpp" translate="no">
 import Example <span class="number">1.0</span>

 Model {
     id: customModel
     geometry: CustomGeometry {
     }
 }
</pre>
<p>At minimum, a custom geometry should have the following specified:</p>
<ul>
<li>vertex data,</li>
<li>vertex stride,</li>
<li>primitive type,</li>
<li>an attribute with PositionSemantic.</li>
</ul>
<p>These are sufficient to render the mesh. For indexed drawing, the index buffer data and an attribute with IndexSemantic needs to be specified as well. In order to support picking (input), the class must specify the bounding volume using <a href="qquick3dgeometry.html#setBounds" translate="no">setBounds</a>(). For proper lighting, an attribute with NormalSemantic is needed. When the material uses texturing, at least one set of UV coordinates must be provided and described in an TexCoord0Semantic or TexCoord1Semantic attribute. Some materials may require tangents and binormals as well.</p>
<p>As a concrete, minimal example, the following class would provide geometry for a single triangle:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> ExampleGeometry : <span class="keyword">public</span> QQuick3DGeometry
 {
     Q_OBJECT
     QML_NAMED_ELEMENT(ExampleGeometry)

 <span class="keyword">public</span>:
     ExampleGeometry();

 <span class="keyword">private</span>:
     <span class="type">void</span> updateData();
 };

 ExampleGeometry<span class="operator">::</span>ExampleGeometry()
 {
     updateData();
 }

 <span class="type">void</span> ExampleGeometry<span class="operator">::</span>updateData()
 {
     <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> v;
     v<span class="operator">.</span>resize(<span class="number">3</span> <span class="operator">*</span> <span class="number">3</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>));
     <span class="type">float</span> <span class="operator">*</span>p <span class="operator">=</span> <span class="keyword">reinterpret_cast</span><span class="operator">&lt;</span><span class="type">float</span> <span class="operator">*</span><span class="operator">&gt;</span>(v<span class="operator">.</span>data());

     <span class="comment">// a triangle, front face = counter-clockwise</span>
     <span class="operator">*</span>p<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> <span class="operator">-</span><span class="number">1.0f</span>; <span class="operator">*</span>p<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> <span class="operator">-</span><span class="number">1.0f</span>; <span class="operator">*</span>p<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> <span class="number">0.0f</span>;
     <span class="operator">*</span>p<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> <span class="number">1.0f</span>; <span class="operator">*</span>p<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> <span class="operator">-</span><span class="number">1.0f</span>; <span class="operator">*</span>p<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> <span class="number">0.0f</span>;
     <span class="operator">*</span>p<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> <span class="number">0.0f</span>; <span class="operator">*</span>p<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> <span class="number">1.0f</span>; <span class="operator">*</span>p<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> <span class="number">0.0f</span>;

     setVertexData(v);
     setStride(<span class="number">3</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>));

     setPrimitiveType(QQuick3DGeometry<span class="operator">::</span>PrimitiveType<span class="operator">::</span>Triangles);

     addAttribute(QQuick3DGeometry<span class="operator">::</span>Attribute<span class="operator">::</span>PositionSemantic<span class="operator">,</span>
                  <span class="number">0</span><span class="operator">,</span>
                  QQuick3DGeometry<span class="operator">::</span>Attribute<span class="operator">::</span>F32Type);
 }
</pre>
<p>Depending on the lighting in the scene, the result of referencing this geometry from a Model:</p>
<p class="centerAlign"><img src="images/customgeometry.jpg" alt="" /></p><div class="admonition note">
<p><b>Note: </b>Vertex data is expected to follow OpenGL conventions. This means the data must be provided with the assumption that the Y axis is pointing up in the normalized device coordinate system, and that front faces have a counter clockwise winding.</p>
</div>
</div>
<p><b>See also </b><a href="qml-qtquick3d-model.html" translate="no">Model</a> and <a href="qml-qtquick3d-geometry.html" translate="no">Geometry</a>.</p>
<!-- @@@QQuick3DGeometry -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$addAttribute[overload1]$$$addAttributeQQuick3DGeometry::Attribute::SemanticintQQuick3DGeometry::Attribute::ComponentType -->
<h3 class="fn" translate="no" id="addAttribute"><span class="type">void</span> QQuick3DGeometry::<span class="name">addAttribute</span>(<span class="type">QQuick3DGeometry::Attribute::Semantic</span> <i>semantic</i>, <span class="type">int</span> <i>offset</i>, <span class="type">QQuick3DGeometry::Attribute::ComponentType</span> <i>componentType</i>)</h3>
<p>Adds vertex attribute description. Each attribute has a <i translate="no">semantic</i>, which specifies the usage of the attribute and the number of components it has, an <i translate="no">offset</i> from the beginning to the vertex to the attribute location inside a vertex and a <i translate="no">componentType</i> specifying the datatype and size of the attribute.</p>
<p>The semantic can be one of the following:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">PositionSemantic</code></td><td class="topAlign">The attribute is a position. 3 components: <i>x</i>, <i>y</i>, and <i>z</i></td></tr>
<tr><td class="topAlign"><code translate="no">NormalSemantic</code></td><td class="topAlign">The attribute is a normal vector. 3 components: <i>x</i>, <i>y</i>, and <i>z</i></td></tr>
<tr><td class="topAlign"><code translate="no">TexCoord0Semantic</code></td><td class="topAlign">The attribute is a texture coordinate. 2 components: <i>u</i> and <i>v</i></td></tr>
<tr><td class="topAlign"><code translate="no">TexCoord1Semantic</code></td><td class="topAlign">The attribute is a texture coordinate. 2 components: <i>u</i> and <i>v</i></td></tr>
<tr><td class="topAlign"><code translate="no">TangentSemantic</code></td><td class="topAlign">The attribute is a tangent vector. 3 components: <i>x</i>, <i>y</i>, and <i>z</i></td></tr>
<tr><td class="topAlign"><code translate="no">BinormalSemantic</code></td><td class="topAlign">The attribute is a binormal vector. 3 components: <i>x</i>, <i>y</i>, and <i>z</i></td></tr>
<tr><td class="topAlign"><code translate="no">JointSemantic</code></td><td class="topAlign">The attribute is a joint index vector for <a href="quick3d-vertex-skinning.html" translate="no">skinning</a>. 4 components: joint index 1-4</td></tr>
<tr><td class="topAlign"><code translate="no">WeightSemantic</code></td><td class="topAlign">The attribute is a weight vector for <a href="quick3d-vertex-skinning.html" translate="no">skinning</a>. 4 components: joint weight 1-4</td></tr>
<tr><td class="topAlign"><code translate="no">ColorSemantic</code></td><td class="topAlign">The attribute is a vertex color vector. 4 components: <i>r</i>, <i>g</i>, <i>b</i>, and <i>a</i></td></tr>
<tr><td class="topAlign"><code translate="no">TargetPositionSemantic</code></td><td class="topAlign">The attribute is a position for the first <a href="quick3d-morphing.html" translate="no">morph target</a>. 3 components: <i>x</i>, <i>y</i>, and <i>z</i></td></tr>
<tr><td class="topAlign"><code translate="no">TargetNormalSemantic</code></td><td class="topAlign">The attribute is a normal vector for the first <a href="quick3d-morphing.html" translate="no">morph target</a>. 3 components: <i>x</i>, <i>y</i>, and <i>z</i></td></tr>
<tr><td class="topAlign"><code translate="no">TargetTangentSemantic</code></td><td class="topAlign">The attribute is a tangent vector for the first <a href="quick3d-morphing.html" translate="no">morph target</a>. 3 components: <i>x</i>, <i>y</i>, and <i>z</i></td></tr>
<tr><td class="topAlign"><code translate="no">TargetBinormalSemantic</code></td><td class="topAlign">The attribute is a binormal vector for the first <a href="quick3d-morphing.html" translate="no">morph target</a>. 3 components: <i>x</i>, <i>y</i>, and <i>z</i></td></tr>
</table></div>
<p>In addition, <i translate="no">semantic</i> can be <code translate="no">IndexSemantic</code>. In this case the attribute does not represent an entry in the vertex buffer, but rather describes the index data in the index buffer. Since there is always just one index per vertex, <i translate="no">offset</i> makes no sense for the index buffer, and should be left at zero.</p>
<p>The component type can be one of the following:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="even"><th class="tblConst">Constant</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">U16Type</code></td><td class="topAlign">The index component type is unsigned 16-bit integer. Only supported for <code translate="no">IndexSemantic</code>.</td></tr>
<tr><td class="topAlign"><code translate="no">U32Type</code></td><td class="topAlign">The attribute (or index component) is an unsigned 32-bit integer.</td></tr>
<tr><td class="topAlign"><code translate="no">I32Type</code></td><td class="topAlign">The attribute is a signed 32-bit integer. Be aware that old OpenGL versions (such as, 2.1 or OpenGL ES 2.0) may not support this data type.</td></tr>
<tr><td class="topAlign"><code translate="no">F32Type</code></td><td class="topAlign">The attribute is a single-precision float.</td></tr>
</table></div>
<div class="admonition note">
<p><b>Note: </b>The joint index data is typically <code translate="no">I32Type</code>. <code translate="no">F32Type</code> is also supported in order to enable functioning with APIs, such as OpenGL ES 2.0, that do not support integer vertex input attributes.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>For index data (<code translate="no">IndexSemantic</code>) only U16Type and U32Type are sensible and supported.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>TargetXXXSemantics will be deprecated. <a href="qquick3dgeometry.html#addTargetAttribute" translate="no">addTargetAttribute</a> can be used for the morph targets. Now these semantics are just supported for backward compatibility. If they are mixed-used with <a href="qquick3dgeometry.html#addTargetAttribute" translate="no">addTargetAttribute</a> and <a href="qquick3dgeometry.html#setTargetData" translate="no">setTargetData</a>, the result cannot be quaranteed.</p>
</div>
<!-- @@@addAttribute -->
<!-- $$$addAttribute$$$addAttributeconstQQuick3DGeometry::Attribute& -->
<h3 class="fn" translate="no" id="addAttribute-1"><span class="type">void</span> QQuick3DGeometry::<span class="name">addAttribute</span>(const <span class="type">QQuick3DGeometry::Attribute</span> &amp;<i>attribute</i>)</h3>
<p>This is an overloaded function.</p>
<p>Adds vertex attribute description. Each attribute has a semantic, which specifies the usage of the attribute and the number of components it has, an offset from the beginning to the vertex to the attribute location inside a vertex and a componentType specifying the datatype and size of the attribute.</p>
<!-- @@@addAttribute -->
<!-- $$$addSubset[overload1]$$$addSubsetintintconstQVector3D&constQVector3D&constQString& -->
<h3 class="fn" translate="no" id="addSubset"><span class="type">void</span> QQuick3DGeometry::<span class="name">addSubset</span>(<span class="type">int</span> <i>offset</i>, <span class="type">int</span> <i>count</i>, const <span class="type"><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a></span> &amp;<i>boundsMin</i>, const <span class="type"><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a></span> &amp;<i>boundsMax</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>name</i> = {})</h3>
<p>Adds new subset to the geometry. Subsets allow rendering parts of the geometry with different materials. The materials are specified in the <a href="qml-qtquick3d-model.html#materials-prop" translate="no">model</a>.</p>
<p>If the geometry has index buffer, then the <i translate="no">offset</i> and <i translate="no">count</i> are the primitive offset and count of indices in the subset. If the geometry has only vertex buffer, the offset is the vertex offset and count is the number of vertices in the subset.</p>
<p>The bounds <i translate="no">boundsMin</i> and <i translate="no">boundsMax</i> should enclose the subset just like geometry bounds. Also the subset can have a <i translate="no">name</i>.</p>
<!-- @@@addSubset -->
<!-- $$$addTargetAttribute[overload1]$$$addTargetAttributequint32QQuick3DGeometry::Attribute::Semanticintint -->
<h3 class="fn" translate="no" id="addTargetAttribute"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">void</span> QQuick3DGeometry::<span class="name">addTargetAttribute</span>(<span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> <i>targetId</i>, <span class="type">QQuick3DGeometry::Attribute::Semantic</span> <i>semantic</i>, <span class="type">int</span> <i>offset</i>, <span class="type">int</span> <i>stride</i> = 0)</h3>
<p>Adds morph target attribute description. Each attribute has a <i translate="no">targetId</i> which the attribute belongs to, a <i translate="no">semantic</i>, which specifies the usage of the attribute and the number of components it has, an <i translate="no">offset</i> from the beginning to the vertex to the attribute location inside a vertex, and a <i translate="no">stride</i> which is a byte size between the elements.</p>
<div class="admonition note">
<p><b>Note: </b>The targetId should be increased from 0 without skipping any number and all the targets should have the same attributes.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The semantic is the same as the vertex attribute but IndexSemantic, JointSementic and WeightSemantic are not allowed for target attributes.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The componentTypes of all the target attributes must be F32Type.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If the stride is not given or less than or equal to zero, the attribute is considered to be tightly packed.</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#addAttribute" translate="no">addAttribute</a>.</p>
<!-- @@@addTargetAttribute -->
<!-- $$$addTargetAttribute$$$addTargetAttributeconstQQuick3DGeometry::TargetAttribute& -->
<h3 class="fn" translate="no" id="addTargetAttribute-1"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">void</span> QQuick3DGeometry::<span class="name">addTargetAttribute</span>(const <span class="type">QQuick3DGeometry::TargetAttribute</span> &amp;<i>attribute</i>)</h3>
<p>This is an overloaded function.</p>
<p>Adds morph target attribute description. Each attribute has a targetId which the attribute belongs to, a semantic, which specifies the usage of the attribute and the number of components it has, an offset from the beginning to the vertex to the attribute location inside a vertex, and a stride which is a byte size between the elements.</p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@addTargetAttribute -->
<!-- $$$attribute[overload1]$$$attributeint -->
<h3 class="fn" translate="no" id="attribute"><span class="type">QQuick3DGeometry::Attribute</span> QQuick3DGeometry::<span class="name">attribute</span>(<span class="type">int</span> <i>index</i>) const</h3>
<p>Returns attribute definition number <i translate="no">index</i></p>
<p>The attribute definitions are numbered from 0 to <code translate="no">attributeCount() - 1</code></p>
<!-- @@@attribute -->
<!-- $$$attributeCount[overload1]$$$attributeCount -->
<h3 class="fn" translate="no" id="attributeCount"><span class="type">int</span> QQuick3DGeometry::<span class="name">attributeCount</span>() const</h3>
<p>Returns the number of attributes defined for this geometry.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#attribute" translate="no">attribute</a>.</p>
<!-- @@@attributeCount -->
<!-- $$$boundsMax[overload1]$$$boundsMax -->
<h3 class="fn" translate="no" id="boundsMax"><span class="type"><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a></span> QQuick3DGeometry::<span class="name">boundsMax</span>() const</h3>
<p>Returns the maximum coordinate of the bounding volume.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#setBounds" translate="no">setBounds</a>.</p>
<!-- @@@boundsMax -->
<!-- $$$boundsMin[overload1]$$$boundsMin -->
<h3 class="fn" translate="no" id="boundsMin"><span class="type"><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a></span> QQuick3DGeometry::<span class="name">boundsMin</span>() const</h3>
<p>Returns the minimum coordinate of the bounding volume.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#setBounds" translate="no">setBounds</a>.</p>
<!-- @@@boundsMin -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QQuick3DGeometry::<span class="name">clear</span>()</h3>
<p>Resets the geometry to its initial state, clearing previously set vertex and index data as well as attributes.</p>
<!-- @@@clear -->
<!-- $$$indexData[overload1]$$$indexData -->
<h3 class="fn" translate="no" id="indexData"><span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> QQuick3DGeometry::<span class="name">indexData</span>() const</h3>
<p>Returns the index buffer data.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#setIndexData" translate="no">setIndexData</a>().</p>
<!-- @@@indexData -->
<!-- $$$primitiveType[overload1]$$$primitiveType -->
<h3 class="fn" translate="no" id="primitiveType"><span class="type">QQuick3DGeometry::PrimitiveType</span> QQuick3DGeometry::<span class="name">primitiveType</span>() const</h3>
<p>Returns the primitive type used when rendering. The default is <code translate="no">Triangles</code>.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#setPrimitiveType" translate="no">setPrimitiveType</a>.</p>
<!-- @@@primitiveType -->
<!-- $$$setBounds[overload1]$$$setBoundsconstQVector3D&constQVector3D& -->
<h3 class="fn" translate="no" id="setBounds"><span class="type">void</span> QQuick3DGeometry::<span class="name">setBounds</span>(const <span class="type"><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a></span> &amp;<i>min</i>, const <span class="type"><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a></span> &amp;<i>max</i>)</h3>
<p>Sets the bounding volume of the geometry to the cube defined by the points <i translate="no">min</i> and <i translate="no">max</i>. This is used for <a href="qml-qtquick3d-view3d.html#pick-method" translate="no">picking</a>.</p>
<!-- @@@setBounds -->
<!-- $$$setIndexData[overload1]$$$setIndexDataconstQByteArray& -->
<h3 class="fn" translate="no" id="setIndexData"><span class="type">void</span> QQuick3DGeometry::<span class="name">setIndexData</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Sets the index buffer to <i translate="no">data</i>. To use indexed drawing, add an attribute with <code translate="no">IndexSemantic</code></p>
<p><b>See also </b><a href="qquick3dgeometry.html#indexData" translate="no">indexData</a>() and <a href="qquick3dgeometry.html#addAttribute" translate="no">addAttribute</a>.</p>
<!-- @@@setIndexData -->
<!-- $$$setIndexData$$$setIndexDataintconstQByteArray& -->
<h3 class="fn" translate="no" id="setIndexData-1"><span class="type">void</span> QQuick3DGeometry::<span class="name">setIndexData</span>(<span class="type">int</span> <i>offset</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>This is an overloaded function.</p>
<p>Updates a subset of the index buffer. <i translate="no">offset</i> specifies the offset in bytes, <i translate="no">data</i> specifies the size and the data.</p>
<p>This function will not resize the buffer. If <code translate="no">offset + data.size()</code> is greater than the current size of the buffer, the overshooting data will be ignored.</p>
<div class="admonition note">
<p><b>Note: </b>The partial update functions for vertex, index and morph target data do not offer any guarantee on how such changes are implemented internally. Depending on the underlying implementation, even partial changes may lead to updating the entire graphics resource.</p>
</div>
<!-- @@@setIndexData -->
<!-- $$$setPrimitiveType[overload1]$$$setPrimitiveTypeQQuick3DGeometry::PrimitiveType -->
<h3 class="fn" translate="no" id="setPrimitiveType"><span class="type">void</span> QQuick3DGeometry::<span class="name">setPrimitiveType</span>(<span class="type">QQuick3DGeometry::PrimitiveType</span> <i>type</i>)</h3>
<p>Sets the primitive type used for rendering to <i translate="no">type</i>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">Points</code></td><td class="topAlign">The primitives are points.</td></tr>
<tr><td class="topAlign"><code translate="no">LineStrip</code></td><td class="topAlign">The primitives are lines in a strip.</td></tr>
<tr><td class="topAlign"><code translate="no">Lines</code></td><td class="topAlign">The primitives are lines in a list.</td></tr>
<tr><td class="topAlign"><code translate="no">TriangleStrip</code></td><td class="topAlign">The primitives are triangles in a strip.</td></tr>
<tr><td class="topAlign"><code translate="no">TriangleFan</code></td><td class="topAlign">The primitives are triangles in a fan. Be aware that triangle fans may not be supported at run time, depending on the underlying graphics API.</td></tr>
<tr><td class="topAlign"><code translate="no">Triangles</code></td><td class="topAlign">The primitives are triangles in a list.</td></tr>
</table></div>
<p>The initial value is <code translate="no">Triangles</code>.</p>
<div class="admonition note">
<p><b>Note: </b>Be aware that triangle fans (TriangleFan) may not be supported at run time, depending on the underlying graphics API. For example, with Direct 3D this topology will not be functional at all.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The point size for Points and the line width for Lines and LineStrip are controlled by the <a href="qml-qtquick3d-principledmaterial.html#pointSize-prop" translate="no">material</a>. Be aware however that sizes other than 1 may not be supported at run time, depending on the underlying graphics API.</p>
</div>
<p><b>See also </b><a href="qquick3dgeometry.html#primitiveType" translate="no">primitiveType</a>().</p>
<!-- @@@setPrimitiveType -->
<!-- $$$setStride[overload1]$$$setStrideint -->
<h3 class="fn" translate="no" id="setStride"><span class="type">void</span> QQuick3DGeometry::<span class="name">setStride</span>(<span class="type">int</span> <i>stride</i>)</h3>
<p>Sets the stride of the vertex buffer to <i translate="no">stride</i>, measured in bytes. This is the distance between two consecutive vertices in the buffer.</p>
<p>For example, a tightly packed, interleaved vertex buffer for a geometry using <code translate="no">PositionSemantic</code>, <code translate="no">IndexSemantic</code>, and <code translate="no">ColorSemantic</code> will have a stride of <code translate="no">28</code> (Seven floats in total: Three for position, four for color, and none for indexes, which do not go in the vertex buffer.)</p>
<div class="admonition note">
<p><b>Note: </b><a href="qquick3dgeometry.html" translate="no">QQuick3DGeometry</a> expects, and works only with, vertex data with an interleaved attribute layout.</p>
</div>
<p><b>See also </b><a href="qquick3dgeometry.html#stride" translate="no">stride</a>() and <a href="qquick3dgeometry.html#addAttribute" translate="no">addAttribute</a>.</p>
<!-- @@@setStride -->
<!-- $$$setTargetData[overload1]$$$setTargetDataconstQByteArray& -->
<h3 class="fn" translate="no" id="setTargetData"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">void</span> QQuick3DGeometry::<span class="name">setTargetData</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Sets the morph target buffer <i translate="no">data</i>. The buffer should hold all the morph target data.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#targetData" translate="no">targetData</a>() and <a href="qquick3dgeometry.html#addTargetAttribute" translate="no">addTargetAttribute</a>.</p>
<!-- @@@setTargetData -->
<!-- $$$setTargetData$$$setTargetDataintconstQByteArray& -->
<h3 class="fn" translate="no" id="setTargetData-1"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">void</span> QQuick3DGeometry::<span class="name">setTargetData</span>(<span class="type">int</span> <i>offset</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>This is an overloaded function.</p>
<p>Updates a subset of the morph target buffer. <i translate="no">offset</i> specifies the offset in bytes, <i translate="no">data</i> specifies the size and the data.</p>
<p>This function will not resize the buffer. If <code translate="no">offset + data.size()</code> is greater than the current size of the buffer, the overshooting data will be ignored.</p>
<div class="admonition note">
<p><b>Note: </b>The partial update functions for vertex, index and morph target data do not offer any guarantee on how such changes are implemented internally. Depending on the underlying implementation, even partial changes may lead to updating the entire graphics resource.</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@setTargetData -->
<!-- $$$setVertexData[overload1]$$$setVertexDataconstQByteArray& -->
<h3 class="fn" translate="no" id="setVertexData"><span class="type">void</span> QQuick3DGeometry::<span class="name">setVertexData</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Sets the vertex buffer <i translate="no">data</i>. The buffer should hold all the vertex data packed in the array, as described by the attribute definitions. Note that this does not include attributes with <code translate="no">IndexSemantic</code>, which belong in the index buffer.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#vertexData" translate="no">vertexData</a>(), <a href="qquick3dgeometry.html#addAttribute" translate="no">addAttribute</a>, <a href="qquick3dgeometry.html#setStride" translate="no">setStride</a>, and <a href="qquick3dgeometry.html#setIndexData" translate="no">setIndexData</a>.</p>
<!-- @@@setVertexData -->
<!-- $$$setVertexData$$$setVertexDataintconstQByteArray& -->
<h3 class="fn" translate="no" id="setVertexData-1"><span class="type">void</span> QQuick3DGeometry::<span class="name">setVertexData</span>(<span class="type">int</span> <i>offset</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>This is an overloaded function.</p>
<p>Updates a subset of the vertex buffer. <i translate="no">offset</i> specifies the offset in bytes, <i translate="no">data</i> specifies the size and the data.</p>
<p>This function will not resize the buffer. If <code translate="no">offset + data.size()</code> is greater than the current size of the buffer, the overshooting data will be ignored.</p>
<div class="admonition note">
<p><b>Note: </b>The partial update functions for vertex, index and morph target data do not offer any guarantee on how such changes are implemented internally. depending on the underlying implementation, even partial changes may lead to updating the entire graphics resource.</p>
</div>
<!-- @@@setVertexData -->
<!-- $$$stride[overload1]$$$stride -->
<h3 class="fn" translate="no" id="stride"><span class="type">int</span> QQuick3DGeometry::<span class="name">stride</span>() const</h3>
<p>Returns the byte stride of the vertex buffer.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#setStride" translate="no">setStride</a>.</p>
<!-- @@@stride -->
<!-- $$$subsetBoundsMax[overload1]$$$subsetBoundsMaxint -->
<h3 class="fn" translate="no" id="subsetBoundsMax"><span class="type"><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a></span> QQuick3DGeometry::<span class="name">subsetBoundsMax</span>(<span class="type">int</span> <i>subset</i>) const</h3>
<p>Returns the number of maximum bounds of a <i translate="no">subset</i>.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#subsetBoundsMin" translate="no">subsetBoundsMin</a>.</p>
<!-- @@@subsetBoundsMax -->
<!-- $$$subsetBoundsMin[overload1]$$$subsetBoundsMinint -->
<h3 class="fn" translate="no" id="subsetBoundsMin"><span class="type"><a href="../qtgui/qvector3d.html" translate="no">QVector3D</a></span> QQuick3DGeometry::<span class="name">subsetBoundsMin</span>(<span class="type">int</span> <i>subset</i>) const</h3>
<p>Returns the number of minimum bounds of a <i translate="no">subset</i>.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#subsetBoundsMax" translate="no">subsetBoundsMax</a>.</p>
<!-- @@@subsetBoundsMin -->
<!-- $$$subsetCount[overload1]$$$subsetCount -->
<h3 class="fn" translate="no" id="subsetCount"><span class="type">int</span> QQuick3DGeometry::<span class="name">subsetCount</span>() const</h3>
<p>Returns the number of subsets.</p>
<!-- @@@subsetCount -->
<!-- $$$subsetCount$$$subsetCountint -->
<h3 class="fn" translate="no" id="subsetCount-1"><span class="type">int</span> QQuick3DGeometry::<span class="name">subsetCount</span>(<span class="type">int</span> <i>subset</i>) const</h3>
<p>Returns the subset primitive count.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#subsetOffset" translate="no">subsetOffset</a>.</p>
<!-- @@@subsetCount -->
<!-- $$$subsetName[overload1]$$$subsetNameint -->
<h3 class="fn" translate="no" id="subsetName"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QQuick3DGeometry::<span class="name">subsetName</span>(<span class="type">int</span> <i>subset</i>) const</h3>
<p>Returns the <i translate="no">subset</i> name.</p>
<!-- @@@subsetName -->
<!-- $$$subsetOffset[overload1]$$$subsetOffsetint -->
<h3 class="fn" translate="no" id="subsetOffset"><span class="type">int</span> QQuick3DGeometry::<span class="name">subsetOffset</span>(<span class="type">int</span> <i>subset</i>) const</h3>
<p>Returns the <i translate="no">subset</i> offset to the vertex or index buffer.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#subsetCount" translate="no">subsetCount</a>.</p>
<!-- @@@subsetOffset -->
<!-- $$$targetAttribute[overload1]$$$targetAttributeint -->
<h3 class="fn" translate="no" id="targetAttribute"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">QQuick3DGeometry::TargetAttribute</span> QQuick3DGeometry::<span class="name">targetAttribute</span>(<span class="type">int</span> <i>index</i>) const</h3>
<p>Returns morph target attribute definition number <i translate="no">index</i></p>
<p>The attribute definitions are numbered from 0 to <code translate="no">attributeCount() - 1</code></p>
<p>This function was introduced in Qt 6.6.</p>
<!-- @@@targetAttribute -->
<!-- $$$targetAttributeCount[overload1]$$$targetAttributeCount -->
<h3 class="fn" translate="no" id="targetAttributeCount"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">int</span> QQuick3DGeometry::<span class="name">targetAttributeCount</span>() const</h3>
<p>Returns the number of morph target attributes defined for this geometry.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#targetAttribute" translate="no">targetAttribute</a>.</p>
<!-- @@@targetAttributeCount -->
<!-- $$$targetData[overload1]$$$targetData -->
<h3 class="fn" translate="no" id="targetData"><code class="details extra" translate="no">[since 6.6]</code> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> QQuick3DGeometry::<span class="name">targetData</span>() const</h3>
<p>Returns the target buffer data set by <a href="qquick3dgeometry.html#setTargetData" translate="no">setTargetData</a>.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#setTargetData" translate="no">setTargetData</a>().</p>
<!-- @@@targetData -->
<!-- $$$vertexData[overload1]$$$vertexData -->
<h3 class="fn" translate="no" id="vertexData"><span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> QQuick3DGeometry::<span class="name">vertexData</span>() const</h3>
<p>Returns the vertex buffer data set by <a href="qquick3dgeometry.html#setVertexData" translate="no">setVertexData</a>.</p>
<p><b>See also </b><a href="qquick3dgeometry.html#setVertexData" translate="no">setVertexData</a>().</p>
<!-- @@@vertexData -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
