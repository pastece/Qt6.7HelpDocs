<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qdtls.cpp -->
  <meta name="description" content="This class provides encryption for UDP sockets.">
  <title>QDtls Class | Qt Network 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtnetwork-index.html" translate="no">Qt Network</a></li>
<li><a href="qtnetwork-module.html" translate="no">C++ Classes</a></li>
<li>QDtls</li>
<li id="buildversion"><a href="qtnetwork-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QDtls Class</h1>
<!-- $$$QDtls-brief -->
<p>This class provides encryption for UDP sockets. <a href="#details">More...</a></p>
<!-- @@@QDtls -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QDtls&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Network) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Network)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += network</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html" translate="no">QObject</a></td></tr>
</table></div>
<ul>
<li><a href="qdtls-members.html">List of all members, including inherited members</a></li>
<li>QDtls is part of <a href="network.html">Network Programming API</a>.</li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#GeneratorParameters-typedef" translate="no">GeneratorParameters</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#HandshakeState-enum" translate="no">HandshakeState</a></b> { HandshakeNotStarted, HandshakeInProgress, PeerVerificationFailed, HandshakeComplete }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#QDtls" translate="no">QDtls</a></b>(QSslSocket::SslMode <i>mode</i>, QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#dtor.QDtls" translate="no">~QDtls</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#abortHandshake" translate="no">abortHandshake</a></b>(QUdpSocket *<i>socket</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDtls::GeneratorParameters </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#cookieGeneratorParameters" translate="no">cookieGeneratorParameters</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#decryptDatagram" translate="no">decryptDatagram</a></b>(QUdpSocket *<i>socket</i>, const QByteArray &amp;<i>dgram</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#doHandshake" translate="no">doHandshake</a></b>(QUdpSocket *<i>socket</i>, const QByteArray &amp;<i>dgram</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslConfiguration </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#dtlsConfiguration" translate="no">dtlsConfiguration</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDtlsError </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#dtlsError" translate="no">dtlsError</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#dtlsErrorString" translate="no">dtlsErrorString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#handleTimeout" translate="no">handleTimeout</a></b>(QUdpSocket *<i>socket</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDtls::HandshakeState </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#handshakeState" translate="no">handshakeState</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a></b>(const QList&lt;QSslError&gt; &amp;<i>errorsToIgnore</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#isConnectionEncrypted" translate="no">isConnectionEncrypted</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#mtuHint" translate="no">mtuHint</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#peerAddress" translate="no">peerAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#peerPort" translate="no">peerPort</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QSslError&gt; </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#peerVerificationErrors" translate="no">peerVerificationErrors</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#peerVerificationName" translate="no">peerVerificationName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#resumeHandshake" translate="no">resumeHandshake</a></b>(QUdpSocket *<i>socket</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslCipher </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#sessionCipher" translate="no">sessionCipher</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSsl::SslProtocol </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#sessionProtocol" translate="no">sessionProtocol</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#setCookieGeneratorParameters" translate="no">setCookieGeneratorParameters</a></b>(const QDtls::GeneratorParameters &amp;<i>params</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#setDtlsConfiguration" translate="no">setDtlsConfiguration</a></b>(const QSslConfiguration &amp;<i>configuration</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#setMtuHint" translate="no">setMtuHint</a></b>(quint16 <i>mtuHint</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#setPeer" translate="no">setPeer</a></b>(const QHostAddress &amp;<i>address</i>, quint16 <i>port</i>, const QString &amp;<i>verificationName</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#setPeerVerificationName" translate="no">setPeerVerificationName</a></b>(const QString &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#shutdown" translate="no">shutdown</a></b>(QUdpSocket *<i>socket</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslSocket::SslMode </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#sslMode" translate="no">sslMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#writeDatagramEncrypted" translate="no">writeDatagramEncrypted</a></b>(QUdpSocket *<i>socket</i>, const QByteArray &amp;<i>dgram</i>)</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#handshakeTimeout" translate="no">handshakeTimeout</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#pskRequired" translate="no">pskRequired</a></b>(QSslPreSharedKeyAuthenticator *<i>authenticator</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="qdtls.html#QDtlsError-enum" translate="no">QDtlsError</a></b> { NoError, InvalidInputParameters, InvalidOperation, UnderlyingSocketError, RemoteClosedConnectionError, &hellip;, TlsNonFatalError }</td></tr>
</table></div>
<!-- $$$QDtls-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QDtls class can be used to establish a secure connection with a network peer using User Datagram Protocol (UDP). DTLS connection over essentially connectionless UDP means that two peers first have to successfully complete a TLS handshake by calling <a href="qdtls.html#doHandshake" translate="no">doHandshake</a>(). After the handshake has completed, encrypted datagrams can be sent to the peer using <a href="qdtls.html#writeDatagramEncrypted" translate="no">writeDatagramEncrypted</a>(). Encrypted datagrams coming from the peer can be decrypted by <a href="qdtls.html#decryptDatagram" translate="no">decryptDatagram</a>().</p>
<p>QDtls is designed to work with <a href="qudpsocket.html" translate="no">QUdpSocket</a>. Since <a href="qudpsocket.html" translate="no">QUdpSocket</a> can receive datagrams coming from different peers, an application must implement demultiplexing, forwarding datagrams coming from different peers to their corresponding instances of QDtls. An association between a network peer and its QDtls object can be established using the peer's address and port number. Before starting a handshake, the application must set the peer's address and port number using <a href="qdtls.html#setPeer" translate="no">setPeer</a>().</p>
<p>QDtls does not read datagrams from <a href="qudpsocket.html" translate="no">QUdpSocket</a>, this is expected to be done by the application, for example, in a slot attached to the <a href="../qtcore/qiodevice.html#readyRead" translate="no">QUdpSocket::readyRead</a>() signal. Then, these datagrams must be processed by QDtls.</p>
<div class="admonition note">
<p><b>Note: </b>QDtls does <i>not</i> take ownership of the <a href="qudpsocket.html" translate="no">QUdpSocket</a> object.</p>
</div>
<p>Normally, several datagrams are to be received and sent by both peers during the handshake phase. Upon reading datagrams, server and client must pass these datagrams to <a href="qdtls.html#doHandshake" translate="no">doHandshake</a>() until some error is found or <a href="qdtls.html#handshakeState" translate="no">handshakeState</a>() returns <a href="qdtls.html#HandshakeState-enum" translate="no">HandshakeComplete</a>:</p>
<pre class="cpp" translate="no">
 <span class="comment">// A client initiates a handshake:</span>
 <span class="type"><a href="qudpsocket.html" translate="no">QUdpSocket</a></span> clientSocket;
 <span class="type"><a href="qdtls.html#QDtls" translate="no">QDtls</a></span> clientDtls;
 clientDtls<span class="operator">.</span>setPeer(address<span class="operator">,</span> port<span class="operator">,</span> peerName);
 clientDtls<span class="operator">.</span>doHandshake(<span class="operator">&amp;</span>clientSocket);

 <span class="comment">// A server accepting an incoming connection; address, port, clientHello are</span>
 <span class="comment">// read by QUdpSocket::readDatagram():</span>
 <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> clientHello(serverSocket<span class="operator">.</span>pendingDatagramSize()<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>Uninitialized);
 <span class="type"><a href="qhostaddress.html" translate="no">QHostAddress</a></span> address;
 quin16 port <span class="operator">=</span> {};
 serverSocket<span class="operator">.</span>readDatagram(clientHello<span class="operator">.</span>data()<span class="operator">,</span> clientHello<span class="operator">.</span>size()<span class="operator">,</span> <span class="operator">&amp;</span>address<span class="operator">,</span> <span class="operator">&amp;</span>port);

 <span class="type"><a href="qdtls.html#QDtls" translate="no">QDtls</a></span> serverDtls;
 serverDtls<span class="operator">.</span>setPeer(address<span class="operator">,</span> port);
 serverDtls<span class="operator">.</span>doHandshake(<span class="operator">&amp;</span>serverSocket<span class="operator">,</span> clientHello);

 <span class="comment">// Handshake completion, both for server and client:</span>
 <span class="type">void</span> DtlsConnection<span class="operator">::</span>continueHandshake(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> <span class="operator">&amp;</span>datagram)
 {
     <span class="keyword">if</span> (dtls<span class="operator">.</span>doHandshake(<span class="operator">&amp;</span>udpSocket<span class="operator">,</span> datagram)) {
         <span class="comment">// Check handshake status:</span>
         <span class="keyword">if</span> (dtls<span class="operator">.</span>handshakeStatus() <span class="operator">=</span><span class="operator">=</span> <span class="type">QDlts</span><span class="operator">::</span>HandshakeComplete) {
             <span class="comment">// Secure DTLS connection is now established.</span>
         }
     } <span class="keyword">else</span> {
         <span class="comment">// Error handling.</span>
     }
 }
</pre>
<p>For a server, the first call to <a href="qdtls.html#doHandshake" translate="no">doHandshake</a>() requires a non-empty datagram containing a ClientHello message. If the server also deploys <a href="qdtlsclientverifier.html" translate="no">QDtlsClientVerifier</a>, the first ClientHello message is expected to be the one verified by <a href="qdtlsclientverifier.html" translate="no">QDtlsClientVerifier</a>.</p>
<p>In case the peer's identity cannot be validated during the handshake, the application must inspect errors returned by <a href="qdtls.html#peerVerificationErrors" translate="no">peerVerificationErrors</a>() and then either ignore errors by calling <a href="qdtls.html#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>() or abort the handshake by calling <a href="qdtls.html#abortHandshake" translate="no">abortHandshake</a>(). If errors were ignored, the handshake can be resumed by calling <a href="qdtls.html#resumeHandshake" translate="no">resumeHandshake</a>().</p>
<p>After the handshake has been completed, datagrams can be sent to and received from the network peer securely:</p>
<pre class="cpp" translate="no">
 <span class="comment">// Sending an encrypted datagram:</span>
 dtlsConnection<span class="operator">.</span>writeDatagramEncrypted(<span class="operator">&amp;</span>clientSocket<span class="operator">,</span> <span class="string">&quot;Hello DTLS server!&quot;</span>);

 <span class="comment">// Decryption:</span>
 <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> encryptedMessage(dgramSize);
 socket<span class="operator">.</span>readDatagram(encryptedMessage<span class="operator">.</span>data()<span class="operator">,</span> dgramSize);
 <span class="keyword">const</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> plainText <span class="operator">=</span> dtlsConnection<span class="operator">.</span>decryptDatagram(<span class="operator">&amp;</span>socket<span class="operator">,</span> encryptedMessage);
</pre>
<p>A DTLS connection may be closed using <a href="qdtls.html#shutdown" translate="no">shutdown</a>().</p>
<pre class="cpp" translate="no">
 DtlsClient<span class="operator">::</span><span class="operator">~</span>DtlsClient()
 {
     clientDtls<span class="operator">.</span>shutdown(<span class="operator">&amp;</span>clientSocket);
 }
</pre>
<div class="admonition warning">
<p><b>Warning: </b>It's recommended to call <a href="qdtls.html#shutdown" translate="no">shutdown</a>() before destroying the client's QDtls object if you are planning to re-use the same port number to connect to the server later. Otherwise, the server may drop incoming ClientHello messages, see <a href="https://datatracker.ietf.org/doc/html/rfc6347#section-4.2.8" translate="no">RFC 6347, section 4.2.8</a> for more details and implementation hints.</p>
</div>
<p>If the server does not use <a href="qdtlsclientverifier.html" translate="no">QDtlsClientVerifier</a>, it <i>must</i> configure its QDtls objects to disable the cookie verification procedure:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> config <span class="operator">=</span> <span class="type"><a href="qsslconfiguration.html" translate="no">QSslConfiguration</a></span><span class="operator">::</span>defaultDtlsConfiguration();
 config<span class="operator">.</span>setDtlsCookieVerificationEnabled(<span class="keyword">false</span>);
 <span class="comment">// Some other customization ...</span>
 dtlsConnection<span class="operator">.</span>setDtlsConfiguration(config);
</pre>
<p>A server that uses cookie verification with non-default generator parameters <i>must</i> set the same parameters for its QDtls object before starting the handshake.</p>
<div class="admonition note">
<p><b>Note: </b>The DTLS protocol leaves Path Maximum Transmission Unit (PMTU) discovery to the application. The application may provide QDtls with the MTU using <a href="qdtls.html#setMtuHint" translate="no">setMtuHint</a>(). This hint affects only the handshake phase, since only handshake messages can be fragmented and reassembled by the DTLS. All other messages sent by the application must fit into a single datagram.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>DTLS-specific headers add some overhead to application data further reducing the possible message size.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>A server configured to reply with HelloVerifyRequest will drop all fragmented ClientHello messages, never starting a handshake.</p>
</div>
<p>The <a href="qtnetwork-secureudpserver-example.html" translate="no">DTLS server</a> and <a href="qtnetwork-secureudpclient-example.html" translate="no">DTLS client</a> examples illustrate how to use QDtls in applications.</p>
</div>
<p><b>See also </b><a href="qudpsocket.html" translate="no">QUdpSocket</a>, <a href="qdtlsclientverifier.html" translate="no">QDtlsClientVerifier</a>, <a href="qdtls.html#HandshakeState-enum" translate="no">HandshakeState</a>, <a href="qdtls.html#QDtlsError-enum" translate="no">QDtlsError</a>, and <a href="qsslconfiguration.html" translate="no">QSslConfiguration</a>.</p>
<!-- @@@QDtls -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$GeneratorParameters -->
<h3 class="fn" translate="no" id="GeneratorParameters-typedef"><code class="details extra" translate="no">[alias]</code> QDtls::<span class="name">GeneratorParameters</span></h3>
<!-- @@@GeneratorParameters -->
<!-- $$$HandshakeState$$$HandshakeNotStarted$$$HandshakeInProgress$$$PeerVerificationFailed$$$HandshakeComplete -->
<h3 class="fn" translate="no" id="HandshakeState-enum">enum QDtls::<span class="name">HandshakeState</span></h3>
<p>Describes the current state of DTLS handshake.</p>
<p>This enum describes the current state of DTLS handshake for a <a href="qdtls.html" translate="no">QDtls</a> connection.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QDtls::HandshakeNotStarted</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Nothing done yet.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::HandshakeInProgress</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Handshake was initiated and no errors were found so far.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::PeerVerificationFailed</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The identity of the peer can't be established.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::HandshakeComplete</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Handshake completed successfully and encrypted connection was established.</td></tr>
</table></div>
<p><b>See also </b><a href="qdtls.html#doHandshake" translate="no">QDtls::doHandshake</a>() and <a href="qdtls.html#handshakeState" translate="no">QDtls::handshakeState</a>().</p>
<!-- @@@HandshakeState -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QDtls[overload1]$$$QDtlsQSslSocket::SslModeQObject* -->
<h3 class="fn" translate="no" id="QDtls"><code class="details extra" translate="no">[explicit]</code> QDtls::<span class="name">QDtls</span>(<span class="type"><a href="qsslsocket.html#SslMode-enum" translate="no">QSslSocket::SslMode</a></span> <i>mode</i>, <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Creates a QDtls object, <i translate="no">parent</i> is passed to the <a href="../qtcore/qobject.html" translate="no">QObject</a> constructor. <i translate="no">mode</i> is <a href="qsslsocket.html#SslMode-enum" translate="no">QSslSocket::SslServerMode</a> for a server-side DTLS connection or <a href="qsslsocket.html#SslMode-enum" translate="no">QSslSocket::SslClientMode</a> for a client.</p>
<p><b>See also </b><a href="qdtls.html#sslMode" translate="no">sslMode</a>() and <a href="qsslsocket.html#SslMode-enum" translate="no">QSslSocket::SslMode</a>.</p>
<!-- @@@QDtls -->
<!-- $$$~QDtls[overload1]$$$~QDtls -->
<h3 class="fn" translate="no" id="dtor.QDtls"><code class="details extra" translate="no">[virtual noexcept]</code> QDtls::<span class="name">~QDtls</span>()</h3>
<p>Destroys the <a href="qdtls.html" translate="no">QDtls</a> object.</p>
<!-- @@@~QDtls -->
<!-- $$$abortHandshake[overload1]$$$abortHandshakeQUdpSocket* -->
<h3 class="fn" translate="no" id="abortHandshake"><span class="type">bool</span> QDtls::<span class="name">abortHandshake</span>(<span class="type"><a href="qudpsocket.html" translate="no">QUdpSocket</a></span> *<i>socket</i>)</h3>
<p>Aborts the ongoing handshake. Returns true if one was on-going on <i translate="no">socket</i>; otherwise, sets a suitable error and returns false.</p>
<p><b>See also </b><a href="qdtls.html#doHandshake" translate="no">doHandshake</a>() and <a href="qdtls.html#resumeHandshake" translate="no">resumeHandshake</a>().</p>
<!-- @@@abortHandshake -->
<!-- $$$cookieGeneratorParameters[overload1]$$$cookieGeneratorParameters -->
<h3 class="fn" translate="no" id="cookieGeneratorParameters"><span class="type"><a href="qdtls.html#GeneratorParameters-typedef" translate="no">QDtls::GeneratorParameters</a></span> QDtls::<span class="name">cookieGeneratorParameters</span>() const</h3>
<p>Returns the current hash algorithm and secret, either default ones or previously set by a call to <a href="qdtls.html#setCookieGeneratorParameters" translate="no">setCookieGeneratorParameters</a>().</p>
<p>The default hash algorithm is <a href="../qtcore/qcryptographichash.html#Algorithm-enum" translate="no">QCryptographicHash::Sha256</a> if Qt was configured to support it, <a href="../qtcore/qcryptographichash.html#Algorithm-enum" translate="no">QCryptographicHash::Sha1</a> otherwise. The default secret is obtained from the backend-specific cryptographically strong pseudorandom number generator.</p>
<p><b>See also </b><a href="qdtls.html#setCookieGeneratorParameters" translate="no">setCookieGeneratorParameters</a>(), <a href="qdtlsclientverifier.html" translate="no">QDtlsClientVerifier</a>, and cookieGeneratorParameters().</p>
<!-- @@@cookieGeneratorParameters -->
<!-- $$$decryptDatagram[overload1]$$$decryptDatagramQUdpSocket*constQByteArray& -->
<h3 class="fn" translate="no" id="decryptDatagram"><span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> QDtls::<span class="name">decryptDatagram</span>(<span class="type"><a href="qudpsocket.html" translate="no">QUdpSocket</a></span> *<i>socket</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>dgram</i>)</h3>
<p>Decrypts <i translate="no">dgram</i> and returns its contents as plain text. The handshake must be completed before datagrams can be decrypted. Depending on the type of the TLS message the connection may write into <i translate="no">socket</i>, which must be a valid pointer.</p>
<!-- @@@decryptDatagram -->
<!-- $$$doHandshake[overload1]$$$doHandshakeQUdpSocket*constQByteArray& -->
<h3 class="fn" translate="no" id="doHandshake"><span class="type">bool</span> QDtls::<span class="name">doHandshake</span>(<span class="type"><a href="qudpsocket.html" translate="no">QUdpSocket</a></span> *<i>socket</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>dgram</i> = {})</h3>
<p>Starts or continues a DTLS handshake. <i translate="no">socket</i> must be a valid pointer. When starting a server-side DTLS handshake, <i translate="no">dgram</i> must contain the initial ClientHello message read from <a href="qudpsocket.html" translate="no">QUdpSocket</a>. This function returns <code translate="no">true</code> if no error was found. Handshake state can be tested using <a href="qdtls.html#handshakeState" translate="no">handshakeState</a>(). <code translate="no">false</code> return means some error occurred, use <a href="qdtls.html#dtlsError" translate="no">dtlsError</a>() for more detailed information.</p>
<div class="admonition note">
<p><b>Note: </b>If the identity of the peer can't be established, the error is set to <a href="qdtls.html#QDtlsError-enum" translate="no">QDtlsError::PeerVerificationError</a>. If you want to ignore verification errors and continue connecting, you must call <a href="qdtls.html#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>() and then <a href="qdtls.html#resumeHandshake" translate="no">resumeHandshake</a>(). If the errors cannot be ignored, you must call <a href="qdtls.html#abortHandshake" translate="no">abortHandshake</a>().</p>
</div>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (<span class="operator">!</span>dtls<span class="operator">.</span>doHandshake(<span class="operator">&amp;</span>socket<span class="operator">,</span> dgram)) {
     <span class="keyword">if</span> (dtls<span class="operator">.</span>dtlsError() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qdtls.html#QDtlsError-enum" translate="no">QDtlsError</a></span><span class="operator">::</span>PeerVerificationError)
         dtls<span class="operator">.</span>abortAfterError(<span class="operator">&amp;</span>socket);
 }
</pre>
<p><b>See also </b><a href="qdtls.html#handshakeState" translate="no">handshakeState</a>(), <a href="qdtls.html#dtlsError" translate="no">dtlsError</a>(), <a href="qdtls.html#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>(), <a href="qdtls.html#resumeHandshake" translate="no">resumeHandshake</a>(), and <a href="qdtls.html#abortHandshake" translate="no">abortHandshake</a>().</p>
<!-- @@@doHandshake -->
<!-- $$$dtlsConfiguration[overload1]$$$dtlsConfiguration -->
<h3 class="fn" translate="no" id="dtlsConfiguration"><span class="type"><a href="qsslconfiguration.html" translate="no">QSslConfiguration</a></span> QDtls::<span class="name">dtlsConfiguration</span>() const</h3>
<p>Returns either the default DTLS configuration or the configuration set by an earlier call to <a href="qdtls.html#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>().</p>
<p><b>See also </b><a href="qdtls.html#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>() and <a href="qsslconfiguration.html#defaultDtlsConfiguration" translate="no">QSslConfiguration::defaultDtlsConfiguration</a>().</p>
<!-- @@@dtlsConfiguration -->
<!-- $$$dtlsError[overload1]$$$dtlsError -->
<h3 class="fn" translate="no" id="dtlsError"><span class="type"><a href="qdtls.html#QDtlsError-enum" translate="no">QDtlsError</a></span> QDtls::<span class="name">dtlsError</span>() const</h3>
<p>Returns the last error encountered by the connection or <a href="qdtls.html#QDtlsError-enum" translate="no">QDtlsError::NoError</a>.</p>
<p><b>See also </b><a href="qdtls.html#dtlsErrorString" translate="no">dtlsErrorString</a>() and <a href="qdtls.html#QDtlsError-enum" translate="no">QDtlsError</a>.</p>
<!-- @@@dtlsError -->
<!-- $$$dtlsErrorString[overload1]$$$dtlsErrorString -->
<h3 class="fn" translate="no" id="dtlsErrorString"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QDtls::<span class="name">dtlsErrorString</span>() const</h3>
<p>Returns a textual description for the last error encountered by the connection or empty string.</p>
<p><b>See also </b><a href="qdtls.html#dtlsError" translate="no">dtlsError</a>().</p>
<!-- @@@dtlsErrorString -->
<!-- $$$handleTimeout[overload1]$$$handleTimeoutQUdpSocket* -->
<h3 class="fn" translate="no" id="handleTimeout"><span class="type">bool</span> QDtls::<span class="name">handleTimeout</span>(<span class="type"><a href="qudpsocket.html" translate="no">QUdpSocket</a></span> *<i>socket</i>)</h3>
<p>If a timeout occurs during the handshake, the <a href="qdtls.html#handshakeTimeout" translate="no">handshakeTimeout</a>() signal is emitted. The application must call handleTimeout() to retransmit handshake messages; handleTimeout() returns <code translate="no">true</code> if a timeout has occurred, false otherwise. <i translate="no">socket</i> must be a valid pointer.</p>
<p><b>See also </b><a href="qdtls.html#handshakeTimeout" translate="no">handshakeTimeout</a>().</p>
<!-- @@@handleTimeout -->
<!-- $$$handshakeState[overload1]$$$handshakeState -->
<h3 class="fn" translate="no" id="handshakeState"><span class="type"><a href="qdtls.html#HandshakeState-enum" translate="no">QDtls::HandshakeState</a></span> QDtls::<span class="name">handshakeState</span>() const</h3>
<p>Returns the current handshake state for this <a href="qdtls.html" translate="no">QDtls</a>.</p>
<p><b>See also </b><a href="qdtls.html#doHandshake" translate="no">doHandshake</a>() and <a href="qdtls.html#HandshakeState-enum" translate="no">QDtls::HandshakeState</a>.</p>
<!-- @@@handshakeState -->
<!-- $$$handshakeTimeout[overload1]$$$handshakeTimeout -->
<h3 class="fn" translate="no" id="handshakeTimeout"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QDtls::<span class="name">handshakeTimeout</span>()</h3>
<p>Packet loss can result in timeouts during the handshake phase. In this case <a href="qdtls.html" translate="no">QDtls</a> emits a handshakeTimeout() signal. Call <a href="qdtls.html#handleTimeout" translate="no">handleTimeout</a>() to retransmit the handshake messages:</p>
<pre class="cpp" translate="no">
 DtlsClient<span class="operator">::</span>DtlsClient()
 {
     <span class="comment">// Some initialization code here ...</span>
     connect(<span class="operator">&amp;</span>clientDtls<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qdtls.html#QDtls" translate="no">QDtls</a></span><span class="operator">::</span>handshakeTimeout<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>DtlsClient<span class="operator">::</span>handleTimeout);
 }

 <span class="type">void</span> DtlsClient<span class="operator">::</span>handleTimeout()
 {
     clientDtls<span class="operator">.</span>handleTimeout(<span class="operator">&amp;</span>clientSocket);
 }
</pre>
<p><b>See also </b><a href="qdtls.html#handleTimeout" translate="no">handleTimeout</a>().</p>
<!-- @@@handshakeTimeout -->
<!-- $$$ignoreVerificationErrors[overload1]$$$ignoreVerificationErrorsconstQList<QSslError>& -->
<h3 class="fn" translate="no" id="ignoreVerificationErrors"><span class="type">void</span> QDtls::<span class="name">ignoreVerificationErrors</span>(const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qsslerror.html" translate="no">QSslError</a></span>&gt; &amp;<i>errorsToIgnore</i>)</h3>
<p>This method tells <a href="qdtls.html" translate="no">QDtls</a> to ignore only the errors given in <i translate="no">errorsToIgnore</i>.</p>
<p>If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslcertificate.html" translate="no">QSslCertificate</a></span><span class="operator">&gt;</span> cert <span class="operator">=</span> <span class="type"><a href="qsslcertificate.html" translate="no">QSslCertificate</a></span><span class="operator">::</span>fromPath(<span class="string">&quot;server-certificate.pem&quot;</span>_L1);
 <span class="type"><a href="qsslerror.html" translate="no">QSslError</a></span> error(<span class="type"><a href="qsslerror.html" translate="no">QSslError</a></span><span class="operator">::</span>SelfSignedCertificate<span class="operator">,</span> cert<span class="operator">.</span>at(<span class="number">0</span>));
 <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslerror.html" translate="no">QSslError</a></span><span class="operator">&gt;</span> expectedSslErrors;
 expectedSslErrors<span class="operator">.</span>append(error);

 <span class="type"><a href="qdtls.html#QDtls" translate="no">QDtls</a></span> dtls;
 dtls<span class="operator">.</span>ignoreVerificationErrors(expectedSslErrors);
 dtls<span class="operator">.</span>doHandshake(udpSocket);
</pre>
<p>You can also call this function after <a href="qdtls.html#doHandshake" translate="no">doHandshake</a>() encountered the <a href="qdtls.html#QDtlsError-enum" translate="no">QDtlsError::PeerVerificationError</a> error, and then resume the handshake by calling <a href="qdtls.html#resumeHandshake" translate="no">resumeHandshake</a>().</p>
<p>Later calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</p>
<p><b>See also </b><a href="qdtls.html#doHandshake" translate="no">doHandshake</a>(), <a href="qdtls.html#resumeHandshake" translate="no">resumeHandshake</a>(), and <a href="qsslerror.html" translate="no">QSslError</a>.</p>
<!-- @@@ignoreVerificationErrors -->
<!-- $$$isConnectionEncrypted[overload1]$$$isConnectionEncrypted -->
<h3 class="fn" translate="no" id="isConnectionEncrypted"><span class="type">bool</span> QDtls::<span class="name">isConnectionEncrypted</span>() const</h3>
<p>Returns <code translate="no">true</code> if DTLS handshake completed successfully.</p>
<p><b>See also </b><a href="qdtls.html#doHandshake" translate="no">doHandshake</a>() and <a href="qdtls.html#handshakeState" translate="no">handshakeState</a>().</p>
<!-- @@@isConnectionEncrypted -->
<!-- $$$mtuHint[overload1]$$$mtuHint -->
<h3 class="fn" translate="no" id="mtuHint"><span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> QDtls::<span class="name">mtuHint</span>() const</h3>
<p>Returns the value previously set by <a href="qdtls.html#setMtuHint" translate="no">setMtuHint</a>(). The default value is 0.</p>
<p><b>See also </b><a href="qdtls.html#setMtuHint" translate="no">setMtuHint</a>().</p>
<!-- @@@mtuHint -->
<!-- $$$peerAddress[overload1]$$$peerAddress -->
<h3 class="fn" translate="no" id="peerAddress"><span class="type"><a href="qhostaddress.html" translate="no">QHostAddress</a></span> QDtls::<span class="name">peerAddress</span>() const</h3>
<p>Returns the peer's address, set by <a href="qdtls.html#setPeer" translate="no">setPeer</a>(), or <a href="qhostaddress.html#SpecialAddress-enum" translate="no">QHostAddress::Null</a>.</p>
<p><b>See also </b><a href="qdtls.html#setPeer" translate="no">setPeer</a>().</p>
<!-- @@@peerAddress -->
<!-- $$$peerPort[overload1]$$$peerPort -->
<h3 class="fn" translate="no" id="peerPort"><span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> QDtls::<span class="name">peerPort</span>() const</h3>
<p>Returns the peer's port number, set by <a href="qdtls.html#setPeer" translate="no">setPeer</a>(), or 0.</p>
<p><b>See also </b><a href="qdtls.html#setPeer" translate="no">setPeer</a>().</p>
<!-- @@@peerPort -->
<!-- $$$peerVerificationErrors[overload1]$$$peerVerificationErrors -->
<h3 class="fn" translate="no" id="peerVerificationErrors"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qsslerror.html" translate="no">QSslError</a></span>&gt; QDtls::<span class="name">peerVerificationErrors</span>() const</h3>
<p>Returns errors found while establishing the identity of the peer.</p>
<p>If you want to continue connecting despite the errors that have occurred, you must call <a href="qdtls.html#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>().</p>
<!-- @@@peerVerificationErrors -->
<!-- $$$peerVerificationName[overload1]$$$peerVerificationName -->
<h3 class="fn" translate="no" id="peerVerificationName"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QDtls::<span class="name">peerVerificationName</span>() const</h3>
<p>Returns the host name set by <a href="qdtls.html#setPeer" translate="no">setPeer</a>() or <a href="qdtls.html#setPeerVerificationName" translate="no">setPeerVerificationName</a>(). The default value is an empty string.</p>
<p><b>See also </b><a href="qdtls.html#setPeerVerificationName" translate="no">setPeerVerificationName</a>() and <a href="qdtls.html#setPeer" translate="no">setPeer</a>().</p>
<!-- @@@peerVerificationName -->
<!-- $$$pskRequired[overload1]$$$pskRequiredQSslPreSharedKeyAuthenticator* -->
<h3 class="fn" translate="no" id="pskRequired"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QDtls::<span class="name">pskRequired</span>(<span class="type"><a href="qsslpresharedkeyauthenticator.html" translate="no">QSslPreSharedKeyAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p><a href="qdtls.html" translate="no">QDtls</a> emits this signal when it negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</p>
<p>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the TLS handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <i translate="no">authenticator</i> object according to their needs.</p>
<div class="admonition note">
<p><b>Note: </b>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The <i translate="no">authenticator</i> object is owned by <a href="qdtls.html" translate="no">QDtls</a> and must not be deleted by the application.</p>
</div>
<p><b>See also </b><a href="qsslpresharedkeyauthenticator.html" translate="no">QSslPreSharedKeyAuthenticator</a>.</p>
<!-- @@@pskRequired -->
<!-- $$$resumeHandshake[overload1]$$$resumeHandshakeQUdpSocket* -->
<h3 class="fn" translate="no" id="resumeHandshake"><span class="type">bool</span> QDtls::<span class="name">resumeHandshake</span>(<span class="type"><a href="qudpsocket.html" translate="no">QUdpSocket</a></span> *<i>socket</i>)</h3>
<p>If peer verification errors were ignored during the handshake, resumeHandshake() resumes and completes the handshake and returns <code translate="no">true</code>. <i translate="no">socket</i> must be a valid pointer. Returns <code translate="no">false</code> if the handshake could not be resumed.</p>
<p><b>See also </b><a href="qdtls.html#doHandshake" translate="no">doHandshake</a>(), <a href="qdtls.html#abortHandshake" translate="no">abortHandshake</a>(), <a href="qdtls.html#peerVerificationErrors" translate="no">peerVerificationErrors</a>(), and <a href="qdtls.html#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>().</p>
<!-- @@@resumeHandshake -->
<!-- $$$sessionCipher[overload1]$$$sessionCipher -->
<h3 class="fn" translate="no" id="sessionCipher"><span class="type"><a href="qsslcipher.html" translate="no">QSslCipher</a></span> QDtls::<span class="name">sessionCipher</span>() const</h3>
<p>Returns the cryptographic <a href="qsslcipher.html" translate="no">cipher</a> used by this connection, or a null cipher if the connection isn't encrypted. The cipher for the session is selected during the handshake phase. The cipher is used to encrypt and decrypt data.</p>
<p><a href="qsslconfiguration.html" translate="no">QSslConfiguration</a> provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</p>
<p><b>See also </b><a href="qsslconfiguration.html" translate="no">QSslConfiguration</a>, <a href="qdtls.html#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>(), and <a href="qdtls.html#dtlsConfiguration" translate="no">dtlsConfiguration</a>().</p>
<!-- @@@sessionCipher -->
<!-- $$$sessionProtocol[overload1]$$$sessionProtocol -->
<h3 class="fn" translate="no" id="sessionProtocol"><span class="type"><a href="qssl.html#SslProtocol-enum" translate="no">QSsl::SslProtocol</a></span> QDtls::<span class="name">sessionProtocol</span>() const</h3>
<p>Returns the DTLS protocol version used by this connection, or UnknownProtocol if the connection isn't encrypted yet. The protocol for the connection is selected during the handshake phase.</p>
<p><a href="qdtls.html#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>() can set the preferred version before the handshake starts.</p>
<p><b>See also </b><a href="qdtls.html#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>(), <a href="qsslconfiguration.html" translate="no">QSslConfiguration</a>, <a href="qsslconfiguration.html#defaultDtlsConfiguration" translate="no">QSslConfiguration::defaultDtlsConfiguration</a>(), and <a href="qsslconfiguration.html#setProtocol" translate="no">QSslConfiguration::setProtocol</a>().</p>
<!-- @@@sessionProtocol -->
<!-- $$$setCookieGeneratorParameters[overload1]$$$setCookieGeneratorParametersconstQDtls::GeneratorParameters& -->
<h3 class="fn" translate="no" id="setCookieGeneratorParameters"><span class="type">bool</span> QDtls::<span class="name">setCookieGeneratorParameters</span>(const <span class="type"><a href="qdtls.html#GeneratorParameters-typedef" translate="no">QDtls::GeneratorParameters</a></span> &amp;<i>params</i>)</h3>
<p>Sets the cryptographic hash algorithm and the secret from <i translate="no">params</i>. This function is only needed for a server-side <a href="qdtls.html" translate="no">QDtls</a> connection. Returns <code translate="no">true</code> if successful.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the handshake starts.</p>
</div>
<p><b>See also </b><a href="qdtls.html#cookieGeneratorParameters" translate="no">cookieGeneratorParameters</a>(), <a href="qdtls.html#doHandshake" translate="no">doHandshake</a>(), <a href="qdtlsclientverifier.html" translate="no">QDtlsClientVerifier</a>, and <a href="qdtlsclientverifier.html#cookieGeneratorParameters" translate="no">QDtlsClientVerifier::cookieGeneratorParameters</a>().</p>
<!-- @@@setCookieGeneratorParameters -->
<!-- $$$setDtlsConfiguration[overload1]$$$setDtlsConfigurationconstQSslConfiguration& -->
<h3 class="fn" translate="no" id="setDtlsConfiguration"><span class="type">bool</span> QDtls::<span class="name">setDtlsConfiguration</span>(const <span class="type"><a href="qsslconfiguration.html" translate="no">QSslConfiguration</a></span> &amp;<i>configuration</i>)</h3>
<p>Sets the connection's TLS configuration from <i translate="no">configuration</i> and returns <code translate="no">true</code> if successful.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the handshake starts.</p>
</div>
<p><b>See also </b><a href="qdtls.html#dtlsConfiguration" translate="no">dtlsConfiguration</a>() and <a href="qdtls.html#doHandshake" translate="no">doHandshake</a>().</p>
<!-- @@@setDtlsConfiguration -->
<!-- $$$setMtuHint[overload1]$$$setMtuHintquint16 -->
<h3 class="fn" translate="no" id="setMtuHint"><span class="type">void</span> QDtls::<span class="name">setMtuHint</span>(<span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>mtuHint</i>)</h3>
<p><i translate="no">mtuHint</i> is the maximum transmission unit (MTU), either discovered or guessed by the application. The application is not required to set this value.</p>
<p><b>See also </b><a href="qdtls.html#mtuHint" translate="no">mtuHint</a>() and <a href="qabstractsocket.html#SocketOption-enum" translate="no">QAbstractSocket::PathMtuSocketOption</a>.</p>
<!-- @@@setMtuHint -->
<!-- $$$setPeer[overload1]$$$setPeerconstQHostAddress&quint16constQString& -->
<h3 class="fn" translate="no" id="setPeer"><span class="type">bool</span> QDtls::<span class="name">setPeer</span>(const <span class="type"><a href="qhostaddress.html" translate="no">QHostAddress</a></span> &amp;<i>address</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>verificationName</i> = {})</h3>
<p>Sets the peer's address, <i translate="no">port</i>, and host name and returns <code translate="no">true</code> if successful. <i translate="no">address</i> must not be null, multicast, or broadcast. <i translate="no">verificationName</i> is the host name used for the certificate validation.</p>
<p><b>See also </b><a href="qdtls.html#peerAddress" translate="no">peerAddress</a>(), <a href="qdtls.html#peerPort" translate="no">peerPort</a>(), and <a href="qdtls.html#peerVerificationName" translate="no">peerVerificationName</a>().</p>
<!-- @@@setPeer -->
<!-- $$$setPeerVerificationName[overload1]$$$setPeerVerificationNameconstQString& -->
<h3 class="fn" translate="no" id="setPeerVerificationName"><span class="type">bool</span> QDtls::<span class="name">setPeerVerificationName</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>name</i>)</h3>
<p>Sets the host <i translate="no">name</i> that will be used for the certificate validation and returns <code translate="no">true</code> if successful.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the handshake starts.</p>
</div>
<p><b>See also </b><a href="qdtls.html#peerVerificationName" translate="no">peerVerificationName</a>() and <a href="qdtls.html#setPeer" translate="no">setPeer</a>().</p>
<!-- @@@setPeerVerificationName -->
<!-- $$$shutdown[overload1]$$$shutdownQUdpSocket* -->
<h3 class="fn" translate="no" id="shutdown"><span class="type">bool</span> QDtls::<span class="name">shutdown</span>(<span class="type"><a href="qudpsocket.html" translate="no">QUdpSocket</a></span> *<i>socket</i>)</h3>
<p>Sends an encrypted shutdown alert message and closes the DTLS connection. Handshake state changes to <a href="qdtls.html#HandshakeState-enum" translate="no">QDtls::HandshakeNotStarted</a>. <i translate="no">socket</i> must be a valid pointer. This function returns <code translate="no">true</code> on success.</p>
<p><b>See also </b><a href="qdtls.html#doHandshake" translate="no">doHandshake</a>().</p>
<!-- @@@shutdown -->
<!-- $$$sslMode[overload1]$$$sslMode -->
<h3 class="fn" translate="no" id="sslMode"><span class="type"><a href="qsslsocket.html#SslMode-enum" translate="no">QSslSocket::SslMode</a></span> QDtls::<span class="name">sslMode</span>() const</h3>
<p>Returns <a href="qsslsocket.html#SslMode-enum" translate="no">QSslSocket::SslServerMode</a> for a server-side connection and <a href="qsslsocket.html#SslMode-enum" translate="no">QSslSocket::SslClientMode</a> for a client.</p>
<p><b>See also </b><a href="qdtls.html#QDtls" translate="no">QDtls</a>() and <a href="qsslsocket.html#SslMode-enum" translate="no">QSslSocket::SslMode</a>.</p>
<!-- @@@sslMode -->
<!-- $$$writeDatagramEncrypted[overload1]$$$writeDatagramEncryptedQUdpSocket*constQByteArray& -->
<h3 class="fn" translate="no" id="writeDatagramEncrypted"><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QDtls::<span class="name">writeDatagramEncrypted</span>(<span class="type"><a href="qudpsocket.html" translate="no">QUdpSocket</a></span> *<i>socket</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>dgram</i>)</h3>
<p>Encrypts <i translate="no">dgram</i> and writes the encrypted data into <i translate="no">socket</i>. Returns the number of bytes written, or -1 in case of error. The handshake must be completed before writing encrypted data. <i translate="no">socket</i> must be a valid pointer.</p>
<p><b>See also </b><a href="qdtls.html#doHandshake" translate="no">doHandshake</a>(), <a href="qdtls.html#handshakeState" translate="no">handshakeState</a>(), <a href="qdtls.html#isConnectionEncrypted" translate="no">isConnectionEncrypted</a>(), and <a href="qdtls.html#dtlsError" translate="no">dtlsError</a>().</p>
<!-- @@@writeDatagramEncrypted -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$QDtlsError$$$NoError$$$InvalidInputParameters$$$InvalidOperation$$$UnderlyingSocketError$$$RemoteClosedConnectionError$$$PeerVerificationError$$$TlsInitializationError$$$TlsFatalError$$$TlsNonFatalError -->
<h3 class="fn" translate="no" id="QDtlsError-enum">enum class <span class="name">QDtlsError</span></h3>
<p>Describes errors that can be found by <a href="qdtls.html" translate="no">QDtls</a> and <a href="qdtlsclientverifier.html" translate="no">QDtlsClientVerifier</a>.</p>
<p>This enum describes general and TLS-specific errors that can be encountered by objects of the classes <a href="qdtlsclientverifier.html" translate="no">QDtlsClientVerifier</a> and <a href="qdtls.html" translate="no">QDtls</a>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::NoError</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">No error occurred, the last operation was successful.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::InvalidInputParameters</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Input parameters provided by a caller were invalid.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::InvalidOperation</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">An operation was attempted in a state that did not permit it.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::UnderlyingSocketError</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign"><a href="qudpsocket.html#writeDatagram" translate="no">QUdpSocket::writeDatagram</a>() failed, <a href="qabstractsocket.html#error" translate="no">QUdpSocket::error</a>() and <a href="../qtcore/qiodevice.html#errorString" translate="no">QUdpSocket::errorString</a>() can provide more specific information.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::RemoteClosedConnectionError</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">TLS shutdown alert message was received.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::PeerVerificationError</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Peer's identity could not be verified during the TLS handshake.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::TlsInitializationError</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">An error occurred while initializing an underlying TLS backend.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::TlsFatalError</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">A fatal error occurred during TLS handshake, other than peer verification error or TLS initialization error.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::TlsNonFatalError</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">A failure to encrypt or decrypt a datagram, non-fatal, meaning <a href="qdtls.html" translate="no">QDtls</a> can continue working after this error.</td></tr>
</table></div>
<!-- @@@QDtlsError -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
