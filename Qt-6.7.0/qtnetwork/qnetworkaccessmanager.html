<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qnetworkaccessmanager.cpp -->
  <meta name="description" content="The QNetworkAccessManager class allows the application to send network requests and receive replies.">
  <title>QNetworkAccessManager Class | Qt Network 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtnetwork-index.html" translate="no">Qt Network</a></li>
<li><a href="qtnetwork-module.html" translate="no">C++ Classes</a></li>
<li>QNetworkAccessManager</li>
<li id="buildversion"><a href="qtnetwork-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QNetworkAccessManager Class</h1>
<!-- $$$QNetworkAccessManager-brief -->
<p>The QNetworkAccessManager class allows the application to send network requests and receive replies. <a href="#details">More...</a></p>
<!-- @@@QNetworkAccessManager -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QNetworkAccessManager&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Network) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Network)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += network</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html" translate="no">QObject</a></td></tr>
</table></div>
<ul>
<li><a href="qnetworkaccessmanager-members.html">List of all members, including inherited members</a></li>
<li><a href="qnetworkaccessmanager-obsolete.html">Deprecated members</a></li>
<li>QNetworkAccessManager is part of <a href="network.html">Network Programming API</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#Operation-enum" translate="no">Operation</a></b> { HeadOperation, GetOperation, PutOperation, PostOperation, DeleteOperation, CustomOperation }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#QNetworkAccessManager" translate="no">QNetworkAccessManager</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#dtor.QNetworkAccessManager" translate="no">~QNetworkAccessManager</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#addStrictTransportSecurityHosts" translate="no">addStrictTransportSecurityHosts</a></b>(const QList&lt;QHstsPolicy&gt; &amp;<i>knownHosts</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#autoDeleteReplies" translate="no">autoDeleteReplies</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractNetworkCache *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#cache" translate="no">cache</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#clearAccessCache" translate="no">clearAccessCache</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#clearConnectionCache" translate="no">clearConnectionCache</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#connectToHost" translate="no">connectToHost</a></b>(const QString &amp;<i>hostName</i>, quint16 <i>port</i> = 80)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#connectToHostEncrypted" translate="no">connectToHostEncrypted</a></b>(const QString &amp;<i>hostName</i>, quint16 <i>port</i> = 443, const QSslConfiguration &amp;<i>sslConfiguration</i> = QSslConfiguration::defaultConfiguration())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#connectToHostEncrypted-1" translate="no">connectToHostEncrypted</a></b>(const QString &amp;<i>hostName</i>, quint16 <i>port</i>, const QSslConfiguration &amp;<i>sslConfiguration</i>, const QString &amp;<i>peerName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkCookieJar *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#cookieJar" translate="no">cookieJar</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#deleteResource" translate="no">deleteResource</a></b>(const QNetworkRequest &amp;<i>request</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#enableStrictTransportSecurityStore" translate="no">enableStrictTransportSecurityStore</a></b>(bool <i>enabled</i>, const QString &amp;<i>storeDir</i> = QString())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#get" translate="no">get</a></b>(const QNetworkRequest &amp;<i>request</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#get-1" translate="no">get</a></b>(const QNetworkRequest &amp;<i>request</i>, QIODevice *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#get-2" translate="no">get</a></b>(const QNetworkRequest &amp;<i>request</i>, const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#head" translate="no">head</a></b>(const QNetworkRequest &amp;<i>request</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#isStrictTransportSecurityEnabled" translate="no">isStrictTransportSecurityEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#isStrictTransportSecurityStoreEnabled" translate="no">isStrictTransportSecurityStoreEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#post" translate="no">post</a></b>(const QNetworkRequest &amp;<i>request</i>, QIODevice *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#post-1" translate="no">post</a></b>(const QNetworkRequest &amp;<i>request</i>, const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#post-2" translate="no">post</a></b>(const QNetworkRequest &amp;<i>request</i>, QHttpMultiPart *<i>multiPart</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkProxy </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#proxy" translate="no">proxy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkProxyFactory *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#proxyFactory" translate="no">proxyFactory</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#put" translate="no">put</a></b>(const QNetworkRequest &amp;<i>request</i>, QIODevice *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#put-1" translate="no">put</a></b>(const QNetworkRequest &amp;<i>request</i>, const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#put-2" translate="no">put</a></b>(const QNetworkRequest &amp;<i>request</i>, QHttpMultiPart *<i>multiPart</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkRequest::RedirectPolicy </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#redirectPolicy" translate="no">redirectPolicy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#sendCustomRequest" translate="no">sendCustomRequest</a></b>(const QNetworkRequest &amp;<i>request</i>, const QByteArray &amp;<i>verb</i>, QIODevice *<i>data</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#sendCustomRequest-1" translate="no">sendCustomRequest</a></b>(const QNetworkRequest &amp;<i>request</i>, const QByteArray &amp;<i>verb</i>, const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#sendCustomRequest-2" translate="no">sendCustomRequest</a></b>(const QNetworkRequest &amp;<i>request</i>, const QByteArray &amp;<i>verb</i>, QHttpMultiPart *<i>multiPart</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setAutoDeleteReplies" translate="no">setAutoDeleteReplies</a></b>(bool <i>shouldAutoDelete</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setCache" translate="no">setCache</a></b>(QAbstractNetworkCache *<i>cache</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setCookieJar" translate="no">setCookieJar</a></b>(QNetworkCookieJar *<i>cookieJar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setProxy" translate="no">setProxy</a></b>(const QNetworkProxy &amp;<i>proxy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setProxyFactory" translate="no">setProxyFactory</a></b>(QNetworkProxyFactory *<i>factory</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setRedirectPolicy" translate="no">setRedirectPolicy</a></b>(QNetworkRequest::RedirectPolicy <i>policy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setStrictTransportSecurityEnabled" translate="no">setStrictTransportSecurityEnabled</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setTransferTimeout" translate="no">setTransferTimeout</a></b>(int <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#setTransferTimeout-1" translate="no">setTransferTimeout</a></b>(std::chrono::milliseconds <i>duration</i> = QNetworkRequest::DefaultTransferTimeout)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QHstsPolicy&gt; </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#strictTransportSecurityHosts" translate="no">strictTransportSecurityHosts</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QStringList </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#supportedSchemes" translate="no">supportedSchemes</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#transferTimeout" translate="no">transferTimeout</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.7)</code> std::chrono::milliseconds </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#transferTimeoutAsDuration" translate="no">transferTimeoutAsDuration</a></b>() const</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#authenticationRequired" translate="no">authenticationRequired</a></b>(QNetworkReply *<i>reply</i>, QAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#encrypted" translate="no">encrypted</a></b>(QNetworkReply *<i>reply</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#finished" translate="no">finished</a></b>(QNetworkReply *<i>reply</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#preSharedKeyAuthenticationRequired" translate="no">preSharedKeyAuthenticationRequired</a></b>(QNetworkReply *<i>reply</i>, QSslPreSharedKeyAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#proxyAuthenticationRequired" translate="no">proxyAuthenticationRequired</a></b>(const QNetworkProxy &amp;<i>proxy</i>, QAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#sslErrors" translate="no">sslErrors</a></b>(QNetworkReply *<i>reply</i>, const QList&lt;QSslError&gt; &amp;<i>errors</i>)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QNetworkReply *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkaccessmanager.html#createRequest" translate="no">createRequest</a></b>(QNetworkAccessManager::Operation <i>op</i>, const QNetworkRequest &amp;<i>originalReq</i>, QIODevice *<i>outgoingData</i> = nullptr)</td></tr>
</table></div>
<!-- $$$QNetworkAccessManager-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The Network Access API is constructed around one QNetworkAccessManager object, which holds the common configuration and settings for the requests it sends. It contains the proxy and cache configuration, as well as the signals related to such issues, and reply signals that can be used to monitor the progress of a network operation. One QNetworkAccessManager instance should be enough for the whole Qt application. Since QNetworkAccessManager is based on <a href="../qtcore/qobject.html" translate="no">QObject</a>, it can only be used from the thread it belongs to.</p>
<p>Once a QNetworkAccessManager object has been created, the application can use it to send requests over the network. A group of standard functions are supplied that take a request and optional data, and each return a <a href="qnetworkreply.html" translate="no">QNetworkReply</a> object. The returned object is used to obtain any data returned in response to the corresponding request.</p>
<p>A simple download off the network could be accomplished with:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qnetworkaccessmanager.html#QNetworkAccessManager" translate="no">QNetworkAccessManager</a></span> <span class="operator">*</span>manager <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qnetworkaccessmanager.html#QNetworkAccessManager" translate="no">QNetworkAccessManager</a></span>(<span class="keyword">this</span>);
 connect(manager<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qnetworkaccessmanager.html#QNetworkAccessManager" translate="no">QNetworkAccessManager</a></span><span class="operator">::</span>finished<span class="operator">,</span>
         <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyClass<span class="operator">::</span>replyFinished);

 manager<span class="operator">-</span><span class="operator">&gt;</span>get(<span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span>(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>(<span class="string">&quot;http://qt-project.org&quot;</span>)));
</pre>
<p>QNetworkAccessManager has an asynchronous API. When the <code translate="no">replyFinished</code> slot above is called, the parameter it takes is the <a href="qnetworkreply.html" translate="no">QNetworkReply</a> object containing the downloaded data as well as meta-data (headers, etc.).</p>
<div class="admonition note">
<p><b>Note: </b>After the request has finished, it is the responsibility of the user to delete the <a href="qnetworkreply.html" translate="no">QNetworkReply</a> object at an appropriate time. Do not directly delete it inside the slot connected to <a href="qnetworkaccessmanager.html#finished" translate="no">finished</a>(). You can use the <a href="../qtcore/qobject.html#deleteLater" translate="no">deleteLater</a>() function.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>QNetworkAccessManager queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. Currently, for the HTTP protocol on desktop platforms, 6 requests are executed in parallel for one host/port combination.</p>
</div>
<p>A more involved example, assuming the manager is already existent, can be:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> request;
 request<span class="operator">.</span>setUrl(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>(<span class="string">&quot;http://qt-project.org&quot;</span>));
 request<span class="operator">.</span>setRawHeader(<span class="string">&quot;User-Agent&quot;</span><span class="operator">,</span> <span class="string">&quot;MyOwnBrowser 1.0&quot;</span>);

 <span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> <span class="operator">*</span>reply <span class="operator">=</span> manager<span class="operator">-</span><span class="operator">&gt;</span>get(request);
 connect(reply<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span><span class="operator">::</span>readyRead<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyClass<span class="operator">::</span>slotReadyRead);
 connect(reply<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span><span class="operator">::</span>errorOccurred<span class="operator">,</span>
         <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyClass<span class="operator">::</span>slotError);
 connect(reply<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span><span class="operator">::</span>sslErrors<span class="operator">,</span>
         <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyClass<span class="operator">::</span>slotSslErrors);
</pre>
</div>
<p><b>See also </b><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a>, <a href="qnetworkreply.html" translate="no">QNetworkReply</a>, and <a href="qnetworkproxy.html" translate="no">QNetworkProxy</a>.</p>
<!-- @@@QNetworkAccessManager -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Operation$$$HeadOperation$$$GetOperation$$$PutOperation$$$PostOperation$$$DeleteOperation$$$CustomOperation$$$UnknownOperation -->
<h3 class="fn" translate="no" id="Operation-enum">enum QNetworkAccessManager::<span class="name">Operation</span></h3>
<p>Indicates the operation this reply is processing.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QNetworkAccessManager::HeadOperation</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">retrieve headers operation (created with <a href="qnetworkaccessmanager.html#head" translate="no">head</a>())</td></tr>
<tr><td class="topAlign"><code translate="no">QNetworkAccessManager::GetOperation</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">retrieve headers and download contents (created with <a href="qnetworkaccessmanager.html#get" translate="no">get</a>())</td></tr>
<tr><td class="topAlign"><code translate="no">QNetworkAccessManager::PutOperation</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">upload contents operation (created with <a href="qnetworkaccessmanager.html#put" translate="no">put</a>())</td></tr>
<tr><td class="topAlign"><code translate="no">QNetworkAccessManager::PostOperation</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">send the contents of an HTML form for processing via HTTP POST (created with <a href="qnetworkaccessmanager.html#post" translate="no">post</a>())</td></tr>
<tr><td class="topAlign"><code translate="no">QNetworkAccessManager::DeleteOperation</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">delete contents operation (created with <a href="qnetworkaccessmanager.html#deleteResource" translate="no">deleteResource</a>())</td></tr>
<tr><td class="topAlign"><code translate="no">QNetworkAccessManager::CustomOperation</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">custom operation (created with <a href="qnetworkaccessmanager.html#sendCustomRequest" translate="no">sendCustomRequest</a>())</td></tr>
</table></div>
<p><b>See also </b><a href="qnetworkreply.html#operation" translate="no">QNetworkReply::operation</a>().</p>
<!-- @@@Operation -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QNetworkAccessManager[overload1]$$$QNetworkAccessManagerQObject* -->
<h3 class="fn" translate="no" id="QNetworkAccessManager"><code class="details extra" translate="no">[explicit]</code> QNetworkAccessManager::<span class="name">QNetworkAccessManager</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a QNetworkAccessManager object that is the center of the Network Access API and sets <i translate="no">parent</i> as the parent object.</p>
<!-- @@@QNetworkAccessManager -->
<!-- $$$~QNetworkAccessManager[overload1]$$$~QNetworkAccessManager -->
<h3 class="fn" translate="no" id="dtor.QNetworkAccessManager"><code class="details extra" translate="no">[virtual noexcept]</code> QNetworkAccessManager::<span class="name">~QNetworkAccessManager</span>()</h3>
<p>Destroys the <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> object and frees up any resources. Note that <a href="qnetworkreply.html" translate="no">QNetworkReply</a> objects that are returned from this class have this object set as their parents, which means that they will be deleted along with it if you don't call <a href="../qtcore/qobject.html#setParent" translate="no">QObject::setParent</a>() on them.</p>
<!-- @@@~QNetworkAccessManager -->
<!-- $$$addStrictTransportSecurityHosts[overload1]$$$addStrictTransportSecurityHostsconstQList<QHstsPolicy>& -->
<h3 class="fn" translate="no" id="addStrictTransportSecurityHosts"><span class="type">void</span> QNetworkAccessManager::<span class="name">addStrictTransportSecurityHosts</span>(const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qhstspolicy.html" translate="no">QHstsPolicy</a></span>&gt; &amp;<i>knownHosts</i>)</h3>
<p>Adds HTTP Strict Transport Security policies into HSTS cache. <i translate="no">knownHosts</i> contains the known hosts that have <a href="qhstspolicy.html" translate="no">QHstsPolicy</a> information.</p>
<div class="admonition note">
<p><b>Note: </b>An expired policy will remove a known host from the cache, if previously present.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>While processing HTTP responses, <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> can also update the HSTS cache, removing or updating exitsting policies or introducing new <i translate="no">knownHosts</i>. The current implementation thus is server-driven, client code can provide <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> with previously known or discovered policies, but this information can be overridden by &quot;Strict-Transport-Security&quot; response headers.</p>
</div>
<p><b>See also </b>addStrictTransportSecurityHosts(), <a href="qnetworkaccessmanager.html#enableStrictTransportSecurityStore" translate="no">enableStrictTransportSecurityStore</a>(), and <a href="qhstspolicy.html" translate="no">QHstsPolicy</a>.</p>
<!-- @@@addStrictTransportSecurityHosts -->
<!-- $$$authenticationRequired[overload1]$$$authenticationRequiredQNetworkReply*QAuthenticator* -->
<h3 class="fn" translate="no" id="authenticationRequired"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QNetworkAccessManager::<span class="name">authenticationRequired</span>(<span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *<i>reply</i>, <span class="type"><a href="qauthenticator.html" translate="no">QAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p>This signal is emitted whenever a final server requests authentication before it delivers the requested contents. The slot connected to this signal should fill the credentials for the contents (which can be determined by inspecting the <i translate="no">reply</i> object) in the <i translate="no">authenticator</i> object.</p>
<p><a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> will cache the credentials internally and will send the same values if the server requires authentication again, without emitting the authenticationRequired() signal. If it rejects the credentials, this signal will be emitted again.</p>
<div class="admonition note">
<p><b>Note: </b>To have the request not send credentials you must not call setUser() or setPassword() on the <i translate="no">authenticator</i> object. This will result in the <a href="qnetworkaccessmanager.html#finished" translate="no">finished</a>() signal being emitted with a <a href="qnetworkreply.html" translate="no">QNetworkReply</a> with error <a href="qnetworkreply.html#NetworkError-enum" translate="no">AuthenticationRequiredError</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#proxyAuthenticationRequired" translate="no">proxyAuthenticationRequired</a>(), <a href="qauthenticator.html#setUser" translate="no">QAuthenticator::setUser</a>(), and <a href="qauthenticator.html#setPassword" translate="no">QAuthenticator::setPassword</a>().</p>
<!-- @@@authenticationRequired -->
<!-- $$$autoDeleteReplies[overload1]$$$autoDeleteReplies -->
<h3 class="fn" translate="no" id="autoDeleteReplies"><span class="type">bool</span> QNetworkAccessManager::<span class="name">autoDeleteReplies</span>() const</h3>
<p>Returns the true if <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> is currently configured to automatically delete QNetworkReplies, false otherwise.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setAutoDeleteReplies" translate="no">setAutoDeleteReplies</a> and <a href="qnetworkrequest.html#Attribute-enum" translate="no">QNetworkRequest::AutoDeleteReplyOnFinishAttribute</a>.</p>
<!-- @@@autoDeleteReplies -->
<!-- $$$cache[overload1]$$$cache -->
<h3 class="fn" translate="no" id="cache"><span class="type"><a href="qabstractnetworkcache.html" translate="no">QAbstractNetworkCache</a></span> *QNetworkAccessManager::<span class="name">cache</span>() const</h3>
<p>Returns the cache that is used to store data obtained from the network.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setCache" translate="no">setCache</a>().</p>
<!-- @@@cache -->
<!-- $$$clearAccessCache[overload1]$$$clearAccessCache -->
<h3 class="fn" translate="no" id="clearAccessCache"><span class="type">void</span> QNetworkAccessManager::<span class="name">clearAccessCache</span>()</h3>
<p>Flushes the internal cache of authentication data and network connections.</p>
<p>This function is useful for doing auto tests.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#clearConnectionCache" translate="no">clearConnectionCache</a>().</p>
<!-- @@@clearAccessCache -->
<!-- $$$clearConnectionCache[overload1]$$$clearConnectionCache -->
<h3 class="fn" translate="no" id="clearConnectionCache"><span class="type">void</span> QNetworkAccessManager::<span class="name">clearConnectionCache</span>()</h3>
<p>Flushes the internal cache of network connections. In contrast to <a href="qnetworkaccessmanager.html#clearAccessCache" translate="no">clearAccessCache</a>() the authentication data is preserved.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#clearAccessCache" translate="no">clearAccessCache</a>().</p>
<!-- @@@clearConnectionCache -->
<!-- $$$connectToHost[overload1]$$$connectToHostconstQString&quint16 -->
<h3 class="fn" translate="no" id="connectToHost"><span class="type">void</span> QNetworkAccessManager::<span class="name">connectToHost</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>hostName</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i> = 80)</h3>
<p>Initiates a connection to the host given by <i translate="no">hostName</i> at port <i translate="no">port</i>. This function is useful to complete the TCP handshake to a host before the HTTP request is made, resulting in a lower network latency.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no possibility to report errors.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>(), <a href="qnetworkaccessmanager.html#get" translate="no">get</a>(), <a href="qnetworkaccessmanager.html#post" translate="no">post</a>(), <a href="qnetworkaccessmanager.html#put" translate="no">put</a>(), and <a href="qnetworkaccessmanager.html#deleteResource" translate="no">deleteResource</a>().</p>
<!-- @@@connectToHost -->
<!-- $$$connectToHostEncrypted[overload1]$$$connectToHostEncryptedconstQString&quint16constQSslConfiguration& -->
<h3 class="fn" translate="no" id="connectToHostEncrypted"><span class="type">void</span> QNetworkAccessManager::<span class="name">connectToHostEncrypted</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>hostName</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i> = 443, const <span class="type"><a href="qsslconfiguration.html" translate="no">QSslConfiguration</a></span> &amp;<i>sslConfiguration</i> = QSslConfiguration::defaultConfiguration())</h3>
<p>Initiates a connection to the host given by <i translate="no">hostName</i> at port <i translate="no">port</i>, using <i translate="no">sslConfiguration</i>. This function is useful to complete the TCP and SSL handshake to a host before the HTTPS request is made, resulting in a lower network latency.</p>
<div class="admonition note">
<p><b>Note: </b>Preconnecting a HTTP/2 connection can be done by calling setAllowedNextProtocols() on <i translate="no">sslConfiguration</i> with QSslConfiguration::ALPNProtocolHTTP2 contained in the list of allowed protocols. When using HTTP/2, one single connection per host is enough, i.e. calling this method multiple times per host will not result in faster network transactions.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function has no possibility to report errors.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#connectToHost" translate="no">connectToHost</a>(), <a href="qnetworkaccessmanager.html#get" translate="no">get</a>(), <a href="qnetworkaccessmanager.html#post" translate="no">post</a>(), <a href="qnetworkaccessmanager.html#put" translate="no">put</a>(), and <a href="qnetworkaccessmanager.html#deleteResource" translate="no">deleteResource</a>().</p>
<!-- @@@connectToHostEncrypted -->
<!-- $$$connectToHostEncrypted$$$connectToHostEncryptedconstQString&quint16constQSslConfiguration&constQString& -->
<h3 class="fn" translate="no" id="connectToHostEncrypted-1"><span class="type">void</span> QNetworkAccessManager::<span class="name">connectToHostEncrypted</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>hostName</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i>, const <span class="type"><a href="qsslconfiguration.html" translate="no">QSslConfiguration</a></span> &amp;<i>sslConfiguration</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>peerName</i>)</h3>
<p>This is an overloaded function.</p>
<p>Initiates a connection to the host given by <i translate="no">hostName</i> at port <i translate="no">port</i>, using <i translate="no">sslConfiguration</i> with <i translate="no">peerName</i> set to be the hostName used for certificate validation. This function is useful to complete the TCP and SSL handshake to a host before the HTTPS request is made, resulting in a lower network latency.</p>
<div class="admonition note">
<p><b>Note: </b>Preconnecting a HTTP/2 connection can be done by calling setAllowedNextProtocols() on <i translate="no">sslConfiguration</i> with QSslConfiguration::ALPNProtocolHTTP2 contained in the list of allowed protocols. When using HTTP/2, one single connection per host is enough, i.e. calling this method multiple times per host will not result in faster network transactions.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function has no possibility to report errors.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#connectToHost" translate="no">connectToHost</a>(), <a href="qnetworkaccessmanager.html#get" translate="no">get</a>(), <a href="qnetworkaccessmanager.html#post" translate="no">post</a>(), <a href="qnetworkaccessmanager.html#put" translate="no">put</a>(), and <a href="qnetworkaccessmanager.html#deleteResource" translate="no">deleteResource</a>().</p>
<!-- @@@connectToHostEncrypted -->
<!-- $$$cookieJar[overload1]$$$cookieJar -->
<h3 class="fn" translate="no" id="cookieJar"><span class="type"><a href="qnetworkcookiejar.html" translate="no">QNetworkCookieJar</a></span> *QNetworkAccessManager::<span class="name">cookieJar</span>() const</h3>
<p>Returns the <a href="qnetworkcookiejar.html" translate="no">QNetworkCookieJar</a> that is used to store cookies obtained from the network as well as cookies that are about to be sent.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setCookieJar" translate="no">setCookieJar</a>().</p>
<!-- @@@cookieJar -->
<!-- $$$createRequest[overload1]$$$createRequestQNetworkAccessManager::OperationconstQNetworkRequest&QIODevice* -->
<h3 class="fn" translate="no" id="createRequest"><code class="details extra" translate="no">[virtual protected]</code> <span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">createRequest</span>(<span class="type"><a href="qnetworkaccessmanager.html#Operation-enum" translate="no">QNetworkAccessManager::Operation</a></span> <i>op</i>, const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>originalReq</i>, <span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span> *<i>outgoingData</i> = nullptr)</h3>
<p>Returns a new <a href="qnetworkreply.html" translate="no">QNetworkReply</a> object to handle the operation <i translate="no">op</i> and request <i translate="no">originalReq</i>. The device <i translate="no">outgoingData</i> is always 0 for Get and Head requests, but is the value passed to <a href="qnetworkaccessmanager.html#post" translate="no">post</a>() and <a href="qnetworkaccessmanager.html#put" translate="no">put</a>() in those operations (the <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a> variants will pass a <a href="../qtcore/qbuffer.html" translate="no">QBuffer</a> object).</p>
<p>The default implementation calls <a href="qnetworkcookiejar.html#cookiesForUrl" translate="no">QNetworkCookieJar::cookiesForUrl</a>() on the cookie jar set with <a href="qnetworkaccessmanager.html#setCookieJar" translate="no">setCookieJar</a>() to obtain the cookies to be sent to the remote server.</p>
<p>The returned object must be in an open state.</p>
<!-- @@@createRequest -->
<!-- $$$deleteResource[overload1]$$$deleteResourceconstQNetworkRequest& -->
<h3 class="fn" translate="no" id="deleteResource"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">deleteResource</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>)</h3>
<p>Sends a request to delete the resource identified by the URL of <i translate="no">request</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This feature is currently available for HTTP only, performing an HTTP DELETE request.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#get" translate="no">get</a>(), <a href="qnetworkaccessmanager.html#post" translate="no">post</a>(), <a href="qnetworkaccessmanager.html#put" translate="no">put</a>(), and <a href="qnetworkaccessmanager.html#sendCustomRequest" translate="no">sendCustomRequest</a>().</p>
<!-- @@@deleteResource -->
<!-- $$$enableStrictTransportSecurityStore[overload1]$$$enableStrictTransportSecurityStoreboolconstQString& -->
<h3 class="fn" translate="no" id="enableStrictTransportSecurityStore"><span class="type">void</span> QNetworkAccessManager::<span class="name">enableStrictTransportSecurityStore</span>(<span class="type">bool</span> <i>enabled</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>storeDir</i> = QString())</h3>
<p>If <i translate="no">enabled</i> is <code translate="no">true</code>, the internal HSTS cache will use a persistent store to read and write HSTS policies. <i translate="no">storeDir</i> defines where this store will be located. The default location is defined by <a href="../qtcore/qstandardpaths.html#StandardLocation-enum" translate="no">QStandardPaths::CacheLocation</a>. If there is no writable QStandartPaths::CacheLocation and <i translate="no">storeDir</i> is an empty string, the store will be located in the program's working directory.</p>
<div class="admonition note">
<p><b>Note: </b>If HSTS cache already contains HSTS policies by the time persistent store is enabled, these policies will be preserved in the store. In case both cache and store contain the same known hosts, policies from cache are considered to be more up-to-date (and thus will overwrite the previous values in the store). If this behavior is undesired, enable HSTS store before enabling Strict Transport Security. By default, the persistent store of HSTS policies is disabled.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#isStrictTransportSecurityStoreEnabled" translate="no">isStrictTransportSecurityStoreEnabled</a>(), <a href="qnetworkaccessmanager.html#setStrictTransportSecurityEnabled" translate="no">setStrictTransportSecurityEnabled</a>(), and <a href="../qtcore/qstandardpaths.html#standardLocations" translate="no">QStandardPaths::standardLocations</a>().</p>
<!-- @@@enableStrictTransportSecurityStore -->
<!-- $$$encrypted[overload1]$$$encryptedQNetworkReply* -->
<h3 class="fn" translate="no" id="encrypted"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QNetworkAccessManager::<span class="name">encrypted</span>(<span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *<i>reply</i>)</h3>
<p>This signal is emitted when an SSL/TLS session has successfully completed the initial handshake. At this point, no user data has been transmitted. The signal can be used to perform additional checks on the certificate chain, for example to notify users when the certificate for a website has changed. The <i translate="no">reply</i> parameter specifies which network reply is responsible. If the reply does not match the expected criteria then it should be aborted by calling <a href="qnetworkreply.html#abort" translate="no">QNetworkReply::abort</a>() by a slot connected to this signal. The SSL configuration in use can be inspected using the <a href="qnetworkreply.html#sslConfiguration" translate="no">QNetworkReply::sslConfiguration</a>() method.</p>
<p>Internally, <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> may open multiple connections to a server, in order to allow it process requests in parallel. These connections may be reused, which means that the encrypted() signal would not be emitted. This means that you are only guaranteed to receive this signal for the first connection to a site in the lifespan of the <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a>.</p>
<p><b>See also </b><a href="qsslsocket.html#encrypted" translate="no">QSslSocket::encrypted</a>() and <a href="qnetworkreply.html#encrypted" translate="no">QNetworkReply::encrypted</a>().</p>
<!-- @@@encrypted -->
<!-- $$$finished[overload1]$$$finishedQNetworkReply* -->
<h3 class="fn" translate="no" id="finished"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QNetworkAccessManager::<span class="name">finished</span>(<span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *<i>reply</i>)</h3>
<p>This signal is emitted whenever a pending network reply is finished. The <i translate="no">reply</i> parameter will contain a pointer to the reply that has just finished. This signal is emitted in tandem with the <a href="qnetworkreply.html#finished" translate="no">QNetworkReply::finished</a>() signal.</p>
<p>See <a href="qnetworkreply.html#finished" translate="no">QNetworkReply::finished</a>() for information on the status that the object will be in.</p>
<div class="admonition note">
<p><b>Note: </b>Do not delete the <i translate="no">reply</i> object in the slot connected to this signal. Use <a href="../qtcore/qobject.html#deleteLater" translate="no">deleteLater</a>().</p>
</div>
<p><b>See also </b><a href="qnetworkreply.html#finished" translate="no">QNetworkReply::finished</a>() and <a href="qnetworkreply.html#error" translate="no">QNetworkReply::error</a>().</p>
<!-- @@@finished -->
<!-- $$$get[overload1]$$$getconstQNetworkRequest& -->
<h3 class="fn" translate="no" id="get"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">get</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>)</h3>
<p>Posts a request to obtain the contents of the target <i translate="no">request</i> and returns a new <a href="qnetworkreply.html" translate="no">QNetworkReply</a> object opened for reading which emits the <a href="../qtcore/qiodevice.html#readyRead" translate="no">readyRead</a>() signal whenever new data arrives.</p>
<p>The contents as well as associated headers will be downloaded.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#post" translate="no">post</a>(), <a href="qnetworkaccessmanager.html#put" translate="no">put</a>(), <a href="qnetworkaccessmanager.html#deleteResource" translate="no">deleteResource</a>(), and <a href="qnetworkaccessmanager.html#sendCustomRequest" translate="no">sendCustomRequest</a>().</p>
<!-- @@@get -->
<!-- $$$get$$$getconstQNetworkRequest&QIODevice* -->
<h3 class="fn" translate="no" id="get-1"><code class="details extra" translate="no">[since 6.7]</code> <span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">get</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, <span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span> *<i>data</i>)</h3>
<p>This is an overloaded function.</p>
<div class="admonition note">
<p><b>Note: </b>A GET request with a message body is not cached.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If the request is redirected, the message body will be kept only if the status code is 307 or 308.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@get -->
<!-- $$$get$$$getconstQNetworkRequest&constQByteArray& -->
<h3 class="fn" translate="no" id="get-2"><code class="details extra" translate="no">[since 6.7]</code> <span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">get</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>This is an overloaded function.</p>
<div class="admonition note">
<p><b>Note: </b>A GET request with a message body is not cached.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If the request is redirected, the message body will be kept only if the status code is 307 or 308.</p>
</div>
<p>This function was introduced in Qt 6.7.</p>
<!-- @@@get -->
<!-- $$$head[overload1]$$$headconstQNetworkRequest& -->
<h3 class="fn" translate="no" id="head"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">head</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>)</h3>
<p>Posts a request to obtain the network headers for <i translate="no">request</i> and returns a new <a href="qnetworkreply.html" translate="no">QNetworkReply</a> object which will contain such headers.</p>
<p>The function is named after the HTTP request associated (HEAD).</p>
<!-- @@@head -->
<!-- $$$isStrictTransportSecurityEnabled[overload1]$$$isStrictTransportSecurityEnabled -->
<h3 class="fn" translate="no" id="isStrictTransportSecurityEnabled"><span class="type">bool</span> QNetworkAccessManager::<span class="name">isStrictTransportSecurityEnabled</span>() const</h3>
<p>Returns true if HTTP Strict Transport Security (HSTS) was enabled. By default HSTS is disabled.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setStrictTransportSecurityEnabled" translate="no">setStrictTransportSecurityEnabled</a>().</p>
<!-- @@@isStrictTransportSecurityEnabled -->
<!-- $$$isStrictTransportSecurityStoreEnabled[overload1]$$$isStrictTransportSecurityStoreEnabled -->
<h3 class="fn" translate="no" id="isStrictTransportSecurityStoreEnabled"><span class="type">bool</span> QNetworkAccessManager::<span class="name">isStrictTransportSecurityStoreEnabled</span>() const</h3>
<p>Returns true if HSTS cache uses a permanent store to load and store HSTS policies.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#enableStrictTransportSecurityStore" translate="no">enableStrictTransportSecurityStore</a>().</p>
<!-- @@@isStrictTransportSecurityStoreEnabled -->
<!-- $$$post[overload1]$$$postconstQNetworkRequest&QIODevice* -->
<h3 class="fn" translate="no" id="post"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">post</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, <span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span> *<i>data</i>)</h3>
<p>Sends an HTTP POST request to the destination specified by <i translate="no">request</i> and returns a new <a href="qnetworkreply.html" translate="no">QNetworkReply</a> object opened for reading that will contain the reply sent by the server. The contents of the <i translate="no">data</i> device will be uploaded to the server.</p>
<p><i translate="no">data</i> must be open for reading and must remain valid until the <a href="qnetworkaccessmanager.html#finished" translate="no">finished</a>() signal is emitted for this reply.</p>
<div class="admonition note">
<p><b>Note: </b>Sending a POST request on protocols other than HTTP and HTTPS is undefined and will probably fail.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#get" translate="no">get</a>(), <a href="qnetworkaccessmanager.html#put" translate="no">put</a>(), <a href="qnetworkaccessmanager.html#deleteResource" translate="no">deleteResource</a>(), and <a href="qnetworkaccessmanager.html#sendCustomRequest" translate="no">sendCustomRequest</a>().</p>
<!-- @@@post -->
<!-- $$$post$$$postconstQNetworkRequest&constQByteArray& -->
<h3 class="fn" translate="no" id="post-1"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">post</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sends the contents of the <i translate="no">data</i> byte array to the destination specified by <i translate="no">request</i>.</p>
<!-- @@@post -->
<!-- $$$post$$$postconstQNetworkRequest&QHttpMultiPart* -->
<h3 class="fn" translate="no" id="post-2"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">post</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, <span class="type"><a href="qhttpmultipart.html" translate="no">QHttpMultiPart</a></span> *<i>multiPart</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sends the contents of the <i translate="no">multiPart</i> message to the destination specified by <i translate="no">request</i>.</p>
<p>This can be used for sending MIME multipart messages over HTTP.</p>
<p><b>See also </b><a href="qhttpmultipart.html" translate="no">QHttpMultiPart</a>, <a href="qhttppart.html" translate="no">QHttpPart</a>, and <a href="qnetworkaccessmanager.html#put" translate="no">put</a>().</p>
<!-- @@@post -->
<!-- $$$preSharedKeyAuthenticationRequired[overload1]$$$preSharedKeyAuthenticationRequiredQNetworkReply*QSslPreSharedKeyAuthenticator* -->
<h3 class="fn" translate="no" id="preSharedKeyAuthenticationRequired"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QNetworkAccessManager::<span class="name">preSharedKeyAuthenticationRequired</span>(<span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *<i>reply</i>, <span class="type"><a href="qsslpresharedkeyauthenticator.html" translate="no">QSslPreSharedKeyAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p>This signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required. The <i translate="no">reply</i> object is the <a href="qnetworkreply.html" translate="no">QNetworkReply</a> that is negotiating such ciphersuites.</p>
<p>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <i translate="no">authenticator</i> object according to their needs.</p>
<div class="admonition note">
<p><b>Note: </b>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The <i translate="no">authenticator</i> object is owned by the reply and must not be deleted by the application.</p>
</div>
<p><b>See also </b><a href="qsslpresharedkeyauthenticator.html" translate="no">QSslPreSharedKeyAuthenticator</a>.</p>
<!-- @@@preSharedKeyAuthenticationRequired -->
<!-- $$$proxy[overload1]$$$proxy -->
<h3 class="fn" translate="no" id="proxy"><span class="type"><a href="qnetworkproxy.html" translate="no">QNetworkProxy</a></span> QNetworkAccessManager::<span class="name">proxy</span>() const</h3>
<p>Returns the <a href="qnetworkproxy.html" translate="no">QNetworkProxy</a> that the requests sent using this <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> object will use. The default value for the proxy is <a href="qnetworkproxy.html#ProxyType-enum" translate="no">QNetworkProxy::DefaultProxy</a>.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setProxy" translate="no">setProxy</a>(), <a href="qnetworkaccessmanager.html#setProxyFactory" translate="no">setProxyFactory</a>(), and <a href="qnetworkaccessmanager.html#proxyAuthenticationRequired" translate="no">proxyAuthenticationRequired</a>().</p>
<!-- @@@proxy -->
<!-- $$$proxyAuthenticationRequired[overload1]$$$proxyAuthenticationRequiredconstQNetworkProxy&QAuthenticator* -->
<h3 class="fn" translate="no" id="proxyAuthenticationRequired"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QNetworkAccessManager::<span class="name">proxyAuthenticationRequired</span>(const <span class="type"><a href="qnetworkproxy.html" translate="no">QNetworkProxy</a></span> &amp;<i>proxy</i>, <span class="type"><a href="qauthenticator.html" translate="no">QAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p>This signal is emitted whenever a proxy requests authentication and <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> cannot find a valid, cached credential. The slot connected to this signal should fill in the credentials for the proxy <i translate="no">proxy</i> in the <i translate="no">authenticator</i> object.</p>
<p><a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> will cache the credentials internally. The next time the proxy requests authentication, <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> will automatically send the same credential without emitting the proxyAuthenticationRequired signal again.</p>
<p>If the proxy rejects the credentials, <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> will emit the signal again.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#proxy" translate="no">proxy</a>(), <a href="qnetworkaccessmanager.html#setProxy" translate="no">setProxy</a>(), and <a href="qnetworkaccessmanager.html#authenticationRequired" translate="no">authenticationRequired</a>().</p>
<!-- @@@proxyAuthenticationRequired -->
<!-- $$$proxyFactory[overload1]$$$proxyFactory -->
<h3 class="fn" translate="no" id="proxyFactory"><span class="type"><a href="qnetworkproxyfactory.html" translate="no">QNetworkProxyFactory</a></span> *QNetworkAccessManager::<span class="name">proxyFactory</span>() const</h3>
<p>Returns the proxy factory that this <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> object is using to determine the proxies to be used for requests.</p>
<p>Note that the pointer returned by this function is managed by <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> and could be deleted at any time.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setProxyFactory" translate="no">setProxyFactory</a>() and <a href="qnetworkaccessmanager.html#proxy" translate="no">proxy</a>().</p>
<!-- @@@proxyFactory -->
<!-- $$$put[overload1]$$$putconstQNetworkRequest&QIODevice* -->
<h3 class="fn" translate="no" id="put"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">put</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, <span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span> *<i>data</i>)</h3>
<p>Uploads the contents of <i translate="no">data</i> to the destination <i translate="no">request</i> and returns a new <a href="qnetworkreply.html" translate="no">QNetworkReply</a> object that will be open for reply.</p>
<p><i translate="no">data</i> must be opened for reading when this function is called and must remain valid until the <a href="qnetworkaccessmanager.html#finished" translate="no">finished</a>() signal is emitted for this reply.</p>
<p>Whether anything will be available for reading from the returned object is protocol dependent. For HTTP, the server may send a small HTML page indicating the upload was successful (or not). Other protocols will probably have content in their replies.</p>
<div class="admonition note">
<p><b>Note: </b>For HTTP, this request will send a PUT request, which most servers do not allow. Form upload mechanisms, including that of uploading files through HTML forms, use the POST mechanism.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#get" translate="no">get</a>(), <a href="qnetworkaccessmanager.html#post" translate="no">post</a>(), <a href="qnetworkaccessmanager.html#deleteResource" translate="no">deleteResource</a>(), and <a href="qnetworkaccessmanager.html#sendCustomRequest" translate="no">sendCustomRequest</a>().</p>
<!-- @@@put -->
<!-- $$$put$$$putconstQNetworkRequest&constQByteArray& -->
<h3 class="fn" translate="no" id="put-1"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">put</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sends the contents of the <i translate="no">data</i> byte array to the destination specified by <i translate="no">request</i>.</p>
<!-- @@@put -->
<!-- $$$put$$$putconstQNetworkRequest&QHttpMultiPart* -->
<h3 class="fn" translate="no" id="put-2"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">put</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, <span class="type"><a href="qhttpmultipart.html" translate="no">QHttpMultiPart</a></span> *<i>multiPart</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sends the contents of the <i translate="no">multiPart</i> message to the destination specified by <i translate="no">request</i>.</p>
<p>This can be used for sending MIME multipart messages over HTTP.</p>
<p><b>See also </b><a href="qhttpmultipart.html" translate="no">QHttpMultiPart</a>, <a href="qhttppart.html" translate="no">QHttpPart</a>, and <a href="qnetworkaccessmanager.html#post" translate="no">post</a>().</p>
<!-- @@@put -->
<!-- $$$redirectPolicy[overload1]$$$redirectPolicy -->
<h3 class="fn" translate="no" id="redirectPolicy"><span class="type"><a href="qnetworkrequest.html#RedirectPolicy-enum" translate="no">QNetworkRequest::RedirectPolicy</a></span> QNetworkAccessManager::<span class="name">redirectPolicy</span>() const</h3>
<p>Returns the redirect policy that is used when creating new requests.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setRedirectPolicy" translate="no">setRedirectPolicy</a>() and <a href="qnetworkrequest.html#RedirectPolicy-enum" translate="no">QNetworkRequest::RedirectPolicy</a>.</p>
<!-- @@@redirectPolicy -->
<!-- $$$sendCustomRequest[overload1]$$$sendCustomRequestconstQNetworkRequest&constQByteArray&QIODevice* -->
<h3 class="fn" translate="no" id="sendCustomRequest"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">sendCustomRequest</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>verb</i>, <span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span> *<i>data</i> = nullptr)</h3>
<p>Sends a custom request to the server identified by the URL of <i translate="no">request</i>.</p>
<p>It is the user's responsibility to send a <i translate="no">verb</i> to the server that is valid according to the HTTP specification.</p>
<p>This method provides means to send verbs other than the common ones provided via <a href="qnetworkaccessmanager.html#get" translate="no">get</a>() or <a href="qnetworkaccessmanager.html#post" translate="no">post</a>() etc., for instance sending an HTTP OPTIONS command.</p>
<p>If <i translate="no">data</i> is not empty, the contents of the <i translate="no">data</i> device will be uploaded to the server; in that case, data must be open for reading and must remain valid until the <a href="qnetworkaccessmanager.html#finished" translate="no">finished</a>() signal is emitted for this reply.</p>
<div class="admonition note">
<p><b>Note: </b>This feature is currently available for HTTP(S) only.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#get" translate="no">get</a>(), <a href="qnetworkaccessmanager.html#post" translate="no">post</a>(), <a href="qnetworkaccessmanager.html#put" translate="no">put</a>(), and <a href="qnetworkaccessmanager.html#deleteResource" translate="no">deleteResource</a>().</p>
<!-- @@@sendCustomRequest -->
<!-- $$$sendCustomRequest$$$sendCustomRequestconstQNetworkRequest&constQByteArray&constQByteArray& -->
<h3 class="fn" translate="no" id="sendCustomRequest-1"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">sendCustomRequest</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>verb</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sends the contents of the <i translate="no">data</i> byte array to the destination specified by <i translate="no">request</i>.</p>
<!-- @@@sendCustomRequest -->
<!-- $$$sendCustomRequest$$$sendCustomRequestconstQNetworkRequest&constQByteArray&QHttpMultiPart* -->
<h3 class="fn" translate="no" id="sendCustomRequest-2"><span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *QNetworkAccessManager::<span class="name">sendCustomRequest</span>(const <span class="type"><a href="qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>verb</i>, <span class="type"><a href="qhttpmultipart.html" translate="no">QHttpMultiPart</a></span> *<i>multiPart</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sends a custom request to the server identified by the URL of <i translate="no">request</i>.</p>
<p>Sends the contents of the <i translate="no">multiPart</i> message to the destination specified by <i translate="no">request</i>.</p>
<p>This can be used for sending MIME multipart messages for custom verbs.</p>
<p><b>See also </b><a href="qhttpmultipart.html" translate="no">QHttpMultiPart</a>, <a href="qhttppart.html" translate="no">QHttpPart</a>, and <a href="qnetworkaccessmanager.html#put" translate="no">put</a>().</p>
<!-- @@@sendCustomRequest -->
<!-- $$$setAutoDeleteReplies[overload1]$$$setAutoDeleteRepliesbool -->
<h3 class="fn" translate="no" id="setAutoDeleteReplies"><span class="type">void</span> QNetworkAccessManager::<span class="name">setAutoDeleteReplies</span>(<span class="type">bool</span> <i>shouldAutoDelete</i>)</h3>
<p>Enables or disables automatic deletion of <a href="qnetworkreply.html" translate="no">QNetworkReplies</a>.</p>
<p>Setting <i translate="no">shouldAutoDelete</i> to true is the same as setting the <a href="qnetworkrequest.html#Attribute-enum" translate="no">QNetworkRequest::AutoDeleteReplyOnFinishAttribute</a> attribute to true on all <i>future</i> <a href="qnetworkrequest.html" translate="no">QNetworkRequests</a> passed to this instance of <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> unless the attribute was already explicitly set on the <a href="qnetworkrequest.html" translate="no">QNetworkRequest</a>.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#autoDeleteReplies" translate="no">autoDeleteReplies</a> and <a href="qnetworkrequest.html#Attribute-enum" translate="no">QNetworkRequest::AutoDeleteReplyOnFinishAttribute</a>.</p>
<!-- @@@setAutoDeleteReplies -->
<!-- $$$setCache[overload1]$$$setCacheQAbstractNetworkCache* -->
<h3 class="fn" translate="no" id="setCache"><span class="type">void</span> QNetworkAccessManager::<span class="name">setCache</span>(<span class="type"><a href="qabstractnetworkcache.html" translate="no">QAbstractNetworkCache</a></span> *<i>cache</i>)</h3>
<p>Sets the manager's network cache to be the <i translate="no">cache</i> specified. The cache is used for all requests dispatched by the manager.</p>
<p>Use this function to set the network cache object to a class that implements additional features, like saving the cookies to permanent storage.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> takes ownership of the <i translate="no">cache</i> object.</p>
</div>
<p><a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> by default does not have a set cache. Qt provides a simple disk cache, <a href="qnetworkdiskcache.html" translate="no">QNetworkDiskCache</a>, which can be used.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#cache" translate="no">cache</a>() and <a href="qnetworkrequest.html#CacheLoadControl-enum" translate="no">QNetworkRequest::CacheLoadControl</a>.</p>
<!-- @@@setCache -->
<!-- $$$setCookieJar[overload1]$$$setCookieJarQNetworkCookieJar* -->
<h3 class="fn" translate="no" id="setCookieJar"><span class="type">void</span> QNetworkAccessManager::<span class="name">setCookieJar</span>(<span class="type"><a href="qnetworkcookiejar.html" translate="no">QNetworkCookieJar</a></span> *<i>cookieJar</i>)</h3>
<p>Sets the manager's cookie jar to be the <i translate="no">cookieJar</i> specified. The cookie jar is used by all requests dispatched by the manager.</p>
<p>Use this function to set the cookie jar object to a class that implements additional features, like saving the cookies to permanent storage.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> takes ownership of the <i translate="no">cookieJar</i> object.</p>
</div>
<p>If <i translate="no">cookieJar</i> is in the same thread as this <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a>, it will set the parent of the <i translate="no">cookieJar</i> so that the cookie jar is deleted when this object is deleted as well. If you want to share cookie jars between different <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> objects, you may want to set the cookie jar's parent to 0 after calling this function.</p>
<p><a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> by default does not implement any cookie policy of its own: it accepts all cookies sent by the server, as long as they are well formed and meet the minimum security requirements (cookie domain matches the request's and cookie path matches the request's). In order to implement your own security policy, override the <a href="qnetworkcookiejar.html#cookiesForUrl" translate="no">QNetworkCookieJar::cookiesForUrl</a>() and <a href="qnetworkcookiejar.html#setCookiesFromUrl" translate="no">QNetworkCookieJar::setCookiesFromUrl</a>() virtual functions. Those functions are called by <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> when it detects a new cookie.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#cookieJar" translate="no">cookieJar</a>(), <a href="qnetworkcookiejar.html#cookiesForUrl" translate="no">QNetworkCookieJar::cookiesForUrl</a>(), and <a href="qnetworkcookiejar.html#setCookiesFromUrl" translate="no">QNetworkCookieJar::setCookiesFromUrl</a>().</p>
<!-- @@@setCookieJar -->
<!-- $$$setProxy[overload1]$$$setProxyconstQNetworkProxy& -->
<h3 class="fn" translate="no" id="setProxy"><span class="type">void</span> QNetworkAccessManager::<span class="name">setProxy</span>(const <span class="type"><a href="qnetworkproxy.html" translate="no">QNetworkProxy</a></span> &amp;<i>proxy</i>)</h3>
<p>Sets the proxy to be used in future requests to be <i translate="no">proxy</i>. This does not affect requests that have already been sent. The <a href="qnetworkaccessmanager.html#proxyAuthenticationRequired" translate="no">proxyAuthenticationRequired</a>() signal will be emitted if the proxy requests authentication.</p>
<p>A proxy set with this function will be used for all requests issued by <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a>. In some cases, it might be necessary to select different proxies depending on the type of request being sent or the destination host. If that's the case, you should consider using <a href="qnetworkaccessmanager.html#setProxyFactory" translate="no">setProxyFactory</a>().</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#proxy" translate="no">proxy</a>() and <a href="qnetworkaccessmanager.html#proxyAuthenticationRequired" translate="no">proxyAuthenticationRequired</a>().</p>
<!-- @@@setProxy -->
<!-- $$$setProxyFactory[overload1]$$$setProxyFactoryQNetworkProxyFactory* -->
<h3 class="fn" translate="no" id="setProxyFactory"><span class="type">void</span> QNetworkAccessManager::<span class="name">setProxyFactory</span>(<span class="type"><a href="qnetworkproxyfactory.html" translate="no">QNetworkProxyFactory</a></span> *<i>factory</i>)</h3>
<p>Sets the proxy factory for this class to be <i translate="no">factory</i>. A proxy factory is used to determine a more specific list of proxies to be used for a given request, instead of trying to use the same proxy value for all requests.</p>
<p>All queries sent by <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> will have type <a href="qnetworkproxyquery.html#QueryType-enum" translate="no">QNetworkProxyQuery::UrlRequest</a>.</p>
<p>For example, a proxy factory could apply the following rules:</p>
<ul>
<li>if the target address is in the local network (for example, if the hostname contains no dots or if it's an IP address in the organization's range), return <a href="qnetworkproxy.html#ProxyType-enum" translate="no">QNetworkProxy::NoProxy</a></li>
<li>if the request is FTP, return an FTP proxy</li>
<li>if the request is HTTP or HTTPS, then return an HTTP proxy</li>
<li>otherwise, return a SOCKSv5 proxy server</li>
</ul>
<p>The lifetime of the object <i translate="no">factory</i> will be managed by <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a>. It will delete the object when necessary.</p>
<div class="admonition note">
<p><b>Note: </b>If a specific proxy is set with <a href="qnetworkaccessmanager.html#setProxy" translate="no">setProxy</a>(), the factory will not be used.</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html#proxyFactory" translate="no">proxyFactory</a>(), <a href="qnetworkaccessmanager.html#setProxy" translate="no">setProxy</a>(), and <a href="qnetworkproxyquery.html" translate="no">QNetworkProxyQuery</a>.</p>
<!-- @@@setProxyFactory -->
<!-- $$$setRedirectPolicy[overload1]$$$setRedirectPolicyQNetworkRequest::RedirectPolicy -->
<h3 class="fn" translate="no" id="setRedirectPolicy"><span class="type">void</span> QNetworkAccessManager::<span class="name">setRedirectPolicy</span>(<span class="type"><a href="qnetworkrequest.html#RedirectPolicy-enum" translate="no">QNetworkRequest::RedirectPolicy</a></span> <i>policy</i>)</h3>
<p>Sets the manager's redirect policy to be the <i translate="no">policy</i> specified. This policy will affect all subsequent requests created by the manager.</p>
<p>Use this function to enable or disable HTTP redirects on the manager's level.</p>
<div class="admonition note">
<p><b>Note: </b>When creating a request QNetworkRequest::RedirectAttributePolicy has the highest priority, next by priority the manager's policy.</p>
</div>
<p>The default value is <a href="qnetworkrequest.html#RedirectPolicy-enum" translate="no">QNetworkRequest::NoLessSafeRedirectPolicy</a>. Clients relying on manual redirect handling are encouraged to set this policy explicitly in their code.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#redirectPolicy" translate="no">redirectPolicy</a>() and <a href="qnetworkrequest.html#RedirectPolicy-enum" translate="no">QNetworkRequest::RedirectPolicy</a>.</p>
<!-- @@@setRedirectPolicy -->
<!-- $$$setStrictTransportSecurityEnabled[overload1]$$$setStrictTransportSecurityEnabledbool -->
<h3 class="fn" translate="no" id="setStrictTransportSecurityEnabled"><span class="type">void</span> QNetworkAccessManager::<span class="name">setStrictTransportSecurityEnabled</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>If <i translate="no">enabled</i> is <code translate="no">true</code>, <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> follows the HTTP Strict Transport Security policy (HSTS, RFC6797). When processing a request, <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> automatically replaces the &quot;http&quot; scheme with &quot;https&quot; and uses a secure transport for HSTS hosts. If it's set explicitly, port 80 is replaced by port 443.</p>
<p>When HSTS is enabled, for each HTTP response containing HSTS header and received over a secure transport, <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> will update its HSTS cache, either remembering a host with a valid policy or removing a host with an expired or disabled HSTS policy.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#isStrictTransportSecurityEnabled" translate="no">isStrictTransportSecurityEnabled</a>().</p>
<!-- @@@setStrictTransportSecurityEnabled -->
<!-- $$$setTransferTimeout[overload1]$$$setTransferTimeoutint -->
<h3 class="fn" translate="no" id="setTransferTimeout"><span class="type">void</span> QNetworkAccessManager::<span class="name">setTransferTimeout</span>(<span class="type">int</span> <i>timeout</i>)</h3>
<p>Sets <i translate="no">timeout</i> as the transfer timeout in milliseconds.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setTransferTimeout-1" translate="no">setTransferTimeout</a>(std::chrono::milliseconds), <a href="qnetworkaccessmanager.html#transferTimeout" translate="no">transferTimeout</a>(), and <a href="qnetworkaccessmanager.html#transferTimeoutAsDuration" translate="no">transferTimeoutAsDuration</a>().</p>
<!-- @@@setTransferTimeout -->
<!-- $$$setTransferTimeout$$$setTransferTimeoutstd::chrono::milliseconds -->
<h3 class="fn" translate="no" id="setTransferTimeout-1"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">void</span> QNetworkAccessManager::<span class="name">setTransferTimeout</span>(<span class="type">std::chrono::milliseconds</span> <i>duration</i> = QNetworkRequest::DefaultTransferTimeout)</h3>
<p>Sets the timeout <i translate="no">duration</i> to abort the transfer if no data is exchanged.</p>
<p>Transfers are aborted if no bytes are transferred before the timeout expires. Zero means no timer is set. If no argument is provided, the timeout is <a href="qnetworkrequest.html#DefaultTransferTimeout-var" translate="no">QNetworkRequest::DefaultTransferTimeout</a>. If this function is not called, the timeout is disabled and has the value zero. The request-specific non-zero timeouts set for the requests that are executed override this value. This means that if <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> has an enabled timeout, it needs to be disabled to execute a request without a timeout.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#transferTimeoutAsDuration" translate="no">transferTimeoutAsDuration</a>().</p>
<!-- @@@setTransferTimeout -->
<!-- $$$sslErrors[overload1]$$$sslErrorsQNetworkReply*constQList<QSslError>& -->
<h3 class="fn" translate="no" id="sslErrors"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QNetworkAccessManager::<span class="name">sslErrors</span>(<span class="type"><a href="qnetworkreply.html" translate="no">QNetworkReply</a></span> *<i>reply</i>, const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qsslerror.html" translate="no">QSslError</a></span>&gt; &amp;<i>errors</i>)</h3>
<p>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The <i translate="no">errors</i> parameter contains the list of errors and <i translate="no">reply</i> is the <a href="qnetworkreply.html" translate="no">QNetworkReply</a> that is encountering these errors.</p>
<p>To indicate that the errors are not fatal and that the connection should proceed, the <a href="qnetworkreply.html#ignoreSslErrors" translate="no">QNetworkReply::ignoreSslErrors</a>() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</p>
<p>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see sslConfiguration() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call ignoreSslErrors().</p>
<p><b>See also </b><a href="qsslsocket.html#sslErrors" translate="no">QSslSocket::sslErrors</a>(), <a href="qnetworkreply.html#sslErrors" translate="no">QNetworkReply::sslErrors</a>(), <a href="qnetworkreply.html#sslConfiguration" translate="no">QNetworkReply::sslConfiguration</a>(), and <a href="qnetworkreply.html#ignoreSslErrors" translate="no">QNetworkReply::ignoreSslErrors</a>().</p>
<!-- @@@sslErrors -->
<!-- $$$strictTransportSecurityHosts[overload1]$$$strictTransportSecurityHosts -->
<h3 class="fn" translate="no" id="strictTransportSecurityHosts"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qhstspolicy.html" translate="no">QHstsPolicy</a></span>&gt; QNetworkAccessManager::<span class="name">strictTransportSecurityHosts</span>() const</h3>
<p>Returns the list of HTTP Strict Transport Security policies. This list can differ from what was initially set via <a href="qnetworkaccessmanager.html#addStrictTransportSecurityHosts" translate="no">addStrictTransportSecurityHosts</a>() if HSTS cache was updated from a &quot;Strict-Transport-Security&quot; response header.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#addStrictTransportSecurityHosts" translate="no">addStrictTransportSecurityHosts</a>() and <a href="qhstspolicy.html" translate="no">QHstsPolicy</a>.</p>
<!-- @@@strictTransportSecurityHosts -->
<!-- $$$supportedSchemes[overload1]$$$supportedSchemes -->
<h3 class="fn" translate="no" id="supportedSchemes"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> QNetworkAccessManager::<span class="name">supportedSchemes</span>() const</h3>
<p>Lists all the URL schemes supported by the access manager.</p>
<p>Reimplement this method to provide your own supported schemes in a <a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> subclass. It is for instance necessary when your subclass provides support for new protocols.</p>
<!-- @@@supportedSchemes -->
<!-- $$$transferTimeout[overload1]$$$transferTimeout -->
<h3 class="fn" translate="no" id="transferTimeout"><span class="type">int</span> QNetworkAccessManager::<span class="name">transferTimeout</span>() const</h3>
<p>Returns the timeout used for transfers, in milliseconds.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setTransferTimeout" translate="no">setTransferTimeout</a>().</p>
<!-- @@@transferTimeout -->
<!-- $$$transferTimeoutAsDuration[overload1]$$$transferTimeoutAsDuration -->
<h3 class="fn" translate="no" id="transferTimeoutAsDuration"><code class="details extra" translate="no">[since 6.7]</code> <span class="type">std::chrono::milliseconds</span> QNetworkAccessManager::<span class="name">transferTimeoutAsDuration</span>() const</h3>
<p>Returns the timeout duration after which the transfer is aborted if no data is exchanged.</p>
<p>The default duration is zero, which means that the timeout is not used.</p>
<p>This function was introduced in Qt 6.7.</p>
<p><b>See also </b><a href="qnetworkaccessmanager.html#setTransferTimeout-1" translate="no">setTransferTimeout</a>(std::chrono::milliseconds).</p>
<!-- @@@transferTimeoutAsDuration -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
