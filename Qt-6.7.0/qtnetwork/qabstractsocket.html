<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qabstractsocket.cpp -->
  <meta name="description" content="The QAbstractSocket class provides the base functionality common to all socket types.">
  <title>QAbstractSocket Class | Qt Network 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtnetwork-index.html" translate="no">Qt Network</a></li>
<li><a href="qtnetwork-module.html" translate="no">C++ Classes</a></li>
<li>QAbstractSocket</li>
<li id="buildversion"><a href="qtnetwork-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QAbstractSocket Class</h1>
<!-- $$$QAbstractSocket-brief -->
<p>The QAbstractSocket class provides the base functionality common to all socket types. <a href="#details">More...</a></p>
<!-- @@@QAbstractSocket -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QAbstractSocket&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Network) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Network)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += network</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qtcpsocket.html" translate="no">QTcpSocket</a> and <a href="qudpsocket.html" translate="no">QUdpSocket</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qabstractsocket-members.html">List of all members, including inherited members</a></li>
<li>QAbstractSocket is part of <a href="network.html">Network Programming API</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#BindFlag-enum" translate="no">BindFlag</a></b> { ShareAddress, DontShareAddress, ReuseAddressHint, DefaultForPlatform }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#BindFlag-enum" translate="no">BindMode</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#NetworkLayerProtocol-enum" translate="no">NetworkLayerProtocol</a></b> { IPv4Protocol, IPv6Protocol, AnyIPProtocol, UnknownNetworkLayerProtocol }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#PauseMode-enum" translate="no">PauseMode</a></b> { PauseNever, PauseOnSslErrors }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#PauseMode-enum" translate="no">PauseModes</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#SocketError-enum" translate="no">SocketError</a></b> { ConnectionRefusedError, RemoteHostClosedError, HostNotFoundError, SocketAccessError, SocketResourceError, &hellip;, UnknownSocketError }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#SocketOption-enum" translate="no">SocketOption</a></b> { LowDelayOption, KeepAliveOption, MulticastTtlOption, MulticastLoopbackOption, TypeOfServiceOption, &hellip;, PathMtuSocketOption }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#SocketState-enum" translate="no">SocketState</a></b> { UnconnectedState, HostLookupState, ConnectingState, ConnectedState, BoundState, &hellip;, ListeningState }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#SocketType-enum" translate="no">SocketType</a></b> { TcpSocket, UdpSocket, SctpSocket, UnknownSocketType }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#QAbstractSocket" translate="no">QAbstractSocket</a></b>(QAbstractSocket::SocketType <i>socketType</i>, QObject *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#dtor.QAbstractSocket" translate="no">~QAbstractSocket</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#abort" translate="no">abort</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#bind" translate="no">bind</a></b>(const QHostAddress &amp;<i>address</i>, quint16 <i>port</i> = 0, QAbstractSocket::BindMode <i>mode</i> = DefaultForPlatform)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#bind-1" translate="no">bind</a></b>(QHostAddress::SpecialAddress <i>addr</i>, quint16 <i>port</i> = 0, QAbstractSocket::BindMode <i>mode</i> = DefaultForPlatform)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#bind-2" translate="no">bind</a></b>(quint16 <i>port</i> = 0, QAbstractSocket::BindMode <i>mode</i> = DefaultForPlatform)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a></b>(const QString &amp;<i>hostName</i>, quint16 <i>port</i>, QIODeviceBase::OpenMode <i>openMode</i> = ReadWrite, QAbstractSocket::NetworkLayerProtocol <i>protocol</i> = AnyIPProtocol)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#connectToHost-1" translate="no">connectToHost</a></b>(const QHostAddress &amp;<i>address</i>, quint16 <i>port</i>, QIODeviceBase::OpenMode <i>openMode</i> = ReadWrite)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#disconnectFromHost" translate="no">disconnectFromHost</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractSocket::SocketError </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#error" translate="no">error</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#flush" translate="no">flush</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#localAddress" translate="no">localAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#localPort" translate="no">localPort</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractSocket::PauseModes </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#pauseMode" translate="no">pauseMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#peerAddress" translate="no">peerAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#peerName" translate="no">peerName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#peerPort" translate="no">peerPort</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#protocolTag" translate="no">protocolTag</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkProxy </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#proxy" translate="no">proxy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#readBufferSize" translate="no">readBufferSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#resume" translate="no">resume</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setPauseMode" translate="no">setPauseMode</a></b>(QAbstractSocket::PauseModes <i>pauseMode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setProtocolTag" translate="no">setProtocolTag</a></b>(const QString &amp;<i>tag</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setProxy" translate="no">setProxy</a></b>(const QNetworkProxy &amp;<i>networkProxy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setReadBufferSize" translate="no">setReadBufferSize</a></b>(qint64 <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setSocketDescriptor" translate="no">setSocketDescriptor</a></b>(qintptr <i>socketDescriptor</i>, QAbstractSocket::SocketState <i>socketState</i> = ConnectedState, QIODeviceBase::OpenMode <i>openMode</i> = ReadWrite)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setSocketOption" translate="no">setSocketOption</a></b>(QAbstractSocket::SocketOption <i>option</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qintptr </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#socketDescriptor" translate="no">socketDescriptor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#socketOption" translate="no">socketOption</a></b>(QAbstractSocket::SocketOption <i>option</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractSocket::SocketType </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#socketType" translate="no">socketType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractSocket::SocketState </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#state" translate="no">state</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#waitForConnected" translate="no">waitForConnected</a></b>(int <i>msecs</i> = 30000)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#waitForDisconnected" translate="no">waitForDisconnected</a></b>(int <i>msecs</i> = 30000)</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#bytesAvailable" translate="no">bytesAvailable</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#bytesToWrite" translate="no">bytesToWrite</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#close" translate="no">close</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#isSequential" translate="no">isSequential</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#waitForBytesWritten" translate="no">waitForBytesWritten</a></b>(int <i>msecs</i> = 30000) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#waitForReadyRead" translate="no">waitForReadyRead</a></b>(int <i>msecs</i> = 30000) override</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#connected" translate="no">connected</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#disconnected" translate="no">disconnected</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#errorOccurred" translate="no">errorOccurred</a></b>(QAbstractSocket::SocketError <i>socketError</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#hostFound" translate="no">hostFound</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#proxyAuthenticationRequired" translate="no">proxyAuthenticationRequired</a></b>(const QNetworkProxy &amp;<i>proxy</i>, QAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#stateChanged" translate="no">stateChanged</a></b>(QAbstractSocket::SocketState <i>socketState</i>)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setLocalAddress" translate="no">setLocalAddress</a></b>(const QHostAddress &amp;<i>address</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setLocalPort" translate="no">setLocalPort</a></b>(quint16 <i>port</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setPeerAddress" translate="no">setPeerAddress</a></b>(const QHostAddress &amp;<i>address</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setPeerName" translate="no">setPeerName</a></b>(const QString &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setPeerPort" translate="no">setPeerPort</a></b>(quint16 <i>port</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setSocketError" translate="no">setSocketError</a></b>(QAbstractSocket::SocketError <i>socketError</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#setSocketState" translate="no">setSocketState</a></b>(QAbstractSocket::SocketState <i>state</i>)</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#readData" translate="no">readData</a></b>(char *<i>data</i>, qint64 <i>maxSize</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#readLineData" translate="no">readLineData</a></b>(char *<i>data</i>, qint64 <i>maxlen</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#skipData" translate="no">skipData</a></b>(qint64 <i>maxSize</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qabstractsocket.html#writeData" translate="no">writeData</a></b>(const char *<i>data</i>, qint64 <i>size</i>) override</td></tr>
</table></div>
<!-- $$$QAbstractSocket-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QAbstractSocket is the base class for <a href="qtcpsocket.html" translate="no">QTcpSocket</a> and <a href="qudpsocket.html" translate="no">QUdpSocket</a> and contains all common functionality of these two classes. If you need a socket, you have two options:</p>
<ul>
<li>Instantiate <a href="qtcpsocket.html" translate="no">QTcpSocket</a> or <a href="qudpsocket.html" translate="no">QUdpSocket</a>.</li>
<li>Create a native socket descriptor, instantiate QAbstractSocket, and call <a href="qabstractsocket.html#setSocketDescriptor" translate="no">setSocketDescriptor</a>() to wrap the native socket.</li>
</ul>
<p>TCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. UDP (User Datagram Protocol) is an unreliable, datagram-oriented, connectionless protocol. In practice, this means that TCP is better suited for continuous transmission of data, whereas the more lightweight UDP can be used when reliability isn't important.</p>
<p>QAbstractSocket's API unifies most of the differences between the two protocols. For example, although UDP is connectionless, <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>() establishes a virtual connection for UDP sockets, enabling you to use QAbstractSocket in more or less the same way regardless of the underlying protocol. Internally, QAbstractSocket remembers the address and port passed to <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>(), and functions like <a href="../qtcore/qiodevice.html#read" translate="no">read</a>() and <a href="../qtcore/qiodevice.html#write" translate="no">write</a>() use these values.</p>
<p>At any time, QAbstractSocket has a state (returned by <a href="qabstractsocket.html#state" translate="no">state</a>()). The initial state is <a href="qabstractsocket.html#SocketState-enum" translate="no">UnconnectedState</a>. After calling <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>(), the socket first enters <a href="qabstractsocket.html#SocketState-enum" translate="no">HostLookupState</a>. If the host is found, QAbstractSocket enters <a href="qabstractsocket.html#SocketState-enum" translate="no">ConnectingState</a> and emits the <a href="qabstractsocket.html#hostFound" translate="no">hostFound</a>() signal. When the connection has been established, it enters <a href="qabstractsocket.html#SocketState-enum" translate="no">ConnectedState</a> and emits <a href="qabstractsocket.html#connected" translate="no">connected</a>(). If an error occurs at any stage, <a href="qabstractsocket.html#errorOccurred" translate="no">errorOccurred</a>() is emitted. Whenever the state changes, <a href="qabstractsocket.html#stateChanged" translate="no">stateChanged</a>() is emitted. For convenience, <a href="qabstractsocket.html#isValid" translate="no">isValid</a>() returns <code translate="no">true</code> if the socket is ready for reading and writing, but note that the socket's state must be <a href="qabstractsocket.html#SocketState-enum" translate="no">ConnectedState</a> before reading and writing can occur.</p>
<p>Read or write data by calling <a href="../qtcore/qiodevice.html#read" translate="no">read</a>() or <a href="../qtcore/qiodevice.html#write" translate="no">write</a>(), or use the convenience functions <a href="../qtcore/qiodevice.html#readLine" translate="no">readLine</a>() and <a href="../qtcore/qiodevice.html#readAll" translate="no">readAll</a>(). QAbstractSocket also inherits <a href="../qtcore/qiodevice.html#getChar" translate="no">getChar</a>(), <a href="../qtcore/qiodevice.html#putChar" translate="no">putChar</a>(), and <a href="../qtcore/qiodevice.html#ungetChar" translate="no">ungetChar</a>() from <a href="../qtcore/qiodevice.html" translate="no">QIODevice</a>, which work on single bytes. The <a href="../qtcore/qiodevice.html#bytesWritten" translate="no">bytesWritten</a>() signal is emitted when data has been written to the socket. Note that Qt does not limit the write buffer size. You can monitor its size by listening to this signal.</p>
<p>The <a href="../qtcore/qiodevice.html#readyRead" translate="no">readyRead</a>() signal is emitted every time a new chunk of data has arrived. <a href="qabstractsocket.html#bytesAvailable" translate="no">bytesAvailable</a>() then returns the number of bytes that are available for reading. Typically, you would connect the <a href="../qtcore/qiodevice.html#readyRead" translate="no">readyRead</a>() signal to a slot and read all available data there. If you don't read all the data at once, the remaining data will still be available later, and any new incoming data will be appended to QAbstractSocket's internal read buffer. To limit the size of the read buffer, call <a href="qabstractsocket.html#setReadBufferSize" translate="no">setReadBufferSize</a>().</p>
<p>To close the socket, call <a href="qabstractsocket.html#disconnectFromHost" translate="no">disconnectFromHost</a>(). QAbstractSocket enters <a href="qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::ClosingState</a>. After all pending data has been written to the socket, QAbstractSocket actually closes the socket, enters <a href="qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::UnconnectedState</a>, and emits <a href="qabstractsocket.html#disconnected" translate="no">disconnected</a>(). If you want to abort a connection immediately, discarding all pending data, call <a href="qabstractsocket.html#abort" translate="no">abort</a>() instead. If the remote host closes the connection, QAbstractSocket will emit <a href="qabstractsocket.html#errorOccurred" translate="no">errorOccurred</a>(<a href="qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::RemoteHostClosedError</a>), during which the socket state will still be <a href="qabstractsocket.html#SocketState-enum" translate="no">ConnectedState</a>, and then the <a href="qabstractsocket.html#disconnected" translate="no">disconnected</a>() signal will be emitted.</p>
<p>The port and address of the connected peer is fetched by calling <a href="qabstractsocket.html#peerPort" translate="no">peerPort</a>() and <a href="qabstractsocket.html#peerAddress" translate="no">peerAddress</a>(). <a href="qabstractsocket.html#peerName" translate="no">peerName</a>() returns the host name of the peer, as passed to <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>(). <a href="qabstractsocket.html#localPort" translate="no">localPort</a>() and <a href="qabstractsocket.html#localAddress" translate="no">localAddress</a>() return the port and address of the local socket.</p>
<p>QAbstractSocket provides a set of functions that suspend the calling thread until certain signals are emitted. These functions can be used to implement blocking sockets:</p>
<ul>
<li><a href="qabstractsocket.html#waitForConnected" translate="no">waitForConnected</a>() blocks until a connection has been established.</li>
<li><a href="qabstractsocket.html#waitForReadyRead" translate="no">waitForReadyRead</a>() blocks until new data is available for reading.</li>
<li><a href="qabstractsocket.html#waitForBytesWritten" translate="no">waitForBytesWritten</a>() blocks until one payload of data has been written to the socket.</li>
<li><a href="qabstractsocket.html#waitForDisconnected" translate="no">waitForDisconnected</a>() blocks until the connection has closed.</li>
</ul>
<p>We show an example:</p>
<pre class="cpp" translate="no">
     <span class="type">int</span> numRead <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span> numReadTotal <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">char</span> buffer<span class="operator">[</span><span class="number">50</span><span class="operator">]</span>;

     forever {
         numRead  <span class="operator">=</span> socket<span class="operator">.</span>read(buffer<span class="operator">,</span> <span class="number">50</span>);

         <span class="comment">// do whatever with array</span>

         numReadTotal <span class="operator">+</span><span class="operator">=</span> numRead;
         <span class="keyword">if</span> (numRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>socket<span class="operator">.</span>waitForReadyRead())
             <span class="keyword">break</span>;
     }
</pre>
<p>If <a href="../qtcore/qiodevice.html#waitForReadyRead" translate="no">waitForReadyRead</a>() returns <code translate="no">false</code>, the connection has been closed or an error has occurred.</p>
<p>Programming with a blocking socket is radically different from programming with a non-blocking socket. A blocking socket doesn't require an event loop and typically leads to simpler code. However, in a GUI application, blocking sockets should only be used in non-GUI threads, to avoid freezing the user interface. See the <a href="qtnetwork-fortuneclient-example.html" translate="no">fortuneclient</a> and <a href="qtnetwork-blockingfortuneclient-example.html" translate="no">blockingfortuneclient</a> examples for an overview of both approaches.</p>
<div class="admonition note">
<p><b>Note: </b>We discourage the use of the blocking functions together with signals. One of the two possibilities should be used.</p>
</div>
<p>QAbstractSocket can be used with <a href="../qtcore/qtextstream.html" translate="no">QTextStream</a> and <a href="../qtcore/qdatastream.html" translate="no">QDataStream</a>'s stream operators (operator&lt;&lt;() and operator&gt;&gt;()). There is one issue to be aware of, though: You must make sure that enough data is available before attempting to read it using operator&gt;&gt;().</p>
</div>
<p><b>See also </b><a href="qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> and <a href="qtcpserver.html" translate="no">QTcpServer</a>.</p>
<!-- @@@QAbstractSocket -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$BindFlag$$$DefaultForPlatform$$$ShareAddress$$$DontShareAddress$$$ReuseAddressHint -->
<h3 class="flags" id="BindFlag-enum">enum QAbstractSocket::<span class="name">BindFlag</span><br/>flags QAbstractSocket::<span class="name">BindMode</span></h3>
<p>This enum describes the different flags you can pass to modify the behavior of <a href="qabstractsocket.html#bind" translate="no">QAbstractSocket::bind</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ShareAddress</code></td><td class="topAlign tblval"><code translate="no">0x1</code></td><td class="topAlign">Allow other services to bind to the same address and port. This is useful when multiple processes share the load of a single service by listening to the same address and port (e.g., a web server with several pre-forked listeners can greatly improve response time). However, because any service is allowed to rebind, this option is subject to certain security considerations. Note that by combining this option with ReuseAddressHint, you will also allow your service to rebind an existing shared address. On Unix, this is equivalent to the SO_REUSEADDR socket option. On Windows, this is the default behavior, so this option is ignored.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::DontShareAddress</code></td><td class="topAlign tblval"><code translate="no">0x2</code></td><td class="topAlign">Bind the address and port exclusively, so that no other services are allowed to rebind. By passing this option to <a href="qabstractsocket.html#bind" translate="no">QAbstractSocket::bind</a>(), you are guaranteed that on success, your service is the only one that listens to the address and port. No services are allowed to rebind, even if they pass ReuseAddressHint. This option provides more security than ShareAddress, but on certain operating systems, it requires you to run the server with administrator privileges. On Unix and macOS, not sharing is the default behavior for binding an address and port, so this option is ignored. On Windows, this option uses the SO_EXCLUSIVEADDRUSE socket option.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ReuseAddressHint</code></td><td class="topAlign tblval"><code translate="no">0x4</code></td><td class="topAlign">Provides a hint to <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> that it should try to rebind the service even if the address and port are already bound by another socket. On Windows and Unix, this is equivalent to the SO_REUSEADDR socket option.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::DefaultForPlatform</code></td><td class="topAlign tblval"><code translate="no">0x0</code></td><td class="topAlign">The default option for the current platform. On Unix and macOS, this is equivalent to (DontShareAddress + ReuseAddressHint), and on Windows, it is equivalent to ShareAddress.</td></tr>
</table></div>
<p>The BindMode type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;BindFlag&gt;. It stores an OR combination of BindFlag values.</p>
<!-- @@@BindFlag -->
<!-- $$$NetworkLayerProtocol$$$IPv4Protocol$$$IPv6Protocol$$$AnyIPProtocol$$$UnknownNetworkLayerProtocol -->
<h3 class="fn" translate="no" id="NetworkLayerProtocol-enum">enum QAbstractSocket::<span class="name">NetworkLayerProtocol</span></h3>
<p>This enum describes the network layer protocol values used in Qt.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::IPv4Protocol</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">IPv4</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::IPv6Protocol</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">IPv6</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::AnyIPProtocol</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Either IPv4 or IPv6</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::UnknownNetworkLayerProtocol</code></td><td class="topAlign tblval"><code translate="no">-1</code></td><td class="topAlign">Other than IPv4 and IPv6</td></tr>
</table></div>
<p><b>See also </b><a href="qhostaddress.html#protocol" translate="no">QHostAddress::protocol</a>().</p>
<!-- @@@NetworkLayerProtocol -->
<!-- $$$PauseMode$$$PauseNever$$$PauseOnSslErrors -->
<h3 class="flags" id="PauseMode-enum">enum QAbstractSocket::<span class="name">PauseMode</span><br/>flags QAbstractSocket::<span class="name">PauseModes</span></h3>
<p>This enum describes the behavior of when the socket should hold back with continuing data transfer. The only notification currently supported is <a href="qsslsocket.html#sslErrors" translate="no">QSslSocket::sslErrors</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::PauseNever</code></td><td class="topAlign tblval"><code translate="no">0x0</code></td><td class="topAlign">Do not pause data transfer on the socket. This is the default and matches the behavior of Qt 4.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::PauseOnSslErrors</code></td><td class="topAlign tblval"><code translate="no">0x1</code></td><td class="topAlign">Pause data transfer on the socket upon receiving an SSL error notification. I.E. <a href="qsslsocket.html#sslErrors" translate="no">QSslSocket::sslErrors</a>().</td></tr>
</table></div>
<p>The PauseModes type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;PauseMode&gt;. It stores an OR combination of PauseMode values.</p>
<!-- @@@PauseMode -->
<!-- $$$SocketError$$$ConnectionRefusedError$$$RemoteHostClosedError$$$HostNotFoundError$$$SocketAccessError$$$SocketResourceError$$$SocketTimeoutError$$$DatagramTooLargeError$$$NetworkError$$$AddressInUseError$$$SocketAddressNotAvailableError$$$UnsupportedSocketOperationError$$$UnfinishedSocketOperationError$$$ProxyAuthenticationRequiredError$$$SslHandshakeFailedError$$$ProxyConnectionRefusedError$$$ProxyConnectionClosedError$$$ProxyConnectionTimeoutError$$$ProxyNotFoundError$$$ProxyProtocolError$$$OperationError$$$SslInternalError$$$SslInvalidUserDataError$$$TemporaryError$$$UnknownSocketError -->
<h3 class="fn" translate="no" id="SocketError-enum">enum QAbstractSocket::<span class="name">SocketError</span></h3>
<p>This enum describes the socket errors that can occur.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ConnectionRefusedError</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The connection was refused by the peer (or timed out).</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::RemoteHostClosedError</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The remote host closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::HostNotFoundError</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The host address was not found.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::SocketAccessError</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The socket operation failed because the application lacked the required privileges.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::SocketResourceError</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The local system ran out of resources (e.g., too many sockets).</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::SocketTimeoutError</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The socket operation timed out.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::DatagramTooLargeError</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The datagram was larger than the operating system's limit (which can be as low as 8192 bytes).</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::NetworkError</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">An error occurred with the network (e.g., the network cable was accidentally plugged out).</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::AddressInUseError</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">The address specified to <a href="qabstractsocket.html#bind" translate="no">QAbstractSocket::bind</a>() is already in use and was set to be exclusive.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::SocketAddressNotAvailableError</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">The address specified to <a href="qabstractsocket.html#bind" translate="no">QAbstractSocket::bind</a>() does not belong to the host.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::UnsupportedSocketOperationError</code></td><td class="topAlign tblval"><code translate="no">10</code></td><td class="topAlign">The requested socket operation is not supported by the local operating system (e.g., lack of IPv6 support).</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ProxyAuthenticationRequiredError</code></td><td class="topAlign tblval"><code translate="no">12</code></td><td class="topAlign">The socket is using a proxy, and the proxy requires authentication.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::SslHandshakeFailedError</code></td><td class="topAlign tblval"><code translate="no">13</code></td><td class="topAlign">The SSL/TLS handshake failed, so the connection was closed (only used in <a href="qsslsocket.html" translate="no">QSslSocket</a>)</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::UnfinishedSocketOperationError</code></td><td class="topAlign tblval"><code translate="no">11</code></td><td class="topAlign">Used by QAbstractSocketEngine only, The last operation attempted has not finished yet (still in progress in the background).</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ProxyConnectionRefusedError</code></td><td class="topAlign tblval"><code translate="no">14</code></td><td class="topAlign">Could not contact the proxy server because the connection to that server was denied</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ProxyConnectionClosedError</code></td><td class="topAlign tblval"><code translate="no">15</code></td><td class="topAlign">The connection to the proxy server was closed unexpectedly (before the connection to the final peer was established)</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ProxyConnectionTimeoutError</code></td><td class="topAlign tblval"><code translate="no">16</code></td><td class="topAlign">The connection to the proxy server timed out or the proxy server stopped responding in the authentication phase.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ProxyNotFoundError</code></td><td class="topAlign tblval"><code translate="no">17</code></td><td class="topAlign">The proxy address set with <a href="qabstractsocket.html#setProxy" translate="no">setProxy</a>() (or the application proxy) was not found.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ProxyProtocolError</code></td><td class="topAlign tblval"><code translate="no">18</code></td><td class="topAlign">The connection negotiation with the proxy server failed, because the response from the proxy server could not be understood.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::OperationError</code></td><td class="topAlign tblval"><code translate="no">19</code></td><td class="topAlign">An operation was attempted while the socket was in a state that did not permit it.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::SslInternalError</code></td><td class="topAlign tblval"><code translate="no">20</code></td><td class="topAlign">The SSL library being used reported an internal error. This is probably the result of a bad installation or misconfiguration of the library.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::SslInvalidUserDataError</code></td><td class="topAlign tblval"><code translate="no">21</code></td><td class="topAlign">Invalid data (certificate, key, cypher, etc.) was provided and its use resulted in an error in the SSL library.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::TemporaryError</code></td><td class="topAlign tblval"><code translate="no">22</code></td><td class="topAlign">A temporary error occurred (e.g., operation would block and socket is non-blocking).</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::UnknownSocketError</code></td><td class="topAlign tblval"><code translate="no">-1</code></td><td class="topAlign">An unidentified error occurred.</td></tr>
</table></div>
<p><b>See also </b><a href="qabstractsocket.html#error" translate="no">QAbstractSocket::error</a>() and <a href="qabstractsocket.html#errorOccurred" translate="no">QAbstractSocket::errorOccurred</a>().</p>
<!-- @@@SocketError -->
<!-- $$$SocketOption$$$LowDelayOption$$$KeepAliveOption$$$MulticastTtlOption$$$MulticastLoopbackOption$$$TypeOfServiceOption$$$SendBufferSizeSocketOption$$$ReceiveBufferSizeSocketOption$$$PathMtuSocketOption -->
<h3 class="fn" translate="no" id="SocketOption-enum">enum QAbstractSocket::<span class="name">SocketOption</span></h3>
<p>This enum represents the options that can be set on a socket. If desired, they can be set after having received the <a href="qabstractsocket.html#connected" translate="no">connected</a>() signal from the socket or after having received a new socket from a <a href="qtcpserver.html" translate="no">QTcpServer</a>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::LowDelayOption</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Try to optimize the socket for low latency. For a <a href="qtcpsocket.html" translate="no">QTcpSocket</a> this would set the TCP_NODELAY option and disable Nagle's algorithm. Set this to 1 to enable.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::KeepAliveOption</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Set this to 1 to enable the SO_KEEPALIVE socket option</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::MulticastTtlOption</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Set this to an integer value to set IP_MULTICAST_TTL (TTL for multicast datagrams) socket option.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::MulticastLoopbackOption</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Set this to 1 to enable the IP_MULTICAST_LOOP (multicast loopback) socket option.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::TypeOfServiceOption</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">This option is not supported on Windows. This maps to the IP_TOS socket option. For possible values, see table below.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::SendBufferSizeSocketOption</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Sets the socket send buffer size in bytes at the OS level. This maps to the SO_SNDBUF socket option. This option does not affect the <a href="../qtcore/qiodevice.html" translate="no">QIODevice</a> or <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> buffers. This enum value has been introduced in Qt 5.3.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ReceiveBufferSizeSocketOption</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">Sets the socket receive buffer size in bytes at the OS level. This maps to the SO_RCVBUF socket option. This option does not affect the <a href="../qtcore/qiodevice.html" translate="no">QIODevice</a> or <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> buffers (see <a href="qabstractsocket.html#setReadBufferSize" translate="no">setReadBufferSize</a>()). This enum value has been introduced in Qt 5.3.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::PathMtuSocketOption</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">Retrieves the Path Maximum Transmission Unit (PMTU) value currently known by the IP stack, if any. Some IP stacks also allow setting the MTU for transmission. This enum value was introduced in Qt 5.11.</td></tr>
</table></div>
<p>Possible values for <i>TypeOfServiceOption</i> are:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Value</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td >224</td><td >Network control</td></tr>
<tr valign="top" class="even"><td >192</td><td >Internetwork control</td></tr>
<tr valign="top" class="odd"><td >160</td><td >CRITIC/ECP</td></tr>
<tr valign="top" class="even"><td >128</td><td >Flash override</td></tr>
<tr valign="top" class="odd"><td >96</td><td >Flash</td></tr>
<tr valign="top" class="even"><td >64</td><td >Immediate</td></tr>
<tr valign="top" class="odd"><td >32</td><td >Priority</td></tr>
<tr valign="top" class="even"><td >0</td><td >Routine</td></tr>
</table></div>
<p><b>See also </b><a href="qabstractsocket.html#setSocketOption" translate="no">QAbstractSocket::setSocketOption</a>() and <a href="qabstractsocket.html#socketOption" translate="no">QAbstractSocket::socketOption</a>().</p>
<!-- @@@SocketOption -->
<!-- $$$SocketState$$$UnconnectedState$$$HostLookupState$$$ConnectingState$$$ConnectedState$$$BoundState$$$ListeningState$$$ClosingState -->
<h3 class="fn" translate="no" id="SocketState-enum">enum QAbstractSocket::<span class="name">SocketState</span></h3>
<p>This enum describes the different states in which a socket can be.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::UnconnectedState</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The socket is not connected.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::HostLookupState</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The socket is performing a host name lookup.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ConnectingState</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The socket has started establishing a connection.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ConnectedState</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">A connection is established.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::BoundState</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The socket is bound to an address and port.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ClosingState</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The socket is about to close (data may still be waiting to be written).</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::ListeningState</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">For internal use only.</td></tr>
</table></div>
<p><b>See also </b><a href="qabstractsocket.html#state" translate="no">QAbstractSocket::state</a>().</p>
<!-- @@@SocketState -->
<!-- $$$SocketType$$$TcpSocket$$$UdpSocket$$$SctpSocket$$$UnknownSocketType -->
<h3 class="fn" translate="no" id="SocketType-enum">enum QAbstractSocket::<span class="name">SocketType</span></h3>
<p>This enum describes the transport layer protocol.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::TcpSocket</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">TCP</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::UdpSocket</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">UDP</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::SctpSocket</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">SCTP</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractSocket::UnknownSocketType</code></td><td class="topAlign tblval"><code translate="no">-1</code></td><td class="topAlign">Other than TCP, UDP and SCTP</td></tr>
</table></div>
<p><b>See also </b><a href="qabstractsocket.html#socketType" translate="no">QAbstractSocket::socketType</a>().</p>
<!-- @@@SocketType -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QAbstractSocket[overload1]$$$QAbstractSocketQAbstractSocket::SocketTypeQObject* -->
<h3 class="fn" translate="no" id="QAbstractSocket">QAbstractSocket::<span class="name">QAbstractSocket</span>(<span class="type"><a href="qabstractsocket.html#SocketType-enum" translate="no">QAbstractSocket::SocketType</a></span> <i>socketType</i>, <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i>)</h3>
<p>Creates a new abstract socket of type <i translate="no">socketType</i>. The <i translate="no">parent</i> argument is passed to <a href="../qtcore/qobject.html" translate="no">QObject</a>'s constructor.</p>
<p><b>See also </b><a href="qabstractsocket.html#socketType" translate="no">socketType</a>(), <a href="qtcpsocket.html" translate="no">QTcpSocket</a>, and <a href="qudpsocket.html" translate="no">QUdpSocket</a>.</p>
<!-- @@@QAbstractSocket -->
<!-- $$$~QAbstractSocket[overload1]$$$~QAbstractSocket -->
<h3 class="fn" translate="no" id="dtor.QAbstractSocket"><code class="details extra" translate="no">[virtual noexcept]</code> QAbstractSocket::<span class="name">~QAbstractSocket</span>()</h3>
<p>Destroys the socket.</p>
<!-- @@@~QAbstractSocket -->
<!-- $$$abort[overload1]$$$abort -->
<h3 class="fn" translate="no" id="abort"><span class="type">void</span> QAbstractSocket::<span class="name">abort</span>()</h3>
<p>Aborts the current connection and resets the socket. Unlike <a href="qabstractsocket.html#disconnectFromHost" translate="no">disconnectFromHost</a>(), this function immediately closes the socket, discarding any pending data in the write buffer.</p>
<p><b>See also </b><a href="qabstractsocket.html#disconnectFromHost" translate="no">disconnectFromHost</a>() and <a href="qabstractsocket.html#close" translate="no">close</a>().</p>
<!-- @@@abort -->
<!-- $$$bind[overload1]$$$bindconstQHostAddress&quint16QAbstractSocket::BindMode -->
<h3 class="fn" translate="no" id="bind"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QAbstractSocket::<span class="name">bind</span>(const <span class="type"><a href="qhostaddress.html" translate="no">QHostAddress</a></span> &amp;<i>address</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i> = 0, <span class="type"><a href="qabstractsocket.html#BindFlag-enum" translate="no">QAbstractSocket::BindMode</a></span> <i>mode</i> = DefaultForPlatform)</h3>
<p>Binds to <i translate="no">address</i> on port <i translate="no">port</i>, using the <a href="qabstractsocket.html#BindFlag-enum" translate="no">BindMode</a> <i translate="no">mode</i>.</p>
<p>For UDP sockets, after binding, the signal <a href="../qtcore/qiodevice.html#readyRead" translate="no">QUdpSocket::readyRead</a>() is emitted whenever a UDP datagram arrives on the specified address and port. Thus, this function is useful to write UDP servers.</p>
<p>For TCP sockets, this function may be used to specify which interface to use for an outgoing connection, which is useful in case of multiple network interfaces.</p>
<p>By default, the socket is bound using the <a href="qabstractsocket.html#BindFlag-enum" translate="no">DefaultForPlatform</a> <a href="qabstractsocket.html#BindFlag-enum" translate="no">BindMode</a>. If a port is not specified, a random port is chosen.</p>
<p>On success, the function returns <code translate="no">true</code> and the socket enters <a href="qabstractsocket.html#SocketState-enum" translate="no">BoundState</a>; otherwise it returns <code translate="no">false</code>.</p>
<!-- @@@bind -->
<!-- $$$bind$$$bindQHostAddress::SpecialAddressquint16QAbstractSocket::BindMode -->
<h3 class="fn" translate="no" id="bind-1"><code class="details extra" translate="no">[since 6.2]</code> <span class="type">bool</span> QAbstractSocket::<span class="name">bind</span>(<span class="type"><a href="qhostaddress.html#SpecialAddress-enum" translate="no">QHostAddress::SpecialAddress</a></span> <i>addr</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i> = 0, <span class="type"><a href="qabstractsocket.html#BindFlag-enum" translate="no">QAbstractSocket::BindMode</a></span> <i>mode</i> = DefaultForPlatform)</h3>
<p>This is an overloaded function.</p>
<p>Binds to the special address <i translate="no">addr</i> on port <i translate="no">port</i>, using the <a href="qabstractsocket.html#BindFlag-enum" translate="no">BindMode</a> <i translate="no">mode</i>.</p>
<p>By default, the socket is bound using the <a href="qabstractsocket.html#BindFlag-enum" translate="no">DefaultForPlatform</a> <a href="qabstractsocket.html#BindFlag-enum" translate="no">BindMode</a>. If a port is not specified, a random port is chosen.</p>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@bind -->
<!-- $$$bind$$$bindquint16QAbstractSocket::BindMode -->
<h3 class="fn" translate="no" id="bind-2"><span class="type">bool</span> QAbstractSocket::<span class="name">bind</span>(<span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i> = 0, <span class="type"><a href="qabstractsocket.html#BindFlag-enum" translate="no">QAbstractSocket::BindMode</a></span> <i>mode</i> = DefaultForPlatform)</h3>
<p>This is an overloaded function.</p>
<p>Binds to <a href="qhostaddress.html" translate="no">QHostAddress</a>:Any on port <i translate="no">port</i>, using the <a href="qabstractsocket.html#BindFlag-enum" translate="no">BindMode</a> <i translate="no">mode</i>.</p>
<p>By default, the socket is bound using the <a href="qabstractsocket.html#BindFlag-enum" translate="no">DefaultForPlatform</a> <a href="qabstractsocket.html#BindFlag-enum" translate="no">BindMode</a>. If a port is not specified, a random port is chosen.</p>
<!-- @@@bind -->
<!-- $$$bytesAvailable[overload1]$$$bytesAvailable -->
<h3 class="fn" translate="no" id="bytesAvailable"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QAbstractSocket::<span class="name">bytesAvailable</span>() const</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#bytesAvailable" translate="no">QIODevice::bytesAvailable() const</a>.</p>
<p>Returns the number of incoming bytes that are waiting to be read.</p>
<p><b>See also </b><a href="qabstractsocket.html#bytesToWrite" translate="no">bytesToWrite</a>() and <a href="../qtcore/qiodevice.html#read" translate="no">read</a>().</p>
<!-- @@@bytesAvailable -->
<!-- $$$bytesToWrite[overload1]$$$bytesToWrite -->
<h3 class="fn" translate="no" id="bytesToWrite"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QAbstractSocket::<span class="name">bytesToWrite</span>() const</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#bytesToWrite" translate="no">QIODevice::bytesToWrite() const</a>.</p>
<p>Returns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when <a href="qabstractsocket.html#flush" translate="no">flush</a>() is called.</p>
<p><b>See also </b><a href="qabstractsocket.html#bytesAvailable" translate="no">bytesAvailable</a>() and <a href="qabstractsocket.html#flush" translate="no">flush</a>().</p>
<!-- @@@bytesToWrite -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" translate="no" id="close"><code class="details extra" translate="no">[override virtual]</code> <span class="type">void</span> QAbstractSocket::<span class="name">close</span>()</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#close" translate="no">QIODevice::close</a>().</p>
<p>Closes the I/O device for the socket and calls <a href="qabstractsocket.html#disconnectFromHost" translate="no">disconnectFromHost</a>() to close the socket's connection.</p>
<p>See <a href="../qtcore/qiodevice.html#close" translate="no">QIODevice::close</a>() for a description of the actions that occur when an I/O device is closed.</p>
<p><b>See also </b><a href="qabstractsocket.html#abort" translate="no">abort</a>().</p>
<!-- @@@close -->
<!-- $$$connectToHost[overload1]$$$connectToHostconstQString&quint16QIODeviceBase::OpenModeQAbstractSocket::NetworkLayerProtocol -->
<h3 class="fn" translate="no" id="connectToHost"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QAbstractSocket::<span class="name">connectToHost</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>hostName</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i>, <span class="type"><a href="../qtcore/qiodevicebase.html#OpenModeFlag-enum" translate="no">QIODeviceBase::OpenMode</a></span> <i>openMode</i> = ReadWrite, <span class="type"><a href="qabstractsocket.html#NetworkLayerProtocol-enum" translate="no">QAbstractSocket::NetworkLayerProtocol</a></span> <i>protocol</i> = AnyIPProtocol)</h3>
<p>Attempts to make a connection to <i translate="no">hostName</i> on the given <i translate="no">port</i>. The <i translate="no">protocol</i> parameter can be used to specify which network protocol to use (eg. IPv4 or IPv6).</p>
<p>The socket is opened in the given <i translate="no">openMode</i> and first enters <a href="qabstractsocket.html#SocketState-enum" translate="no">HostLookupState</a>, then performs a host name lookup of <i translate="no">hostName</i>. If the lookup succeeds, <a href="qabstractsocket.html#hostFound" translate="no">hostFound</a>() is emitted and <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> enters <a href="qabstractsocket.html#SocketState-enum" translate="no">ConnectingState</a>. It then attempts to connect to the address or addresses returned by the lookup. Finally, if a connection is established, <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> enters <a href="qabstractsocket.html#SocketState-enum" translate="no">ConnectedState</a> and emits <a href="qabstractsocket.html#connected" translate="no">connected</a>().</p>
<p>At any point, the socket can emit <a href="qabstractsocket.html#errorOccurred" translate="no">errorOccurred</a>() to signal that an error occurred.</p>
<p><i translate="no">hostName</i> may be an IP address in string form (e.g., &quot;43.195.83.32&quot;), or it may be a host name (e.g., &quot;example.com&quot;). <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> will do a lookup only if required. <i translate="no">port</i> is in native byte order.</p>
<p><b>See also </b><a href="qabstractsocket.html#state" translate="no">state</a>(), <a href="qabstractsocket.html#peerName" translate="no">peerName</a>(), <a href="qabstractsocket.html#peerAddress" translate="no">peerAddress</a>(), <a href="qabstractsocket.html#peerPort" translate="no">peerPort</a>(), and <a href="qabstractsocket.html#waitForConnected" translate="no">waitForConnected</a>().</p>
<!-- @@@connectToHost -->
<!-- $$$connectToHost$$$connectToHostconstQHostAddress&quint16QIODeviceBase::OpenMode -->
<h3 class="fn" translate="no" id="connectToHost-1"><span class="type">void</span> QAbstractSocket::<span class="name">connectToHost</span>(const <span class="type"><a href="qhostaddress.html" translate="no">QHostAddress</a></span> &amp;<i>address</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i>, <span class="type"><a href="../qtcore/qiodevicebase.html#OpenModeFlag-enum" translate="no">QIODeviceBase::OpenMode</a></span> <i>openMode</i> = ReadWrite)</h3>
<p>This is an overloaded function.</p>
<p>Attempts to make a connection to <i translate="no">address</i> on port <i translate="no">port</i>.</p>
<!-- @@@connectToHost -->
<!-- $$$connected[overload1]$$$connected -->
<h3 class="fn" translate="no" id="connected"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QAbstractSocket::<span class="name">connected</span>()</h3>
<p>This signal is emitted after <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>() has been called and a connection has been successfully established.</p>
<div class="admonition note">
<p><b>Note: </b>On some operating systems the connected() signal may be directly emitted from the <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>() call for connections to the localhost.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>() and <a href="qabstractsocket.html#disconnected" translate="no">disconnected</a>().</p>
<!-- @@@connected -->
<!-- $$$disconnectFromHost[overload1]$$$disconnectFromHost -->
<h3 class="fn" translate="no" id="disconnectFromHost"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QAbstractSocket::<span class="name">disconnectFromHost</span>()</h3>
<p>Attempts to close the socket. If there is pending data waiting to be written, <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> will enter <a href="qabstractsocket.html#SocketState-enum" translate="no">ClosingState</a> and wait until all data has been written. Eventually, it will enter <a href="qabstractsocket.html#SocketState-enum" translate="no">UnconnectedState</a> and emit the <a href="qabstractsocket.html#disconnected" translate="no">disconnected</a>() signal.</p>
<p><b>See also </b><a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>().</p>
<!-- @@@disconnectFromHost -->
<!-- $$$disconnected[overload1]$$$disconnected -->
<h3 class="fn" translate="no" id="disconnected"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QAbstractSocket::<span class="name">disconnected</span>()</h3>
<p>This signal is emitted when the socket has been disconnected.</p>
<div class="admonition warning">
<p><b>Warning: </b>If you need to delete the <a href="../qtcore/qobject.html#sender" translate="no">sender</a>() of this signal in a slot connected to it, use the <a href="../qtcore/qobject.html#deleteLater" translate="no">deleteLater</a>() function.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>(), <a href="qabstractsocket.html#disconnectFromHost" translate="no">disconnectFromHost</a>(), and <a href="qabstractsocket.html#abort" translate="no">abort</a>().</p>
<!-- @@@disconnected -->
<!-- $$$error[overload1]$$$error -->
<h3 class="fn" translate="no" id="error"><span class="type"><a href="qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::SocketError</a></span> QAbstractSocket::<span class="name">error</span>() const</h3>
<p>Returns the type of error that last occurred.</p>
<p><b>See also </b><a href="qabstractsocket.html#state" translate="no">state</a>() and <a href="../qtcore/qiodevice.html#errorString" translate="no">errorString</a>().</p>
<!-- @@@error -->
<!-- $$$errorOccurred[overload1]$$$errorOccurredQAbstractSocket::SocketError -->
<h3 class="fn" translate="no" id="errorOccurred"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QAbstractSocket::<span class="name">errorOccurred</span>(<span class="type"><a href="qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::SocketError</a></span> <i>socketError</i>)</h3>
<p>This signal is emitted after an error occurred. The <i translate="no">socketError</i> parameter describes the type of error that occurred.</p>
<p>When this signal is emitted, the socket may not be ready for a reconnect attempt. In that case, attempts to reconnect should be done from the event loop. For example, use a <a href="../qtcore/qtimer.html#singleShot" translate="no">QTimer::singleShot</a>() with 0 as the timeout.</p>
<p><a href="qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::SocketError</a> is not a registered metatype, so for queued connections, you will have to register it with <a href="../qtcore/qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>() and <a href="../qtcore/qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>().</p>
<p><b>See also </b><a href="qabstractsocket.html#error" translate="no">error</a>(), <a href="../qtcore/qiodevice.html#errorString" translate="no">errorString</a>(), and <a href="../qtcore/custom-types.html" translate="no">Creating Custom Qt Types</a>.</p>
<!-- @@@errorOccurred -->
<!-- $$$flush[overload1]$$$flush -->
<h3 class="fn" translate="no" id="flush"><span class="type">bool</span> QAbstractSocket::<span class="name">flush</span>()</h3>
<p>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns <code translate="no">true</code>; otherwise false is returned.</p>
<p>Call this function if you need <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call <a href="qabstractsocket.html#waitForBytesWritten" translate="no">waitForBytesWritten</a>() instead.</p>
<p><b>See also </b><a href="../qtcore/qiodevice.html#write" translate="no">write</a>() and <a href="qabstractsocket.html#waitForBytesWritten" translate="no">waitForBytesWritten</a>().</p>
<!-- @@@flush -->
<!-- $$$hostFound[overload1]$$$hostFound -->
<h3 class="fn" translate="no" id="hostFound"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QAbstractSocket::<span class="name">hostFound</span>()</h3>
<p>This signal is emitted after <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>() has been called and the host lookup has succeeded.</p>
<div class="admonition note">
<p><b>Note: </b>Since Qt 4.6.3 <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> may emit hostFound() directly from the <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>() call since a DNS result could have been cached.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#connected" translate="no">connected</a>().</p>
<!-- @@@hostFound -->
<!-- $$$isSequential[overload1]$$$isSequential -->
<h3 class="fn" translate="no" id="isSequential"><code class="details extra" translate="no">[override virtual]</code> <span class="type">bool</span> QAbstractSocket::<span class="name">isSequential</span>() const</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#isSequential" translate="no">QIODevice::isSequential() const</a>.</p>
<!-- @@@isSequential -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QAbstractSocket::<span class="name">isValid</span>() const</h3>
<p>Returns <code translate="no">true</code> if the socket is valid and ready for use; otherwise returns <code translate="no">false</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The socket's state must be <a href="qabstractsocket.html#SocketState-enum" translate="no">ConnectedState</a> before reading and writing can occur.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#state" translate="no">state</a>().</p>
<!-- @@@isValid -->
<!-- $$$localAddress[overload1]$$$localAddress -->
<h3 class="fn" translate="no" id="localAddress"><span class="type"><a href="qhostaddress.html" translate="no">QHostAddress</a></span> QAbstractSocket::<span class="name">localAddress</span>() const</h3>
<p>Returns the host address of the local socket if available; otherwise returns <a href="qhostaddress.html#SpecialAddress-enum" translate="no">QHostAddress::Null</a>.</p>
<p>This is normally the main IP address of the host, but can be <a href="qhostaddress.html#SpecialAddress-enum" translate="no">QHostAddress::LocalHost</a> (127.0.0.1) for connections to the local host.</p>
<p><b>See also </b><a href="qabstractsocket.html#localPort" translate="no">localPort</a>(), <a href="qabstractsocket.html#peerAddress" translate="no">peerAddress</a>(), and <a href="qabstractsocket.html#setLocalAddress" translate="no">setLocalAddress</a>().</p>
<!-- @@@localAddress -->
<!-- $$$localPort[overload1]$$$localPort -->
<h3 class="fn" translate="no" id="localPort"><span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> QAbstractSocket::<span class="name">localPort</span>() const</h3>
<p>Returns the host port number (in native byte order) of the local socket if available; otherwise returns 0.</p>
<p><b>See also </b><a href="qabstractsocket.html#localAddress" translate="no">localAddress</a>(), <a href="qabstractsocket.html#peerPort" translate="no">peerPort</a>(), and <a href="qabstractsocket.html#setLocalPort" translate="no">setLocalPort</a>().</p>
<!-- @@@localPort -->
<!-- $$$pauseMode[overload1]$$$pauseMode -->
<h3 class="fn" translate="no" id="pauseMode"><span class="type"><a href="qabstractsocket.html#PauseMode-enum" translate="no">QAbstractSocket::PauseModes</a></span> QAbstractSocket::<span class="name">pauseMode</span>() const</h3>
<p>Returns the pause mode of this socket.</p>
<p><b>See also </b><a href="qabstractsocket.html#setPauseMode" translate="no">setPauseMode</a>() and <a href="qabstractsocket.html#resume" translate="no">resume</a>().</p>
<!-- @@@pauseMode -->
<!-- $$$peerAddress[overload1]$$$peerAddress -->
<h3 class="fn" translate="no" id="peerAddress"><span class="type"><a href="qhostaddress.html" translate="no">QHostAddress</a></span> QAbstractSocket::<span class="name">peerAddress</span>() const</h3>
<p>Returns the address of the connected peer if the socket is in <a href="qabstractsocket.html#SocketState-enum" translate="no">ConnectedState</a>; otherwise returns <a href="qhostaddress.html#SpecialAddress-enum" translate="no">QHostAddress::Null</a>.</p>
<p><b>See also </b><a href="qabstractsocket.html#peerName" translate="no">peerName</a>(), <a href="qabstractsocket.html#peerPort" translate="no">peerPort</a>(), <a href="qabstractsocket.html#localAddress" translate="no">localAddress</a>(), and <a href="qabstractsocket.html#setPeerAddress" translate="no">setPeerAddress</a>().</p>
<!-- @@@peerAddress -->
<!-- $$$peerName[overload1]$$$peerName -->
<h3 class="fn" translate="no" id="peerName"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QAbstractSocket::<span class="name">peerName</span>() const</h3>
<p>Returns the name of the peer as specified by <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>(), or an empty <a href="../qtcore/qstring.html" translate="no">QString</a> if <a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>() has not been called.</p>
<p><b>See also </b><a href="qabstractsocket.html#peerAddress" translate="no">peerAddress</a>(), <a href="qabstractsocket.html#peerPort" translate="no">peerPort</a>(), and <a href="qabstractsocket.html#setPeerName" translate="no">setPeerName</a>().</p>
<!-- @@@peerName -->
<!-- $$$peerPort[overload1]$$$peerPort -->
<h3 class="fn" translate="no" id="peerPort"><span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> QAbstractSocket::<span class="name">peerPort</span>() const</h3>
<p>Returns the port of the connected peer if the socket is in <a href="qabstractsocket.html#SocketState-enum" translate="no">ConnectedState</a>; otherwise returns 0.</p>
<p><b>See also </b><a href="qabstractsocket.html#peerAddress" translate="no">peerAddress</a>(), <a href="qabstractsocket.html#localPort" translate="no">localPort</a>(), and <a href="qabstractsocket.html#setPeerPort" translate="no">setPeerPort</a>().</p>
<!-- @@@peerPort -->
<!-- $$$protocolTag[overload1]$$$protocolTag -->
<h3 class="fn" translate="no" id="protocolTag"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QAbstractSocket::<span class="name">protocolTag</span>() const</h3>
<p>Returns the protocol tag for this socket. If the protocol tag is set then this is passed to <a href="qnetworkproxyquery.html" translate="no">QNetworkProxyQuery</a> when this is created internally to indicate the protocol tag to be used.</p>
<p><b>See also </b><a href="qabstractsocket.html#setProtocolTag" translate="no">setProtocolTag</a>() and <a href="qnetworkproxyquery.html" translate="no">QNetworkProxyQuery</a>.</p>
<!-- @@@protocolTag -->
<!-- $$$proxy[overload1]$$$proxy -->
<h3 class="fn" translate="no" id="proxy"><span class="type"><a href="qnetworkproxy.html" translate="no">QNetworkProxy</a></span> QAbstractSocket::<span class="name">proxy</span>() const</h3>
<p>Returns the network proxy for this socket. By default <a href="qnetworkproxy.html#ProxyType-enum" translate="no">QNetworkProxy::DefaultProxy</a> is used, which means this socket will query the default proxy settings for the application.</p>
<p><b>See also </b><a href="qabstractsocket.html#setProxy" translate="no">setProxy</a>(), <a href="qnetworkproxy.html" translate="no">QNetworkProxy</a>, and <a href="qnetworkproxyfactory.html" translate="no">QNetworkProxyFactory</a>.</p>
<!-- @@@proxy -->
<!-- $$$proxyAuthenticationRequired[overload1]$$$proxyAuthenticationRequiredconstQNetworkProxy&QAuthenticator* -->
<h3 class="fn" translate="no" id="proxyAuthenticationRequired"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QAbstractSocket::<span class="name">proxyAuthenticationRequired</span>(const <span class="type"><a href="qnetworkproxy.html" translate="no">QNetworkProxy</a></span> &amp;<i>proxy</i>, <span class="type"><a href="qauthenticator.html" translate="no">QAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p>This signal can be emitted when a <i translate="no">proxy</i> that requires authentication is used. The <i translate="no">authenticator</i> object can then be filled in with the required details to allow authentication and continue the connection.</p>
<div class="admonition note">
<p><b>Note: </b>It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</p>
</div>
<p><b>See also </b><a href="qauthenticator.html" translate="no">QAuthenticator</a> and <a href="qnetworkproxy.html" translate="no">QNetworkProxy</a>.</p>
<!-- @@@proxyAuthenticationRequired -->
<!-- $$$readBufferSize[overload1]$$$readBufferSize -->
<h3 class="fn" translate="no" id="readBufferSize"><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QAbstractSocket::<span class="name">readBufferSize</span>() const</h3>
<p>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call <a href="../qtcore/qiodevice.html#read" translate="no">read</a>() or <a href="../qtcore/qiodevice.html#readAll" translate="no">readAll</a>().</p>
<p>A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</p>
<p><b>See also </b><a href="qabstractsocket.html#setReadBufferSize" translate="no">setReadBufferSize</a>() and <a href="../qtcore/qiodevice.html#read" translate="no">read</a>().</p>
<!-- @@@readBufferSize -->
<!-- $$$readData[overload1]$$$readDatachar*qint64 -->
<h3 class="fn" translate="no" id="readData"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QAbstractSocket::<span class="name">readData</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>maxSize</i>)</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#readData" translate="no">QIODevice::readData</a>(char *data, qint64 maxSize).</p>
<!-- @@@readData -->
<!-- $$$readLineData[overload1]$$$readLineDatachar*qint64 -->
<h3 class="fn" translate="no" id="readLineData"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QAbstractSocket::<span class="name">readLineData</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>maxlen</i>)</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#readLineData" translate="no">QIODevice::readLineData</a>(char *data, qint64 maxSize).</p>
<!-- @@@readLineData -->
<!-- $$$resume[overload1]$$$resume -->
<h3 class="fn" translate="no" id="resume"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QAbstractSocket::<span class="name">resume</span>()</h3>
<p>Continues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is <a href="qsslsocket.html#sslErrors" translate="no">QSslSocket::sslErrors</a>(). Calling this method if the socket is not paused results in undefined behavior.</p>
<p><b>See also </b><a href="qabstractsocket.html#pauseMode" translate="no">pauseMode</a>() and <a href="qabstractsocket.html#setPauseMode" translate="no">setPauseMode</a>().</p>
<!-- @@@resume -->
<!-- $$$setLocalAddress[overload1]$$$setLocalAddressconstQHostAddress& -->
<h3 class="fn" translate="no" id="setLocalAddress"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QAbstractSocket::<span class="name">setLocalAddress</span>(const <span class="type"><a href="qhostaddress.html" translate="no">QHostAddress</a></span> &amp;<i>address</i>)</h3>
<p>Sets the address on the local side of a connection to <i translate="no">address</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> to change the return value of the <a href="qabstractsocket.html#localAddress" translate="no">localAddress</a>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<p>Note that this function does not bind the local address of the socket prior to a connection (e.g., <a href="qabstractsocket.html#bind" translate="no">QAbstractSocket::bind</a>()).</p>
<p><b>See also </b><a href="qabstractsocket.html#localAddress" translate="no">localAddress</a>(), <a href="qabstractsocket.html#setLocalPort" translate="no">setLocalPort</a>(), and <a href="qabstractsocket.html#setPeerAddress" translate="no">setPeerAddress</a>().</p>
<!-- @@@setLocalAddress -->
<!-- $$$setLocalPort[overload1]$$$setLocalPortquint16 -->
<h3 class="fn" translate="no" id="setLocalPort"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QAbstractSocket::<span class="name">setLocalPort</span>(<span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i>)</h3>
<p>Sets the port on the local side of a connection to <i translate="no">port</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> to change the return value of the <a href="qabstractsocket.html#localPort" translate="no">localPort</a>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<p>Note that this function does not bind the local port of the socket prior to a connection (e.g., <a href="qabstractsocket.html#bind" translate="no">QAbstractSocket::bind</a>()).</p>
<p><b>See also </b><a href="qabstractsocket.html#localPort" translate="no">localPort</a>(), <a href="qabstractsocket.html#localAddress" translate="no">localAddress</a>(), <a href="qabstractsocket.html#setLocalAddress" translate="no">setLocalAddress</a>(), and <a href="qabstractsocket.html#setPeerPort" translate="no">setPeerPort</a>().</p>
<!-- @@@setLocalPort -->
<!-- $$$setPauseMode[overload1]$$$setPauseModeQAbstractSocket::PauseModes -->
<h3 class="fn" translate="no" id="setPauseMode"><span class="type">void</span> QAbstractSocket::<span class="name">setPauseMode</span>(<span class="type"><a href="qabstractsocket.html#PauseMode-enum" translate="no">QAbstractSocket::PauseModes</a></span> <i>pauseMode</i>)</h3>
<p>Controls whether to pause upon receiving a notification. The <i translate="no">pauseMode</i> parameter specifies the conditions in which the socket should be paused. The only notification currently supported is <a href="qsslsocket.html#sslErrors" translate="no">QSslSocket::sslErrors</a>(). If set to <a href="qabstractsocket.html#PauseMode-enum" translate="no">PauseOnSslErrors</a>, data transfer on the socket will be paused and needs to be enabled explicitly again by calling <a href="qabstractsocket.html#resume" translate="no">resume</a>(). By default this option is set to <a href="qabstractsocket.html#PauseMode-enum" translate="no">PauseNever</a>. This option must be called before connecting to the server, otherwise it will result in undefined behavior.</p>
<p><b>See also </b><a href="qabstractsocket.html#pauseMode" translate="no">pauseMode</a>() and <a href="qabstractsocket.html#resume" translate="no">resume</a>().</p>
<!-- @@@setPauseMode -->
<!-- $$$setPeerAddress[overload1]$$$setPeerAddressconstQHostAddress& -->
<h3 class="fn" translate="no" id="setPeerAddress"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QAbstractSocket::<span class="name">setPeerAddress</span>(const <span class="type"><a href="qhostaddress.html" translate="no">QHostAddress</a></span> &amp;<i>address</i>)</h3>
<p>Sets the address of the remote side of the connection to <i translate="no">address</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> to change the return value of the <a href="qabstractsocket.html#peerAddress" translate="no">peerAddress</a>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<p><b>See also </b><a href="qabstractsocket.html#peerAddress" translate="no">peerAddress</a>(), <a href="qabstractsocket.html#setPeerPort" translate="no">setPeerPort</a>(), and <a href="qabstractsocket.html#setLocalAddress" translate="no">setLocalAddress</a>().</p>
<!-- @@@setPeerAddress -->
<!-- $$$setPeerName[overload1]$$$setPeerNameconstQString& -->
<h3 class="fn" translate="no" id="setPeerName"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QAbstractSocket::<span class="name">setPeerName</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>name</i>)</h3>
<p>Sets the host name of the remote peer to <i translate="no">name</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> to change the return value of the <a href="qabstractsocket.html#peerName" translate="no">peerName</a>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<p><b>See also </b><a href="qabstractsocket.html#peerName" translate="no">peerName</a>().</p>
<!-- @@@setPeerName -->
<!-- $$$setPeerPort[overload1]$$$setPeerPortquint16 -->
<h3 class="fn" translate="no" id="setPeerPort"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QAbstractSocket::<span class="name">setPeerPort</span>(<span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i>)</h3>
<p>Sets the port of the remote side of the connection to <i translate="no">port</i>.</p>
<p>You can call this function in a subclass of <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> to change the return value of the <a href="qabstractsocket.html#peerPort" translate="no">peerPort</a>() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<p><b>See also </b><a href="qabstractsocket.html#peerPort" translate="no">peerPort</a>(), <a href="qabstractsocket.html#setPeerAddress" translate="no">setPeerAddress</a>(), and <a href="qabstractsocket.html#setLocalPort" translate="no">setLocalPort</a>().</p>
<!-- @@@setPeerPort -->
<!-- $$$setProtocolTag[overload1]$$$setProtocolTagconstQString& -->
<h3 class="fn" translate="no" id="setProtocolTag"><span class="type">void</span> QAbstractSocket::<span class="name">setProtocolTag</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>tag</i>)</h3>
<p>Sets the protocol tag for this socket to <i translate="no">tag</i>.</p>
<p><b>See also </b><a href="qabstractsocket.html#protocolTag" translate="no">protocolTag</a>().</p>
<!-- @@@setProtocolTag -->
<!-- $$$setProxy[overload1]$$$setProxyconstQNetworkProxy& -->
<h3 class="fn" translate="no" id="setProxy"><span class="type">void</span> QAbstractSocket::<span class="name">setProxy</span>(const <span class="type"><a href="qnetworkproxy.html" translate="no">QNetworkProxy</a></span> &amp;<i>networkProxy</i>)</h3>
<p>Sets the explicit network proxy for this socket to <i translate="no">networkProxy</i>.</p>
<p>To disable the use of a proxy for this socket, use the <a href="qnetworkproxy.html#ProxyType-enum" translate="no">QNetworkProxy::NoProxy</a> proxy type:</p>
<pre class="cpp" translate="no">
 socket<span class="operator">-</span><span class="operator">&gt;</span>setProxy(<span class="type"><a href="qnetworkproxy.html" translate="no">QNetworkProxy</a></span><span class="operator">::</span>NoProxy);
</pre>
<p>The default value for the proxy is <a href="qnetworkproxy.html#ProxyType-enum" translate="no">QNetworkProxy::DefaultProxy</a>, which means the socket will use the application settings: if a proxy is set with <a href="qnetworkproxy.html#setApplicationProxy" translate="no">QNetworkProxy::setApplicationProxy</a>, it will use that; otherwise, if a factory is set with <a href="qnetworkproxyfactory.html#setApplicationProxyFactory" translate="no">QNetworkProxyFactory::setApplicationProxyFactory</a>, it will query that factory with type <a href="qnetworkproxyquery.html#QueryType-enum" translate="no">QNetworkProxyQuery::TcpSocket</a>.</p>
<p><b>See also </b><a href="qabstractsocket.html#proxy" translate="no">proxy</a>(), <a href="qnetworkproxy.html" translate="no">QNetworkProxy</a>, and <a href="qnetworkproxyfactory.html#queryProxy" translate="no">QNetworkProxyFactory::queryProxy</a>().</p>
<!-- @@@setProxy -->
<!-- $$$setReadBufferSize[overload1]$$$setReadBufferSizeqint64 -->
<h3 class="fn" translate="no" id="setReadBufferSize"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QAbstractSocket::<span class="name">setReadBufferSize</span>(<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>size</i>)</h3>
<p>Sets the size of <a href="qabstractsocket.html" translate="no">QAbstractSocket</a>'s internal read buffer to be <i translate="no">size</i> bytes.</p>
<p>If the buffer size is limited to a certain size, <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</p>
<p>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</p>
<p>Only <a href="qtcpsocket.html" translate="no">QTcpSocket</a> uses <a href="qabstractsocket.html" translate="no">QAbstractSocket</a>'s internal buffer; <a href="qudpsocket.html" translate="no">QUdpSocket</a> does not use any buffering at all, but rather relies on the implicit buffering provided by the operating system. Because of this, calling this function on <a href="qudpsocket.html" translate="no">QUdpSocket</a> has no effect.</p>
<p><b>See also </b><a href="qabstractsocket.html#readBufferSize" translate="no">readBufferSize</a>() and <a href="../qtcore/qiodevice.html#read" translate="no">read</a>().</p>
<!-- @@@setReadBufferSize -->
<!-- $$$setSocketDescriptor[overload1]$$$setSocketDescriptorqintptrQAbstractSocket::SocketStateQIODeviceBase::OpenMode -->
<h3 class="fn" translate="no" id="setSocketDescriptor"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QAbstractSocket::<span class="name">setSocketDescriptor</span>(<span class="type"><a href="../qtcore/qttypes.html#qintptr-typedef" translate="no">qintptr</a></span> <i>socketDescriptor</i>, <span class="type"><a href="qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::SocketState</a></span> <i>socketState</i> = ConnectedState, <span class="type"><a href="../qtcore/qiodevicebase.html#OpenModeFlag-enum" translate="no">QIODeviceBase::OpenMode</a></span> <i>openMode</i> = ReadWrite)</h3>
<p>Initializes <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> with the native socket descriptor <i translate="no">socketDescriptor</i>. Returns <code translate="no">true</code> if <i translate="no">socketDescriptor</i> is accepted as a valid socket descriptor; otherwise returns <code translate="no">false</code>. The socket is opened in the mode specified by <i translate="no">openMode</i>, and enters the socket state specified by <i translate="no">socketState</i>. Read and write buffers are cleared, discarding any pending data.</p>
<p><b>Note:</b> It is not possible to initialize two abstract sockets with the same native socket descriptor.</p>
<p><b>See also </b><a href="qabstractsocket.html#socketDescriptor" translate="no">socketDescriptor</a>().</p>
<!-- @@@setSocketDescriptor -->
<!-- $$$setSocketError[overload1]$$$setSocketErrorQAbstractSocket::SocketError -->
<h3 class="fn" translate="no" id="setSocketError"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QAbstractSocket::<span class="name">setSocketError</span>(<span class="type"><a href="qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::SocketError</a></span> <i>socketError</i>)</h3>
<p>Sets the type of error that last occurred to <i translate="no">socketError</i>.</p>
<p><b>See also </b><a href="qabstractsocket.html#setSocketState" translate="no">setSocketState</a>() and <a href="../qtcore/qiodevice.html#setErrorString" translate="no">setErrorString</a>().</p>
<!-- @@@setSocketError -->
<!-- $$$setSocketOption[overload1]$$$setSocketOptionQAbstractSocket::SocketOptionconstQVariant& -->
<h3 class="fn" translate="no" id="setSocketOption"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QAbstractSocket::<span class="name">setSocketOption</span>(<span class="type"><a href="qabstractsocket.html#SocketOption-enum" translate="no">QAbstractSocket::SocketOption</a></span> <i>option</i>, const <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Sets the given <i translate="no">option</i> to the value described by <i translate="no">value</i>.</p>
<div class="admonition note">
<p><b>Note: </b>Since the options are set on an internal socket the options only apply if the socket has been created. This is only guaranteed to have happened after a call to <a href="qabstractsocket.html#bind" translate="no">bind</a>(), or when <a href="qabstractsocket.html#connected" translate="no">connected</a>() has been emitted.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#socketOption" translate="no">socketOption</a>().</p>
<!-- @@@setSocketOption -->
<!-- $$$setSocketState[overload1]$$$setSocketStateQAbstractSocket::SocketState -->
<h3 class="fn" translate="no" id="setSocketState"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QAbstractSocket::<span class="name">setSocketState</span>(<span class="type"><a href="qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::SocketState</a></span> <i>state</i>)</h3>
<p>Sets the state of the socket to <i translate="no">state</i>.</p>
<p><b>See also </b><a href="qabstractsocket.html#state" translate="no">state</a>().</p>
<!-- @@@setSocketState -->
<!-- $$$skipData[overload1]$$$skipDataqint64 -->
<h3 class="fn" translate="no" id="skipData"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QAbstractSocket::<span class="name">skipData</span>(<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>maxSize</i>)</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#skipData" translate="no">QIODevice::skipData</a>(qint64 maxSize).</p>
<!-- @@@skipData -->
<!-- $$$socketDescriptor[overload1]$$$socketDescriptor -->
<h3 class="fn" translate="no" id="socketDescriptor"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="../qtcore/qttypes.html#qintptr-typedef" translate="no">qintptr</a></span> QAbstractSocket::<span class="name">socketDescriptor</span>() const</h3>
<p>Returns the native socket descriptor of the <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> object if this is available; otherwise returns -1.</p>
<p>If the socket is using <a href="qnetworkproxy.html" translate="no">QNetworkProxy</a>, the returned descriptor may not be usable with native socket functions.</p>
<p>The socket descriptor is not available when <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> is in <a href="qabstractsocket.html#SocketState-enum" translate="no">UnconnectedState</a>.</p>
<p><b>See also </b><a href="qabstractsocket.html#setSocketDescriptor" translate="no">setSocketDescriptor</a>().</p>
<!-- @@@socketDescriptor -->
<!-- $$$socketOption[overload1]$$$socketOptionQAbstractSocket::SocketOption -->
<h3 class="fn" translate="no" id="socketOption"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> QAbstractSocket::<span class="name">socketOption</span>(<span class="type"><a href="qabstractsocket.html#SocketOption-enum" translate="no">QAbstractSocket::SocketOption</a></span> <i>option</i>)</h3>
<p>Returns the value of the <i translate="no">option</i> option.</p>
<p><b>See also </b><a href="qabstractsocket.html#setSocketOption" translate="no">setSocketOption</a>().</p>
<!-- @@@socketOption -->
<!-- $$$socketType[overload1]$$$socketType -->
<h3 class="fn" translate="no" id="socketType"><span class="type"><a href="qabstractsocket.html#SocketType-enum" translate="no">QAbstractSocket::SocketType</a></span> QAbstractSocket::<span class="name">socketType</span>() const</h3>
<p>Returns the socket type (TCP, UDP, or other).</p>
<p><b>See also </b><a href="qtcpsocket.html" translate="no">QTcpSocket</a> and <a href="qudpsocket.html" translate="no">QUdpSocket</a>.</p>
<!-- @@@socketType -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn" translate="no" id="state"><span class="type"><a href="qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::SocketState</a></span> QAbstractSocket::<span class="name">state</span>() const</h3>
<p>Returns the state of the socket.</p>
<p><b>See also </b><a href="qabstractsocket.html#error" translate="no">error</a>().</p>
<!-- @@@state -->
<!-- $$$stateChanged[overload1]$$$stateChangedQAbstractSocket::SocketState -->
<h3 class="fn" translate="no" id="stateChanged"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QAbstractSocket::<span class="name">stateChanged</span>(<span class="type"><a href="qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::SocketState</a></span> <i>socketState</i>)</h3>
<p>This signal is emitted whenever <a href="qabstractsocket.html" translate="no">QAbstractSocket</a>'s state changes. The <i translate="no">socketState</i> parameter is the new state.</p>
<p><a href="qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::SocketState</a> is not a registered metatype, so for queued connections, you will have to register it with <a href="../qtcore/qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>() and <a href="../qtcore/qmetatype.html#qRegisterMetaType-2" translate="no">qRegisterMetaType</a>().</p>
<p><b>See also </b><a href="qabstractsocket.html#state" translate="no">state</a>() and <a href="../qtcore/custom-types.html" translate="no">Creating Custom Qt Types</a>.</p>
<!-- @@@stateChanged -->
<!-- $$$waitForBytesWritten[overload1]$$$waitForBytesWrittenint -->
<h3 class="fn" translate="no" id="waitForBytesWritten"><code class="details extra" translate="no">[override virtual]</code> <span class="type">bool</span> QAbstractSocket::<span class="name">waitForBytesWritten</span>(<span class="type">int</span> <i>msecs</i> = 30000)</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#waitForBytesWritten" translate="no">QIODevice::waitForBytesWritten</a>(int msecs).</p>
<p>This function blocks until at least one byte has been written on the socket and the <a href="../qtcore/qiodevice.html#bytesWritten" translate="no">bytesWritten</a>() signal has been emitted. The function will timeout after <i translate="no">msecs</i> milliseconds; the default timeout is 30000 milliseconds.</p>
<p>The function returns <code translate="no">true</code> if the <a href="../qtcore/qiodevice.html#bytesWritten" translate="no">bytesWritten</a>() signal is emitted; otherwise it returns <code translate="no">false</code> (if an error occurred or the operation timed out).</p>
<div class="admonition note">
<p><b>Note: </b>This function may fail randomly on Windows. Consider using the event loop and the <a href="../qtcore/qiodevice.html#bytesWritten" translate="no">bytesWritten</a>() signal if your software will run on Windows.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#waitForReadyRead" translate="no">waitForReadyRead</a>().</p>
<!-- @@@waitForBytesWritten -->
<!-- $$$waitForConnected[overload1]$$$waitForConnectedint -->
<h3 class="fn" translate="no" id="waitForConnected"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QAbstractSocket::<span class="name">waitForConnected</span>(<span class="type">int</span> <i>msecs</i> = 30000)</h3>
<p>Waits until the socket is connected, up to <i translate="no">msecs</i> milliseconds. If the connection has been established, this function returns <code translate="no">true</code>; otherwise it returns <code translate="no">false</code>. In the case where it returns <code translate="no">false</code>, you can call <a href="qabstractsocket.html#error" translate="no">error</a>() to determine the cause of the error.</p>
<p>The following example waits up to one second for a connection to be established:</p>
<pre class="cpp" translate="no">
 socket<span class="operator">-</span><span class="operator">&gt;</span>connectToHost(<span class="string">&quot;imap&quot;</span><span class="operator">,</span> <span class="number">143</span>);
 <span class="keyword">if</span> (socket<span class="operator">-</span><span class="operator">&gt;</span>waitForConnected(<span class="number">1000</span>))
     <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>(<span class="string">&quot;Connected!&quot;</span>);
</pre>
<p>If msecs is -1, this function will not time out.</p>
<div class="admonition note">
<p><b>Note: </b>This function may wait slightly longer than <i translate="no">msecs</i>, depending on the time it takes to complete the host lookup.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Multiple calls to this functions do not accumulate the time. If the function times out, the connecting process will be aborted.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function may fail randomly on Windows. Consider using the event loop and the <a href="qabstractsocket.html#connected" translate="no">connected</a>() signal if your software will run on Windows.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#connectToHost" translate="no">connectToHost</a>() and <a href="qabstractsocket.html#connected" translate="no">connected</a>().</p>
<!-- @@@waitForConnected -->
<!-- $$$waitForDisconnected[overload1]$$$waitForDisconnectedint -->
<h3 class="fn" translate="no" id="waitForDisconnected"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QAbstractSocket::<span class="name">waitForDisconnected</span>(<span class="type">int</span> <i>msecs</i> = 30000)</h3>
<p>Waits until the socket has disconnected, up to <i translate="no">msecs</i> milliseconds. If the connection was successfully disconnected, this function returns <code translate="no">true</code>; otherwise it returns <code translate="no">false</code> (if the operation timed out, if an error occurred, or if this <a href="qabstractsocket.html" translate="no">QAbstractSocket</a> is already disconnected). In the case where it returns <code translate="no">false</code>, you can call <a href="qabstractsocket.html#error" translate="no">error</a>() to determine the cause of the error.</p>
<p>The following example waits up to one second for a connection to be closed:</p>
<pre class="cpp" translate="no">
 socket<span class="operator">-</span><span class="operator">&gt;</span>disconnectFromHost();
 <span class="keyword">if</span> (socket<span class="operator">-</span><span class="operator">&gt;</span>state() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qabstractsocket.html#QAbstractSocket" translate="no">QAbstractSocket</a></span><span class="operator">::</span>UnconnectedState
     <span class="operator">|</span><span class="operator">|</span> socket<span class="operator">-</span><span class="operator">&gt;</span>waitForDisconnected(<span class="number">1000</span>)) {
         <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>(<span class="string">&quot;Disconnected!&quot;</span>);
 }
</pre>
<p>If msecs is -1, this function will not time out.</p>
<div class="admonition note">
<p><b>Note: </b>This function may fail randomly on Windows. Consider using the event loop and the <a href="qabstractsocket.html#disconnected" translate="no">disconnected</a>() signal if your software will run on Windows.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#disconnectFromHost" translate="no">disconnectFromHost</a>() and <a href="qabstractsocket.html#close" translate="no">close</a>().</p>
<!-- @@@waitForDisconnected -->
<!-- $$$waitForReadyRead[overload1]$$$waitForReadyReadint -->
<h3 class="fn" translate="no" id="waitForReadyRead"><code class="details extra" translate="no">[override virtual]</code> <span class="type">bool</span> QAbstractSocket::<span class="name">waitForReadyRead</span>(<span class="type">int</span> <i>msecs</i> = 30000)</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#waitForReadyRead" translate="no">QIODevice::waitForReadyRead</a>(int msecs).</p>
<p>This function blocks until new data is available for reading and the <a href="../qtcore/qiodevice.html#readyRead" translate="no">readyRead</a>() signal has been emitted. The function will timeout after <i translate="no">msecs</i> milliseconds; the default timeout is 30000 milliseconds.</p>
<p>The function returns <code translate="no">true</code> if the <a href="../qtcore/qiodevice.html#readyRead" translate="no">readyRead</a>() signal is emitted and there is new data available for reading; otherwise it returns <code translate="no">false</code> (if an error occurred or the operation timed out).</p>
<div class="admonition note">
<p><b>Note: </b>This function may fail randomly on Windows. Consider using the event loop and the <a href="../qtcore/qiodevice.html#readyRead" translate="no">readyRead</a>() signal if your software will run on Windows.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#waitForBytesWritten" translate="no">waitForBytesWritten</a>().</p>
<!-- @@@waitForReadyRead -->
<!-- $$$writeData[overload1]$$$writeDataconstchar*qint64 -->
<h3 class="fn" translate="no" id="writeData"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QAbstractSocket::<span class="name">writeData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>size</i>)</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#writeData" translate="no">QIODevice::writeData</a>(const char *data, qint64 maxSize).</p>
<!-- @@@writeData -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
