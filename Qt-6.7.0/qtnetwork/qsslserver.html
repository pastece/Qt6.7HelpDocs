<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qsslserver.cpp -->
  <meta name="description" content="Implements an encrypted, secure TCP server over TLS.">
  <title>QSslServer Class | Qt Network 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtnetwork-index.html" translate="no">Qt Network</a></li>
<li><a href="qtnetwork-module.html" translate="no">C++ Classes</a></li>
<li>QSslServer</li>
<li id="buildversion"><a href="qtnetwork-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QSslServer Class</h1>
<!-- $$$QSslServer-brief -->
<p>Implements an encrypted, secure TCP server over TLS. <a href="#details">More...</a></p>
<!-- @@@QSslServer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QSslServer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Network) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Network)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += network</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.4</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qtcpserver.html" translate="no">QTcpServer</a></td></tr>
</table></div>
<ul>
<li><a href="qsslserver-members.html">List of all members, including inherited members</a></li>
<li>QSslServer is part of <a href="network.html">Network Programming API</a>.</li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#QSslServer-2" translate="no">QSslServer</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#dtor.QSslServer" translate="no">~QSslServer</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#handshakeTimeout" translate="no">handshakeTimeout</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#setHandshakeTimeout" translate="no">setHandshakeTimeout</a></b>(int <i>timeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#setSslConfiguration" translate="no">setSslConfiguration</a></b>(const QSslConfiguration &amp;<i>sslConfiguration</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslConfiguration </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#sslConfiguration" translate="no">sslConfiguration</a></b>() const</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#alertReceived" translate="no">alertReceived</a></b>(QSslSocket *<i>socket</i>, QSsl::AlertLevel <i>level</i>, QSsl::AlertType <i>type</i>, const QString &amp;<i>description</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#alertSent" translate="no">alertSent</a></b>(QSslSocket *<i>socket</i>, QSsl::AlertLevel <i>level</i>, QSsl::AlertType <i>type</i>, const QString &amp;<i>description</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#errorOccurred" translate="no">errorOccurred</a></b>(QSslSocket *<i>socket</i>, QAbstractSocket::SocketError <i>socketError</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#handshakeInterruptedOnError" translate="no">handshakeInterruptedOnError</a></b>(QSslSocket *<i>socket</i>, const QSslError &amp;<i>error</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#peerVerifyError" translate="no">peerVerifyError</a></b>(QSslSocket *<i>socket</i>, const QSslError &amp;<i>error</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#preSharedKeyAuthenticationRequired" translate="no">preSharedKeyAuthenticationRequired</a></b>(QSslSocket *<i>socket</i>, QSslPreSharedKeyAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#sslErrors" translate="no">sslErrors</a></b>(QSslSocket *<i>socket</i>, const QList&lt;QSslError&gt; &amp;<i>errors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#startedEncryptionHandshake" translate="no">startedEncryptionHandshake</a></b>(QSslSocket *<i>socket</i>)</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qsslserver.html#incomingConnection" translate="no">incomingConnection</a></b>(qintptr <i>socket</i>) override</td></tr>
</table></div>
<!-- $$$QSslServer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Class to use in place of <a href="qtcpserver.html" translate="no">QTcpServer</a> to implement TCP server using Transport Layer Security (TLS).</p>
<p>To configure the secure handshake settings, use the applicable setter functions on a <a href="qsslconfiguration.html" translate="no">QSslConfiguration</a> object, and then use it as an argument to the <a href="qsslserver.html#setSslConfiguration" translate="no">setSslConfiguration</a>() function. All following incoming connections handled will use these settings.</p>
<p>To start listening to incoming connections use the <a href="qtcpserver.html#listen" translate="no">listen</a>() function inherited from <a href="qtcpserver.html" translate="no">QTcpServer</a>. Other settings can be configured by using the setter functions inherited from the <a href="qtcpserver.html" translate="no">QTcpServer</a> class.</p>
<p>Connect to the signals of this class to respond to the incoming connection attempts. They are the same as the signals on <a href="qsslsocket.html" translate="no">QSslSocket</a>, but also passes a pointer to the socket in question.</p>
<p>When responding to the <a href="qtcpserver.html#pendingConnectionAvailable" translate="no">pendingConnectionAvailable</a>() signal, use the <a href="qtcpserver.html#nextPendingConnection" translate="no">nextPendingConnection</a>() function to fetch the next incoming connection and take it out of the pending connection queue. The <a href="qsslsocket.html" translate="no">QSslSocket</a> is a child of the QSslServer and will be deleted when the QSslServer is deleted. It is still a good idea to destroy the object explicitly when you are done with it, to avoid wasting memory.</p>
</div>
<p><b>See also </b><a href="qtcpserver.html" translate="no">QTcpServer</a>, <a href="qsslconfiguration.html" translate="no">QSslConfiguration</a>, and <a href="qsslsocket.html" translate="no">QSslSocket</a>.</p>
<!-- @@@QSslServer -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QSslServer$$$QSslServerQObject* -->
<h3 class="fn" translate="no" id="QSslServer-2"><code class="details extra" translate="no">[explicit]</code> QSslServer::<span class="name">QSslServer</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new QSslServer with the given <i translate="no">parent</i>.</p>
<!-- @@@QSslServer -->
<!-- $$$~QSslServer[overload1]$$$~QSslServer -->
<h3 class="fn" translate="no" id="dtor.QSslServer"><code class="details extra" translate="no">[override virtual noexcept]</code> QSslServer::<span class="name">~QSslServer</span>()</h3>
<p>Destroys the <a href="qsslserver.html" translate="no">QSslServer</a>.</p>
<p>All open connections are closed.</p>
<!-- @@@~QSslServer -->
<!-- $$$alertReceived[overload1]$$$alertReceivedQSslSocket*QSsl::AlertLevelQSsl::AlertTypeconstQString& -->
<h3 class="fn" translate="no" id="alertReceived"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QSslServer::<span class="name">alertReceived</span>(<span class="type"><a href="qsslsocket.html" translate="no">QSslSocket</a></span> *<i>socket</i>, <span class="type"><a href="qsslsocket.html#AlertLevel-enum" translate="no">QSsl::AlertLevel</a></span> <i>level</i>, <span class="type"><a href="qsslsocket.html#AlertType-enum" translate="no">QSsl::AlertType</a></span> <i>type</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>description</i>)</h3>
<p><a href="qsslserver.html" translate="no">QSslServer</a> emits this signal if an alert message was received by the <i translate="no">socket</i> from a peer. <i translate="no">level</i> tells if the alert was fatal or it was a warning. <i translate="no">type</i> is the code explaining why the alert was sent. When a textual description of the alert message is available, it is supplied in <i translate="no">description</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The signal is mostly for informational and debugging purposes and does not require any handling in the application. If the alert was fatal, underlying backend will handle it and close the connection.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Not all backends support this functionality.</p>
</div>
<p><b>See also </b><a href="qsslserver.html#alertSent" translate="no">alertSent</a>(), <a href="qsslsocket.html#AlertLevel-enum" translate="no">QSsl::AlertLevel</a>, and <a href="qsslsocket.html#AlertType-enum" translate="no">QSsl::AlertType</a>.</p>
<!-- @@@alertReceived -->
<!-- $$$alertSent[overload1]$$$alertSentQSslSocket*QSsl::AlertLevelQSsl::AlertTypeconstQString& -->
<h3 class="fn" translate="no" id="alertSent"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QSslServer::<span class="name">alertSent</span>(<span class="type"><a href="qsslsocket.html" translate="no">QSslSocket</a></span> *<i>socket</i>, <span class="type"><a href="qsslsocket.html#AlertLevel-enum" translate="no">QSsl::AlertLevel</a></span> <i>level</i>, <span class="type"><a href="qsslsocket.html#AlertType-enum" translate="no">QSsl::AlertType</a></span> <i>type</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>description</i>)</h3>
<p><a href="qsslserver.html" translate="no">QSslServer</a> emits this signal if an alert message was sent from <i translate="no">socket</i> to a peer. <i translate="no">level</i> describes if it was a warning or a fatal error. <i translate="no">type</i> gives the code of the alert message. When a textual description of the alert message is available, it is supplied in <i translate="no">description</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This signal is mostly informational and can be used for debugging purposes, normally it does not require any actions from the application.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Not all backends support this functionality.</p>
</div>
<p><b>See also </b><a href="qsslserver.html#alertReceived" translate="no">alertReceived</a>(), <a href="qsslsocket.html#AlertLevel-enum" translate="no">QSsl::AlertLevel</a>, and <a href="qsslsocket.html#AlertType-enum" translate="no">QSsl::AlertType</a>.</p>
<!-- @@@alertSent -->
<!-- $$$errorOccurred[overload1]$$$errorOccurredQSslSocket*QAbstractSocket::SocketError -->
<h3 class="fn" translate="no" id="errorOccurred"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QSslServer::<span class="name">errorOccurred</span>(<span class="type"><a href="qsslsocket.html" translate="no">QSslSocket</a></span> *<i>socket</i>, <span class="type"><a href="qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::SocketError</a></span> <i>socketError</i>)</h3>
<p>This signal is emitted after an error occurred during handshake. The <i translate="no">socketError</i> parameter describes the type of error that occurred.</p>
<p>The <i translate="no">socket</i> is automatically deleted after this signal is emitted if the socket handshake has not reached encrypted state. But if the <i translate="no">socket</i> is successfully encrypted, it is inserted into the <a href="qsslserver.html" translate="no">QSslServer</a>'s pending connections queue. When the user has called <a href="qtcpserver.html#nextPendingConnection" translate="no">QTcpServer::nextPendingConnection</a>() it is the user's responsibility to destroy the <i translate="no">socket</i> or the <i translate="no">socket</i> will not be destroyed until the <a href="qsslserver.html" translate="no">QSslServer</a> object is destroyed. If an error occurs on a <i translate="no">socket</i> after it has been inserted into the pending connections queue, this signal will not be emitted, and the <i translate="no">socket</i> will not be removed or destroyed.</p>
<div class="admonition note">
<p><b>Note: </b>You cannot use <a href="../qtcore/qt.html#ConnectionType-enum" translate="no">Qt::QueuedConnection</a> when connecting to this signal, or the <i translate="no">socket</i> will have been already destroyed when the signal is handled.</p>
</div>
<p><b>See also </b><a href="qabstractsocket.html#error" translate="no">QSslSocket::error</a>() and <a href="qtcpserver.html#errorString" translate="no">errorString</a>().</p>
<!-- @@@errorOccurred -->
<!-- $$$handshakeInterruptedOnError[overload1]$$$handshakeInterruptedOnErrorQSslSocket*constQSslError& -->
<h3 class="fn" translate="no" id="handshakeInterruptedOnError"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QSslServer::<span class="name">handshakeInterruptedOnError</span>(<span class="type"><a href="qsslsocket.html" translate="no">QSslSocket</a></span> *<i>socket</i>, const <span class="type"><a href="qsslerror.html" translate="no">QSslError</a></span> &amp;<i>error</i>)</h3>
<p><a href="qsslserver.html" translate="no">QSslServer</a> emits this signal if a certificate verification error was found by <i translate="no">socket</i> and if early error reporting was enabled in <a href="qsslconfiguration.html" translate="no">QSslConfiguration</a>. An application is expected to inspect the <i translate="no">error</i> and decide if it wants to continue the handshake, or abort it and send an alert message to the peer. The signal-slot connection must be direct.</p>
<p><b>See also </b><a href="qsslsocket.html#continueInterruptedHandshake" translate="no">QSslSocket::continueInterruptedHandshake</a>(), <a href="qsslserver.html#sslErrors" translate="no">sslErrors</a>(), and <a href="qsslconfiguration.html#setHandshakeMustInterruptOnError" translate="no">QSslConfiguration::setHandshakeMustInterruptOnError</a>().</p>
<!-- @@@handshakeInterruptedOnError -->
<!-- $$$handshakeTimeout[overload1]$$$handshakeTimeout -->
<h3 class="fn" translate="no" id="handshakeTimeout"><span class="type">int</span> QSslServer::<span class="name">handshakeTimeout</span>() const</h3>
<p>Returns the currently configured handshake timeout.</p>
<p><b>See also </b><a href="qsslserver.html#setHandshakeTimeout" translate="no">setHandshakeTimeout</a>().</p>
<!-- @@@handshakeTimeout -->
<!-- $$$incomingConnection[overload1]$$$incomingConnectionqintptr -->
<h3 class="fn" translate="no" id="incomingConnection"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QSslServer::<span class="name">incomingConnection</span>(<span class="type"><a href="../qtcore/qttypes.html#qintptr-typedef" translate="no">qintptr</a></span> <i>socket</i>)</h3>
<p>Reimplements: <a href="qtcpserver.html#incomingConnection" translate="no">QTcpServer::incomingConnection</a>(qintptr socketDescriptor).</p>
<p>Called when a new connection is established.</p>
<p>Converts <i translate="no">socket</i> to a <a href="qsslsocket.html" translate="no">QSslSocket</a>.</p>
<!-- @@@incomingConnection -->
<!-- $$$peerVerifyError[overload1]$$$peerVerifyErrorQSslSocket*constQSslError& -->
<h3 class="fn" translate="no" id="peerVerifyError"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QSslServer::<span class="name">peerVerifyError</span>(<span class="type"><a href="qsslsocket.html" translate="no">QSslSocket</a></span> *<i>socket</i>, const <span class="type"><a href="qsslerror.html" translate="no">QSslError</a></span> &amp;<i>error</i>)</h3>
<p><a href="qsslserver.html" translate="no">QSslServer</a> can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The <i translate="no">error</i> is usually an indication that <i translate="no">socket</i> is unable to securely identify the peer.</p>
<p>This signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, <a href="qsslserver.html" translate="no">QSslServer</a> will proceed to emitting <a href="qsslserver.html#sslErrors" translate="no">sslErrors</a>().</p>
<p><b>See also </b><a href="qsslserver.html#sslErrors" translate="no">sslErrors</a>().</p>
<!-- @@@peerVerifyError -->
<!-- $$$preSharedKeyAuthenticationRequired[overload1]$$$preSharedKeyAuthenticationRequiredQSslSocket*QSslPreSharedKeyAuthenticator* -->
<h3 class="fn" translate="no" id="preSharedKeyAuthenticationRequired"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QSslServer::<span class="name">preSharedKeyAuthenticationRequired</span>(<span class="type"><a href="qsslsocket.html" translate="no">QSslSocket</a></span> *<i>socket</i>, <span class="type"><a href="qsslpresharedkeyauthenticator.html" translate="no">QSslPreSharedKeyAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p><a href="qsslserver.html" translate="no">QSslServer</a> emits this signal when <i translate="no">socket</i> negotiates a PSK ciphersuite, and therefore PSK authentication is then required.</p>
<p>When using PSK, the server must supply a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <i translate="no">authenticator</i> object according to their needs.</p>
<div class="admonition note">
<p><b>Note: </b>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The <i translate="no">authenticator</i> object is owned by the <i translate="no">socket</i> and must not be deleted by the application.</p>
</div>
<p><b>See also </b><a href="qsslpresharedkeyauthenticator.html" translate="no">QSslPreSharedKeyAuthenticator</a>.</p>
<!-- @@@preSharedKeyAuthenticationRequired -->
<!-- $$$setHandshakeTimeout[overload1]$$$setHandshakeTimeoutint -->
<h3 class="fn" translate="no" id="setHandshakeTimeout"><span class="type">void</span> QSslServer::<span class="name">setHandshakeTimeout</span>(<span class="type">int</span> <i>timeout</i>)</h3>
<p>Sets the <i translate="no">timeout</i> to use for all incoming handshakes, in milliseconds.</p>
<p>This is relevant in the scenario where a client, whether malicious or accidental, connects to the server but makes no attempt at communicating or initiating a handshake. <a href="qsslserver.html" translate="no">QSslServer</a> will then automatically end the connection after <i translate="no">timeout</i> milliseconds have elapsed.</p>
<p>By default the timeout is 5000 milliseconds (5 seconds).</p>
<div class="admonition note">
<p><b>Note: </b>The underlying TLS framework may have their own timeout logic now or in the future, this function does not affect that.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The <i translate="no">timeout</i> passed to this function will only apply to <i>new</i> connections. If a client is already connected it will use the timeout which was set when it connected.</p>
</div>
<p><b>See also </b><a href="qsslserver.html#handshakeTimeout" translate="no">handshakeTimeout</a>().</p>
<!-- @@@setHandshakeTimeout -->
<!-- $$$setSslConfiguration[overload1]$$$setSslConfigurationconstQSslConfiguration& -->
<h3 class="fn" translate="no" id="setSslConfiguration"><span class="type">void</span> QSslServer::<span class="name">setSslConfiguration</span>(const <span class="type"><a href="qsslconfiguration.html" translate="no">QSslConfiguration</a></span> &amp;<i>sslConfiguration</i>)</h3>
<p>Sets the <i translate="no">sslConfiguration</i> to use for all following incoming connections.</p>
<p>This must be called before <a href="qtcpserver.html#listen" translate="no">listen</a>() to ensure that the desired configuration was in use during all handshakes.</p>
<p><b>See also </b><a href="qsslserver.html#sslConfiguration" translate="no">sslConfiguration</a>() and <a href="qsslsocket.html#setSslConfiguration" translate="no">QSslSocket::setSslConfiguration</a>().</p>
<!-- @@@setSslConfiguration -->
<!-- $$$sslConfiguration[overload1]$$$sslConfiguration -->
<h3 class="fn" translate="no" id="sslConfiguration"><span class="type"><a href="qsslconfiguration.html" translate="no">QSslConfiguration</a></span> QSslServer::<span class="name">sslConfiguration</span>() const</h3>
<p>Returns the current ssl configuration.</p>
<p><b>See also </b><a href="qsslserver.html#setSslConfiguration" translate="no">setSslConfiguration</a>().</p>
<!-- @@@sslConfiguration -->
<!-- $$$sslErrors[overload1]$$$sslErrorsQSslSocket*constQList<QSslError>& -->
<h3 class="fn" translate="no" id="sslErrors"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QSslServer::<span class="name">sslErrors</span>(<span class="type"><a href="qsslsocket.html" translate="no">QSslSocket</a></span> *<i>socket</i>, const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qsslerror.html" translate="no">QSslError</a></span>&gt; &amp;<i>errors</i>)</h3>
<p><a href="qsslserver.html" translate="no">QSslServer</a> emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that <i translate="no">socket</i> is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted.</p>
<p>If you want to continue connecting despite the errors that have occurred, you must call <a href="qsslsocket.html#ignoreSslErrors" translate="no">QSslSocket::ignoreSslErrors</a>() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslHandshakeErrors().</p>
<p><i translate="no">errors</i> contains one or more errors that prevent <a href="qsslsocket.html" translate="no">QSslSocket</a> from verifying the identity of the peer.</p>
<div class="admonition note">
<p><b>Note: </b>You cannot use <a href="../qtcore/qt.html#ConnectionType-enum" translate="no">Qt::QueuedConnection</a> when connecting to this signal, or calling <a href="qsslsocket.html#ignoreSslErrors" translate="no">QSslSocket::ignoreSslErrors</a>() will have no effect.</p>
</div>
<p><b>See also </b><a href="qsslserver.html#peerVerifyError" translate="no">peerVerifyError</a>().</p>
<!-- @@@sslErrors -->
<!-- $$$startedEncryptionHandshake[overload1]$$$startedEncryptionHandshakeQSslSocket* -->
<h3 class="fn" translate="no" id="startedEncryptionHandshake"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QSslServer::<span class="name">startedEncryptionHandshake</span>(<span class="type"><a href="qsslsocket.html" translate="no">QSslSocket</a></span> *<i>socket</i>)</h3>
<p>This signal is emitted when the client, connected to <i translate="no">socket</i>, initiates the TLS handshake.</p>
<!-- @@@startedEncryptionHandshake -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
