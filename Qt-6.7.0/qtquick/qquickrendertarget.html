<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquickrendertarget.cpp -->
  <meta name="description" content="The QQuickRenderTarget class provides an opaque container for native graphics resources specifying a render target, and associated metadata.">
  <title>QQuickRenderTarget Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QQuickRenderTarget</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QQuickRenderTarget Class</h1>
<!-- $$$QQuickRenderTarget-brief -->
<p>The QQuickRenderTarget class provides an opaque container for native graphics resources specifying a render target, and associated metadata. <a href="#details">More...</a></p>
<!-- @@@QQuickRenderTarget -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QQuickRenderTarget&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Quick) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr>
</table></div>
<ul>
<li><a href="qquickrendertarget-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#dtor.QQuickRenderTarget" translate="no">~QQuickRenderTarget</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#devicePixelRatio" translate="no">devicePixelRatio</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#isNull" translate="no">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#mirrorVertically" translate="no">mirrorVertically</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#setDevicePixelRatio" translate="no">setDevicePixelRatio</a></b>(qreal <i>ratio</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#setMirrorVertically" translate="no">setMirrorVertically</a></b>(bool <i>enable</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromD3D11Texture" translate="no">fromD3D11Texture</a></b>(void *<i>texture</i>, uint <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromD3D11Texture-1" translate="no">fromD3D11Texture</a></b>(void *<i>texture</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromD3D12Texture" translate="no">fromD3D12Texture</a></b>(void *<i>texture</i>, int <i>resourceState</i>, uint <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromMetalTexture" translate="no">fromMetalTexture</a></b>(MTLTexture *<i>texture</i>, uint <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromMetalTexture-1" translate="no">fromMetalTexture</a></b>(MTLTexture *<i>texture</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromOpenGLRenderBuffer" translate="no">fromOpenGLRenderBuffer</a></b>(uint <i>renderbufferId</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromOpenGLTexture" translate="no">fromOpenGLTexture</a></b>(uint <i>textureId</i>, uint <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromOpenGLTexture-1" translate="no">fromOpenGLTexture</a></b>(uint <i>textureId</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromPaintDevice" translate="no">fromPaintDevice</a></b>(QPaintDevice *<i>device</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromRhiRenderTarget" translate="no">fromRhiRenderTarget</a></b>(QRhiRenderTarget *<i>renderTarget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromVulkanImage" translate="no">fromVulkanImage</a></b>(VkImage <i>image</i>, VkImageLayout <i>layout</i>, VkFormat <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromVulkanImage-1" translate="no">fromVulkanImage</a></b>(VkImage <i>image</i>, VkImageLayout <i>layout</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#operator-not-eq" translate="no">operator!=</a></b>(const QQuickRenderTarget &amp;<i>a</i>, const QQuickRenderTarget &amp;<i>b</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#operator-eq-eq" translate="no">operator==</a></b>(const QQuickRenderTarget &amp;<i>a</i>, const QQuickRenderTarget &amp;<i>b</i>)</td></tr>
</table></div>
<!-- $$$QQuickRenderTarget-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickgraphicsdevice.html" translate="no">QQuickGraphicsDevice</a>.</p>
<!-- @@@QQuickRenderTarget -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickRenderTarget[overload1]$$$QQuickRenderTarget -->
<h3 class="fn" translate="no" id="QQuickRenderTarget">QQuickRenderTarget::<span class="name">QQuickRenderTarget</span>()</h3>
<p>Constructs a default QQuickRenderTarget that does not reference any native objects.</p>
<!-- @@@QQuickRenderTarget -->
<!-- $$$~QQuickRenderTarget[overload1]$$$~QQuickRenderTarget -->
<h3 class="fn" translate="no" id="dtor.QQuickRenderTarget"><code class="details extra" translate="no">[noexcept]</code> QQuickRenderTarget::<span class="name">~QQuickRenderTarget</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QQuickRenderTarget -->
<!-- $$$devicePixelRatio[overload1]$$$devicePixelRatio -->
<h3 class="fn" translate="no" id="devicePixelRatio"><code class="details extra" translate="no">[since 6.3]</code> <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> QQuickRenderTarget::<span class="name">devicePixelRatio</span>() const</h3>
<p>Returns the device pixel ratio for the render target. This is the ratio between <i>device pixels</i> and <i>device independent pixels</i>.</p>
<p>The default device pixel ratio is 1.0.</p>
<p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qquickrendertarget.html#setDevicePixelRatio" translate="no">setDevicePixelRatio</a>().</p>
<!-- @@@devicePixelRatio -->
<!-- $$$fromD3D11Texture[overload1]$$$fromD3D11Texturevoid*uintconstQSize&int -->
<h3 class="fn" translate="no" id="fromD3D11Texture"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromD3D11Texture</span>(<span class="type">void</span> *<i>texture</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a D3D11 texture object specified by <i translate="no">texture</i>.</p>
<p><i translate="no">format</i> specifies the DXGI_FORMAT of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromD3D11Texture -->
<!-- $$$fromD3D11Texture$$$fromD3D11Texturevoid*constQSize&int -->
<h3 class="fn" translate="no" id="fromD3D11Texture-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromD3D11Texture</span>(<span class="type">void</span> *<i>texture</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a D3D11 texture object specified by <i translate="no">texture</i>. The texture is assumed to have a format of DXGI_FORMAT_R8G8B8A8_UNORM.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromD3D11Texture -->
<!-- $$$fromD3D12Texture[overload1]$$$fromD3D12Texturevoid*intuintconstQSize&int -->
<h3 class="fn" translate="no" id="fromD3D12Texture"><code class="details extra" translate="no">[static, since 6.6]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromD3D12Texture</span>(<span class="type">void</span> *<i>texture</i>, <span class="type">int</span> <i>resourceState</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a D3D12 texture object specified by <i translate="no">texture</i>.</p>
<p><i translate="no">resourceState</i> must a valid bitmask with bits from D3D12_RESOURCE_STATES, specifying the resource's current state.</p>
<p><i translate="no">format</i> specifies the DXGI_FORMAT of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromD3D12Texture -->
<!-- $$$fromMetalTexture[overload1]$$$fromMetalTextureMTLTexture*uintconstQSize&int -->
<h3 class="fn" translate="no" id="fromMetalTexture"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromMetalTexture</span>(<span class="type">MTLTexture</span> *<i>texture</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Metal texture object specified by <i translate="no">texture</i>.</p>
<p><i translate="no">format</i> specifies the MTLPixelFormat of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromMetalTexture -->
<!-- $$$fromMetalTexture$$$fromMetalTextureMTLTexture*constQSize&int -->
<h3 class="fn" translate="no" id="fromMetalTexture-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromMetalTexture</span>(<span class="type">MTLTexture</span> *<i>texture</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Metal texture object specified by <i translate="no">texture</i>. The texture is assumed to have a format of MTLPixelFormatRGBA8Unorm.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromMetalTexture -->
<!-- $$$fromOpenGLRenderBuffer[overload1]$$$fromOpenGLRenderBufferuintconstQSize&int -->
<h3 class="fn" translate="no" id="fromOpenGLRenderBuffer"><code class="details extra" translate="no">[static, since 6.2]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromOpenGLRenderBuffer</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>renderbufferId</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing an OpenGL renderbuffer object specified by <i translate="no">renderbufferId</i>.</p>
<p>The renderbuffer will be used as the color attachment for the internal framebuffer object. This function is provided to allow targeting renderbuffers that are created by the application with some external buffer underneath, such as an EGLImageKHR. Once the application has called <a href="https://www.khronos.org/registry/OpenGL/extensions/OES/OES_EGL_image.txt" translate="no">glEGLImageTargetRenderbufferStorageOES</a>, the renderbuffer can be passed to this function.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample renderbuffer.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromOpenGLRenderBuffer -->
<!-- $$$fromOpenGLTexture[overload1]$$$fromOpenGLTextureuintuintconstQSize&int -->
<h3 class="fn" translate="no" id="fromOpenGLTexture"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromOpenGLTexture</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>textureId</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing an OpenGL texture object specified by <i translate="no">textureId</i>.</p>
<p><i translate="no">format</i> specifies the native internal format of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<p>The OpenGL object name <i translate="no">textureId</i> must be a valid name in the rendering context used by the Qt Quick scenegraph.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromOpenGLTexture -->
<!-- $$$fromOpenGLTexture$$$fromOpenGLTextureuintconstQSize&int -->
<h3 class="fn" translate="no" id="fromOpenGLTexture-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromOpenGLTexture</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>textureId</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing an OpenGL texture object specified by <i translate="no">textureId</i>. The texture is assumed to have a format of GL_RGBA (GL_RGBA8).</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<p>The OpenGL object name <i translate="no">textureId</i> must be a valid name in the rendering context used by the Qt Quick scenegraph.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromOpenGLTexture -->
<!-- $$$fromPaintDevice[overload1]$$$fromPaintDeviceQPaintDevice* -->
<h3 class="fn" translate="no" id="fromPaintDevice"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromPaintDevice</span>(<span class="type"><a href="../qtgui/qpaintdevice.html" translate="no">QPaintDevice</a></span> *<i>device</i>)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a paint device object specified by <i translate="no">device</i>.</p>
<p>This option of redirecting rendering to a <a href="../qtgui/qpaintdevice.html" translate="no">QPaintDevice</a> is available only when running with the <code translate="no">software</code> backend of Qt Quick.</p>
<div class="admonition note">
<p><b>Note: </b>The <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not take ownship of <i translate="no">device</i>, it is the caller's responsibility to ensure the object exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromPaintDevice -->
<!-- $$$fromRhiRenderTarget[overload1]$$$fromRhiRenderTargetQRhiRenderTarget* -->
<h3 class="fn" translate="no" id="fromRhiRenderTarget"><code class="details extra" translate="no">[static, since 6.6]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromRhiRenderTarget</span>(<span class="type"><a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a></span> *<i>renderTarget</i>)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing an existing <i translate="no">renderTarget</i>.</p>
<p><i translate="no">renderTarget</i> will in most cases be a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>, which allows directing the Qt Quick scene's rendering into a <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own <i translate="no">renderTarget</i> and any underlying native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the referenced resources exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromRhiRenderTarget -->
<!-- $$$fromVulkanImage[overload1]$$$fromVulkanImageVkImageVkImageLayoutVkFormatconstQSize&int -->
<h3 class="fn" translate="no" id="fromVulkanImage"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromVulkanImage</span>(<span class="type">VkImage</span> <i>image</i>, <span class="type">VkImageLayout</span> <i>layout</i>, <span class="type">VkFormat</span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Vulkan image object specified by <i translate="no">image</i>. The current <i translate="no">layout</i> of the image must be provided as well.</p>
<p><i translate="no">format</i> specifies the VkFormat of the image. Only image formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The image is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromVulkanImage -->
<!-- $$$fromVulkanImage$$$fromVulkanImageVkImageVkImageLayoutconstQSize&int -->
<h3 class="fn" translate="no" id="fromVulkanImage-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromVulkanImage</span>(<span class="type">VkImage</span> <i>image</i>, <span class="type">VkImageLayout</span> <i>layout</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Vulkan image object specified by <i translate="no">image</i>. The image is assumed to have a format of VK_FORMAT_R8G8B8A8_UNORM.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specific the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromVulkanImage -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" translate="no" id="isNull"><span class="type">bool</span> QQuickRenderTarget::<span class="name">isNull</span>() const</h3>
<p>Returns true if this <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> is default constructed, referencing no native objects.</p>
<!-- @@@isNull -->
<!-- $$$mirrorVertically[overload1]$$$mirrorVertically -->
<h3 class="fn" translate="no" id="mirrorVertically"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">bool</span> QQuickRenderTarget::<span class="name">mirrorVertically</span>() const</h3>
<p>Returns Returns whether the render target is mirrored vertically.</p>
<p>The default value is <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickrendertarget.html#setMirrorVertically" translate="no">setMirrorVertically</a>().</p>
<!-- @@@mirrorVertically -->
<!-- $$$setDevicePixelRatio[overload1]$$$setDevicePixelRatioqreal -->
<h3 class="fn" translate="no" id="setDevicePixelRatio"><code class="details extra" translate="no">[since 6.3]</code> <span class="type">void</span> QQuickRenderTarget::<span class="name">setDevicePixelRatio</span>(<span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> <i>ratio</i>)</h3>
<p>Sets the device pixel ratio for this render target to <i translate="no">ratio</i>. This is the ratio between <i>device pixels</i> and <i>device independent pixels</i>.</p>
<p>Note that the specified device pixel ratio value will be ignored if <a href="qquickrendercontrol.html#renderWindow" translate="no">QQuickRenderControl::renderWindow</a>() is re-implemented to return a valid <a href="../qtgui/qwindow.html" translate="no">QWindow</a>.</p>
<p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qquickrendertarget.html#devicePixelRatio" translate="no">devicePixelRatio</a>().</p>
<!-- @@@setDevicePixelRatio -->
<!-- $$$setMirrorVertically[overload1]$$$setMirrorVerticallybool -->
<h3 class="fn" translate="no" id="setMirrorVertically"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">void</span> QQuickRenderTarget::<span class="name">setMirrorVertically</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Sets the size of the render target contents should be mirrored vertically to <i translate="no">enable</i> when drawing. This allows easy integration of third-party rendering code that does not follow the standard expectations.</p>
<div class="admonition note">
<p><b>Note: </b>This function should not be used when using the <code translate="no">software</code> backend.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickrendertarget.html#mirrorVertically" translate="no">mirrorVertically</a>().</p>
<!-- @@@setMirrorVertically -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$operator!=[overload1]$$$operator!=constQQuickRenderTarget&constQQuickRenderTarget& -->
<h3 class="fn" translate="no" id="operator-not-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> &amp;<i>a</i>, const <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> &amp;<i>b</i>)</h3>
<p>Returns true if <i translate="no">a</i> and <i translate="no">b</i> refer to a different set of native objects, or the associated data (size, sample count) does not match.</p>
<!-- @@@operator!= -->
<!-- $$$operator==[overload1]$$$operator==constQQuickRenderTarget&constQQuickRenderTarget& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> &amp;<i>a</i>, const <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> &amp;<i>b</i>)</h3>
<p>Returns true if <i translate="no">a</i> and <i translate="no">b</i> refer to the same set of native objects and have matching associated data (size, sample count).</p>
<!-- @@@operator== -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
