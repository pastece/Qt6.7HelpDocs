<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquickrhiitem.cpp -->
  <meta name="description" content="A QQuickRhiItemRenderer implements the rendering logic of a QQuickRhiItem.">
  <title>QQuickRhiItemRenderer Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QQuickRhiItemRenderer</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QQuickRhiItemRenderer Class</h1>
<!-- $$$QQuickRhiItemRenderer-brief -->
<p>A QQuickRhiItemRenderer implements the rendering logic of a <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a>. <a href="#details">More...</a></p>
<!-- @@@QQuickRhiItemRenderer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QQuickRhiItemRenderer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Quick) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.7</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Status:</td><td class="memItemRight bottomAlign"> Preliminary<span class="status preliminary"></span></td></tr>
</table></div>
<p><b>This class is under development and is subject to change.</b></p>
<ul>
<li><a href="qquickrhiitemrenderer-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#QQuickRhiItemRenderer" translate="no">QQuickRhiItemRenderer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#dtor.QQuickRhiItemRenderer" translate="no">~QQuickRhiItemRenderer</a></b>()</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#depthStencilBuffer" translate="no">depthStencilBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a></b>(QRhiCommandBuffer *<i>cb</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#msaaColorBuffer" translate="no">msaaColorBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#render" translate="no">render</a></b>(QRhiCommandBuffer *<i>cb</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiRenderTarget *</td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#resolveTexture" translate="no">resolveTexture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhi *</td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#rhi" translate="no">rhi</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#synchronize" translate="no">synchronize</a></b>(QQuickRhiItem *<i>item</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitemrenderer.html#update" translate="no">update</a></b>()</td></tr>
</table></div>
<!-- $$$QQuickRhiItemRenderer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<div class="admonition note">
<p><b>Note: </b><a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> and QQuickRhiItemRenderer are in tech preview in Qt 6.7. <b>The API is under development and subject to change.</b></p>
</div>
</div>
<p><b>See also </b><a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> and <a href="../qtgui/qrhi.html" translate="no">QRhi</a>.</p>
<!-- @@@QQuickRhiItemRenderer -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickRhiItemRenderer[overload1]$$$QQuickRhiItemRenderer -->
<h3 class="fn" translate="no" id="QQuickRhiItemRenderer">QQuickRhiItemRenderer::<span class="name">QQuickRhiItemRenderer</span>()</h3>
<p>Constructs a new renderer.</p>
<p>This function is called on the rendering thread during the scene graph sync phase when the GUI thread is blocked.</p>
<p><b>See also </b><a href="qquickrhiitem.html#createRenderer" translate="no">QQuickRhiItem::createRenderer</a>().</p>
<!-- @@@QQuickRhiItemRenderer -->
<!-- $$$~QQuickRhiItemRenderer[overload1]$$$~QQuickRhiItemRenderer -->
<h3 class="fn" translate="no" id="dtor.QQuickRhiItemRenderer"><code class="details extra" translate="no">[virtual noexcept]</code> QQuickRhiItemRenderer::<span class="name">~QQuickRhiItemRenderer</span>()</h3>
<p>The Renderer is automatically deleted when the scene graph resources for the <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> item are cleaned up.</p>
<p>This function is called on the rendering thread.</p>
<p>Under certain conditions it is normal and expected that the renderer object is destroyed and then recreated. This is because the renderer's lifetime effectively follows the underlying scene graph node. For example, when changing the parent of a <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> object so that it then belongs to a different <a href="qquickwindow.html" translate="no">QQuickWindow</a>, the scene graph nodes are all dropped and recreated due to the window change. This will also involve dropping and creating a new <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a>.</p>
<p>Unlike <a href="../qtwidgets/qrhiwidget.html" translate="no">QRhiWidget</a>, <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a> has no need to implement additional code paths for releasing (or early-relasing) graphics resources created via <a href="../qtgui/qrhi.html" translate="no">QRhi</a>. It is sufficient to release everything in the destructor, or rely on smart pointers.</p>
<!-- @@@~QQuickRhiItemRenderer -->
<!-- $$$colorTexture[overload1]$$$colorTexture -->
<h3 class="fn" translate="no" id="colorTexture"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a></span> *QQuickRhiItemRenderer::<span class="name">colorTexture</span>() const</h3>
<p>Returns the texture serving as the color buffer for the item.</p>
<p>Must only be called from <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() and <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<p>Unlike the depth-stencil buffer and the <a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a>, this texture is always available and is managed by the <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a>, independent of the value of autoRenderTarget.</p>
<div class="admonition note">
<p><b>Note: </b>When <a href="qquickrhiitem.html#sampleCount-prop" translate="no">sampleCount</a> is larger than 1, and so multisample antialiasing is enabled, the return value is <code translate="no">nullptr</code>. Instead, query the <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> by calling <a href="qquickrhiitemrenderer.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The backing texture size and sample count can also be queried via the <a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a> returned from <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a>(). This can be more convenient and compact than querying from the <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a> or <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>, because it works regardless of multisampling is in use or not.</p>
</div>
<p><b>See also </b><a href="qquickrhiitemrenderer.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>(), <a href="qquickrhiitemrenderer.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>(), <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a>(), and <a href="qquickrhiitemrenderer.html#resolveTexture" translate="no">resolveTexture</a>().</p>
<!-- @@@colorTexture -->
<!-- $$$depthStencilBuffer[overload1]$$$depthStencilBuffer -->
<h3 class="fn" translate="no" id="depthStencilBuffer"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *QQuickRhiItemRenderer::<span class="name">depthStencilBuffer</span>() const</h3>
<p>Returns the depth-stencil buffer used by the item's rendering.</p>
<p>Must only be called from <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() and <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<p>Available only when autoRenderTarget is <code translate="no">true</code>. Otherwise the returned value is <code translate="no">nullptr</code> and it is up the reimplementation of <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() to create and manage a depth-stencil buffer and a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>.</p>
<p><b>See also </b><a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a>() and <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a>().</p>
<!-- @@@depthStencilBuffer -->
<!-- $$$initialize[overload1]$$$initializeQRhiCommandBuffer* -->
<h3 class="fn" translate="no" id="initialize"><code class="details extra" translate="no">[pure virtual protected]</code> <span class="type">void</span> QQuickRhiItemRenderer::<span class="name">initialize</span>(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> *<i>cb</i>)</h3>
<p>Called when the item is initialized for the first time, when the associated texture's size, format, or sample count changes, or when the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> or texture change for any reason. The function is expected to maintain (create if not yet created, adjust and rebuild if the size has changed) the graphics resources used by the rendering code in <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<p>To query the <a href="../qtgui/qrhi.html" translate="no">QRhi</a>, <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>, and other related objects, call <a href="qquickrhiitemrenderer.html#rhi" translate="no">rhi</a>(), <a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a>(), <a href="qquickrhiitemrenderer.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>(), and <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a>().</p>
<p>When the item size changes, the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> object, the color buffer texture, and the depth stencil buffer objects are all the same instances (so the getters return the same pointers) as before, but the color and depth/stencil buffers will likely have been rebuilt, meaning the <a href="../qtgui/qrhitexture.html#pixelSize" translate="no">size</a> and the underlying native texture resource may be different than in the last invocation.</p>
<p>Reimplementations should also be prepared that the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> object and the color buffer texture may change between invocations of this function. For example, when the item is reparented so that it belongs to a new <a href="qquickwindow.html" translate="no">QQuickWindow</a>, the the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> and all related resources managed by the <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> will be different instances than before in the subsequent call to this function. Is is then important that all existing <a href="../qtgui/qrhi.html" translate="no">QRhi</a> resources previously created by the subclass are destroyed because they belong to the previous <a href="../qtgui/qrhi.html" translate="no">QRhi</a> that should not be used anymore.</p>
<p>When autoRenderTarget is <code translate="no">true</code>, which is the default, a depth-stencil <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> and a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> associated with the <a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a>() (or <a href="qquickrhiitemrenderer.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>()) and the depth-stencil buffer are created and managed automatically. Reimplementations of initialize() and <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>() can query those objects via <a href="qquickrhiitemrenderer.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>() and <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a>(). When autoRenderTarget is set to <code translate="no">false</code>, these objects are no longer created and managed automatically. Rather, it will be up the the initialize() implementation to create buffers and set up the render target as it sees fit. When manually managing additional color or depth-stencil attachments for the render target, their size and sample count must always follow the size and sample count of <a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a>() (or <a href="qquickrhiitemrenderer.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>()), otherwise rendering or 3D API validation errors may occur.</p>
<p>The subclass-created graphics resources are expected to be released in the destructor implementation of the subclass.</p>
<p><i translate="no">cb</i> is the <a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> for the current frame. The function is called with a frame being recorded, but without an active render pass. The command buffer is provided primarily to allow enqueuing <a href="../qtgui/qrhicommandbuffer.html#resourceUpdate" translate="no">resource updates</a> without deferring to <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<p>This function is called on the render thread, if there is one.</p>
<p><b>See also </b><a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<!-- @@@initialize -->
<!-- $$$msaaColorBuffer[overload1]$$$msaaColorBuffer -->
<h3 class="fn" translate="no" id="msaaColorBuffer"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a></span> *QQuickRhiItemRenderer::<span class="name">msaaColorBuffer</span>() const</h3>
<p>Returns the renderbuffer serving as the multisample color buffer for the item.</p>
<p>Must only be called from <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() and <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<p>When <a href="qquickrhiitem.html#sampleCount-prop" translate="no">sampleCount</a> is larger than 1, and so multisample antialising is enabled, the returned <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> has a matching sample count and serves as the color buffer. Graphics pipelines used to render into this buffer must be created with the same sample count, and the depth-stencil buffer's sample count must match as well. The multisample content is expected to be resolved into the texture returned from <a href="qquickrhiitemrenderer.html#resolveTexture" translate="no">resolveTexture</a>(). When autoRenderTarget is <code translate="no">true</code>, <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a>() is set up automatically to do this, by setting up msaaColorBuffer() as the <a href="../qtgui/qrhicolorattachment.html#renderBuffer" translate="no">renderbuffer</a> of color attachment 0 and <a href="qquickrhiitemrenderer.html#resolveTexture" translate="no">resolveTexture</a>() as its <a href="../qtgui/qrhicolorattachment.html#resolveTexture" translate="no">resolveTexture</a>.</p>
<p>When MSAA is not in use, the return value is <code translate="no">nullptr</code>. Use <a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a>() instead then.</p>
<p>Depending on the underlying 3D graphics API, there may be no practical difference between multisample textures and color renderbuffers with a sample count larger than 1 (<a href="../qtgui/qrhi.html" translate="no">QRhi</a> may just map both to the same native resource type). Some older APIs however may differentiate between textures and renderbuffers. In order to support OpenGL ES 3.0, where multisample renderbuffers are available, but multisample textures are not, <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> always performs MSAA by using a multisample <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> as the color attachment (and never a multisample <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>).</p>
<div class="admonition note">
<p><b>Note: </b>The backing texture size and sample count can also be queried via the <a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a> returned from <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a>(). This can be more convenient and compact than querying from the <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a> or <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>, because it works regardless of multisampling is in use or not.</p>
</div>
<p><b>See also </b><a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a>(), <a href="qquickrhiitemrenderer.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>(), <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a>(), and <a href="qquickrhiitemrenderer.html#resolveTexture" translate="no">resolveTexture</a>().</p>
<!-- @@@msaaColorBuffer -->
<!-- $$$render[overload1]$$$renderQRhiCommandBuffer* -->
<h3 class="fn" translate="no" id="render"><code class="details extra" translate="no">[pure virtual protected]</code> <span class="type">void</span> QQuickRhiItemRenderer::<span class="name">render</span>(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> *<i>cb</i>)</h3>
<p>Called when the backing color buffer's contents needs updating.</p>
<p>There is always at least one call to <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() before this function is called.</p>
<p>To request updates, call <a href="qquickitem.html#update" translate="no">QQuickItem::update</a>() when calling from QML or from C++ code on the main/GUI thread (e.g. when in a property setter), or <a href="qquickrhiitemrenderer.html#update" translate="no">update</a>() when calling from within a <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a> callback. Calling <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a>'s <a href="qquickrhiitemrenderer.html#update" translate="no">update</a>() from within render() will lead to triggering updates continuously.</p>
<p><i translate="no">cb</i> is the <a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> for the current frame. The function is called with a frame being recorded, but without an active render pass.</p>
<p>This function is called on the render thread, if there is one.</p>
<p><b>See also </b><a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() and <a href="qquickrhiitemrenderer.html#synchronize" translate="no">synchronize</a>().</p>
<!-- @@@render -->
<!-- $$$renderTarget[overload1]$$$renderTarget -->
<h3 class="fn" translate="no" id="renderTarget"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a></span> *QQuickRhiItemRenderer::<span class="name">renderTarget</span>() const</h3>
<p>Returns the render target object that must be used with <a href="../qtgui/qrhicommandbuffer.html#beginPass" translate="no">QRhiCommandBuffer::beginPass</a>() in reimplementations of <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<p>Must only be called from <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() and <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<p>Available only when autoRenderTarget is <code translate="no">true</code>. Otherwise the returned value is <code translate="no">nullptr</code> and it is up the reimplementation of <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() to create and manage a depth-stencil buffer and a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>.</p>
<p>When creating <a href="../qtgui/qrhigraphicspipeline.html" translate="no">graphics pipelines</a>, a <a href="../qtgui/qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> is needed. This can be queried from the returned <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> by calling <a href="../qtgui/qrhirendertarget.html#renderPassDescriptor" translate="no">renderPassDescriptor</a>().</p>
<div class="admonition note">
<p><b>Note: </b>The returned <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> always reports a <a href="../qtgui/qrhirendertarget.html#devicePixelRatio" translate="no">devicePixelRatio</a>() of <code translate="no">1</code>. This is because only swapchains and the associated window have a concept of device pixel ratio, not textures, and the render target here always refers to a texture. If the on-screen scale factor is relevant for rendering, query and store it via the item's <code translate="no">window()-&gt;effectiveDevicePixelRatio()</code> in <a href="qquickrhiitemrenderer.html#synchronize" translate="no">synchronize</a>(). When doing so, always prefer using <a href="qquickwindow.html#effectiveDevicePixelRatio" translate="no">effectiveDevicePixelRatio</a>() over the base class' <a href="../qtgui/qwindow.html#devicePixelRatio" translate="no">devicePixelRatio</a>().</p>
</div>
<p><b>See also </b><a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a>(), <a href="qquickrhiitemrenderer.html#depthStencilBuffer" translate="no">depthStencilBuffer</a>(), and <a href="qquickwindow.html#effectiveDevicePixelRatio" translate="no">QQuickWindow::effectiveDevicePixelRatio</a>().</p>
<!-- @@@renderTarget -->
<!-- $$$resolveTexture[overload1]$$$resolveTexture -->
<h3 class="fn" translate="no" id="resolveTexture"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a></span> *QQuickRhiItemRenderer::<span class="name">resolveTexture</span>() const</h3>
<p>Returns the non-multisample texture to which the multisample content is resolved.</p>
<p>The result is <code translate="no">nullptr</code> when multisample antialiasing is not enabled.</p>
<p>Must only be called from <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() and <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<p>With MSAA enabled, this is the texture that gets used by the item's underlying scene graph node when texturing a quad in the main render pass of Qt Quick. However, the <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a>'s rendering must target the (multisample) <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> returned from <a href="qquickrhiitemrenderer.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>(). When autoRenderTarget is <code translate="no">true</code>, this is taken care of by the <a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a> returned from <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">renderTarget</a>(). Otherwise, it is up to the subclass code to correctly configure a render target object with both the color buffer and resolve textures.</p>
<p><b>See also </b><a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a>().</p>
<!-- @@@resolveTexture -->
<!-- $$$rhi[overload1]$$$rhi -->
<h3 class="fn" translate="no" id="rhi"><code class="details extra" translate="no">[protected]</code> <span class="type"><a href="../qtgui/qrhi.html" translate="no">QRhi</a></span> *QQuickRhiItemRenderer::<span class="name">rhi</span>() const</h3>
<p>Returns the current <a href="../qtgui/qrhi.html" translate="no">QRhi</a> object.</p>
<p>Must only be called from <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() and <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<!-- @@@rhi -->
<!-- $$$synchronize[overload1]$$$synchronizeQQuickRhiItem* -->
<h3 class="fn" translate="no" id="synchronize"><code class="details extra" translate="no">[pure virtual protected]</code> <span class="type">void</span> QQuickRhiItemRenderer::<span class="name">synchronize</span>(<span class="type"><a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a></span> *<i>item</i>)</h3>
<p>This function is called on the render thread, if there is one, while the main/GUI thread is blocked. It is called from <a href="qquickitem.html#updatePaintNode" translate="no">the <i translate="no">item</i>'s synchronize step</a>, and allows reading and writing data belonging to the main and render threads. Typically property values stored in the <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> are copied into the <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a>, so that they can be safely read afterwards in <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>() when the render and main threads continue to work in parallel.</p>
<p><b>See also </b><a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() and <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>().</p>
<!-- @@@synchronize -->
<!-- $$$update[overload1]$$$update -->
<h3 class="fn" translate="no" id="update"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QQuickRhiItemRenderer::<span class="name">update</span>()</h3>
<p>Call this function when the content of the offscreen color buffer should be updated. (i.e. to request that <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>() is called again; the call will happen at a later point, and note that updates are typically throttled to the presentation rate)</p>
<p>This function can be called from <a href="qquickrhiitemrenderer.html#render" translate="no">render</a>() to schedule an update.</p>
<div class="admonition note">
<p><b>Note: </b>This function should be used from inside the renderer. To update the item on the GUI thread, use <a href="qquickitem.html#update" translate="no">QQuickRhiItem::update</a>().</p>
</div>
<!-- @@@update -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
