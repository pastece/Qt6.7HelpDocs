<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qsgmaterialshader.cpp -->
  <meta name="description" content="The QSGMaterialShader class represents a graphics API independent shader program.">
  <title>QSGMaterialShader Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QSGMaterialShader</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QSGMaterialShader Class</h1>
<!-- $$$QSGMaterialShader-brief -->
<p>The QSGMaterialShader class represents a graphics API independent shader program. <a href="#details">More...</a></p>
<!-- @@@QSGMaterialShader -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QSGMaterialShader&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Quick) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr>
</table></div>
<ul>
<li><a href="qsgmaterialshader-members.html">List of all members, including inherited members</a></li>
<li>QSGMaterialShader is part of <a href="qtquick-scenegraph-materials.html">Qt Quick Scene Graph Material Classes</a>.</li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader-graphicspipelinestate.html" translate="no">GraphicsPipelineState</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader-renderstate.html" translate="no">RenderState</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#Flag-enum" translate="no">Flag</a></b> { UpdatesGraphicsPipelineState }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#Flag-enum" translate="no">Flags</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#QSGMaterialShader" translate="no">QSGMaterialShader</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> int </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#combinedImageSamplerCount" translate="no">combinedImageSamplerCount</a></b>(int <i>binding</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGMaterialShader::Flags </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#setFlag" translate="no">setFlag</a></b>(QSGMaterialShader::Flags <i>flags</i>, bool <i>on</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#setFlags" translate="no">setFlags</a></b>(QSGMaterialShader::Flags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#updateGraphicsPipelineState" translate="no">updateGraphicsPipelineState</a></b>(QSGMaterialShader::RenderState &amp;<i>state</i>, QSGMaterialShader::GraphicsPipelineState *<i>ps</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#updateSampledImage" translate="no">updateSampledImage</a></b>(QSGMaterialShader::RenderState &amp;<i>state</i>, int <i>binding</i>, QSGTexture **<i>texture</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#updateUniformData" translate="no">updateUniformData</a></b>(QSGMaterialShader::RenderState &amp;<i>state</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#setShader" translate="no">setShader</a></b>(QSGMaterialShader::Stage <i>stage</i>, const QShader &amp;<i>shader</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#setShaderFileName" translate="no">setShaderFileName</a></b>(QSGMaterialShader::Stage <i>stage</i>, const QString &amp;<i>filename</i>)</td></tr>
</table></div>
<!-- $$$QSGMaterialShader-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QSGMaterialShader represents a combination of vertex and fragment shaders, data that define the graphics pipeline state changes, and logic that updates graphics resources, such as uniform buffers and textures.</p>
<div class="admonition note">
<p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a> for more information.</p>
</div>
<p>The <a href="qsgmaterial.html" translate="no">QSGMaterial</a> and QSGMaterialShader form a tight relationship. For one scene graph (including nested graphs), there is one unique QSGMaterialShader instance that encapsulates the shaders and other data the scene graph uses to render an object with that material. Each <a href="qsggeometrynode.html" translate="no">QSGGeometryNode</a> can have a unique <a href="qsgmaterial.html" translate="no">QSGMaterial</a> that defines how the graphics pipeline must be configured while drawing the node. An instance of QSGMaterialShader is never created explicitly by the user, it will be created on demand by the scene graph through <a href="qsgmaterial.html#createShader" translate="no">QSGMaterial::createShader</a>(). The scene graph creates an instance of QSGMaterialShader by calling the <a href="qsgmaterial.html#createShader" translate="no">QSGMaterial::createShader</a>() method, ensuring that there is only one instance of each shader implementation.</p>
<p>In Qt 5, QSGMaterialShader was tied to OpenGL. It was built directly on <a href="../qtopengl/qopenglshaderprogram.html" translate="no">QOpenGLShaderProgram</a> and had functions like <code translate="no">updateState()</code> that could issue arbitrary OpenGL commands. This is no longer the case in Qt 6. QSGMaterialShader is not strictly data-oriented, meaning it provides data (shaders and the desired pipeline state changes) together with logic that updates data in a uniform buffer. Graphics API access is not provided. This means that a QSGMaterialShader cannot make OpenGL, Vulkan, Metal, or Direct 3D calls on its own. Together with the unified shader management, this allows a QSGMaterialShader to be written once, and be functional with any of the supported graphics APIs at run time.</p>
<p>The shaders set by calling the protected <a href="qsgmaterialshader.html#setShaderFileName" translate="no">setShaderFileName</a>() function control what material does with the vertex data from the geometry, and how the fragments are shaded. A QSGMaterialShader will typically set a vertex and a fragment shader during construction. Changing the shaders afterwards may not lead to the desired effect and must be avoided.</p>
<p>In Qt 6, the default approach is to ship <code translate="no">.qsb</code> files with the application, typically embedded via the resource system, and referenced when calling <a href="qsgmaterialshader.html#setShaderFileName" translate="no">setShaderFileName</a>(). The <code translate="no">.qsb</code> files are generated offline, or at latest at application build time, from Vulkan-style GLSL source code using the <code translate="no">qsb</code> tool from the Qt Shader Tools module.</p>
<p>There are three virtuals that can be overridden. These provide the data, or the logic to generate the data, for uniform buffers, textures, and pipeline state changes.</p>
<p><a href="qsgmaterialshader.html#updateUniformData" translate="no">updateUniformData</a>() is the function that is most commonly reimplemented in subclasses. This function is expected to update the contents of a <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a> that will then be exposed to the shaders as a uniform buffer. Any QSGMaterialShader that has a uniform block in its vertex or fragment shader must reimplement <a href="qsgmaterialshader.html#updateUniformData" translate="no">updateUniformData</a>().</p>
<p><a href="qsgmaterialshader.html#updateSampledImage" translate="no">updateSampledImage</a>() is relevant when the shader code samples textures. The function will be invoked for each sampler (or combined image sampler, in APIs where relevant), giving it the option to specify which <a href="qsgtexture.html" translate="no">QSGTexture</a> should be exposed to the shader.</p>
<p>The shader pipeline state changes are less often used. One use case is materials that wish to use a specific blend mode. The relevant function is <a href="qsgmaterialshader.html#updateGraphicsPipelineState" translate="no">updateGraphicsPipelineState</a>(). This function is not called unless the QSGMaterialShader has opted in by setting the flag <a href="qsgmaterialshader.html#Flag-enum" translate="no">UpdatesGraphicsPipelineState</a>. The task of the function is to update the <a href="qsgmaterialshader-graphicspipelinestate.html" translate="no">GraphicsPipelineState</a> struct instance that is passed to it with the desired changes. Currently only blending and culling-related features are available, other states cannot be controlled by materials.</p>
<p>A minimal example, that also includes texture support, could be the following. Here we assume that Material is the <a href="qsgmaterial.html" translate="no">QSGMaterial</a> that creates an instance of Shader in its <a href="qsgmaterial.html#createShader" translate="no">createShader</a>(), and that it holds a <a href="qsgtexture.html" translate="no">QSGTexture</a> we want to sample in the fragment shader. The vertex shader relies only on the modelview-projection matrix.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Shader : <span class="keyword">public</span> <span class="type"><a href="qsgmaterialshader.html#QSGMaterialShader" translate="no">QSGMaterialShader</a></span>
 {
 <span class="keyword">public</span>:
     Shader()
     {
         setShaderFileName(VertexStage<span class="operator">,</span> QLatin1String(<span class="string">&quot;:/materialshader.vert.qsb&quot;</span>));
         setShaderFileName(FragmentStage<span class="operator">,</span> QLatin1String(<span class="string">&quot;:/materialshader.frag.qsb&quot;</span>));
     }

     <span class="type">bool</span> updateUniformData(RenderState <span class="operator">&amp;</span>state<span class="operator">,</span> <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> <span class="operator">*</span><span class="operator">,</span> <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> <span class="operator">*</span>)
     {
         <span class="type">bool</span> changed <span class="operator">=</span> <span class="keyword">false</span>;
         <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> <span class="operator">*</span>buf <span class="operator">=</span> state<span class="operator">.</span>uniformData();
         <span class="keyword">if</span> (state<span class="operator">.</span>isMatrixDirty()) {
             <span class="keyword">const</span> QMatrix4x4 m <span class="operator">=</span> state<span class="operator">.</span>combinedMatrix();
             memcpy(buf<span class="operator">-</span><span class="operator">&gt;</span>data()<span class="operator">,</span> m<span class="operator">.</span>constData()<span class="operator">,</span> <span class="number">64</span>);
             changed <span class="operator">=</span> <span class="keyword">true</span>;
         }
         <span class="keyword">return</span> changed;
     }

     <span class="type">void</span> updateSampledImage(RenderState <span class="operator">&amp;</span><span class="operator">,</span> <span class="type">int</span> binding<span class="operator">,</span> <span class="type"><a href="qsgtexture.html" translate="no">QSGTexture</a></span> <span class="operator">*</span><span class="operator">*</span>texture<span class="operator">,</span> <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> <span class="operator">*</span>newMaterial<span class="operator">,</span> <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> <span class="operator">*</span>)
     {
         Material <span class="operator">*</span>mat <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span>Material <span class="operator">*</span><span class="operator">&gt;</span>(newMaterial);
         <span class="keyword">if</span> (binding <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span>)
             <span class="operator">*</span>texture <span class="operator">=</span> mat<span class="operator">-</span><span class="operator">&gt;</span>texture();
     }
 };
</pre>
<p>The Vulkan-style GLSL source code for the shaders could look like the following. These are expected to be preprocessed offline using the <code translate="no">qsb</code> tool, which generates the <code translate="no">.qsb</code> files referenced in the Shader() constructor.</p>
<pre class="cpp plain" translate="no">
 #version 440
 layout(location = 0) in vec4 aVertex;
 layout(location = 1) in vec2 aTexCoord;
 layout(location = 0) out vec2 vTexCoord;
 layout(std140, binding = 0) uniform buf {
     mat4 qt_Matrix;
 } ubuf;
 out gl_PerVertex { vec4 gl_Position; };
 void main() {
     gl_Position = ubuf.qt_Matrix * aVertex;
     vTexCoord = aTexCoord;
 }
</pre>
<pre class="cpp plain" translate="no">
 #version 440
 layout(location = 0) in vec2 vTexCoord;
 layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D srcTex;
 void main() {
     vec4 c = texture(srcTex, vTexCoord);
     fragColor = vec4(c.rgb * 0.5, 1.0);
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a> for more information.</p>
</div>
</div>
<p><b>See also </b><a href="qsgmaterial.html" translate="no">QSGMaterial</a>, <a href="qtquick-scenegraph-custommaterial-example.html" translate="no">Scene Graph - Custom Material</a>, <a href="qtquick-scenegraph-twotextureproviders-example.html" translate="no">Scene Graph - Two Texture Providers</a>, and <a href="qtquick-scenegraph-graph-example.html" translate="no">Scene Graph - Graph</a>.</p>
<!-- @@@QSGMaterialShader -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Flag$$$UpdatesGraphicsPipelineState -->
<h3 class="flags" id="Flag-enum">enum QSGMaterialShader::<span class="name">Flag</span><br/>flags QSGMaterialShader::<span class="name">Flags</span></h3>
<p>Flag values to indicate special material properties.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGMaterialShader::UpdatesGraphicsPipelineState</code></td><td class="topAlign tblval"><code translate="no">0x0001</code></td><td class="topAlign">Setting this flag enables calling <a href="qsgmaterialshader.html#updateGraphicsPipelineState" translate="no">updateGraphicsPipelineState</a>().</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QSGMaterialShader[overload1]$$$QSGMaterialShader -->
<h3 class="fn" translate="no" id="QSGMaterialShader">QSGMaterialShader::<span class="name">QSGMaterialShader</span>()</h3>
<p>Constructs a new QSGMaterialShader.</p>
<!-- @@@QSGMaterialShader -->
<!-- $$$combinedImageSamplerCount[overload1]$$$combinedImageSamplerCountint -->
<h3 class="fn" translate="no" id="combinedImageSamplerCount"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">int</span> QSGMaterialShader::<span class="name">combinedImageSamplerCount</span>(<span class="type">int</span> <i>binding</i>) const</h3>
<p>Returns the number of elements in the combined image sampler variable at <i translate="no">binding</i>. This value is introspected from the shader code. The variable may be an array, and may have more than one dimension.</p>
<p>The count reflects the total number of combined image sampler items in the variable. In the following example, the count for <code translate="no">srcA</code> is 1, <code translate="no">srcB</code> is 4, and <code translate="no">srcC</code> is 6.</p>
<pre class="cpp plain" translate="no">
 layout (binding = 0) uniform sampler2D srcA;
 layout (binding = 1) uniform sampler2D srcB[4];
 layout (binding = 2) uniform sampler2D srcC[2][3];
</pre>
<p>This count is the number of <a href="qsgtexture.html" translate="no">QSGTexture</a> pointers in the texture parameter of <a href="qsgmaterialshader.html#updateSampledImage" translate="no">QSGMaterialShader::updateSampledImage</a>.</p>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qsgmaterialshader.html#updateSampledImage" translate="no">QSGMaterialShader::updateSampledImage</a>.</p>
<!-- @@@combinedImageSamplerCount -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><span class="type"><a href="qsgmaterialshader.html#Flag-enum" translate="no">QSGMaterialShader::Flags</a></span> QSGMaterialShader::<span class="name">flags</span>() const</h3>
<p>Returns the currently set flags for this material shader.</p>
<p><b>See also </b><a href="qsgmaterialshader.html#setFlags" translate="no">setFlags</a>().</p>
<!-- @@@flags -->
<!-- $$$setFlag[overload1]$$$setFlagQSGMaterialShader::Flagsbool -->
<h3 class="fn" translate="no" id="setFlag"><span class="type">void</span> QSGMaterialShader::<span class="name">setFlag</span>(<span class="type"><a href="qsgmaterialshader.html#Flag-enum" translate="no">QSGMaterialShader::Flags</a></span> <i>flags</i>, <span class="type">bool</span> <i>on</i> = true)</h3>
<p>Sets the <i translate="no">flags</i> on this material shader if <i translate="no">on</i> is true; otherwise clears the specified flags.</p>
<!-- @@@setFlag -->
<!-- $$$setFlags[overload1]$$$setFlagsQSGMaterialShader::Flags -->
<h3 class="fn" translate="no" id="setFlags"><span class="type">void</span> QSGMaterialShader::<span class="name">setFlags</span>(<span class="type"><a href="qsgmaterialshader.html#Flag-enum" translate="no">QSGMaterialShader::Flags</a></span> <i>flags</i>)</h3>
<p>Sets the <i translate="no">flags</i> for this material shader.</p>
<p><b>See also </b><a href="qsgmaterialshader.html#flags" translate="no">flags</a>().</p>
<!-- @@@setFlags -->
<!-- $$$setShader[overload1]$$$setShaderQSGMaterialShader::StageconstQShader& -->
<h3 class="fn" translate="no" id="setShader"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QSGMaterialShader::<span class="name">setShader</span>(<span class="type">QSGMaterialShader::Stage</span> <i>stage</i>, const <span class="type"><a href="../qtgui/qshader.html" translate="no">QShader</a></span> &amp;<i>shader</i>)</h3>
<p>Sets the <i translate="no">shader</i> for the specified <i translate="no">stage</i>.</p>
<!-- @@@setShader -->
<!-- $$$setShaderFileName[overload1]$$$setShaderFileNameQSGMaterialShader::StageconstQString& -->
<h3 class="fn" translate="no" id="setShaderFileName"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QSGMaterialShader::<span class="name">setShaderFileName</span>(<span class="type">QSGMaterialShader::Stage</span> <i>stage</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>filename</i>)</h3>
<p>Sets the <i translate="no">filename</i> for the shader for the specified <i translate="no">stage</i>.</p>
<p>The file is expected to contain a serialized <a href="../qtgui/qshader.html" translate="no">QShader</a>.</p>
<!-- @@@setShaderFileName -->
<!-- $$$updateGraphicsPipelineState[overload1]$$$updateGraphicsPipelineStateQSGMaterialShader::RenderState&QSGMaterialShader::GraphicsPipelineState*QSGMaterial*QSGMaterial* -->
<h3 class="fn" translate="no" id="updateGraphicsPipelineState"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QSGMaterialShader::<span class="name">updateGraphicsPipelineState</span>(<span class="type"><a href="qsgmaterialshader-renderstate.html" translate="no">QSGMaterialShader::RenderState</a></span> &amp;<i>state</i>, <span class="type"><a href="qsgmaterialshader-graphicspipelinestate.html" translate="no">QSGMaterialShader::GraphicsPipelineState</a></span> *<i>ps</i>, <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> *<i>oldMaterial</i>)</h3>
<p>This function is called by the scene graph to enable the material to provide a custom set of graphics state. The set of states that are customizable by material is limited to blending and related settings.</p>
<div class="admonition note">
<p><b>Note: </b>This function is only called when the <a href="qsgmaterialshader.html#Flag-enum" translate="no">UpdatesGraphicsPipelineState</a> flag was enabled via <a href="qsgmaterialshader.html#setFlags" translate="no">setFlags</a>(). By default it is not set, and so this function is never called.</p>
</div>
<p>The return value must be <code translate="no">true</code> whenever a change was made to any of the members in <i translate="no">ps</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The contents of <i translate="no">ps</i> is not persistent between invocations of this function.</p>
</div>
<p>The current rendering <i translate="no">state</i> is passed from the scene graph.</p>
<p>The subclass specific state can be extracted from <i translate="no">newMaterial</i>. When <i translate="no">oldMaterial</i> is null, this shader was just activated.</p>
<!-- @@@updateGraphicsPipelineState -->
<!-- $$$updateSampledImage[overload1]$$$updateSampledImageQSGMaterialShader::RenderState&intQSGTexture**QSGMaterial*QSGMaterial* -->
<h3 class="fn" translate="no" id="updateSampledImage"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QSGMaterialShader::<span class="name">updateSampledImage</span>(<span class="type"><a href="qsgmaterialshader-renderstate.html" translate="no">QSGMaterialShader::RenderState</a></span> &amp;<i>state</i>, <span class="type">int</span> <i>binding</i>, <span class="type"><a href="qsgtexture.html" translate="no">QSGTexture</a></span> **<i>texture</i>, <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> *<i>oldMaterial</i>)</h3>
<p>This function is called by the scene graph to prepare use of sampled images in the shader, typically in the form of combined image samplers.</p>
<p><i translate="no">binding</i> is the binding number of the sampler. The function is called for each combined image sampler variable in the shader code associated with the <a href="qsgmaterialshader.html" translate="no">QSGMaterialShader</a>.</p>
<p><i translate="no">texture</i> is an array of <a href="qsgtexture.html" translate="no">QSGTexture</a> pointers. The number of elements in the array matches the number of elements in the image sampler variable specified in the shader code. This variable may be an array, and may have more than one dimension. The number of elements in the array may be found via <a href="qsgmaterialshader.html#combinedImageSamplerCount" translate="no">QSGMaterialShader::combinedImageSamplerCount</a></p>
<p>When an element in <i translate="no">texture</i> is null, it must be set to a valid <a href="qsgtexture.html" translate="no">QSGTexture</a> pointer before returning. When non-null, it is up to the material to decide if a new <code translate="no">QSGTexture *</code> is stored to it, or if it updates some parameters on the already known <a href="qsgtexture.html" translate="no">QSGTexture</a>. The ownership of the <a href="qsgtexture.html" translate="no">QSGTexture</a> is not transferred.</p>
<p>The current rendering <i translate="no">state</i> is passed from the scene graph. Where relevant, it is up to the material to trigger enqueuing texture data uploads via <a href="qsgtexture.html#commitTextureOperations" translate="no">QSGTexture::commitTextureOperations</a>().</p>
<p>The subclass specific state can be extracted from <i translate="no">newMaterial</i>.</p>
<p><i translate="no">oldMaterial</i> can be used to minimize changes. When <i translate="no">oldMaterial</i> is null, this shader was just activated.</p>
<p><b>See also </b><a href="qsgmaterialshader.html#combinedImageSamplerCount" translate="no">QSGMaterialShader::combinedImageSamplerCount</a>.</p>
<!-- @@@updateSampledImage -->
<!-- $$$updateUniformData[overload1]$$$updateUniformDataQSGMaterialShader::RenderState&QSGMaterial*QSGMaterial* -->
<h3 class="fn" translate="no" id="updateUniformData"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QSGMaterialShader::<span class="name">updateUniformData</span>(<span class="type"><a href="qsgmaterialshader-renderstate.html" translate="no">QSGMaterialShader::RenderState</a></span> &amp;<i>state</i>, <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="qsgmaterial.html" translate="no">QSGMaterial</a></span> *<i>oldMaterial</i>)</h3>
<p>This function is called by the scene graph to get the contents of the shader program's uniform buffer updated. The implementation is not expected to perform any real graphics operations, it is merely responsible for copying data to the <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a> returned from <a href="qsgmaterialshader-renderstate.html#uniformData" translate="no">RenderState::uniformData</a>(). The scene graph takes care of making that buffer visible in the shaders.</p>
<p>The current rendering <i translate="no">state</i> is passed from the scene graph. If the state indicates that any relevant state is dirty, the implementation must update the appropriate region in the buffer data that is accessible via <a href="qsgmaterialshader-renderstate.html#uniformData" translate="no">RenderState::uniformData</a>(). When a state, such as, matrix or opacity, is not dirty, there is no need to touch the corresponding region since the data is persistent.</p>
<p>The return value must be <code translate="no">true</code> whenever any change was made to the uniform data.</p>
<p>The subclass specific state, such as the color of a flat color material, should be extracted from <i translate="no">newMaterial</i> to update the relevant regions in the buffer accordingly.</p>
<p><i translate="no">oldMaterial</i> can be used to minimize buffer changes (which are typically memcpy calls) when updating material states. When <i translate="no">oldMaterial</i> is null, this shader was just activated.</p>
<!-- @@@updateUniformData -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
