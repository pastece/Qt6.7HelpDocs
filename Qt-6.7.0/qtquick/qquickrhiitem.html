<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquickrhiitem.cpp -->
  <meta name="description" content="The QQuickRhiItem class is a portable alternative to QQuickFramebufferObject that is not tied to OpenGL, but rather allows integrating rendering with the QRhi APIs with Qt Quick.">
  <title>QQuickRhiItem Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QQuickRhiItem</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#a-simple-example">A simple example</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QQuickRhiItem Class</h1>
<!-- $$$QQuickRhiItem-brief -->
<p>The QQuickRhiItem class is a portable alternative to <a href="qquickframebufferobject.html" translate="no">QQuickFramebufferObject</a> that is not tied to OpenGL, but rather allows integrating rendering with the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> APIs with Qt Quick. <a href="#details">More...</a></p>
<!-- @@@QQuickRhiItem -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QQuickRhiItem&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Quick) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.7</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qquickitem.html" translate="no">QQuickItem</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Status:</td><td class="memItemRight bottomAlign"> Preliminary<span class="status preliminary"></span></td></tr>
</table></div>
<p><b>This class is under development and is subject to change.</b></p>
<ul>
<li><a href="qquickrhiitem-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="properties">Properties</h2>
<div class="table"><table class="propsummary" translate="no">
<tr><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qquickrhiitem.html#alphaBlending-prop" translate="no">alphaBlending</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qquickrhiitem.html#colorBufferFormat-prop" translate="no">colorBufferFormat</a></b> : TextureFormat</li>
<li class="fn" translate="no"><b><a href="qquickrhiitem.html#effectiveColorBufferSize-prop" translate="no">effectiveColorBufferSize</a></b> : const QSize</li>
<li class="fn" translate="no"><b><a href="qquickrhiitem.html#fixedColorBufferHeight-prop" translate="no">fixedColorBufferHeight</a></b> : int</li>
</ul></td><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qquickrhiitem.html#fixedColorBufferWidth-prop" translate="no">fixedColorBufferWidth</a></b> : int</li>
<li class="fn" translate="no"><b><a href="qquickrhiitem.html#mirrorVertically-prop" translate="no">mirrorVertically</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qquickrhiitem.html#sampleCount-prop" translate="no">sampleCount</a></b> : int</li>
</ul>
</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#QQuickRhiItem" translate="no">QQuickRhiItem</a></b>(QQuickItem *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#dtor.QQuickRhiItem" translate="no">~QQuickRhiItem</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#alphaBlending-prop" translate="no">alphaBlending</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickRhiItem::TextureFormat </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#colorBufferFormat-prop" translate="no">colorBufferFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#effectiveColorBufferSize-prop" translate="no">effectiveColorBufferSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#fixedColorBufferHeight-prop" translate="no">fixedColorBufferHeight</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#fixedColorBufferWidth-prop" translate="no">fixedColorBufferWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#mirrorVertically-prop" translate="no">isMirrorVerticallyEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#sampleCount-prop" translate="no">sampleCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#alphaBlending-prop" translate="no">setAlphaBlending</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#colorBufferFormat-prop" translate="no">setColorBufferFormat</a></b>(QQuickRhiItem::TextureFormat <i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#fixedColorBufferHeight-prop" translate="no">setFixedColorBufferHeight</a></b>(int <i>height</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#fixedColorBufferWidth-prop" translate="no">setFixedColorBufferWidth</a></b>(int <i>width</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#mirrorVertically-prop" translate="no">setMirrorVertically</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#sampleCount-prop" translate="no">setSampleCount</a></b>(int <i>samples</i>)</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#isTextureProvider" translate="no">isTextureProvider</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGTextureProvider *</td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#textureProvider" translate="no">textureProvider</a></b>() const override</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#alphaBlending-prop" translate="no">alphaBlendingChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#colorBufferFormat-prop" translate="no">colorBufferFormatChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#effectiveColorBufferSize-prop" translate="no">effectiveColorBufferSizeChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#fixedColorBufferHeight-prop" translate="no">fixedColorBufferHeightChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#fixedColorBufferWidth-prop" translate="no">fixedColorBufferWidthChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#mirrorVertically-prop" translate="no">mirrorVerticallyChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#sampleCount-prop" translate="no">sampleCountChanged</a></b>()</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QQuickRhiItemRenderer *</td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#createRenderer" translate="no">createRenderer</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#isAutoRenderTargetEnabled" translate="no">isAutoRenderTargetEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#setAutoRenderTarget" translate="no">setAutoRenderTarget</a></b>(bool <i>enabled</i>)</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#event" translate="no">event</a></b>(QEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#geometryChange" translate="no">geometryChange</a></b>(const QRectF &amp;<i>newGeometry</i>, const QRectF &amp;<i>oldGeometry</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickrhiitem.html#releaseResources" translate="no">releaseResources</a></b>() override</td></tr>
</table></div>
<!-- $$$QQuickRhiItem-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<div class="admonition note">
<p><b>Note: </b>QQuickRhiItem is in tech preview in Qt 6.7. <b>The API is under development and subject to change.</b></p>
</div>
<p>QQuickRhiItem is effectively the counterpart of <a href="../qtwidgets/qrhiwidget.html" translate="no">QRhiWidget</a> in the world of Qt Quick. Both of these are meant to be subclassed, and they both enable recording <a href="../qtgui/qrhi.html" translate="no">QRhi</a>-based rendering that targets an offscreen color buffer. The resulting 2D image is then composited with the rest of the Qt Quick scene.</p>
<div class="admonition note">
<p><b>Note: </b>While QQuickRhiItem is a public Qt API, the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> family of classes in the Qt Gui module, including <a href="../qtgui/qshader.html" translate="no">QShader</a> and <a href="../qtgui/qshaderdescription.html" translate="no">QShaderDescription</a>, offer limited compatibility guarantees. There are no source or binary compatibility guarantees for these classes, meaning the API is only guaranteed to work with the Qt version the application was developed against. Source incompatible changes are however aimed to be kept at a minimum and will only be made in minor releases (6.7, 6.8, and so on). <code translate="no">qquickrhiitem.h</code> does not directly include any <a href="../qtgui/qrhi.html" translate="no">QRhi</a>-related headers. To use those classes when implementing a QQuickRhiItem subclass, link to <code translate="no">Qt::GuiPrivate</code> (if using CMake), and include the appropriate headers with the <code translate="no">rhi</code> prefix, for example <code translate="no">#include &lt;rhi/qrhi.h&gt;</code>.</p>
</div>
<p>QQuickRhiItem is a replacement for the legacy <a href="qquickframebufferobject.html" translate="no">QQuickFramebufferObject</a> class. The latter is inherently tied to OpenGL / OpenGL ES, whereas QQuickRhiItem works with the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> classes, allowing to run the same rendering code with Vulkan, Metal, Direct 3D 11/12, and OpenGL / OpenGL ES. Conceptually and functionally they are very close, and migrating from <a href="qquickframebufferobject.html" translate="no">QQuickFramebufferObject</a> to QQuickRhiItem is straightforward. <a href="qquickframebufferobject.html" translate="no">QQuickFramebufferObject</a> continues to be available to ensure compatibility for existing application code that works directly with the OpenGL API.</p>
<div class="admonition note">
<p><b>Note: </b>QQuickRhiItem will not be functional when using the <code translate="no">software</code> adaptation of the Qt Quick scene graph.</p>
</div>
<p>On most platforms, the scene graph rendering, and thus the rendering performed by the QQuickRhiItem will occur on a <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering" translate="no">dedicated thread</a>. For this reason, the QQuickRhiItem class enforces a strict separation between the item implementation (the <a href="qquickitem.html" translate="no">QQuickItem</a> subclass) and the actual rendering logic. All item logic, such as properties and UI-related helper functions exposed to QML must be located in the QQuickRhiItem subclass. Everything that relates to rendering must be located in the <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a> class. To avoid race conditions and read/write issues from two threads it is important that the renderer and the item never read or write shared variables. Communication between the item and the renderer should primarily happen via the QQuickRhiItem::synchronize() function. This function will be called on the render thread while the GUI thread is blocked. Using queued connections or events for communication between item and renderer is also possible.</p>
<p>Applications must subclass both QQuickRhiItem and <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a>. The pure virtual <a href="qquickrhiitem.html#createRenderer" translate="no">createRenderer</a>() function must be reimplemented to return a new instance of the <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a> subclass.</p>
<p>As with <a href="../qtwidgets/qrhiwidget.html" translate="no">QRhiWidget</a>, QQuickRhiItem automatically managed the color buffer, which is a 2D texture (<a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>) normally, or a <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> when multisampling is in use. (some 3D APIs differentiate between textures and renderbuffers, while with some others the underlying native resource is the same; renderbuffers are used mainly to allow multisampling with OpenGL ES 3.0)</p>
<p>The size of the texture will by default adapt to the size of the item (with the <a href="qquickwindow.html#effectiveDevicePixelRatio" translate="no">device pixel ratio</a> taken into account). If the item size changes, the texture is recreated with the correct size. If a fixed size is preferred, set <a href="qquickrhiitem.html#fixedColorBufferWidth-prop" translate="no">fixedColorBufferWidth</a> and <a href="qquickrhiitem.html#fixedColorBufferHeight-prop" translate="no">fixedColorBufferHeight</a> to non-zero values.</p>
<p>QQuickRhiItem is a <a href="qsgtextureprovider.html" translate="no">texture provider</a> and can be used directly in <a href="qml-qtquick-shadereffect.html" translate="no">ShaderEffects</a> and other classes that consume texture providers.</p>
<p>While not a primary use case, QQuickRhiItem also allows incorporating rendering code that directly uses a 3D graphics API such as Vulkan, Metal, Direct 3D, or OpenGL. See <a href="../qtgui/qrhicommandbuffer.html#beginExternal" translate="no">QRhiCommandBuffer::beginExternal</a>() for details on recording native commands within a <a href="../qtgui/qrhi.html" translate="no">QRhi</a> render pass, as well as <a href="../qtgui/qrhitexture.html#createFrom" translate="no">QRhiTexture::createFrom</a>() for a way to wrap an existing native texture and then use it with <a href="../qtgui/qrhi.html" translate="no">QRhi</a> in a subsequent render pass. See also <a href="qquickgraphicsconfiguration.html" translate="no">QQuickGraphicsConfiguration</a> regarding configuring the native 3D API environment (e.g. device extensions) and note that the <a href="qquickwindow.html" translate="no">QQuickWindow</a> can be associated with a custom <a href="../qtgui/qvulkaninstance.html" translate="no">QVulkanInstance</a> by calling <a href="../qtgui/qwindow.html#setVulkanInstance" translate="no">QWindow::setVulkanInstance</a>() early enough.</p>
<div class="admonition note">
<p><b>Note: </b>QQuickRhiItem always uses the same <a href="../qtgui/qrhi.html" translate="no">QRhi</a> instance the <a href="qquickwindow.html" translate="no">QQuickWindow</a> uses (and by extension, the same OpenGL context, Vulkan device, etc.). To choose which underlying 3D graphics API is used, call <a href="qquickwindow.html#setGraphicsApi" translate="no">setGraphicsApi</a>() on the <a href="qquickwindow.html" translate="no">QQuickWindow</a> early enough. Changing it is not possible once the scene graph has initialized, and all QQuickRhiItem instances in the scene will render using the same 3D API.</p>
</div>
<h4 id="a-simple-example">A simple example</h4>
<p>Take the following subclass of QQuickRhiItem. It is shown here in complete form. It renders a single triangle with a perspective projection, where the triangle is rotated based on the <code translate="no">angle</code> property of the custom item. (meaning it can be driven for example with animations such as <a href="qml-qtquick-numberanimation.html" translate="no">NumberAnimation</a> from QML)</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> ExampleRhiItemRenderer : <span class="keyword">public</span> <span class="type"><a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a></span>
 {
 <span class="keyword">public</span>:
     <span class="type">void</span> initialize(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb) override;
     <span class="type">void</span> synchronize(<span class="type"><a href="qquickrhiitem.html#QQuickRhiItem" translate="no">QQuickRhiItem</a></span> <span class="operator">*</span>item) override;
     <span class="type">void</span> render(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb) override;

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtgui/qrhi.html" translate="no">QRhi</a></span> <span class="operator">*</span>m_rhi <span class="operator">=</span> nullptr;
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">&gt;</span> m_vbuf;
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">&gt;</span> m_ubuf;
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="../qtgui/qrhishaderresourcebindings.html" translate="no">QRhiShaderResourceBindings</a></span><span class="operator">&gt;</span> m_srb;
     std<span class="operator">::</span>unique_ptr<span class="operator">&lt;</span><span class="type"><a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a></span><span class="operator">&gt;</span> m_pipeline;
     QMatrix4x4 m_viewProjection;
     <span class="type">float</span> m_angle <span class="operator">=</span> <span class="number">0.0f</span>;
 };

 <span class="keyword">class</span> ExampleRhiItem : <span class="keyword">public</span> <span class="type"><a href="qquickrhiitem.html#QQuickRhiItem" translate="no">QQuickRhiItem</a></span>
 {
     Q_OBJECT
     QML_NAMED_ELEMENT(ExampleRhiItem)
     Q_PROPERTY(<span class="type">float</span> angle READ angle WRITE setAngle NOTIFY angleChanged)

 <span class="keyword">public</span>:
     <span class="type"><a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a></span> <span class="operator">*</span>createRenderer() override;

     <span class="type">float</span> angle() <span class="keyword">const</span> { <span class="keyword">return</span> m_angle; }
     <span class="type">void</span> setAngle(<span class="type">float</span> a);

 <span class="keyword">signals</span>:
     <span class="type">void</span> angleChanged();

 <span class="keyword">private</span>:
     <span class="type">float</span> m_angle <span class="operator">=</span> <span class="number">0.0f</span>;
 };

 <span class="type"><a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a></span> <span class="operator">*</span>ExampleRhiItem<span class="operator">::</span>createRenderer()
 {
     <span class="keyword">return</span> <span class="keyword">new</span> ExampleRhiItemRenderer;
 }

 <span class="type">void</span> ExampleRhiItem<span class="operator">::</span>setAngle(<span class="type">float</span> a)
 {
     <span class="keyword">if</span> (m_angle <span class="operator">=</span><span class="operator">=</span> a)
         <span class="keyword">return</span>;

     m_angle <span class="operator">=</span> a;
     <span class="keyword">emit</span> angleChanged();
     update();
 }

 <span class="type">void</span> ExampleRhiItemRenderer<span class="operator">::</span>synchronize(<span class="type"><a href="qquickrhiitem.html#QQuickRhiItem" translate="no">QQuickRhiItem</a></span> <span class="operator">*</span>rhiItem)
 {
     ExampleRhiItem <span class="operator">*</span>item <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span>ExampleRhiItem <span class="operator">*</span><span class="operator">&gt;</span>(rhiItem);
     <span class="keyword">if</span> (item<span class="operator">-</span><span class="operator">&gt;</span>angle() <span class="operator">!</span><span class="operator">=</span> m_angle)
         m_angle <span class="operator">=</span> item<span class="operator">-</span><span class="operator">&gt;</span>angle();
 }

 <span class="keyword">static</span> <span class="type"><a href="../qtgui/qshader.html" translate="no">QShader</a></span> getShader(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>name)
 {
     <span class="type"><a href="../qtcore/qfile.html" translate="no">QFile</a></span> f(name);
     <span class="keyword">return</span> f<span class="operator">.</span>open(<span class="type"><a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></span><span class="operator">::</span>ReadOnly) <span class="operator">?</span> <span class="type"><a href="../qtgui/qshader.html" translate="no">QShader</a></span><span class="operator">::</span>fromSerialized(f<span class="operator">.</span>readAll()) : <span class="type"><a href="../qtgui/qshader.html" translate="no">QShader</a></span>();
 }

 <span class="keyword">static</span> <span class="type">float</span> vertexData<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
     <span class="number">0.0f</span><span class="operator">,</span>   <span class="number">0.5f</span><span class="operator">,</span>   <span class="number">1.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span>
     <span class="operator">-</span><span class="number">0.5f</span><span class="operator">,</span>  <span class="operator">-</span><span class="number">0.5f</span><span class="operator">,</span>   <span class="number">0.0f</span><span class="operator">,</span> <span class="number">1.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span>
     <span class="number">0.5f</span><span class="operator">,</span>  <span class="operator">-</span><span class="number">0.5f</span><span class="operator">,</span>   <span class="number">0.0f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span> <span class="number">1.0f</span><span class="operator">,</span>
 };

 <span class="type">void</span> ExampleRhiItemRenderer<span class="operator">::</span>initialize(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb)
 {
     <span class="keyword">if</span> (m_rhi <span class="operator">!</span><span class="operator">=</span> rhi()) {
         m_pipeline<span class="operator">.</span>reset();
         m_rhi <span class="operator">=</span> rhi();
     }

     <span class="keyword">if</span> (<span class="operator">!</span>m_pipeline) {
         m_vbuf<span class="operator">.</span>reset(m_rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>Immutable<span class="operator">,</span> <span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>VertexBuffer<span class="operator">,</span> <span class="keyword">sizeof</span>(vertexData)));
         m_vbuf<span class="operator">-</span><span class="operator">&gt;</span>create();

         m_ubuf<span class="operator">.</span>reset(m_rhi<span class="operator">-</span><span class="operator">&gt;</span>newBuffer(<span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>Dynamic<span class="operator">,</span> <span class="type"><a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a></span><span class="operator">::</span>UniformBuffer<span class="operator">,</span> <span class="number">64</span>));
         m_ubuf<span class="operator">-</span><span class="operator">&gt;</span>create();

         m_srb<span class="operator">.</span>reset(m_rhi<span class="operator">-</span><span class="operator">&gt;</span>newShaderResourceBindings());
         m_srb<span class="operator">-</span><span class="operator">&gt;</span>setBindings({
             <span class="type"><a href="../qtgui/qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>uniformBuffer(<span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtgui/qrhishaderresourcebinding.html" translate="no">QRhiShaderResourceBinding</a></span><span class="operator">::</span>VertexStage<span class="operator">,</span> m_ubuf<span class="operator">.</span>get())<span class="operator">,</span>
         });
         m_srb<span class="operator">-</span><span class="operator">&gt;</span>create();

         m_pipeline<span class="operator">.</span>reset(m_rhi<span class="operator">-</span><span class="operator">&gt;</span>newGraphicsPipeline());
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>setShaderStages({
             { <span class="type"><a href="../qtgui/qrhishaderstage.html" translate="no">QRhiShaderStage</a></span><span class="operator">::</span>Vertex<span class="operator">,</span> getShader(QLatin1String(<span class="string">&quot;:/shaders/color.vert.qsb&quot;</span>)) }<span class="operator">,</span>
             { <span class="type"><a href="../qtgui/qrhishaderstage.html" translate="no">QRhiShaderStage</a></span><span class="operator">::</span>Fragment<span class="operator">,</span> getShader(QLatin1String(<span class="string">&quot;:/shaders/color.frag.qsb&quot;</span>)) }
         });
         <span class="type"><a href="../qtgui/qrhivertexinputlayout.html" translate="no">QRhiVertexInputLayout</a></span> inputLayout;
         inputLayout<span class="operator">.</span>setBindings({
             { <span class="number">5</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) }
         });
         inputLayout<span class="operator">.</span>setAttributes({
             { <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtgui/qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a></span><span class="operator">::</span>Float2<span class="operator">,</span> <span class="number">0</span> }<span class="operator">,</span>
             { <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="../qtgui/qrhivertexinputattribute.html" translate="no">QRhiVertexInputAttribute</a></span><span class="operator">::</span>Float3<span class="operator">,</span> <span class="number">2</span> <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) }
         });
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>setVertexInputLayout(inputLayout);
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>setShaderResourceBindings(m_srb<span class="operator">.</span>get());
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>setRenderPassDescriptor(renderTarget()<span class="operator">-</span><span class="operator">&gt;</span>renderPassDescriptor());
         m_pipeline<span class="operator">-</span><span class="operator">&gt;</span>create();

         <span class="type"><a href="../qtgui/qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>resourceUpdates <span class="operator">=</span> m_rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
         resourceUpdates<span class="operator">-</span><span class="operator">&gt;</span>uploadStaticBuffer(m_vbuf<span class="operator">.</span>get()<span class="operator">,</span> vertexData);
         cb<span class="operator">-</span><span class="operator">&gt;</span>resourceUpdate(resourceUpdates);
     }

     <span class="keyword">const</span> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> outputSize <span class="operator">=</span> renderTarget()<span class="operator">-</span><span class="operator">&gt;</span>pixelSize();
     m_viewProjection <span class="operator">=</span> m_rhi<span class="operator">-</span><span class="operator">&gt;</span>clipSpaceCorrMatrix();
     m_viewProjection<span class="operator">.</span>perspective(<span class="number">45.0f</span><span class="operator">,</span> outputSize<span class="operator">.</span>width() <span class="operator">/</span> (<span class="type">float</span>) outputSize<span class="operator">.</span>height()<span class="operator">,</span> <span class="number">0.01f</span><span class="operator">,</span> <span class="number">1000.0f</span>);
     m_viewProjection<span class="operator">.</span>translate(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">4</span>);
 }

 <span class="type">void</span> ExampleRhiItemRenderer<span class="operator">::</span>render(<span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> <span class="operator">*</span>cb)
 {
     <span class="type"><a href="../qtgui/qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> <span class="operator">*</span>resourceUpdates <span class="operator">=</span> m_rhi<span class="operator">-</span><span class="operator">&gt;</span>nextResourceUpdateBatch();
     QMatrix4x4 modelViewProjection <span class="operator">=</span> m_viewProjection;
     modelViewProjection<span class="operator">.</span>rotate(m_angle<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span>);
     resourceUpdates<span class="operator">-</span><span class="operator">&gt;</span>updateDynamicBuffer(m_ubuf<span class="operator">.</span>get()<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">64</span><span class="operator">,</span> modelViewProjection<span class="operator">.</span>constData());

     <span class="keyword">const</span> <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> clearColor <span class="operator">=</span> <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span><span class="operator">::</span>fromRgbF(<span class="number">0.4f</span><span class="operator">,</span> <span class="number">0.7f</span><span class="operator">,</span> <span class="number">0.0f</span><span class="operator">,</span> <span class="number">1.0f</span>);
     cb<span class="operator">-</span><span class="operator">&gt;</span>beginPass(renderTarget()<span class="operator">,</span> clearColor<span class="operator">,</span> { <span class="number">1.0f</span><span class="operator">,</span> <span class="number">0</span> }<span class="operator">,</span> resourceUpdates);

     cb<span class="operator">-</span><span class="operator">&gt;</span>setGraphicsPipeline(m_pipeline<span class="operator">.</span>get());
     <span class="keyword">const</span> <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> outputSize <span class="operator">=</span> renderTarget()<span class="operator">-</span><span class="operator">&gt;</span>pixelSize();
     cb<span class="operator">-</span><span class="operator">&gt;</span>setViewport(<span class="type"><a href="../qtgui/qrhiviewport.html" translate="no">QRhiViewport</a></span>(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> outputSize<span class="operator">.</span>width()<span class="operator">,</span> outputSize<span class="operator">.</span>height()));
     cb<span class="operator">-</span><span class="operator">&gt;</span>setShaderResources();
     <span class="keyword">const</span> <span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span><span class="operator">::</span>VertexInput vbufBinding(m_vbuf<span class="operator">.</span>get()<span class="operator">,</span> <span class="number">0</span>);
     cb<span class="operator">-</span><span class="operator">&gt;</span>setVertexInput(<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="operator">&amp;</span>vbufBinding);
     cb<span class="operator">-</span><span class="operator">&gt;</span>draw(<span class="number">3</span>);

     cb<span class="operator">-</span><span class="operator">&gt;</span>endPass();
 }
</pre>
<p>It is notable that this simple class is almost exactly the same as the code shown in the <a href="../qtwidgets/qrhiwidget.html" translate="no">QRhiWidget</a> introduction. The vertex and fragment shaders are the same as shown there.</p>
<p>Once exposed to QML (note the <code translate="no">QML_NAMED_ELEMENT</code>), our custom item can be instantiated in any scene. (after importing the appropriate <code translate="no">URI</code> specified for <a href="../qtqml/qt-add-qml-module.html#qt6-add-qml-module" translate="no">qt_add_qml_module</a> in the CMake project)</p>
<pre class="cpp" translate="no">
 ExampleRhiItem {
     anchors<span class="operator">.</span>fill: parent
     anchors<span class="operator">.</span>margins: <span class="number">10</span>
     NumberAnimation on angle { from: <span class="number">0</span>; to: <span class="number">360</span>: duration: <span class="number">5000</span>; loops: Animation<span class="operator">.</span>Infinite }
 }
</pre>
<p>See <a href="qtquick-scenegraph-rhitextureitem-example.html" translate="no">Scene Graph - RHI Texture Item</a> for a more complex example.</p>
</div>
<p><b>See also </b><a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a>, <a href="qtquick-scenegraph-rhitextureitem-example.html" translate="no">Scene Graph - RHI Texture Item</a>, <a href="../qtgui/qrhi.html" translate="no">QRhi</a>, and <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a>.</p>
<!-- @@@QQuickRhiItem -->
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$alphaBlending-prop$$$alphaBlending$$$setAlphaBlendingbool$$$alphaBlendingChanged -->
<h3 class="fn" translate="no" id="alphaBlending-prop"><span class="name">alphaBlending</span> : <span class="type">bool</span></h3>
<p>Controls if blending is always enabled when drawing the quad textured with the content generated by the <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> and its renderer.</p>
<p>The default value is <code translate="no">false</code>. This is for performance reasons: if semi-transparency is not involved, because the <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a> clears to an opaque color and never renders fragments with alpha smaller than 1, then there is no point in enabling blending.</p>
<p>If the <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a> subclass renders with semi-transparency involved, set this property to true.</p>
<div class="admonition note">
<p><b>Note: </b>Under certain conditions blending is still going to happen regardless of the value of this property. For example, if the item's <a href="qquickitem.html#opacity-prop" translate="no">opacity</a> (more precisely, the combined opacity inherited from the parent chain) is smaller than 1, blending will be automatically enabled even when this property is set to false.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The Qt Quick scene graph relies on and expect pre-multiplied alpha. For example, if the intention is to clear the background in the renderer to an alpha value of 0.5, then make sure to multiply the red, green, and blue clear color values with 0.5 as well. Otherwise the blending results will be incorrect.</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>alphaBlending</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAlphaBlending</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>alphaBlendingChanged</b></span>()</td></tr>
</table></div>
<!-- @@@alphaBlending -->
<!-- $$$colorBufferFormat-prop$$$colorBufferFormat$$$setColorBufferFormatQQuickRhiItem::TextureFormat$$$colorBufferFormatChanged -->
<h3 class="fn" translate="no" id="colorBufferFormat-prop"><span class="name">colorBufferFormat</span> : <span class="type">TextureFormat</span></h3>
<p>This property controls the texture format for the texture used as the color buffer. The default value is TextureFormat::RGBA8. <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> supports rendering to a subset of the formats supported by <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>. Only formats that are reported as supported from <a href="../qtgui/qrhi.html#isTextureFormatSupported" translate="no">QRhi::isTextureFormatSupported</a>() should be specified, rendering will not be functional otherwise.</p>
<div class="admonition note">
<p><b>Note: </b>Setting a new format when the item and its renderer are already initialized and have rendered implies that all <a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> objects created by the renderer may become unusable, if the associated <a href="../qtgui/qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> is now incompatible due to the different texture format. Similarly to changing <a href="qquickrhiitem.html#sampleCount-prop" translate="no">sampleCount</a> dynamically, this means that initialize() or render() implementations must then take care of releasing the existing pipelines and creating new ones.</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QQuickRhiItem::TextureFormat </td><td class="memItemRight bottomAlign"><span class="name"><b>colorBufferFormat</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setColorBufferFormat</b></span>(QQuickRhiItem::TextureFormat <i>format</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>colorBufferFormatChanged</b></span>()</td></tr>
</table></div>
<!-- @@@colorBufferFormat -->
<!-- $$$effectiveColorBufferSize-prop$$$effectiveColorBufferSize$$$effectiveColorBufferSizeChanged -->
<h3 class="fn" translate="no" id="effectiveColorBufferSize-prop"><code class="details extra" translate="no">[read-only]</code> <span class="name">effectiveColorBufferSize</span> : const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span></h3>
<p>This property exposes the size, in pixels, of the underlying color buffer (the <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a> or <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>). It is provided for use on the GUI (main) thread, in QML bindings or JavaScript.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a> implementations, operating on the scene graph render thread, should not use this property. Those should rather query the size from the <a href="qquickrhiitemrenderer.html#renderTarget" translate="no">render target</a>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The value becomes available asynchronously from the main thread's perspective in the sense that the value changes when rendering happens on the render thread. This means that this property is useful mainly in QML bindings. Application code must not assume that the value is up to date already when the <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a> object is constructed.</p>
</div>
<p>This is a read-only property.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>effectiveColorBufferSize</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>effectiveColorBufferSizeChanged</b></span>()</td></tr>
</table></div>
<!-- @@@effectiveColorBufferSize -->
<!-- $$$fixedColorBufferHeight-prop$$$fixedColorBufferHeight$$$setFixedColorBufferHeightint$$$fixedColorBufferHeightChanged -->
<h3 class="fn" translate="no" id="fixedColorBufferHeight-prop"><span class="name">fixedColorBufferHeight</span> : <span class="type">int</span></h3>
<p>The fixed height, in pixels, of the item's associated texture. Relevant when a fixed texture size is desired that does not depend on the item's size. This size has no effect on the geometry of the item (its size and placement within the scene), which means the texture's content will appear stretched (scaled up) or scaled down onto the item's area.</p>
<p>For example, setting a size that is exactly twice the item's (pixel) size effectively performs 2x supersampling (rendering at twice the resolution and then implicitly scaling down when texturing the quad corresponding to the item in the scene).</p>
<p>By default the value is <code translate="no">0</code>. A value of 0 means that texture's size follows the item's size. (<code translate="no">texture size</code> = <code translate="no">item size</code> * <code translate="no">device pixel ratio</code>).</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>fixedColorBufferHeight</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFixedColorBufferHeight</b></span>(int <i>height</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>fixedColorBufferHeightChanged</b></span>()</td></tr>
</table></div>
<!-- @@@fixedColorBufferHeight -->
<!-- $$$fixedColorBufferWidth-prop$$$fixedColorBufferWidth$$$setFixedColorBufferWidthint$$$fixedColorBufferWidthChanged -->
<h3 class="fn" translate="no" id="fixedColorBufferWidth-prop"><span class="name">fixedColorBufferWidth</span> : <span class="type">int</span></h3>
<p>The fixed width, in pixels, of the item's associated texture or renderbuffer. Relevant when a fixed color buffer size is desired that does not depend on the item's size. This size has no effect on the geometry of the item (its size and placement within the scene), which means the texture's content will appear stretched (scaled up) or scaled down onto the item's area.</p>
<p>For example, setting a size that is exactly twice the item's (pixel) size effectively performs 2x supersampling (rendering at twice the resolution and then implicitly scaling down when texturing the quad corresponding to the item in the scene).</p>
<p>By default the value is <code translate="no">0</code>. A value of 0 means that texture's size follows the item's size. (<code translate="no">texture size</code> = <code translate="no">item size</code> * <code translate="no">device pixel ratio</code>).</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>fixedColorBufferWidth</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFixedColorBufferWidth</b></span>(int <i>width</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>fixedColorBufferWidthChanged</b></span>()</td></tr>
</table></div>
<!-- @@@fixedColorBufferWidth -->
<!-- $$$mirrorVertically-prop$$$isMirrorVerticallyEnabled$$$setMirrorVerticallybool$$$mirrorVerticallyChanged -->
<h3 class="fn" translate="no" id="mirrorVertically-prop"><span class="name">mirrorVertically</span> : <span class="type">bool</span></h3>
<p>This property controls if texture UVs are flipped when drawing the textured quad. It has no effect on the contents of the offscreen color buffer and the rendering implemented by the <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a>.</p>
<p>The default value is <code translate="no">false</code>.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isMirrorVerticallyEnabled</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMirrorVertically</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>mirrorVerticallyChanged</b></span>()</td></tr>
</table></div>
<!-- @@@mirrorVertically -->
<!-- $$$sampleCount-prop$$$sampleCount$$$setSampleCountint$$$sampleCountChanged -->
<h3 class="fn" translate="no" id="sampleCount-prop"><span class="name">sampleCount</span> : <span class="type">int</span></h3>
<p>This property controls for sample count for multisample antialiasing. By default the value is <code translate="no">1</code> which means MSAA is disabled.</p>
<p>Valid values are 1, 4, 8, and sometimes 16 and 32. <a href="../qtgui/qrhi.html#supportedSampleCounts" translate="no">QRhi::supportedSampleCounts</a>() can be used to query the supported sample counts at run time, but typically applications should request 1 (no MSAA), 4x (normal MSAA) or 8x (high MSAA).</p>
<div class="admonition note">
<p><b>Note: </b>Setting a new value implies that all <a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> objects created by the renderer must use the same sample count from then on. Existing <a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> objects created with a different sample count must not be used anymore. When the value changes, all color and depth-stencil buffers are destroyed and recreated automatically, and <a href="qquickrhiitemrenderer.html#initialize" translate="no">initialize</a>() is invoked again. However, when <a href="qquickrhiitem.html#isAutoRenderTargetEnabled" translate="no">isAutoRenderTargetEnabled</a>() is <code translate="no">false</code>, it will be up to the application to manage this with regards to the depth-stencil buffer or additional color buffers.</p>
</div>
<p>Changing the sample count from the default 1 to a higher value implies that <a href="qquickrhiitemrenderer.html#colorTexture" translate="no">colorTexture</a>() becomes <code translate="no">nullptr</code> and <a href="qquickrhiitemrenderer.html#msaaColorBuffer" translate="no">msaaColorBuffer</a>() starts returning a valid object. Switching back to 1 (or 0), implies the opposite: in the next call to initialize() msaaColorBuffer() is going to return <code translate="no">nullptr</code>, whereas colorTexture() becomes once again valid. In addition, <a href="qquickrhiitemrenderer.html#resolveTexture" translate="no">resolveTexture</a>() returns a valid (non-multisample) <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a> whenever the sample count is greater than 1 (i.e., MSAA is in use).</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>sampleCount</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSampleCount</b></span>(int <i>samples</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sampleCountChanged</b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qquickrhiitemrenderer.html#msaaColorBuffer" translate="no">QQuickRhiItemRenderer::msaaColorBuffer</a>() and <a href="qquickrhiitemrenderer.html#resolveTexture" translate="no">QQuickRhiItemRenderer::resolveTexture</a>().</p>
<!-- @@@sampleCount -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickRhiItem[overload1]$$$QQuickRhiItemQQuickItem* -->
<h3 class="fn" translate="no" id="QQuickRhiItem"><code class="details extra" translate="no">[explicit]</code> QQuickRhiItem::<span class="name">QQuickRhiItem</span>(<span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new QQuickRhiItem with the given <i translate="no">parent</i>.</p>
<!-- @@@QQuickRhiItem -->
<!-- $$$~QQuickRhiItem[overload1]$$$~QQuickRhiItem -->
<h3 class="fn" translate="no" id="dtor.QQuickRhiItem"><code class="details extra" translate="no">[override virtual noexcept]</code> QQuickRhiItem::<span class="name">~QQuickRhiItem</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QQuickRhiItem -->
<!-- $$$createRenderer[overload1]$$$createRenderer -->
<h3 class="fn" translate="no" id="createRenderer"><code class="details extra" translate="no">[pure virtual protected]</code> <span class="type"><a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a></span> *QQuickRhiItem::<span class="name">createRenderer</span>()</h3>
<p>Reimplement this function to create and return a new instance of a <a href="qquickrhiitemrenderer.html" translate="no">QQuickRhiItemRenderer</a> subclass.</p>
<p>This function will be called on the rendering thread while the GUI thread is blocked.</p>
<!-- @@@createRenderer -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" translate="no" id="event"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">bool</span> QQuickRhiItem::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qquickitem.html#event" translate="no">QQuickItem::event</a>(QEvent *ev).</p>
<!-- @@@event -->
<!-- $$$geometryChange[overload1]$$$geometryChangeconstQRectF&constQRectF& -->
<h3 class="fn" translate="no" id="geometryChange"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickRhiItem::<span class="name">geometryChange</span>(const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> &amp;<i>newGeometry</i>, const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> &amp;<i>oldGeometry</i>)</h3>
<p>Reimplements: <a href="qquickitem.html#geometryChange" translate="no">QQuickItem::geometryChange</a>(const QRectF &amp;newGeometry, const QRectF &amp;oldGeometry).</p>
<!-- @@@geometryChange -->
<!-- $$$isAutoRenderTargetEnabled[overload1]$$$isAutoRenderTargetEnabled -->
<h3 class="fn" translate="no" id="isAutoRenderTargetEnabled"><code class="details extra" translate="no">[protected]</code> <span class="type">bool</span> QQuickRhiItem::<span class="name">isAutoRenderTargetEnabled</span>() const</h3>
<p>Returns the current automatic depth-stencil buffer and render target management setting.</p>
<p>By default this value is <code translate="no">true</code>.</p>
<p><b>See also </b><a href="qquickrhiitem.html#setAutoRenderTarget" translate="no">setAutoRenderTarget</a>().</p>
<!-- @@@isAutoRenderTargetEnabled -->
<!-- $$$isTextureProvider[overload1]$$$isTextureProvider -->
<h3 class="fn" translate="no" id="isTextureProvider"><code class="details extra" translate="no">[override virtual]</code> <span class="type">bool</span> QQuickRhiItem::<span class="name">isTextureProvider</span>() const</h3>
<p>Reimplements: <a href="qquickitem.html#isTextureProvider" translate="no">QQuickItem::isTextureProvider() const</a>.</p>
<!-- @@@isTextureProvider -->
<!-- $$$releaseResources[overload1]$$$releaseResources -->
<h3 class="fn" translate="no" id="releaseResources"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickRhiItem::<span class="name">releaseResources</span>()</h3>
<p>Reimplements: <a href="qquickitem.html#releaseResources" translate="no">QQuickItem::releaseResources</a>().</p>
<!-- @@@releaseResources -->
<!-- $$$setAutoRenderTarget[overload1]$$$setAutoRenderTargetbool -->
<h3 class="fn" translate="no" id="setAutoRenderTarget"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QQuickRhiItem::<span class="name">setAutoRenderTarget</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>Controls if a depth-stencil <a href="../qtgui/qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> and a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> is created and maintained automatically by the item. The default value is <code translate="no">true</code>. Call this function early on, for example from the derived class' constructor, with <i translate="no">enabled</i> set to <code translate="no">false</code> to disable this.</p>
<p>In automatic mode, the size and sample count of the depth-stencil buffer follows the color buffer texture's settings. In non-automatic mode, renderTarget() and depthStencilBuffer() always return <code translate="no">nullptr</code> and it is then up to the application's implementation of initialize() to take care of setting up and managing these objects.</p>
<!-- @@@setAutoRenderTarget -->
<!-- $$$textureProvider[overload1]$$$textureProvider -->
<h3 class="fn" translate="no" id="textureProvider"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="qsgtextureprovider.html" translate="no">QSGTextureProvider</a></span> *QQuickRhiItem::<span class="name">textureProvider</span>() const</h3>
<p>Reimplements: <a href="qquickitem.html#textureProvider" translate="no">QQuickItem::textureProvider() const</a>.</p>
<!-- @@@textureProvider -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
