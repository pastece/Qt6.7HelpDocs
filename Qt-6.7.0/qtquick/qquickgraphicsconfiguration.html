<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquickgraphicsconfiguration.cpp -->
  <meta name="description" content="QQuickGraphicsConfiguration controls lower level graphics settings for the QQuickWindow.">
  <title>QQuickGraphicsConfiguration Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QQuickGraphicsConfiguration</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#configuration-for-external-rendering-engines-or-xr-apis">Configuration for External Rendering Engines or XR APIs</a></li>
<li class="level2"><a href="#qt-quick-scene-graph-renderer-configuration">Qt Quick Scene Graph Renderer Configuration</a></li>
<li class="level2"><a href="#graphics-device-configuration">Graphics Device Configuration</a></li>
<li class="level2"><a href="#pipeline-cache-save-and-load">Pipeline Cache Save and Load</a></li>
<li class="level2"><a href="#the-automatic-pipeline-cache">The Automatic Pipeline Cache</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QQuickGraphicsConfiguration Class</h1>
<!-- $$$QQuickGraphicsConfiguration-brief -->
<p>QQuickGraphicsConfiguration controls lower level graphics settings for the <a href="qquickwindow.html" translate="no">QQuickWindow</a>. <a href="#details">More...</a></p>
<!-- @@@QQuickGraphicsConfiguration -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QQuickGraphicsConfiguration&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Quick) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr>
</table></div>
<ul>
<li><a href="qquickgraphicsconfiguration-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#QQuickGraphicsConfiguration" translate="no">QQuickGraphicsConfiguration</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#dtor.QQuickGraphicsConfiguration" translate="no">~QQuickGraphicsConfiguration</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayList </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#deviceExtensions" translate="no">deviceExtensions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#isAutomaticPipelineCacheEnabled" translate="no">isAutomaticPipelineCacheEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#isDebugLayerEnabled" translate="no">isDebugLayerEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#isDebugMarkersEnabled" translate="no">isDebugMarkersEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#isDepthBufferEnabledFor2D" translate="no">isDepthBufferEnabledFor2D</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#pipelineCacheLoadFile" translate="no">pipelineCacheLoadFile</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#pipelineCacheSaveFile" translate="no">pipelineCacheSaveFile</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#prefersSoftwareDevice" translate="no">prefersSoftwareDevice</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setAutomaticPipelineCache" translate="no">setAutomaticPipelineCache</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setDebugLayer" translate="no">setDebugLayer</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setDebugMarkers" translate="no">setDebugMarkers</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setDepthBufferFor2D" translate="no">setDepthBufferFor2D</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setDeviceExtensions" translate="no">setDeviceExtensions</a></b>(const QByteArrayList &amp;<i>extensions</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setPipelineCacheLoadFile" translate="no">setPipelineCacheLoadFile</a></b>(const QString &amp;<i>filename</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setPipelineCacheSaveFile" translate="no">setPipelineCacheSaveFile</a></b>(const QString &amp;<i>filename</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setPreferSoftwareDevice" translate="no">setPreferSoftwareDevice</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setTimestamps" translate="no">setTimestamps</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#timestampsEnabled" translate="no">timestampsEnabled</a></b>() const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.1)</code> QByteArrayList </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#preferredInstanceExtensions" translate="no">preferredInstanceExtensions</a></b>()</td></tr>
</table></div>
<!-- $$$QQuickGraphicsConfiguration-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QQuickGraphicsConfiguration class is a container for low-level graphics settings that can affect how the underlying graphics API, such as Vulkan, is initialized by the Qt Quick scene graph. It can also control certain aspects of the scene graph renderer.</p>
<div class="admonition note">
<p><b>Note: </b>Setting a QQuickGraphicsConfiguration on a <a href="qquickwindow.html" translate="no">QQuickWindow</a> must happen early enough, before the scene graph is initialized for the first time for that window. With on-screen windows this means the call must be done before invoking show() on the <a href="qquickwindow.html" translate="no">QQuickWindow</a> or <a href="qquickview.html" translate="no">QQuickView</a>. With <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a> the configuration must be finalized before calling <a href="qquickrendercontrol.html#initialize" translate="no">initialize</a>().</p>
</div>
<h3 id="configuration-for-external-rendering-engines-or-xr-apis">Configuration for External Rendering Engines or XR APIs</h3>
<p>When constructing and showing a <a href="qquickwindow.html" translate="no">QQuickWindow</a> that uses Vulkan to render, a Vulkan instance (<code translate="no">VkInstance</code>), a physical device (<code translate="no">VkPhysicalDevice</code>), a device (<code translate="no">VkDevice</code>) and associated objects (queues, pools) are initialized through the Vulkan API. The same is mostly true when using <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a> to redirect the rendering into a custom render target, such as a texture. While <a href="../qtgui/qvulkaninstance.html" translate="no">QVulkanInstance</a> construction is under the application's control then, the initialization of other graphics objects happen the same way in <a href="qquickrendercontrol.html#initialize" translate="no">QQuickRenderControl::initialize</a>() as with an on-screen <a href="qquickwindow.html" translate="no">QQuickWindow</a>.</p>
<p>For the majority of applications no additional configuration is needed because Qt Quick provides reasonable defaults for many low-level graphics settings, for example which device extensions to enable.</p>
<p>This will not alway be sufficient, however. In advanced use cases, when integrating direct Vulkan or other graphics API content, or when integrating with an external 3D or VR engine, such as, OpenXR, the application will want to specify its own set of settings when it comes to details, such as which device extensions to enable.</p>
<p>That is what this class enables. It allows specifying, for example, a list of device extensions that is then picked up by the scene graph when using Vulkan, or graphics APIs where the concept is applicable. Where some concepts are not applicable, the related settings are simply ignored.</p>
<p>Examples of functions in this category are <a href="qquickgraphicsconfiguration.html#setDeviceExtensions" translate="no">setDeviceExtensions</a>() and <a href="qquickgraphicsconfiguration.html#preferredInstanceExtensions" translate="no">preferredInstanceExtensions</a>(). The latter is useful when the application manages its own <a href="../qtgui/qvulkaninstance.html" translate="no">QVulkanInstance</a> which is then associated with the <a href="qquickwindow.html" translate="no">QQuickWindow</a> via <a href="../qtgui/qwindow.html#setVulkanInstance" translate="no">QWindow::setVulkanInstance</a>().</p>
<h3 id="qt-quick-scene-graph-renderer-configuration">Qt Quick Scene Graph Renderer Configuration</h3>
<p>Another class of settings are related to the scene graph's renderer. In some cases applications may want to control certain behavior,such as using the depth buffer when rendering 2D content. In Qt 5 such settings were either not controllable at all, or were managed through environment variables. In Qt 6, QQuickGraphicsConfiguration provides a new home for these settings, while keeping support for the legacy environment variables, where applicable.</p>
<p>An example in this category is <a href="qquickgraphicsconfiguration.html#setDepthBufferFor2D" translate="no">setDepthBufferFor2D</a>().</p>
<h3 id="graphics-device-configuration">Graphics Device Configuration</h3>
<p>When the graphics instance and device objects (for example, the VkInstance and VkDevice with Vulkan, the ID3D11Device with Direct 3D, etc.) are created by Qt when initializing a <a href="qquickwindow.html" translate="no">QQuickWindow</a>, there are settings which applications or libraries will want to control under certain circumstances.</p>
<p>Before Qt 6.5, some of such settings were available to control via environment variables. For example, <code translate="no">QSG_RHI_DEBUG_LAYER</code> or <code translate="no">QSG_RHI_PREFER_SOFTWARE_RENDERER</code>. These are still available and continue to function as before. QQuickGraphicsConfiguration provides C++ setters in addition.</p>
<p>For example, the following main() function opens a <a href="qquickview.html" translate="no">QQuickView</a> while specifying that the Vulkan validation or Direct3D debug layer should be enabled:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>argv<span class="operator">[</span><span class="operator">]</span>)
 {
     <span class="type"><a href="../qtgui/qguiapplication.html" translate="no">QGuiApplication</a></span> app(argc<span class="operator">,</span> argv);

     <span class="type"><a href="qquickgraphicsconfiguration.html#QQuickGraphicsConfiguration" translate="no">QQuickGraphicsConfiguration</a></span> config;
     config<span class="operator">.</span>setDebugLayer(<span class="keyword">true</span>);

     <span class="type"><a href="qquickview.html" translate="no">QQuickView</a></span> <span class="operator">*</span>view <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qquickview.html" translate="no">QQuickView</a></span>;
     view<span class="operator">-</span><span class="operator">&gt;</span>setGraphicsConfiguration(config);

     view<span class="operator">-</span><span class="operator">&gt;</span>setSource(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span><span class="operator">::</span>fromLocalFile(<span class="string">&quot;myqmlfile.qml&quot;</span>));
     view<span class="operator">-</span><span class="operator">&gt;</span>show();
     <span class="keyword">return</span> app<span class="operator">.</span>exec();
 }
</pre>
<h3 id="pipeline-cache-save-and-load">Pipeline Cache Save and Load</h3>
<p>Qt Quick supports storing the graphics/compute pipeline cache to disk, and reloading it in subsequent runs of an application. What exactly the pipeline cache contains, how lookups work, and what exactly gets accelerated all depend on the Qt RHI backend and the underlying native graphics API that is used at run time. Different 3D APIs have different concepts when it comes to shaders, programs, and pipeline state objects, and corresponding cache mechanisms. The high level pipeline cache concept here abstracts all this to storing and retrieving a single binary blob to and from a file.</p>
<div class="admonition note">
<p><b>Note: </b>Storing the cache on disk can lead to improvements, sometimes significant, in subsequent runs of the application.</p>
</div>
<p>When the same shader program and/or pipeline state is encountered as in a previous run, a number of operations are likely skipped, leading to faster shader and material initialization times, which means startup may become faster and lags and &quot;janks&quot; during rendering may be reduced or avoided.</p>
<p>When running with a graphics API where retrieving and reloading the pipeline cache (or shader/program binaries) is not applicable or not supported, attempting to use a file to save and load the cache has no effect.</p>
<div class="admonition note">
<p><b>Note: </b>In many cases the retrieved data is dependent on and tied to the graphics driver (and possibly the exact version of it). Qt performs the necessary checks automatically, by storing additional metadata in the pipeline cache file. If the data in the file does not match the graphics device and driver version at run time, the contents will be ignored transparently to the application. It is therefore safe to reference a cache that was generated on another device or driver.</p>
</div>
<p>There are exceptions to the driver dependency problem, most notably Direct 3D 11, where the &quot;pipeline cache&quot; is used only to store the results of runtime HLSL-&gt;DXBC compilation and is therefore device and vendor independent.</p>
<p>In some cases it may be desirable to improve the very first run of the application, by &quot;pre-seeding&quot; the cache. This is possible by shipping the cache file saved from a previous run, and referencing it on another machine or device. This way, the application or device has the shader programs/pipelines that have been encountered before in the run that saved the cache file available already during its first run. Shipping and deploying the cache file only makes sense if the device and graphics drivers are the same on the target system, otherwise the cache file is ignored if the device or driver version does not match (with the exception of D3D11), as described above.</p>
<p>Once the cache contents is loaded, there is still a chance that the application builds graphics and compute pipelines that have not been encountered in previous runs. In this cases the cache is grown, with the pipelines / shader programs added to it. If the application also chooses to save the contents (perhaps to the same file even), then both the old and new pipelines will get stored. Loading from and saving to the same file in every run allows an ever growing cache that stores all encountered pipelines and shader programs.</p>
<p>In practice the Qt pipeline cache can be expected to map to the following native graphics API features:</p>
<ul>
<li>Vulkan - <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html" translate="no">VkPipelineCache</a> - Saving the pipeline cache effectively stores the blob retrieved from <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html" translate="no">vkGetPipelineCacheData</a>, with additional metadata to safely identify the device and the driver since the pipeline cache blob is dependent on the exact driver.</li>
<li>Metal - <a href="https://developer.apple.com/documentation/metal/mtlbinaryarchive?language=objc" translate="no">MTLBinaryArchive</a> - With pipeline cache saving enabled, Qt stores all render and compute pipelines encountered into an MTLBinaryArchive. Saving the pipeline cache stores the blob retrieved from the archive, with additional metadata to identify the device. <b>Note:</b> currently MTLBinaryArchive usage is disabled on macOS and iOS due to various issues on some hardware and OS versions.</li>
<li>OpenGL - There is no native concept of pipelines, the &quot;pipeline cache&quot; stores a collection of program binaries retrieved via <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml" translate="no">glGetProgramBinary</a>. The program binaries are packaged into a single blob, with additional metadata to identify the device, driver, and its version that the binaries were retrieved from. Persistent caching of program binaries is not new in Qt: Qt 5 already had similar functionality in <a href="../qtopengl/qopenglshaderprogram.html" translate="no">QOpenGLShaderProgram</a>, see <a href="../qtopengl/qopenglshaderprogram.html#addCacheableShaderFromSourceCode" translate="no">addCacheableShaderFromSourceCode</a>() for example. In fact that mechanism is always active in Qt 6 as well when using Qt Quick with OpenGL. However, when using the new, graphics API independent pipeline cache abstraction provided here, the Qt 5 era program binary cache gets automatically disabled, since the same content is packaged in the &quot;pipeline cache&quot; now.</li>
<li>Direct 3D 11 - There is no native concept of pipelines or retrieving binaries for the second phase compilation (where the vendor independent, intermediate bytecode is compiled into the device specific instruction set). Drivers will typically employ their own caching system on that level. Instead, the Qt Quick &quot;pipeline cache&quot; is used to speed up cases where the shaders contain HLSL source code that needs to be compiled into the intermediate bytecode format first. This can present significant performance improvements in application and libraries that compose shader code at run time, because in subsequent runs the potentially expensive, uncached calls to <a href="https://docs.microsoft.com/en-us/windows/win32/api/d3dcompiler/nf-d3dcompiler-d3dcompile" translate="no">D3DCompile()</a> can be avoided if the bytecode is already available for the encountered HLSL shader. A good example is Qt Quick 3D, where the runtime-generated shaders for materials imply having to deal with HLSL source code. Saving and reloading the Qt Quick pipeline cache can therefore bring considerable improvements in scenes with one or more <a href="../qtquick3d/qml-qtquick3d-view3d.html" translate="no">View3D</a> items in them. A counterexample may be Qt Quick itself: as most built-in shaders for 2D content ship with DirectX bytecode generated at build time, the cache is not going to present any significant improvements.</li>
</ul>
<p>All this is independent from the shader processing performed by the <a href="../qtshadertools/qtshadertools-index.html" translate="no">Qt Shader Tools</a> module and its command-line tools such as <code translate="no">qsb</code>. As an example, take Vulkan. Having the Vulkan-compatible GLSL source code compiled to SPIR-V either at offline or build time (directly via qsb or CMake) is good, because the expensive compilation from source form is avoided at run time. SPIR-V is however a vendor-independent intermediate format. At runtime, when constructing graphics or compute pipelines, there is likely another round of compilation happening, this time from the intermediate format to the vendor-specific instruction set of the GPU (and this may be dependent on certain state in the graphics pipeline and the render targets as well). The pipeline cache helps with this latter phase.</p>
<div class="admonition note">
<p><b>Note: </b>Many graphics API implementation employ their own persistent disk cache transparently to the applications. Using the pipeline cache feature of Qt Quick will likely provide improvements in this case, but the gains might be smaller.</p>
</div>
<p>Call <a href="qquickgraphicsconfiguration.html#setPipelineCacheSaveFile" translate="no">setPipelineCacheSaveFile</a>() and <a href="qquickgraphicsconfiguration.html#setPipelineCacheLoadFile" translate="no">setPipelineCacheLoadFile</a>() to control which files a <a href="qquickwindow.html" translate="no">QQuickWindow</a> or <a href="qquickview.html" translate="no">QQuickView</a> saves and loads the pipeline cache to/from.</p>
<p>To get an idea of the effects of enabling disk storage of the pipeline cache, enable the most important scenegraph and graphics logs either via the environment variable <code translate="no">QSG_INFO=1</code>, or both the <code translate="no">qt.scenegraph.general</code> and <code translate="no">qt.rhi.general</code> logging categories. When closing the <a href="qquickwindow.html" translate="no">QQuickWindow</a>, there is log message like the following:</p>
<pre class="cpp plain" translate="no">
 Total time spent on pipeline creation during the lifetime of the QRhi was 123 ms
</pre>
<p>This gives an approximate idea of how much time was spent in graphics and compute pipeline creation (which may include various stages of shader compilation) during the lifetime of the window.</p>
<p>When loading from a pipeline cache file is enabled, this is confirmed with a message:</p>
<pre class="cpp plain" translate="no">
 Attempting to seed pipeline cache from 'filename'
</pre>
<p>Similarly, to check if saving of the cache is successfully enabled, look for a message such as this:</p>
<pre class="cpp plain" translate="no">
 Writing pipeline cache contents to 'filename'
</pre>
<h3 id="the-automatic-pipeline-cache">The Automatic Pipeline Cache</h3>
<p>When no filename is provided for save and load, the automatic pipeline caching strategy is used. This involves storing data to the application-specific cache location of the system (<a href="../qtcore/qstandardpaths.html#StandardLocation-enum" translate="no">QStandardPaths::CacheLocation</a>).</p>
<p>This can be disabled by one of the following means:</p>
<ul>
<li>Set the application attribute <a href="../qtcore/qt.html#ApplicationAttribute-enum" translate="no">Qt::AA_DisableShaderDiskCache</a>. (completely disables the automatic storage)</li>
<li>Set the environment variable QT_DISABLE_SHADER_DISK_CACHE to a non-zero value. (completely disables the automatic storage)</li>
<li>Set the environment variable QSG_RHI_DISABLE_SHADER_DISK_CACHE to a non-zero value. (completely disables the automatic storage)</li>
<li>Call setAutomaticPiplineCache() with the enable argument set to false. (completely disables the automatic storage)</li>
<li>Set a filename by calling <a href="qquickgraphicsconfiguration.html#setPipelineCacheLoadFile" translate="no">setPipelineCacheLoadFile</a>(). (only disables loading from the automatic storage, prefering the specified file instead)</li>
<li>Set a filename by calling <a href="qquickgraphicsconfiguration.html#setPipelineCacheSaveFile" translate="no">setPipelineCacheSaveFile</a>(). (only disables writing to the automatic storage, prefering the specified file instead)</li>
</ul>
<p>The first two are existing mechanisms that are used since Qt 5.9 to control the OpenGL program binary cache. For compatibility and familiarity the same attribute and environment variable are supported for Qt 6's enhanced pipeline cache.</p>
<p>The automatic pipeline cache uses a single file per application, but a different one for each RHI backend (graphics API). This means that changing to another graphics API in the next run of the application will not lead to losing the pipeline cache generated in the previous run. Applications with multiple <a href="qquickwindow.html" translate="no">QQuickWindow</a> instances shown simultaneously may however not benefit 100% since the automatic cache can only store the data collected from one RHI object at a time. (and with the default <code translate="no">threaded</code> render loop each window has its own RHI as rendering operates independently on dedicated threads). To fully benefit from the disk cache in application with multiple windows, prefer setting the filename explicitly, per-window via <a href="qquickgraphicsconfiguration.html#setPipelineCacheSaveFile" translate="no">setPipelineCacheSaveFile</a>().</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#setGraphicsConfiguration" translate="no">QQuickWindow::setGraphicsConfiguration</a>(), <a href="qquickwindow.html" translate="no">QQuickWindow</a>, and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@QQuickGraphicsConfiguration -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickGraphicsConfiguration[overload1]$$$QQuickGraphicsConfiguration -->
<h3 class="fn" translate="no" id="QQuickGraphicsConfiguration">QQuickGraphicsConfiguration::<span class="name">QQuickGraphicsConfiguration</span>()</h3>
<p>Constructs a default QQuickGraphicsConfiguration that does not specify any additional settings for the scene graph to take into account.</p>
<!-- @@@QQuickGraphicsConfiguration -->
<!-- $$$~QQuickGraphicsConfiguration[overload1]$$$~QQuickGraphicsConfiguration -->
<h3 class="fn" translate="no" id="dtor.QQuickGraphicsConfiguration"><code class="details extra" translate="no">[noexcept]</code> QQuickGraphicsConfiguration::<span class="name">~QQuickGraphicsConfiguration</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QQuickGraphicsConfiguration -->
<!-- $$$deviceExtensions[overload1]$$$deviceExtensions -->
<h3 class="fn" translate="no" id="deviceExtensions"><span class="type"><a href="../qtcore/qbytearraylist.html" translate="no">QByteArrayList</a></span> QQuickGraphicsConfiguration::<span class="name">deviceExtensions</span>() const</h3>
<p>Returns the list of the requested additional device extensions.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#setDeviceExtensions" translate="no">setDeviceExtensions</a>().</p>
<!-- @@@deviceExtensions -->
<!-- $$$isAutomaticPipelineCacheEnabled[overload1]$$$isAutomaticPipelineCacheEnabled -->
<h3 class="fn" translate="no" id="isAutomaticPipelineCacheEnabled"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">bool</span> QQuickGraphicsConfiguration::<span class="name">isAutomaticPipelineCacheEnabled</span>() const</h3>
<p>Returns true if the automatic pipeline cache is enabled.</p>
<p>By default this is true, unless certain application attributes or environment variables are set. See <a href="qquickgraphicsconfiguration.html#the-automatic-pipeline-cache" translate="no">The Automatic Pipeline Cache</a> for more information.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#setAutomaticPipelineCache" translate="no">setAutomaticPipelineCache</a>().</p>
<!-- @@@isAutomaticPipelineCacheEnabled -->
<!-- $$$isDebugLayerEnabled[overload1]$$$isDebugLayerEnabled -->
<h3 class="fn" translate="no" id="isDebugLayerEnabled"><span class="type">bool</span> QQuickGraphicsConfiguration::<span class="name">isDebugLayerEnabled</span>() const</h3>
<p>Returns true if the debug/validation layers are to be enabled.</p>
<p>By default the value is false.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#setDebugLayer" translate="no">setDebugLayer</a>().</p>
<!-- @@@isDebugLayerEnabled -->
<!-- $$$isDebugMarkersEnabled[overload1]$$$isDebugMarkersEnabled -->
<h3 class="fn" translate="no" id="isDebugMarkersEnabled"><span class="type">bool</span> QQuickGraphicsConfiguration::<span class="name">isDebugMarkersEnabled</span>() const</h3>
<p>Returns true if debug markers are enabled.</p>
<p>By default the value is false.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#setDebugMarkers" translate="no">setDebugMarkers</a>().</p>
<!-- @@@isDebugMarkersEnabled -->
<!-- $$$isDepthBufferEnabledFor2D[overload1]$$$isDepthBufferEnabledFor2D -->
<h3 class="fn" translate="no" id="isDepthBufferEnabledFor2D"><span class="type">bool</span> QQuickGraphicsConfiguration::<span class="name">isDepthBufferEnabledFor2D</span>() const</h3>
<p>Returns true if depth buffer usage is enabled for 2D content.</p>
<p>By default the value is true, unless the <code translate="no">QSG_NO_DEPTH_BUFFER</code> environment variable is set.</p>
<!-- @@@isDepthBufferEnabledFor2D -->
<!-- $$$pipelineCacheLoadFile[overload1]$$$pipelineCacheLoadFile -->
<h3 class="fn" translate="no" id="pipelineCacheLoadFile"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QQuickGraphicsConfiguration::<span class="name">pipelineCacheLoadFile</span>() const</h3>
<p>Returns the currently set filename for loading the pipeline cache.</p>
<p>By default the value is an empty string.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#setPipelineCacheLoadFile" translate="no">setPipelineCacheLoadFile</a>().</p>
<!-- @@@pipelineCacheLoadFile -->
<!-- $$$pipelineCacheSaveFile[overload1]$$$pipelineCacheSaveFile -->
<h3 class="fn" translate="no" id="pipelineCacheSaveFile"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QQuickGraphicsConfiguration::<span class="name">pipelineCacheSaveFile</span>() const</h3>
<p>Returns the currently set filename for storing the pipeline cache.</p>
<p>By default the value is an empty string.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#setPipelineCacheSaveFile" translate="no">setPipelineCacheSaveFile</a>().</p>
<!-- @@@pipelineCacheSaveFile -->
<!-- $$$preferredInstanceExtensions[overload1]$$$preferredInstanceExtensions -->
<h3 class="fn" translate="no" id="preferredInstanceExtensions"><code class="details extra" translate="no">[static, since 6.1]</code> <span class="type"><a href="../qtcore/qbytearraylist.html" translate="no">QByteArrayList</a></span> QQuickGraphicsConfiguration::<span class="name">preferredInstanceExtensions</span>()</h3>
<p>Returns the list of Vulkan instance extensions Qt Quick prefers to have enabled on the VkInstance.</p>
<p>In most cases Qt Quick is responsible for creating a <a href="../qtgui/qvulkaninstance.html" translate="no">QVulkanInstance</a>. This function is not relevant then. On the other hand, when using <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a> in combination with Vulkan-based rendering, it is the application's responsibility to create a <a href="../qtgui/qvulkaninstance.html" translate="no">QVulkanInstance</a> and associate it with the (offscreen) <a href="qquickwindow.html" translate="no">QQuickWindow</a>. In this case, it is expected that the application queries the list of instance extensions to enable, and passes them to <a href="../qtgui/qvulkaninstance.html#setExtensions" translate="no">QVulkanInstance::setExtensions</a>() before calling <a href="../qtgui/qvulkaninstance.html#create" translate="no">QVulkanInstance::create</a>().</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@preferredInstanceExtensions -->
<!-- $$$prefersSoftwareDevice[overload1]$$$prefersSoftwareDevice -->
<h3 class="fn" translate="no" id="prefersSoftwareDevice"><span class="type">bool</span> QQuickGraphicsConfiguration::<span class="name">prefersSoftwareDevice</span>() const</h3>
<p>Returns true if a software rasterizer-based graphics device is prioritized.</p>
<p>By default the value is false.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#setPreferSoftwareDevice" translate="no">setPreferSoftwareDevice</a>().</p>
<!-- @@@prefersSoftwareDevice -->
<!-- $$$setAutomaticPipelineCache[overload1]$$$setAutomaticPipelineCachebool -->
<h3 class="fn" translate="no" id="setAutomaticPipelineCache"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setAutomaticPipelineCache</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Changes the usage of the automatic pipeline cache based on <i translate="no">enable</i>.</p>
<p>The default value is true, unless certain application attributes or environment variables are set. See <a href="qquickgraphicsconfiguration.html#the-automatic-pipeline-cache" translate="no">The Automatic Pipeline Cache</a> for more information.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#isAutomaticPipelineCacheEnabled" translate="no">isAutomaticPipelineCacheEnabled</a>().</p>
<!-- @@@setAutomaticPipelineCache -->
<!-- $$$setDebugLayer[overload1]$$$setDebugLayerbool -->
<h3 class="fn" translate="no" id="setDebugLayer"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setDebugLayer</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Enables the graphics API implementation's debug or validation layers, if available.</p>
<p>In practice this is supported with Vulkan and Direct 3D 11, assuming the necessary support (validation layers, Windows SDK) is installed and available at runtime. When <i translate="no">enable</i> is true, Qt will attempt to enable the standard validation layer on the VkInstance, or set <code translate="no">D3D11_CREATE_DEVICE_DEBUG</code> on the graphics device.</p>
<p>For Metal on macOS, set the environment variable <code translate="no">METAL_DEVICE_WRAPPER_TYPE=1</code> instead before launching the application.</p>
<p>Calling this function with <i translate="no">enable</i> set to true is equivalent to setting the environment variable <code translate="no">QSG_RHI_DEBUG_LAYER</code> to a non-zero value.</p>
<p>The default value is false.</p>
<div class="admonition note">
<p><b>Note: </b>Enabling debug or validation layers may have a non-insignificant performance impact. Shipping applications to production with the flag enabled is strongly discouraged.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Be aware that due to differences in the design of the underlying graphics APIs, this setting cannot always be a per-<a href="qquickwindow.html" translate="no">QQuickWindow</a> setting, even though each <a href="qquickwindow.html" translate="no">QQuickWindow</a> has their own <a href="qquickgraphicsconfiguration.html" translate="no">QQuickGraphicsConfiguration</a>. With Vulkan in particular, the instance object (VkInstance) is only created once and then used by all windows in the application. Therefore, enabling the validation layer is something that affects all windows. This also means that attempting to enable validation via a window that only gets shown after some other windows have already started rendering has no effect with Vulkan. Other APIs, such as D3D11, expose the debug layer concept as a per-device (ID3D11Device) setting, and so it is controlled on a true per-window basis (assuming the scenegraph render loop uses a dedicated graphics device/context for each <a href="qquickwindow.html" translate="no">QQuickWindow</a>).</p>
</div>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#isDebugLayerEnabled" translate="no">isDebugLayerEnabled</a>().</p>
<!-- @@@setDebugLayer -->
<!-- $$$setDebugMarkers[overload1]$$$setDebugMarkersbool -->
<h3 class="fn" translate="no" id="setDebugMarkers"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setDebugMarkers</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Where applicable, <i translate="no">enable</i> controls inserting debug markers and object names into the graphics command stream.</p>
<p>Some frameworks, such as Qt Quick 3D, have the ability to annotate the graphics objects they create (buffers, textures) with names and also indicate the beginning and end of render passes in the command buffer. These are then visible in frame captures made with tools like <a href="https://renderdoc.org/" translate="no">RenderDoc</a> or XCode.</p>
<p>Graphics APIs where this can be expected to be supported are Vulkan (if VK_EXT_debug_utils is available), Direct 3D 11, and Metal.</p>
<p>Calling this function with <i translate="no">enable</i> set to true is equivalent to setting the environment variable <code translate="no">QSG_RHI_PROFILE</code> to a non-zero value.</p>
<p>The default value is false.</p>
<div class="admonition note">
<p><b>Note: </b>Enabling debug markers may have a performance impact. Shipping applications to production with the flag enabled is not recommended.</p>
</div>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#isDebugMarkersEnabled" translate="no">isDebugMarkersEnabled</a>().</p>
<!-- @@@setDebugMarkers -->
<!-- $$$setDepthBufferFor2D[overload1]$$$setDepthBufferFor2Dbool -->
<h3 class="fn" translate="no" id="setDepthBufferFor2D"><span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setDepthBufferFor2D</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Sets the usage of depth buffer for 2D content to <i translate="no">enable</i>. When disabled, the Qt Quick scene graph never writes into the depth buffer.</p>
<p>By default the value is true, unless the <code translate="no">QSG_NO_DEPTH_BUFFER</code> environment variable is set.</p>
<p>The default value of true is the most optimal setting for the vast majority of scenes. Disabling depth buffer usage reduces the efficiency of the scene graph's batching.</p>
<p>There are cases however, when allowing the 2D content write to the depth buffer is not ideal. Consider a 3D scene as an &quot;overlay&quot; on top the 2D scene, rendered via Qt Quick 3D using a <a href="../qtquick3d/qml-qtquick3d-view3d.html" translate="no">View3D</a> with <a href="../qtquick3d/qml-qtquick3d-view3d.html#renderMode-prop" translate="no">renderMode</a> set to <code translate="no">Overlay</code>. In this case, having the depth buffer filled by 2D content can cause unexpected results. This is because the way the 2D scene graph renderer generates and handles depth values is not necessarily compatible with how a 3D scene works. This may end up in depth value clashes, collisions, and unexpected depth test failures. Therefore, the robust approach here is to call this function with <i translate="no">enable</i> set to false, and disable depth buffer writes for the 2D content in the <a href="qquickwindow.html" translate="no">QQuickWindow</a>.</p>
<div class="admonition note">
<p><b>Note: </b>This flag is not fully identical to setting the <code translate="no">QSG_NO_DEPTH_BUFFER</code> environment variable. This flag does not control the depth-stencil buffers' presence. It is rather relevant for the rendering pipeline. To force not having depth/stencil attachments at all, set <code translate="no">QSG_NO_DEPTH_BUFFER</code> and <code translate="no">QSG_NO_STENCIL_BUFFER</code>. Be aware however that such a <a href="qquickwindow.html" translate="no">QQuickWindow</a>, and any Item layers in it, may then become incompatible with items, such as <a href="../qtquick3d/qml-qtquick3d-view3d.html" translate="no">View3D</a> with certain operating modes, because 3D content requires a depth buffer. Calling this function is always safe, but can mean that resources, such as depth buffers, are created even though they are not actively used.</p>
</div>
<!-- @@@setDepthBufferFor2D -->
<!-- $$$setDeviceExtensions[overload1]$$$setDeviceExtensionsconstQByteArrayList& -->
<h3 class="fn" translate="no" id="setDeviceExtensions"><span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setDeviceExtensions</span>(const <span class="type"><a href="../qtcore/qbytearraylist.html" translate="no">QByteArrayList</a></span> &amp;<i>extensions</i>)</h3>
<p>Sets the list of additional <i translate="no">extensions</i> to enable on the graphics device (such as, the <code translate="no">VkDevice</code>).</p>
<p>When rendering with a graphics API where the concept is not applicable, <i translate="no">extensions</i> will be ignored.</p>
<div class="admonition note">
<p><b>Note: </b>The list specifies additional, extra extensions. Qt Quick always enables extensions that are required by the scene graph.</p>
</div>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#deviceExtensions" translate="no">deviceExtensions</a>().</p>
<!-- @@@setDeviceExtensions -->
<!-- $$$setPipelineCacheLoadFile[overload1]$$$setPipelineCacheLoadFileconstQString& -->
<h3 class="fn" translate="no" id="setPipelineCacheLoadFile"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setPipelineCacheLoadFile</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>filename</i>)</h3>
<p>Sets the <i translate="no">filename</i> where the <a href="qquickwindow.html" translate="no">QQuickWindow</a> is expected to load the initial contents of its graphics/compute pipeline cache from. The default value is empty, which means pipeline cache loading is disabled.</p>
<p>See <a href="qquickgraphicsconfiguration.html#pipeline-cache-save-and-load" translate="no">Pipeline Cache Save and Load</a> for a discussion on pipeline caches.</p>
<p>Persistently storing the pipeline cache can lead to performance improvements in future runs of the application since expensive shader compilation and pipeline construction steps may be avoided.</p>
<p>If and when the loading of the file's contents happens is not defined, apart from that it will happen at some point during the initialization of the scenegraph of the <a href="qquickwindow.html" translate="no">QQuickWindow</a>. Therefore, the file must continue to exist after calling this function. <a href="qquickgraphicsconfiguration.html" translate="no">QQuickGraphicsConfiguration</a> only stores the filename, it cannot perform any actual I/O and graphics operations on its own. The real work is going to happen later on, possibly on another thread.</p>
<p>When running with a graphics API where retrieving and reloading the pipeline cache (or shader/program binaries) is not applicable or not supported, calling this function has no effect.</p>
<p>Calling this function is mostly equivalent to setting the environment variable <code translate="no">QSG_RHI_PIPELINE_CACHE_LOAD</code> to <i translate="no">filename</i>, with one important difference: this function controls the pipeline cache storage for the associated <a href="qquickwindow.html" translate="no">QQuickWindow</a> only. Applications with multiple <a href="qquickwindow.html" translate="no">QQuickWindow</a> or <a href="qquickview.html" translate="no">QQuickView</a> instances can therefore store and later reload the cache contents via files dedicated to each window. The environment variable does not allow this.</p>
<div class="admonition note">
<p><b>Note: </b>If the data in the file does not match the graphics device and driver version at run time, the contents will be ignored, transparently to the application. This applies to a number of graphics APIs, and the necessary checks are taken care of by Qt. There are exceptions, most notably Direct 3D 11, where the &quot;pipeline cache&quot; is used only to store the results of runtime HLSL-&gt;DXBC compilation and is therefore device and vendor independent.</p>
</div>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#pipelineCacheLoadFile" translate="no">pipelineCacheLoadFile</a>() and <a href="qquickgraphicsconfiguration.html#setPipelineCacheSaveFile" translate="no">setPipelineCacheSaveFile</a>().</p>
<!-- @@@setPipelineCacheLoadFile -->
<!-- $$$setPipelineCacheSaveFile[overload1]$$$setPipelineCacheSaveFileconstQString& -->
<h3 class="fn" translate="no" id="setPipelineCacheSaveFile"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setPipelineCacheSaveFile</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>filename</i>)</h3>
<p>Sets the <i translate="no">filename</i> where the <a href="qquickwindow.html" translate="no">QQuickWindow</a> is expected to store its graphics/compute pipeline cache contents. The default value is empty, which means pipeline cache loading is disabled.</p>
<p>See <a href="qquickgraphicsconfiguration.html#pipeline-cache-save-and-load" translate="no">Pipeline Cache Save and Load</a> for a discussion on pipeline caches.</p>
<p>Persistently storing the pipeline cache can lead to performance improvements in future runs of the application since expensive shader compilation and pipeline construction steps may be avoided.</p>
<p>If and when the writing of the file happens is not defined. It will likely happen at some point when tearing down the scenegraph due to closing the window. Therefore, applications should not assume availability of the file until the <a href="qquickwindow.html" translate="no">QQuickWindow</a> is fully destructed. <a href="qquickgraphicsconfiguration.html" translate="no">QQuickGraphicsConfiguration</a> only stores the filename, it does not perform any actual I/O and graphics operations on its own.</p>
<p>When running with a graphics API where retrieving the pipeline cache (or shader/program binaries) is not applicable or not supported, calling this function has no effect.</p>
<p>Calling this function is mostly equivalent to setting the environment variable <code translate="no">QSG_RHI_PIPELINE_CACHE_SAVE</code> to <i translate="no">filename</i>, with one important difference: this function controls the pipeline cache storage for the associated <a href="qquickwindow.html" translate="no">QQuickWindow</a> only. Applications with multiple <a href="qquickwindow.html" translate="no">QQuickWindow</a> or <a href="qquickview.html" translate="no">QQuickView</a> instances can therefore store and later reload the cache contents via files dedicated to each window. The environment variable does not allow this.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#pipelineCacheSaveFile" translate="no">pipelineCacheSaveFile</a>(), <a href="qquickgraphicsconfiguration.html#pipelineCacheLoadFile" translate="no">pipelineCacheLoadFile</a>(), and setPipelineCacheSaveFile().</p>
<!-- @@@setPipelineCacheSaveFile -->
<!-- $$$setPreferSoftwareDevice[overload1]$$$setPreferSoftwareDevicebool -->
<h3 class="fn" translate="no" id="setPreferSoftwareDevice"><code class="details extra" translate="no">[since 6.5]</code> <span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setPreferSoftwareDevice</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Requests choosing an adapter or physical device that uses software-based rasterization. Applicable only when the underlying API has support for enumerating adapters (for example, Direct 3D or Vulkan), and is ignored otherwise.</p>
<p>If the graphics API implementation has no such graphics adapter or physical device available, the request is ignored. With Direct 3D it can be expected that a <a href="https://docs.microsoft.com/en-us/windows/win32/direct3darticles/directx-warp" translate="no">WARP</a>-based rasterizer is always available. With Vulkan, the flag only has an effect if Mesa's <code translate="no">lavapipe</code>, or some other physical device reporting <code translate="no">VK_PHYSICAL_DEVICE_TYPE_CPU</code> is available.</p>
<p>Calling this function with <i translate="no">enable</i> set to true is equivalent to setting the environment variable <code translate="no">QSG_RHI_PREFER_SOFTWARE_RENDERER</code> to a non-zero value.</p>
<p>The default value is false.</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#prefersSoftwareDevice" translate="no">prefersSoftwareDevice</a>().</p>
<!-- @@@setPreferSoftwareDevice -->
<!-- $$$setTimestamps[overload1]$$$setTimestampsbool -->
<h3 class="fn" translate="no" id="setTimestamps"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setTimestamps</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>When enabled, GPU timing data is collected from command buffers on platforms and 3D APIs where this is supported. This data is then printed in the renderer logs that can be enabled via <code translate="no">QSG_RENDER_TIMING</code> environment variable or logging categories such as <code translate="no">qt.scenegraph.time.renderloop</code>, and may also be made visible to other modules, such as Qt Quick 3D's <a href="../qtquick3d/qml-qtquick3d-helpers-debugview.html" translate="no">DebugView</a> item.</p>
<p>By default this is disabled, because collecting the data may involve additional work, such as inserting timestamp queries in the command stream, depending on the underlying graphics API. To enable, either call this function with <i translate="no">enable</i> set to true, or set the <code translate="no">QSG_RHI_PROFILE</code> environment variable to a non-zero value.</p>
<p>Graphics APIs where this can be expected to be supported are Direct 3D 11, Direct 3D 12, Vulkan (as long as the underlying Vulkan implementation supports timestamp queries), Metal, and OpenGL with a core or compatibility profile context for version 3.3 or newer. Timestamps are not supported with OpenGL ES.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#timestampsEnabled" translate="no">timestampsEnabled</a>() and <a href="qquickgraphicsconfiguration.html#setDebugMarkers" translate="no">setDebugMarkers</a>().</p>
<!-- @@@setTimestamps -->
<!-- $$$timestampsEnabled[overload1]$$$timestampsEnabled -->
<h3 class="fn" translate="no" id="timestampsEnabled"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">bool</span> QQuickGraphicsConfiguration::<span class="name">timestampsEnabled</span>() const</h3>
<p>Returns true if GPU timing collection is enabled.</p>
<p>By default the value is false.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#setTimestamps" translate="no">setTimestamps</a>().</p>
<!-- @@@timestampsEnabled -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
