<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qsgnode.cpp -->
  <meta name="description" content="The QSGNode class is the base class for all nodes in the scene graph.">
  <title>QSGNode Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QSGNode</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QSGNode Class</h1>
<!-- $$$QSGNode-brief -->
<p>The QSGNode class is the base class for all nodes in the scene graph. <a href="#details">More...</a></p>
<!-- @@@QSGNode -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QSGNode&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Quick) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qsgbasicgeometrynode.html" translate="no">QSGBasicGeometryNode</a>, <a href="qsgopacitynode.html" translate="no">QSGOpacityNode</a>, <a href="qsgrendernode.html" translate="no">QSGRenderNode</a>, and <a href="qsgtransformnode.html" translate="no">QSGTransformNode</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qsgnode-members.html">List of all members, including inherited members</a></li>
<li>QSGNode is part of <a href="qtquick-scenegraph-nodes.html">Qt Quick Scene Graph Node classes</a>.</li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#DirtyStateBit-enum" translate="no">DirtyState</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#DirtyStateBit-enum" translate="no">DirtyStateBit</a></b> { DirtyMatrix, DirtyNodeAdded, DirtyNodeRemoved, DirtyGeometry, DirtyMaterial, &hellip;, DirtySubtreeBlocked }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#Flag-enum" translate="no">Flag</a></b> { OwnedByParent, UsePreprocess, OwnsGeometry, OwnsMaterial, OwnsOpaqueMaterial, InternalReserved }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#Flag-enum" translate="no">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#NodeType-enum" translate="no">NodeType</a></b> { BasicNodeType, GeometryNodeType, TransformNodeType, ClipNodeType, OpacityNodeType, RenderNodeType }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#dtor.QSGNode" translate="no">~QSGNode</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#appendChildNode" translate="no">appendChildNode</a></b>(QSGNode *<i>node</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGNode *</td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#childAtIndex" translate="no">childAtIndex</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#childCount" translate="no">childCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGNode *</td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#firstChild" translate="no">firstChild</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGNode::Flags </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#insertChildNodeAfter" translate="no">insertChildNodeAfter</a></b>(QSGNode *<i>node</i>, QSGNode *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#insertChildNodeBefore" translate="no">insertChildNodeBefore</a></b>(QSGNode *<i>node</i>, QSGNode *<i>before</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#isSubtreeBlocked" translate="no">isSubtreeBlocked</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGNode *</td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#lastChild" translate="no">lastChild</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#markDirty" translate="no">markDirty</a></b>(QSGNode::DirtyState <i>bits</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGNode *</td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#nextSibling" translate="no">nextSibling</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGNode *</td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#parent" translate="no">parent</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#prependChildNode" translate="no">prependChildNode</a></b>(QSGNode *<i>node</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#preprocess" translate="no">preprocess</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGNode *</td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#previousSibling" translate="no">previousSibling</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#removeAllChildNodes" translate="no">removeAllChildNodes</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#removeChildNode" translate="no">removeChildNode</a></b>(QSGNode *<i>node</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#setFlag" translate="no">setFlag</a></b>(QSGNode::Flag <i>f</i>, bool <i>enabled</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#setFlags" translate="no">setFlags</a></b>(QSGNode::Flags <i>f</i>, bool <i>enabled</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGNode::NodeType </td><td class="memItemRight bottomAlign"><b><a href="qsgnode.html#type" translate="no">type</a></b>() const</td></tr>
</table></div>
<!-- $$$QSGNode-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QSGNode class can be used as a child container. Children are added with the <a href="qsgnode.html#appendChildNode" translate="no">appendChildNode</a>(), <a href="qsgnode.html#prependChildNode" translate="no">prependChildNode</a>(), <a href="qsgnode.html#insertChildNodeBefore" translate="no">insertChildNodeBefore</a>() and <a href="qsgnode.html#insertChildNodeAfter" translate="no">insertChildNodeAfter</a>(). The order of nodes is important as geometry nodes are rendered according to their ordering in the scene graph.</p>
<p>The scene graph nodes contain a mechanism that describes which parts of the scene have changed. This includes the combined matrices, accumulated opacity, changes to the node hierarchy, and so on. This information can be used for optimizations inside the scene graph renderer. For the renderer to properly render the nodes, it is important that users call <a href="qsgnode.html#markDirty" translate="no">QSGNode::markDirty</a>() with the correct flags when nodes are changed. Most of the functions on the node classes will implicitly call <a href="qsgnode.html#markDirty" translate="no">markDirty</a>(). For example, <a href="qsgnode.html#appendChildNode" translate="no">QSGNode::appendChildNode</a>() will call <a href="qsgnode.html#markDirty" translate="no">markDirty</a>() passing in <a href="qsgnode.html#DirtyStateBit-enum" translate="no">QSGNode::DirtyNodeAdded</a>.</p>
<p>If nodes change every frame, the <a href="qsgnode.html#preprocess" translate="no">preprocess</a>() function can be used to apply changes to a node for every frame it is rendered. The use of <a href="qsgnode.html#preprocess" translate="no">preprocess</a>() must be explicitly enabled by setting the <a href="qsgnode.html#Flag-enum" translate="no">QSGNode::UsePreprocess</a> flag on the node.</p>
<p>The virtual <a href="qsgnode.html#isSubtreeBlocked" translate="no">isSubtreeBlocked</a>() function can be used to disable a subtree all together. Nodes in a blocked subtree will not be preprocessed() and not rendered.</p>
<div class="admonition note">
<p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a> for more information.</p>
</div>
</div>
<!-- @@@QSGNode -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$DirtyStateBit$$$DirtySubtreeBlocked$$$DirtyMatrix$$$DirtyNodeAdded$$$DirtyNodeRemoved$$$DirtyGeometry$$$DirtyMaterial$$$DirtyOpacity$$$DirtyForceUpdate$$$DirtyUsePreprocess$$$DirtyPropagationMask -->
<h3 class="flags" id="DirtyStateBit-enum">enum QSGNode::<span class="name">DirtyStateBit</span><br/>flags QSGNode::<span class="name">DirtyState</span></h3>
<p>Used in <a href="qsgnode.html#markDirty" translate="no">QSGNode::markDirty</a>() to indicate how the scene graph has changed.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::DirtyMatrix</code></td><td class="topAlign tblval"><code translate="no">0x0100</code></td><td class="topAlign">The matrix in a <a href="qsgtransformnode.html" translate="no">QSGTransformNode</a> has changed.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::DirtyNodeAdded</code></td><td class="topAlign tblval"><code translate="no">0x0400</code></td><td class="topAlign">A node was added.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::DirtyNodeRemoved</code></td><td class="topAlign tblval"><code translate="no">0x0800</code></td><td class="topAlign">A node was removed.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::DirtyGeometry</code></td><td class="topAlign tblval"><code translate="no">0x1000</code></td><td class="topAlign">The geometry of a <a href="qsggeometrynode.html" translate="no">QSGGeometryNode</a> has changed.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::DirtyMaterial</code></td><td class="topAlign tblval"><code translate="no">0x2000</code></td><td class="topAlign">The material of a <a href="qsggeometrynode.html" translate="no">QSGGeometryNode</a> has changed.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::DirtyOpacity</code></td><td class="topAlign tblval"><code translate="no">0x4000</code></td><td class="topAlign">The opacity of a <a href="qsgopacitynode.html" translate="no">QSGOpacityNode</a> has changed.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::DirtySubtreeBlocked</code></td><td class="topAlign tblval"><code translate="no">0x0080</code></td><td class="topAlign">The subtree has been blocked.</td></tr>
</table></div>
<p>The DirtyState type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;DirtyStateBit&gt;. It stores an OR combination of DirtyStateBit values.</p>
<p><b>See also </b><a href="qsgnode.html#markDirty" translate="no">QSGNode::markDirty</a>().</p>
<!-- @@@DirtyStateBit -->
<!-- $$$Flag$$$OwnedByParent$$$UsePreprocess$$$OwnsGeometry$$$OwnsMaterial$$$OwnsOpaqueMaterial$$$IsVisitableNode$$$InternalReserved -->
<h3 class="flags" id="Flag-enum">enum QSGNode::<span class="name">Flag</span><br/>flags QSGNode::<span class="name">Flags</span></h3>
<p>The QSGNode::Flag enum describes flags on the <a href="qsgnode.html" translate="no">QSGNode</a></p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::OwnedByParent</code></td><td class="topAlign tblval"><code translate="no">0x0001</code></td><td class="topAlign">The node is owned by its parent and will be deleted when the parent is deleted.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::UsePreprocess</code></td><td class="topAlign tblval"><code translate="no">0x0002</code></td><td class="topAlign">The node's virtual <a href="qsgnode.html#preprocess" translate="no">preprocess</a>() function will be called before rendering starts.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::OwnsGeometry</code></td><td class="topAlign tblval"><code translate="no">0x00010000</code></td><td class="topAlign">Only valid for <a href="qsggeometrynode.html" translate="no">QSGGeometryNode</a> and <a href="qsgclipnode.html" translate="no">QSGClipNode</a>. The node has ownership over the <a href="qsggeometry.html" translate="no">QSGGeometry</a> instance and will delete it when the node is destroyed or a geometry is assigned.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::OwnsMaterial</code></td><td class="topAlign tblval"><code translate="no">0x00020000</code></td><td class="topAlign">Only valid for <a href="qsggeometrynode.html" translate="no">QSGGeometryNode</a>. The node has ownership over the material and will delete it when the node is destroyed or a material is assigned.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::OwnsOpaqueMaterial</code></td><td class="topAlign tblval"><code translate="no">0x00040000</code></td><td class="topAlign">Only valid for <a href="qsggeometrynode.html" translate="no">QSGGeometryNode</a>. The node has ownership over the opaque material and will delete it when the node is destroyed or a material is assigned.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::InternalReserved</code></td><td class="topAlign tblval"><code translate="no">0x01000000</code></td><td class="topAlign">Reserved for internal use.</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
<!-- $$$NodeType$$$BasicNodeType$$$GeometryNodeType$$$TransformNodeType$$$ClipNodeType$$$OpacityNodeType$$$RootNodeType$$$RenderNodeType -->
<h3 class="fn" translate="no" id="NodeType-enum">enum QSGNode::<span class="name">NodeType</span></h3>
<p>Can be used to figure out the type of node.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::BasicNodeType</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The type of <a href="qsgnode.html" translate="no">QSGNode</a></td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::GeometryNodeType</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The type of <a href="qsggeometrynode.html" translate="no">QSGGeometryNode</a></td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::TransformNodeType</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The type of <a href="qsgtransformnode.html" translate="no">QSGTransformNode</a></td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::ClipNodeType</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The type of <a href="qsgclipnode.html" translate="no">QSGClipNode</a></td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::OpacityNodeType</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The type of <a href="qsgopacitynode.html" translate="no">QSGOpacityNode</a></td></tr>
<tr><td class="topAlign"><code translate="no">QSGNode::RenderNodeType</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The type of <a href="qsgrendernode.html" translate="no">QSGRenderNode</a></td></tr>
</table></div>
<p><b>See also </b><a href="qsgnode.html#type" translate="no">type</a>().</p>
<!-- @@@NodeType -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QSGNode[overload1]$$$QSGNode -->
<h3 class="fn" translate="no" id="QSGNode">QSGNode::<span class="name">QSGNode</span>()</h3>
<p>Constructs a new node</p>
<!-- @@@QSGNode -->
<!-- $$$~QSGNode[overload1]$$$~QSGNode -->
<h3 class="fn" translate="no" id="dtor.QSGNode"><code class="details extra" translate="no">[virtual noexcept]</code> QSGNode::<span class="name">~QSGNode</span>()</h3>
<p>Destroys the node.</p>
<p>Every child of this node that has the flag <a href="qsgnode.html#Flag-enum" translate="no">QSGNode::OwnedByParent</a> set, will also be deleted.</p>
<!-- @@@~QSGNode -->
<!-- $$$appendChildNode[overload1]$$$appendChildNodeQSGNode* -->
<h3 class="fn" translate="no" id="appendChildNode"><span class="type">void</span> QSGNode::<span class="name">appendChildNode</span>(<span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *<i>node</i>)</h3>
<p>Appends <i translate="no">node</i> to this node's list of children.</p>
<p>Ordering of nodes is important as geometry nodes will be rendered in the order they are added to the scene graph.</p>
<!-- @@@appendChildNode -->
<!-- $$$childAtIndex[overload1]$$$childAtIndexint -->
<h3 class="fn" translate="no" id="childAtIndex"><span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *QSGNode::<span class="name">childAtIndex</span>(<span class="type">int</span> <i>i</i>) const</h3>
<p>Returns the child at index <i translate="no">i</i>.</p>
<p>Children are stored internally as a linked list, so iterating over the children via the index is suboptimal.</p>
<!-- @@@childAtIndex -->
<!-- $$$childCount[overload1]$$$childCount -->
<h3 class="fn" translate="no" id="childCount"><span class="type">int</span> QSGNode::<span class="name">childCount</span>() const</h3>
<p>Returns the number of child nodes.</p>
<!-- @@@childCount -->
<!-- $$$firstChild[overload1]$$$firstChild -->
<h3 class="fn" translate="no" id="firstChild"><span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *QSGNode::<span class="name">firstChild</span>() const</h3>
<p>Returns the first child of this node.</p>
<p>The children are stored in a linked list.</p>
<!-- @@@firstChild -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><span class="type"><a href="qsgnode.html#Flag-enum" translate="no">QSGNode::Flags</a></span> QSGNode::<span class="name">flags</span>() const</h3>
<p>Returns the set of flags for this node.</p>
<p><b>See also </b><a href="qsgnode.html#setFlags" translate="no">setFlags</a>().</p>
<!-- @@@flags -->
<!-- $$$insertChildNodeAfter[overload1]$$$insertChildNodeAfterQSGNode*QSGNode* -->
<h3 class="fn" translate="no" id="insertChildNodeAfter"><span class="type">void</span> QSGNode::<span class="name">insertChildNodeAfter</span>(<span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *<i>node</i>, <span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *<i>after</i>)</h3>
<p>Inserts <i translate="no">node</i> to this node's list of children after the node specified with <i translate="no">after</i>.</p>
<p>Ordering of nodes is important as geometry nodes will be rendered in the order they are added to the scene graph.</p>
<!-- @@@insertChildNodeAfter -->
<!-- $$$insertChildNodeBefore[overload1]$$$insertChildNodeBeforeQSGNode*QSGNode* -->
<h3 class="fn" translate="no" id="insertChildNodeBefore"><span class="type">void</span> QSGNode::<span class="name">insertChildNodeBefore</span>(<span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *<i>node</i>, <span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *<i>before</i>)</h3>
<p>Inserts <i translate="no">node</i> to this node's list of children before the node specified with <i translate="no">before</i>.</p>
<p>Ordering of nodes is important as geometry nodes will be rendered in the order they are added to the scene graph.</p>
<!-- @@@insertChildNodeBefore -->
<!-- $$$isSubtreeBlocked[overload1]$$$isSubtreeBlocked -->
<h3 class="fn" translate="no" id="isSubtreeBlocked"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QSGNode::<span class="name">isSubtreeBlocked</span>() const</h3>
<p>Returns whether this node and its subtree is available for use.</p>
<p>Blocked subtrees will not get their dirty states updated and they will not be rendered.</p>
<p>The <a href="qsgopacitynode.html" translate="no">QSGOpacityNode</a> will return a blocked subtree when accumulated opacity is 0, for instance.</p>
<!-- @@@isSubtreeBlocked -->
<!-- $$$lastChild[overload1]$$$lastChild -->
<h3 class="fn" translate="no" id="lastChild"><span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *QSGNode::<span class="name">lastChild</span>() const</h3>
<p>Returns the last child of this node.</p>
<p>The children are stored as a linked list.</p>
<!-- @@@lastChild -->
<!-- $$$markDirty[overload1]$$$markDirtyQSGNode::DirtyState -->
<h3 class="fn" translate="no" id="markDirty"><span class="type">void</span> QSGNode::<span class="name">markDirty</span>(<span class="type"><a href="qsgnode.html#DirtyStateBit-enum" translate="no">QSGNode::DirtyState</a></span> <i>bits</i>)</h3>
<p>Notifies all connected renderers that the node has dirty <i translate="no">bits</i>.</p>
<!-- @@@markDirty -->
<!-- $$$nextSibling[overload1]$$$nextSibling -->
<h3 class="fn" translate="no" id="nextSibling"><span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *QSGNode::<span class="name">nextSibling</span>() const</h3>
<p>Returns the node after this in the parent's list of children.</p>
<p>The children are stored as a linked list.</p>
<!-- @@@nextSibling -->
<!-- $$$parent[overload1]$$$parent -->
<h3 class="fn" translate="no" id="parent"><span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *QSGNode::<span class="name">parent</span>() const</h3>
<p>Returns the parent node of this node.</p>
<!-- @@@parent -->
<!-- $$$prependChildNode[overload1]$$$prependChildNodeQSGNode* -->
<h3 class="fn" translate="no" id="prependChildNode"><span class="type">void</span> QSGNode::<span class="name">prependChildNode</span>(<span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *<i>node</i>)</h3>
<p>Prepends <i translate="no">node</i> to this node's the list of children.</p>
<p>Ordering of nodes is important as geometry nodes will be rendered in the order they are added to the scene graph.</p>
<!-- @@@prependChildNode -->
<!-- $$$preprocess[overload1]$$$preprocess -->
<h3 class="fn" translate="no" id="preprocess"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QSGNode::<span class="name">preprocess</span>()</h3>
<p>Override this function to do processing on the node before it is rendered.</p>
<p>Preprocessing needs to be explicitly enabled by setting the flag <a href="qsgnode.html#Flag-enum" translate="no">QSGNode::UsePreprocess</a>. The flag needs to be set before the node is added to the scene graph and will cause the preprocess() function to be called for every frame the node is rendered.</p>
<div class="admonition warning">
<p><b>Warning: </b>Beware of deleting nodes while they are being preprocessed. It is possible, with a small performance hit, to delete a single node during its own preprocess call. Deleting a subtree which has nodes that also use preprocessing may result in a segmentation fault. This is done for performance reasons.</p>
</div>
<!-- @@@preprocess -->
<!-- $$$previousSibling[overload1]$$$previousSibling -->
<h3 class="fn" translate="no" id="previousSibling"><span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *QSGNode::<span class="name">previousSibling</span>() const</h3>
<p>Returns the node before this in the parent's list of children.</p>
<p>The children are stored as a linked list.</p>
<!-- @@@previousSibling -->
<!-- $$$removeAllChildNodes[overload1]$$$removeAllChildNodes -->
<h3 class="fn" translate="no" id="removeAllChildNodes"><span class="type">void</span> QSGNode::<span class="name">removeAllChildNodes</span>()</h3>
<p>Removes all child nodes from this node's list of children.</p>
<!-- @@@removeAllChildNodes -->
<!-- $$$removeChildNode[overload1]$$$removeChildNodeQSGNode* -->
<h3 class="fn" translate="no" id="removeChildNode"><span class="type">void</span> QSGNode::<span class="name">removeChildNode</span>(<span class="type"><a href="qsgnode.html#QSGNode" translate="no">QSGNode</a></span> *<i>node</i>)</h3>
<p>Removes <i translate="no">node</i> from this node's list of children.</p>
<!-- @@@removeChildNode -->
<!-- $$$setFlag[overload1]$$$setFlagQSGNode::Flagbool -->
<h3 class="fn" translate="no" id="setFlag"><span class="type">void</span> QSGNode::<span class="name">setFlag</span>(<span class="type"><a href="qsgnode.html#Flag-enum" translate="no">QSGNode::Flag</a></span> <i>f</i>, <span class="type">bool</span> <i>enabled</i> = true)</h3>
<p>Sets the flag <i translate="no">f</i> on this node if <i translate="no">enabled</i> is true; otherwise clears the flag.</p>
<p><b>See also </b><a href="qsgnode.html#flags" translate="no">flags</a>().</p>
<!-- @@@setFlag -->
<!-- $$$setFlags[overload1]$$$setFlagsQSGNode::Flagsbool -->
<h3 class="fn" translate="no" id="setFlags"><span class="type">void</span> QSGNode::<span class="name">setFlags</span>(<span class="type"><a href="qsgnode.html#Flag-enum" translate="no">QSGNode::Flags</a></span> <i>f</i>, <span class="type">bool</span> <i>enabled</i> = true)</h3>
<p>Sets the flags <i translate="no">f</i> on this node if <i translate="no">enabled</i> is true; otherwise clears the flags.</p>
<p><b>See also </b><a href="qsgnode.html#flags" translate="no">flags</a>().</p>
<!-- @@@setFlags -->
<!-- $$$type[overload1]$$$type -->
<h3 class="fn" translate="no" id="type"><span class="type"><a href="qsgnode.html#NodeType-enum" translate="no">QSGNode::NodeType</a></span> QSGNode::<span class="name">type</span>() const</h3>
<p>Returns the type of this node. The node type must be one of the predefined types defined in <a href="qsgnode.html#NodeType-enum" translate="no">QSGNode::NodeType</a> and can safely be used to cast to the corresponding class.</p>
<!-- @@@type -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
