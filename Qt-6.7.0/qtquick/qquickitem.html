<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquickitem.cpp -->
  <meta name="description" content="The QQuickItem class provides the most basic of all visual items in Qt Quick.">
  <title>QQuickItem Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QQuickItem</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#custom-scene-graph-items">Custom Scene Graph Items</a></li>
<li class="level2"><a href="#custom-qpainter-items">Custom QPainter Items</a></li>
<li class="level2"><a href="#behavior-animations">Behavior Animations</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QQuickItem Class</h1>
<!-- $$$QQuickItem-brief -->
<p>The QQuickItem class provides the most basic of all visual items in <a href="qtquick-index.html" translate="no">Qt Quick</a>. <a href="#details">More...</a></p>
<!-- @@@QQuickItem -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QQuickItem&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Quick) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Instantiated By:</td><td class="memItemRight bottomAlign"> <a href="qml-qtquick-windowcontainer.html" translate="no">WindowContainer</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html" translate="no">QObject</a> and <a href="../qtqml/qqmlparserstatus.html" translate="no">QQmlParserStatus</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qquickframebufferobject.html" translate="no">QQuickFramebufferObject</a>, <a href="qquickpainteditem.html" translate="no">QQuickPaintedItem</a>, and <a href="qquickrhiitem.html" translate="no">QQuickRhiItem</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qquickitem-members.html">List of all members, including inherited members</a></li>
<li><a href="qquickitem-obsolete.html">Deprecated members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> union </td><td class="memItemRight bottomAlign"><b><a href="qquickitem-itemchangedata.html" translate="no">ItemChangeData</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#Flag-enum" translate="no">Flag</a></b> { ItemClipsChildrenToShape, ItemAcceptsInputMethod, ItemIsFocusScope, ItemHasContents, ItemAcceptsDrops, &hellip;, ItemObservesViewport }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#Flag-enum" translate="no">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#ItemChange-enum" translate="no">ItemChange</a></b> { ItemChildAddedChange, ItemChildRemovedChange, ItemSceneChange, ItemVisibleHasChanged, ItemParentHasChanged, &hellip;, ItemEnabledHasChanged }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#TransformOrigin-enum" translate="no">TransformOrigin</a></b> { TopLeft, Top, TopRight, Left, Center, &hellip;, BottomRight }</td></tr>
</table></div>
<h2 id="properties">Properties</h2>
<div class="table"><table class="propsummary" translate="no">
<tr><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qquickitem.html#activeFocus-prop" translate="no">activeFocus</a></b> : const bool</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#activeFocusOnTab-prop" translate="no">activeFocusOnTab</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#antialiasing-prop" translate="no">antialiasing</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#baselineOffset-prop" translate="no">baselineOffset</a></b> : qreal</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#childrenRect-prop" translate="no">childrenRect</a></b> : const QRectF</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#clip-prop" translate="no">clip</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#containmentMask-prop" translate="no">containmentMask</a></b> : QObject*</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#enabled-prop" translate="no">enabled</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#focus-prop" translate="no">focus</a></b> : bool</li>
<li class="fn" translate="no"><code class="summary extra" translate="no">(since 6.7)</code> <b><a href="qquickitem.html#focusPolicy-prop" translate="no">focusPolicy</a></b> : Qt::FocusPolicy</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#height-prop" translate="no">height</a></b> : qreal</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#implicitHeight-prop" translate="no">implicitHeight</a></b> : qreal</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#implicitWidth-prop" translate="no">implicitWidth</a></b> : qreal</li>
</ul></td><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qquickitem.html#opacity-prop" translate="no">opacity</a></b> : qreal</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#parent-prop" translate="no">parent</a></b> : QQuickItem*</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#rotation-prop" translate="no">rotation</a></b> : qreal</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#scale-prop" translate="no">scale</a></b> : qreal</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#smooth-prop" translate="no">smooth</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#state-prop" translate="no">state</a></b> : QString</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a></b> : TransformOrigin</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#visible-prop" translate="no">visible</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#width-prop" translate="no">width</a></b> : qreal</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#x-prop" translate="no">x</a></b> : qreal</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#y-prop" translate="no">y</a></b> : qreal</li>
<li class="fn" translate="no"><b><a href="qquickitem.html#z-prop" translate="no">z</a></b> : qreal</li>
</ul>
</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></b>(QQuickItem *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dtor.QQuickItem" translate="no">~QQuickItem</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#acceptHoverEvents" translate="no">acceptHoverEvents</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#acceptTouchEvents" translate="no">acceptTouchEvents</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::MouseButtons </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#acceptedMouseButtons" translate="no">acceptedMouseButtons</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#activeFocusOnTab-prop" translate="no">activeFocusOnTab</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#antialiasing-prop" translate="no">antialiasing</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#baselineOffset-prop" translate="no">baselineOffset</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;qreal&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#height-prop" translate="no">bindableHeight</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;qreal&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#width-prop" translate="no">bindableWidth</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;qreal&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#x-prop" translate="no">bindableX</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;qreal&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#y-prop" translate="no">bindableY</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#boundingRect" translate="no">boundingRect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#childAt" translate="no">childAt</a></b>(qreal <i>x</i>, qreal <i>y</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QQuickItem *&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#childItems" translate="no">childItems</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#childrenRect-prop" translate="no">childrenRect</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#clip-prop" translate="no">clip</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#clipRect" translate="no">clipRect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#containmentMask-prop" translate="no">containmentMask</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#contains" translate="no">contains</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCursor </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#cursor" translate="no">cursor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dumpItemTree" translate="no">dumpItemTree</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#ensurePolished" translate="no">ensurePolished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#filtersChildMouseEvents" translate="no">filtersChildMouseEvents</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem::Flags </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::FocusPolicy </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focusPolicy-prop" translate="no">focusPolicy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#forceActiveFocus" translate="no">forceActiveFocus</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#forceActiveFocus-1" translate="no">forceActiveFocus</a></b>(Qt::FocusReason <i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;QQuickItemGrabResult&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#grabToImage-1" translate="no">grabToImage</a></b>(const QSize &amp;<i>targetSize</i> = QSize())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#activeFocus-prop" translate="no">hasActiveFocus</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focus-prop" translate="no">hasFocus</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#height-prop" translate="no">height</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitHeight-prop" translate="no">implicitHeight</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitWidth" translate="no">implicitWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#inputMethodQuery" translate="no">inputMethodQuery</a></b>(Qt::InputMethodQuery <i>query</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#isAncestorOf" translate="no">isAncestorOf</a></b>(const QQuickItem *<i>child</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#enabled-prop" translate="no">isEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#isFocusScope" translate="no">isFocusScope</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#isTextureProvider" translate="no">isTextureProvider</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#visible-prop" translate="no">isVisible</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#keepMouseGrab" translate="no">keepMouseGrab</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#keepTouchGrab" translate="no">keepTouchGrab</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapFromGlobal-2" translate="no">mapFromGlobal</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapFromItem-1" translate="no">mapFromItem</a></b>(const QQuickItem *<i>item</i>, const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapFromScene" translate="no">mapFromScene</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapRectFromItem" translate="no">mapRectFromItem</a></b>(const QQuickItem *<i>item</i>, const QRectF &amp;<i>rect</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapRectFromScene" translate="no">mapRectFromScene</a></b>(const QRectF &amp;<i>rect</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapRectToItem" translate="no">mapRectToItem</a></b>(const QQuickItem *<i>item</i>, const QRectF &amp;<i>rect</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapRectToScene" translate="no">mapRectToScene</a></b>(const QRectF &amp;<i>rect</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapToGlobal-2" translate="no">mapToGlobal</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapToItem-1" translate="no">mapToItem</a></b>(const QQuickItem *<i>item</i>, const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapToScene" translate="no">mapToScene</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#nextItemInFocusChain" translate="no">nextItemInFocusChain</a></b>(bool <i>forward</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#opacity-prop" translate="no">opacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#parent-prop" translate="no">parentItem</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#polish" translate="no">polish</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#antialiasing-prop" translate="no">resetAntialiasing</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#height-prop" translate="no">resetHeight</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#width-prop" translate="no">resetWidth</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#rotation-prop" translate="no">rotation</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#scale-prop" translate="no">scale</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#scopedFocusItem" translate="no">scopedFocusItem</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setAcceptHoverEvents" translate="no">setAcceptHoverEvents</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setAcceptTouchEvents" translate="no">setAcceptTouchEvents</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setAcceptedMouseButtons" translate="no">setAcceptedMouseButtons</a></b>(Qt::MouseButtons <i>buttons</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#activeFocusOnTab-prop" translate="no">setActiveFocusOnTab</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#antialiasing-prop" translate="no">setAntialiasing</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#baselineOffset-prop" translate="no">setBaselineOffset</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#clip-prop" translate="no">setClip</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#containmentMask-prop" translate="no">setContainmentMask</a></b>(QObject *<i>mask</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setCursor" translate="no">setCursor</a></b>(const QCursor &amp;<i>cursor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#enabled-prop" translate="no">setEnabled</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setFiltersChildMouseEvents" translate="no">setFiltersChildMouseEvents</a></b>(bool <i>filter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setFlag" translate="no">setFlag</a></b>(QQuickItem::Flag <i>flag</i>, bool <i>enabled</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setFlags" translate="no">setFlags</a></b>(QQuickItem::Flags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focus-prop" translate="no">setFocus</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focus-prop" translate="no">setFocus</a></b>(bool <i>focus</i>, Qt::FocusReason <i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setFocusPolicy" translate="no">setFocusPolicy</a></b>(Qt::FocusPolicy <i>policy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#height-prop" translate="no">setHeight</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitHeight-prop" translate="no">setImplicitHeight</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitWidth-prop" translate="no">setImplicitWidth</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setKeepMouseGrab" translate="no">setKeepMouseGrab</a></b>(bool <i>keep</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setKeepTouchGrab" translate="no">setKeepTouchGrab</a></b>(bool <i>keep</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#opacity-prop" translate="no">setOpacity</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#parent-prop" translate="no">setParentItem</a></b>(QQuickItem *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#rotation-prop" translate="no">setRotation</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#scale-prop" translate="no">setScale</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setSize" translate="no">setSize</a></b>(const QSizeF &amp;<i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#smooth-prop" translate="no">setSmooth</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#state-prop" translate="no">setState</a></b>(const QString &amp;)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#transformOrigin-prop" translate="no">setTransformOrigin</a></b>(QQuickItem::TransformOrigin)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#visible-prop" translate="no">setVisible</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#width-prop" translate="no">setWidth</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#x-prop" translate="no">setX</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#y-prop" translate="no">setY</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#z-prop" translate="no">setZ</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSizeF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#smooth-prop" translate="no">smooth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#stackAfter" translate="no">stackAfter</a></b>(const QQuickItem *<i>sibling</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#stackBefore" translate="no">stackBefore</a></b>(const QQuickItem *<i>sibling</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#state-prop" translate="no">state</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGTextureProvider *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#textureProvider" translate="no">textureProvider</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem::TransformOrigin </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#unsetCursor" translate="no">unsetCursor</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#viewportItem" translate="no">viewportItem</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#width-prop" translate="no">width</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickWindow *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#window" translate="no">window</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#x-prop" translate="no">x</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#y-prop" translate="no">y</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#z-prop" translate="no">z</a></b>() const</td></tr>
</table></div>
<h2 id="public-slots">Public Slots</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#update" translate="no">update</a></b>()</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#activeFocus-prop" translate="no">activeFocusChanged</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#activeFocusOnTab-prop" translate="no">activeFocusOnTabChanged</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#antialiasing-prop" translate="no">antialiasingChanged</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#baselineOffset-prop" translate="no">baselineOffsetChanged</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#childrenRect-prop" translate="no">childrenRectChanged</a></b>(const QRectF &amp;)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#clip-prop" translate="no">clipChanged</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#containmentMask-prop" translate="no">containmentMaskChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#enabled-prop" translate="no">enabledChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focus-prop" translate="no">focusChanged</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focusPolicy-prop" translate="no">focusPolicyChanged</a></b>(Qt::FocusPolicy)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#height-prop" translate="no">heightChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitHeight-prop" translate="no">implicitHeightChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitWidth-prop" translate="no">implicitWidthChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#opacity-prop" translate="no">opacityChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#parent-prop" translate="no">parentChanged</a></b>(QQuickItem *)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#rotation-prop" translate="no">rotationChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#scale-prop" translate="no">scaleChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#smooth-prop" translate="no">smoothChanged</a></b>(bool)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#state-prop" translate="no">stateChanged</a></b>(const QString &amp;)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#transformOrigin-prop" translate="no">transformOriginChanged</a></b>(QQuickItem::TransformOrigin)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#visible-prop" translate="no">visibleChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#width-prop" translate="no">widthChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#windowChanged" translate="no">windowChanged</a></b>(QQuickWindow *<i>window</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#x-prop" translate="no">xChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#y-prop" translate="no">yChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#z-prop" translate="no">zChanged</a></b>()</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#childMouseEventFilter" translate="no">childMouseEventFilter</a></b>(QQuickItem *<i>item</i>, QEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dragEnterEvent" translate="no">dragEnterEvent</a></b>(QDragEnterEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dragLeaveEvent" translate="no">dragLeaveEvent</a></b>(QDragLeaveEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dragMoveEvent" translate="no">dragMoveEvent</a></b>(QDragMoveEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dropEvent" translate="no">dropEvent</a></b>(QDropEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focusInEvent" translate="no">focusInEvent</a></b>(QFocusEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focusOutEvent" translate="no">focusOutEvent</a></b>(QFocusEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#geometryChange" translate="no">geometryChange</a></b>(const QRectF &amp;<i>newGeometry</i>, const QRectF &amp;<i>oldGeometry</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#heightValid" translate="no">heightValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#hoverEnterEvent" translate="no">hoverEnterEvent</a></b>(QHoverEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#hoverLeaveEvent" translate="no">hoverLeaveEvent</a></b>(QHoverEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#hoverMoveEvent" translate="no">hoverMoveEvent</a></b>(QHoverEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#inputMethodEvent" translate="no">inputMethodEvent</a></b>(QInputMethodEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#isComponentComplete" translate="no">isComponentComplete</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#itemChange" translate="no">itemChange</a></b>(QQuickItem::ItemChange <i>change</i>, const QQuickItem::ItemChangeData &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#keyPressEvent" translate="no">keyPressEvent</a></b>(QKeyEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#keyReleaseEvent" translate="no">keyReleaseEvent</a></b>(QKeyEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mouseDoubleClickEvent" translate="no">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mouseMoveEvent" translate="no">mouseMoveEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mousePressEvent" translate="no">mousePressEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mouseReleaseEvent" translate="no">mouseReleaseEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mouseUngrabEvent" translate="no">mouseUngrabEvent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#releaseResources" translate="no">releaseResources</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#touchEvent" translate="no">touchEvent</a></b>(QTouchEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#touchUngrabEvent" translate="no">touchUngrabEvent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#updateInputMethod" translate="no">updateInputMethod</a></b>(Qt::InputMethodQueries <i>queries</i> = Qt::ImQueryInput)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGNode *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#updatePaintNode" translate="no">updatePaintNode</a></b>(QSGNode *<i>oldNode</i>, QQuickItem::UpdatePaintNodeData *<i>updatePaintNodeData</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#updatePolish" translate="no">updatePolish</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#wheelEvent" translate="no">wheelEvent</a></b>(QWheelEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#widthValid" translate="no">widthValid</a></b>() const</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#classBegin" translate="no">classBegin</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#componentComplete" translate="no">componentComplete</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#event" translate="no">event</a></b>(QEvent *<i>ev</i>) override</td></tr>
</table></div>
<!-- $$$QQuickItem-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>All visual items in Qt Quick inherit from QQuickItem. Although a QQuickItem instance has no visual appearance, it defines all the attributes that are common across visual items, such as x and y position, width and height, <a href="qtquick-positioning-anchors.html" translate="no">anchoring</a> and key handling support.</p>
<p>You can subclass QQuickItem to provide your own custom visual item that inherits these features.</p>
<h3 id="custom-scene-graph-items">Custom Scene Graph Items</h3>
<p>All visual QML items are rendered using the scene graph, the default implementation of which is a low-level, high-performance rendering stack, closely tied to accelerated graphics APIs, such as OpenGL, Vulkan, Metal, or Direct 3D. It is possible for subclasses of QQuickItem to add their own custom content into the scene graph by setting the <a href="qquickitem.html#Flag-enum" translate="no">QQuickItem::ItemHasContents</a> flag and reimplementing the <a href="qquickitem.html#updatePaintNode" translate="no">QQuickItem::updatePaintNode</a>() function.</p>
<div class="admonition warning">
<p><b>Warning: </b>It is crucial that graphics operations and interaction with the scene graph happens exclusively on the rendering thread, primarily during the <a href="qquickitem.html#updatePaintNode" translate="no">updatePaintNode</a>() call. The best rule of thumb is to only use classes with the &quot;QSG&quot; prefix inside the <a href="qquickitem.html#updatePaintNode" translate="no">QQuickItem::updatePaintNode</a>() function.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a> for more information.</p>
</div>
<h4 id="graphics-resource-handling">Graphics Resource Handling</h4>
<p>The preferred way to handle cleanup of graphics resources used in the scene graph, is to rely on the automatic cleanup of nodes. A <a href="qsgnode.html" translate="no">QSGNode</a> returned from <a href="qquickitem.html#updatePaintNode" translate="no">QQuickItem::updatePaintNode</a>() is automatically deleted on the right thread at the right time. Trees of <a href="qsgnode.html" translate="no">QSGNode</a> instances are managed through the use of <a href="qsgnode.html#Flag-enum" translate="no">QSGNode::OwnedByParent</a>, which is set by default. So, for the majority of custom scene graph items, no extra work will be required.</p>
<p>Implementations that store graphics resources outside the node tree, such as an item implementing <a href="qquickitem.html#textureProvider" translate="no">QQuickItem::textureProvider</a>(), will need to take care in cleaning it up correctly depending on how the item is used in QML. The situations to handle are:</p>
<ul>
<li>The scene graph is invalidated; This can happen, depending on the platform and <a href="qquickwindow.html" translate="no">QQuickWindow</a> configuration, when the window is hidden using <a href="../qtgui/qwindow.html#hide" translate="no">QQuickWindow::hide</a>(), or when it is closed. If the item class implements a <code translate="no">slot</code> named <code translate="no">invalidateSceneGraph()</code>, this slot will be called on the rendering thread while the GUI thread is blocked. This is equivalent to connecting to <a href="qquickwindow.html#sceneGraphInvalidated" translate="no">QQuickWindow::sceneGraphInvalidated</a>(). When rendering through OpenGL, the OpenGL context of this item's window will be bound when this slot is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through <code translate="no">EGL_CONTEXT_LOST</code>.</li>
<li>The item is removed from the scene; If an item is taken out of the scene, for instance because it's parent was set to <code translate="no">null</code> or an item in another window, the <a href="qquickitem.html#releaseResources" translate="no">QQuickItem::releaseResources</a>() will be called on the GUI thread. <a href="qquickwindow.html#scheduleRenderJob" translate="no">QQuickWindow::scheduleRenderJob</a>() should be used to schedule cleanup of rendering resources.</li>
<li>The item is deleted; When the destructor if an item runs, it should delete any graphics resources it has. If neither of the two conditions above were already met, the item will be part of a window and it is possible to use <a href="qquickwindow.html#scheduleRenderJob" translate="no">QQuickWindow::scheduleRenderJob</a>() to have them cleaned up. If an implementation ignores the call to <a href="qquickitem.html#releaseResources" translate="no">QQuickItem::releaseResources</a>(), the item will in many cases no longer have access to a <a href="qquickwindow.html" translate="no">QQuickWindow</a> and thus no means of scheduling cleanup.</li>
</ul>
<p>When scheduling cleanup of graphics resources using <a href="qquickwindow.html#scheduleRenderJob" translate="no">QQuickWindow::scheduleRenderJob</a>(), one should use either <a href="qquickwindow.html#RenderStage-enum" translate="no">QQuickWindow::BeforeSynchronizingStage</a> or <a href="qquickwindow.html#RenderStage-enum" translate="no">QQuickWindow::AfterSynchronizingStage</a>. The <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering" translate="no">synchronization stage</a> is where the scene graph is changed as a result of changes to the QML tree. If cleanup is scheduled at any other time, it may result in other parts of the scene graph referencing the newly deleted objects as these parts have not been updated.</p>
<div class="admonition note">
<p><b>Note: </b>Use of <a href="../qtcore/qobject.html#deleteLater" translate="no">QObject::deleteLater</a>() to clean up graphics resources is strongly discouraged as this will make the <code translate="no">delete</code> operation run at an arbitrary time and it is unknown if there will be an OpenGL context bound when the deletion takes place.</p>
</div>
<h3 id="custom-qpainter-items">Custom QPainter Items</h3>
<p>The QQuickItem provides a subclass, <a href="qquickpainteditem.html" translate="no">QQuickPaintedItem</a>, which allows the users to render content using <a href="../qtgui/qpainter.html" translate="no">QPainter</a>.</p>
<div class="admonition warning">
<p><b>Warning: </b>Using <a href="qquickpainteditem.html" translate="no">QQuickPaintedItem</a> uses an indirect 2D surface to render its content, using software rasterization, so the rendering is a two-step operation. First rasterize the surface, then draw the surface. Using scene graph API directly is always significantly faster.</p>
</div>
<h3 id="behavior-animations">Behavior Animations</h3>
<p>If your Item uses the <a href="qml-qtquick-behavior.html" translate="no">Behavior</a> type to define animations for property changes, you should always use either <a href="../qtcore/qobject.html#setProperty" translate="no">QObject::setProperty</a>(), QQmlProperty(), or <a href="../qtcore/qmetaproperty.html#write" translate="no">QMetaProperty::write</a>() when you need to modify those properties from C++. This ensures that the QML engine knows about the property change. Otherwise, the engine won't be able to carry out your requested animation. Note that these functions incur a slight performance penalty. For more details, see <a href="../qtqml/qtqml-cppintegration-interactqmlfromcpp.html#accessing-members-of-a-qml-object-type-from-c" translate="no">Accessing Members of a QML Object Type from C++</a>.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html" translate="no">QQuickWindow</a> and <a href="qquickpainteditem.html" translate="no">QQuickPaintedItem</a>.</p>
<!-- @@@QQuickItem -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Flag$$$ItemClipsChildrenToShape$$$ItemAcceptsInputMethod$$$ItemIsFocusScope$$$ItemHasContents$$$ItemAcceptsDrops$$$ItemIsViewport$$$ItemObservesViewport -->
<h3 class="flags" id="Flag-enum">enum QQuickItem::<span class="name">Flag</span><br/>flags QQuickItem::<span class="name">Flags</span></h3>
<p>This enum type is used to specify various item properties.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemClipsChildrenToShape</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Indicates this item should visually clip its children so that they are rendered only within the boundaries of this item.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemAcceptsInputMethod</code></td><td class="topAlign tblval"><code translate="no">0x02</code></td><td class="topAlign">Indicates the item supports text input methods.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemIsFocusScope</code></td><td class="topAlign tblval"><code translate="no">0x04</code></td><td class="topAlign">Indicates the item is a focus scope. See <a href="qtquick-input-focus.html" translate="no">Keyboard Focus in Qt Quick</a> for more information.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemHasContents</code></td><td class="topAlign tblval"><code translate="no">0x08</code></td><td class="topAlign">Indicates the item has visual content and should be rendered by the scene graph.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemAcceptsDrops</code></td><td class="topAlign tblval"><code translate="no">0x10</code></td><td class="topAlign">Indicates the item accepts drag and drop events.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemIsViewport</code></td><td class="topAlign tblval"><code translate="no">0x20</code></td><td class="topAlign">Indicates that the item defines a viewport for its children.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemObservesViewport</code></td><td class="topAlign tblval"><code translate="no">0x40</code></td><td class="topAlign">Indicates that the item wishes to know the viewport bounds when any ancestor has the ItemIsViewport flag set.</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<p><b>See also </b><a href="qquickitem.html#setFlag" translate="no">setFlag</a>(), <a href="qquickitem.html#setFlags" translate="no">setFlags</a>(), and <a href="qquickitem.html#flags" translate="no">flags</a>().</p>
<!-- @@@Flag -->
<!-- $$$ItemChange$$$ItemChildAddedChange$$$ItemChildRemovedChange$$$ItemSceneChange$$$ItemVisibleHasChanged$$$ItemParentHasChanged$$$ItemOpacityHasChanged$$$ItemActiveFocusHasChanged$$$ItemRotationHasChanged$$$ItemAntialiasingHasChanged$$$ItemDevicePixelRatioHasChanged$$$ItemEnabledHasChanged -->
<h3 class="fn" translate="no" id="ItemChange-enum">enum QQuickItem::<span class="name">ItemChange</span></h3>
<p>Used in conjunction with <a href="qquickitem.html#itemChange" translate="no">QQuickItem::itemChange</a>() to notify the item about certain types of changes.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemChildAddedChange</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">A child was added. <a href="qquickitem-itemchangedata.html#item-var" translate="no">ItemChangeData::item</a> contains the added child.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemChildRemovedChange</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">A child was removed. <a href="qquickitem-itemchangedata.html#item-var" translate="no">ItemChangeData::item</a> contains the removed child.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemSceneChange</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The item was added to or removed from a scene. The <a href="qquickwindow.html" translate="no">QQuickWindow</a> rendering the scene is specified in using <a href="qquickitem-itemchangedata.html#window-var" translate="no">ItemChangeData::window</a>. The window parameter is null when the item is removed from a scene.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemVisibleHasChanged</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The item's visibility has changed. <a href="qquickitem-itemchangedata.html#boolValue-var" translate="no">ItemChangeData::boolValue</a> contains the new visibility.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemParentHasChanged</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The item's parent has changed. <a href="qquickitem-itemchangedata.html#item-var" translate="no">ItemChangeData::item</a> contains the new parent.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemOpacityHasChanged</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The item's opacity has changed. <a href="qquickitem-itemchangedata.html#realValue-var" translate="no">ItemChangeData::realValue</a> contains the new opacity.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemActiveFocusHasChanged</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The item's focus has changed. <a href="qquickitem-itemchangedata.html#boolValue-var" translate="no">ItemChangeData::boolValue</a> contains whether the item has focus or not.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemRotationHasChanged</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">The item's rotation has changed. <a href="qquickitem-itemchangedata.html#realValue-var" translate="no">ItemChangeData::realValue</a> contains the new rotation.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemDevicePixelRatioHasChanged</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">The device pixel ratio of the screen the item is on has changed. ItemChangedData::realValue contains the new device pixel ratio.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemAntialiasingHasChanged</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">The antialiasing has changed. The current (boolean) value can be found in <a href="qquickitem.html#antialiasing-prop" translate="no">QQuickItem::antialiasing</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::ItemEnabledHasChanged</code></td><td class="topAlign tblval"><code translate="no">10</code></td><td class="topAlign">The item's enabled state has changed. <a href="qquickitem-itemchangedata.html#boolValue-var" translate="no">ItemChangeData::boolValue</a> contains the new enabled state. (since Qt 5.10)</td></tr>
</table></div>
<!-- @@@ItemChange -->
<!-- $$$TransformOrigin$$$TopLeft$$$Top$$$TopRight$$$Left$$$Center$$$Right$$$BottomLeft$$$Bottom$$$BottomRight -->
<h3 class="fn" translate="no" id="TransformOrigin-enum">enum QQuickItem::<span class="name">TransformOrigin</span></h3>
<p>Controls the point about which simple transforms like scale apply.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::TopLeft</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The top-left corner of the item.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::Top</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The center point of the top of the item.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::TopRight</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The top-right corner of the item.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::Left</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The left most point of the vertical middle.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::Center</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The center of the item.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::Right</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The right most point of the vertical middle.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::BottomLeft</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The bottom-left corner of the item.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::Bottom</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">The center point of the bottom of the item.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickItem::BottomRight</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">The bottom-right corner of the item.</td></tr>
</table></div>
<p><b>See also </b><a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>() and <a href="qquickitem.html#transformOrigin-prop" translate="no">setTransformOrigin</a>().</p>
<!-- @@@TransformOrigin -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" translate="no" id="implicitHeight-prop"><span class="name">implicitHeight</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3><h3 class="fn fngroupitem" translate="no" id="implicitWidth-prop"><span class="name">implicitWidth</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3></div>
<p>Defines the preferred width or height of the Item.</p>
<p>If <a href="qquickitem.html#width-prop" translate="no">width</a> or <a href="qquickitem.html#height-prop" translate="no">height</a> is not specified, an item's effective size will be determined by its <a href="qquickitem.html#implicitWidth" translate="no">implicitWidth</a> or <a href="qquickitem.html#implicitHeight-prop" translate="no">implicitHeight</a>.</p>
<p>However, if an item is the child of a <a href="qtquicklayouts-index.html" translate="no">layout</a>, the layout will determine the item's preferred size using its implicit size. In such a scenario, the explicit <a href="qquickitem.html#width-prop" translate="no">width</a> or <a href="qquickitem.html#height-prop" translate="no">height</a> will be ignored.</p>
<p>The default implicit size for most items is 0x0, however some items have an inherent implicit size which cannot be overridden, for example, <a href="qml-qtquick-image.html" translate="no">Image</a> and <a href="qml-qtquick-text.html" translate="no">Text</a>.</p>
<p>Setting the implicit size is useful for defining components that have a preferred size based on their content, for example:</p>
<pre class="qml" translate="no">
 <span class="comment">// Label.qml</span>
 import QtQuick 2.0

 <span class="type"><a href="qml-qtquick-item.html" translate="no">Item</a></span> {
     property <span class="type">alias</span> <span class="name">icon</span>: <span class="name">image</span>.<span class="name">source</span>
     property <span class="type">alias</span> <span class="name">label</span>: <span class="name">text</span>.<span class="name">text</span>
     <span class="name">implicitWidth</span>: <span class="name">text</span>.<span class="name">implicitWidth</span> <span class="operator">+</span> <span class="name">image</span>.<span class="name">implicitWidth</span>
     <span class="name">implicitHeight</span>: <span class="name">Math</span>.<span class="name">max</span>(<span class="name">text</span>.<span class="name">implicitHeight</span>, <span class="name">image</span>.<span class="name">implicitHeight</span>)
     <span class="type"><a href="qml-qtquick-image.html" translate="no">Image</a></span> { <span class="name">id</span>: <span class="name">image</span> }
     <span class="type"><a href="qml-qtquick-text.html" translate="no">Text</a></span> {
         <span class="name">id</span>: <span class="name">text</span>
         <span class="name">wrapMode</span>: <span class="name">Text</span>.<span class="name">Wrap</span>
         <span class="name">anchors</span>.left: <span class="name">image</span>.<span class="name">right</span>; <span class="name">anchors</span>.right: <span class="name">parent</span>.<span class="name">right</span>
         <span class="name">anchors</span>.verticalCenter: <span class="name">parent</span>.<span class="name">verticalCenter</span>
     }
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>Using <a href="qquickitem.html#implicitWidth" translate="no">implicitWidth</a> of <a href="qml-qtquick-text.html" translate="no">Text</a> or <a href="qml-qtquick-textedit.html" translate="no">TextEdit</a> and setting the width explicitly incurs a performance penalty as the text must be laid out twice.</p>
</div>
<!-- @@@ -->
<!-- $$$activeFocus-prop$$$hasActiveFocus$$$activeFocusChangedbool -->
<h3 class="fn" translate="no" id="activeFocus-prop"><code class="details extra" translate="no">[read-only]</code> <span class="name">activeFocus</span> : const <span class="type">bool</span></h3>
<p>This read-only property indicates whether the item has active focus.</p>
<p>If activeFocus is true, either this item is the one that currently receives keyboard input, or it is a <a href="qml-qtquick-focusscope.html" translate="no">FocusScope</a> ancestor of the item that currently receives keyboard input.</p>
<p>Usually, activeFocus is gained by setting <a href="qquickitem.html#focus-prop" translate="no">focus</a> on an item and its enclosing <a href="qml-qtquick-focusscope.html" translate="no">FocusScope</a> objects. In the following example, the <code translate="no">input</code> and <code translate="no">focusScope</code> objects will have active focus, while the root rectangle object will not.</p>
<pre class="qml" translate="no">
 import QtQuick 2.0

 <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

     <span class="type"><a href="qml-qtquick-focusscope.html" translate="no">FocusScope</a></span> {
         <span class="name">focus</span>: <span class="number">true</span>

         <span class="type"><a href="qml-qtquick-textinput.html" translate="no">TextInput</a></span> {
             <span class="name">id</span>: <span class="name">input</span>
             <span class="name">focus</span>: <span class="number">true</span>
         }
     }
 }
</pre>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>hasActiveFocus</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>activeFocusChanged</b></span>(bool)</td></tr>
</table></div>
<p><b>See also </b><a href="qquickitem.html#focus-prop" translate="no">focus</a> and <a href="qtquick-input-focus.html" translate="no">Keyboard Focus in Qt Quick</a>.</p>
<!-- @@@activeFocus -->
<!-- $$$activeFocusOnTab-prop$$$activeFocusOnTab$$$setActiveFocusOnTabbool$$$activeFocusOnTabChangedbool -->
<h3 class="fn" translate="no" id="activeFocusOnTab-prop"><span class="name">activeFocusOnTab</span> : <span class="type">bool</span></h3>
<p>This property holds whether the item wants to be in the tab focus chain. By default, this is set to <code translate="no">false</code>.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>activeFocusOnTab</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setActiveFocusOnTab</b></span>(bool)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>activeFocusOnTabChanged</b></span>(bool)</td></tr>
</table></div>
<!-- @@@activeFocusOnTab -->
<!-- $$$antialiasing-prop$$$antialiasing$$$setAntialiasingbool$$$resetAntialiasing$$$antialiasingChangedbool -->
<h3 class="fn" translate="no" id="antialiasing-prop"><span class="name">antialiasing</span> : <span class="type">bool</span></h3>
<p>Specifies whether the item is antialiased or not</p>
<p>Used by visual elements to decide if the item should use antialiasing or not. In some cases items with antialiasing require more memory and are potentially slower to render (see <a href="qtquick-visualcanvas-scenegraph-renderer.html#antialiasing" translate="no">Antialiasing</a> for more details).</p>
<p>The default is false, but may be overridden by derived elements.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>antialiasing</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAntialiasing</b></span>(bool)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>resetAntialiasing</b></span>()</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>antialiasingChanged</b></span>(bool)</td></tr>
</table></div>
<!-- @@@antialiasing -->
<!-- $$$baselineOffset-prop$$$baselineOffset$$$setBaselineOffsetqreal$$$baselineOffsetChangedqreal -->
<h3 class="fn" translate="no" id="baselineOffset-prop"><span class="name">baselineOffset</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3>
<p>Specifies the position of the item's baseline in local coordinates.</p>
<p>The baseline of a <a href="qml-qtquick-text.html" translate="no">Text</a> item is the imaginary line on which the text sits. Controls containing text usually set their baseline to the baseline of their text.</p>
<p>For non-text items, a default baseline offset of 0 is used.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>baselineOffset</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setBaselineOffset</b></span>(qreal)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>baselineOffsetChanged</b></span>(qreal)</td></tr>
</table></div>
<!-- @@@baselineOffset -->
<!-- $$$childrenRect-prop$$$childrenRect$$$childrenRectChangedconstQRectF& -->
<h3 class="fn" translate="no" id="childrenRect-prop"><code class="details extra" translate="no">[read-only]</code> <span class="name">childrenRect</span> : const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span></h3>
<p>This property holds the collective position and size of the item's children.</p>
<p>This property is useful if you need to access the collective geometry of an item's children in order to correctly size the item.</p>
<p>The geometry that is returned is local to the item. For example:</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">x</span>: <span class="number">50</span>
     <span class="name">y</span>: <span class="number">100</span>

     <span class="comment">// prints: QRectF(-10, -20, 30, 40)</span>
     <span class="name">Component</span>.onCompleted: <span class="name">print</span>(<span class="name">childrenRect</span>)

     <span class="type"><a href="qml-qtquick-item.html" translate="no">Item</a></span> {
         <span class="name">x</span>: -<span class="number">10</span>
         <span class="name">y</span>: -<span class="number">20</span>
         <span class="name">width</span>: <span class="number">30</span>
         <span class="name">height</span>: <span class="number">40</span>
     }
 }
</pre>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QRectF </td><td class="memItemRight bottomAlign"><span class="name"><b>childrenRect</b></span>()</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>childrenRectChanged</b></span>(const QRectF &amp;)</td></tr>
</table></div>
<!-- @@@childrenRect -->
<!-- $$$clip-prop$$$clip$$$setClipbool$$$clipChangedbool -->
<h3 class="fn" translate="no" id="clip-prop"><span class="name">clip</span> : <span class="type">bool</span></h3>
<p>This property holds whether clipping is enabled. The default clip value is <code translate="no">false</code>.</p>
<p>If clipping is enabled, an item will clip its own painting, as well as the painting of its children, to its bounding rectangle. If you set clipping during an item's paint operation, remember to re-set it to prevent clipping the rest of your scene.</p>
<div class="admonition note">
<p><b>Note: </b>Clipping can affect rendering performance. See <a href="qtquick-visualcanvas-scenegraph-renderer.html#clipping" translate="no">Clipping</a> for more information.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>For the sake of QML, setting clip to <code translate="no">true</code> also sets the <a href="qquickitem.html#Flag-enum" translate="no">ItemIsViewport</a> flag, which sometimes acts as an optimization: child items that have the <a href="qquickitem.html#Flag-enum" translate="no">ItemObservesViewport</a> flag may forego creating scene graph nodes that fall outside the viewport. But the <code translate="no">ItemIsViewport</code> flag can also be set independently.</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>clip</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setClip</b></span>(bool)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>clipChanged</b></span>(bool)</td></tr>
</table></div>
<!-- @@@clip -->
<!-- $$$containmentMask-prop$$$containmentMask$$$setContainmentMaskQObject*$$$containmentMaskChanged -->
<h3 class="fn" translate="no" id="containmentMask-prop"><span class="name">containmentMask</span> : <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span>*</h3>
<p>This property holds an optional mask to be used in the <a href="qquickitem.html#contains" translate="no">contains</a>() method, which is mainly used for hit-testing each <a href="../qtgui/qpointerevent.html" translate="no">QPointerEvent</a>.</p>
<p>By default, <a href="qquickitem.html#contains" translate="no">contains</a>() will return <code translate="no">true</code> for any point within the Item's bounding box. But any <a href="qquickitem.html" translate="no">QQuickItem</a>, or any <a href="../qtcore/qobject.html" translate="no">QObject</a> that implements a function of the form</p>
<pre class="cpp" translate="no">
 Q_INVOKABLE <span class="type">bool</span> contains(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> <span class="operator">&amp;</span>point) <span class="keyword">const</span>;
</pre>
<p>can be used as a mask, to defer hit-testing to that object.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qquickitem.html#contains" translate="no">contains</a>() is called frequently during event delivery. Deferring hit-testing to another object slows it down somewhat. containmentMask() can cause performance problems if that object's <a href="qquickitem.html#contains" translate="no">contains</a>() method is not efficient. If you implement a custom <a href="qquickitem.html" translate="no">QQuickItem</a> subclass, you can alternatively override <a href="qquickitem.html#contains" translate="no">contains</a>().</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QObject *</td><td class="memItemRight bottomAlign"><span class="name"><b>containmentMask</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setContainmentMask</b></span>(QObject *<i>mask</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>containmentMaskChanged</b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qquickitem.html#contains" translate="no">contains</a>().</p>
<!-- @@@containmentMask -->
<!-- $$$enabled-prop$$$isEnabled$$$setEnabledbool$$$enabledChanged -->
<h3 class="fn" translate="no" id="enabled-prop"><span class="name">enabled</span> : <span class="type">bool</span></h3>
<p>This property holds whether the item receives mouse and keyboard events. By default this is true.</p>
<p>Setting this property directly affects the <code translate="no">enabled</code> value of child items. When set to <code translate="no">false</code>, the <code translate="no">enabled</code> values of all child items also become <code translate="no">false</code>. When set to <code translate="no">true</code>, the <code translate="no">enabled</code> values of child items are returned to <code translate="no">true</code>, unless they have explicitly been set to <code translate="no">false</code>.</p>
<p>Setting this property to <code translate="no">false</code> automatically causes <a href="qquickitem.html#activeFocus-prop" translate="no">activeFocus</a> to be set to <code translate="no">false</code>, and this item will longer receive keyboard events.</p>
<div class="admonition note">
<p><b>Note: </b>Hover events are enabled separately by <a href="qquickitem.html#setAcceptHoverEvents" translate="no">setAcceptHoverEvents</a>(). Thus, a disabled item can continue to receive hover events, even when this property is <code translate="no">false</code>. This makes it possible to show informational feedback (such as <a href="../qtquickcontrols/qml-qtquick-controls-tooltip.html" translate="no">ToolTip</a>) even when an interactive item is disabled. The same is also true for any <a href="qml-qtquick-hoverhandler.html" translate="no">HoverHandlers</a> added as children of the item. A <a href="qml-qtquick-hoverhandler.html" translate="no">HoverHandler</a> can, however, be <a href="qml-qtquick-pointerhandler.html#enabled-prop" translate="no">disabled</a> explicitly, or for example be bound to the <code translate="no">enabled</code> state of the item.</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isEnabled</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setEnabled</b></span>(bool)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>enabledChanged</b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qquickitem.html#visible-prop" translate="no">visible</a>.</p>
<!-- @@@enabled -->
<!-- $$$focus-prop$$$hasFocus$$$setFocusbool$$$setFocusboolQt::FocusReason$$$focusChangedbool -->
<h3 class="fn" translate="no" id="focus-prop"><span class="name">focus</span> : <span class="type">bool</span></h3>
<p>This property holds whether the item has focus within the enclosing <a href="qml-qtquick-focusscope.html" translate="no">FocusScope</a>. If true, this item will gain active focus when the enclosing <a href="qml-qtquick-focusscope.html" translate="no">FocusScope</a> gains active focus.</p>
<p>In the following example, <code translate="no">input</code> will be given active focus when <code translate="no">scope</code> gains active focus:</p>
<pre class="qml" translate="no">
 import QtQuick 2.0

 <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

     <span class="type"><a href="qml-qtquick-focusscope.html" translate="no">FocusScope</a></span> {
         <span class="name">id</span>: <span class="name">scope</span>

         <span class="type"><a href="qml-qtquick-textinput.html" translate="no">TextInput</a></span> {
             <span class="name">id</span>: <span class="name">input</span>
             <span class="name">focus</span>: <span class="number">true</span>
         }
     }
 }
</pre>
<p>For the purposes of this property, the scene as a whole is assumed to act like a focus scope. On a practical level, that means the following QML will give active focus to <code translate="no">input</code> on startup.</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

     <span class="type"><a href="qml-qtquick-textinput.html" translate="no">TextInput</a></span> {
           <span class="name">id</span>: <span class="name">input</span>
           <span class="name">focus</span>: <span class="number">true</span>
     }
 }
</pre>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>hasFocus</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFocus</b></span>(bool)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFocus</b></span>(bool <i>focus</i>, Qt::FocusReason <i>reason</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>focusChanged</b></span>(bool)</td></tr>
</table></div>
<p><b>See also </b><a href="qquickitem.html#activeFocus-prop" translate="no">activeFocus</a> and <a href="qtquick-input-focus.html" translate="no">Keyboard Focus in Qt Quick</a>.</p>
<!-- @@@focus -->
<!-- $$$focusPolicy-prop$$$focusPolicy$$$setFocusPolicyQt::FocusPolicy$$$focusPolicyChangedQt::FocusPolicy -->
<h3 class="fn" translate="no" id="focusPolicy-prop"><code class="details extra" translate="no">[since 6.7]</code> <span class="name">focusPolicy</span> : <span class="type"><a href="../qtcore/qt.html#FocusPolicy-enum" translate="no">Qt::FocusPolicy</a></span></h3>
<p>This property determines the way the item accepts focus.</p>
<p>This property was introduced in Qt 6.7.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::FocusPolicy </td><td class="memItemRight bottomAlign"><span class="name"><b>focusPolicy</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qquickitem.html#setFocusPolicy" translate="no">setFocusPolicy</a></b></span>(Qt::FocusPolicy <i>policy</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>focusPolicyChanged</b></span>(Qt::FocusPolicy)</td></tr>
</table></div>
<!-- @@@focusPolicy -->
<!-- $$$height-prop$$$height$$$setHeightqreal$$$resetHeight$$$heightChanged$$$bindableHeight -->
<h3 class="fn" translate="no" id="height-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">height</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="../qtcore/qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds the height of this item.</p>
<!-- @@@height -->
<!-- $$$opacity-prop$$$opacity$$$setOpacityqreal$$$opacityChanged -->
<h3 class="fn" translate="no" id="opacity-prop"><span class="name">opacity</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3>
<p>This property holds the opacity of the item. Opacity is specified as a number between 0.0 (fully transparent) and 1.0 (fully opaque). The default value is 1.0.</p>
<p>When this property is set, the specified opacity is also applied individually to child items. This may have an unintended effect in some circumstances. For example in the second set of rectangles below, the red rectangle has specified an opacity of 0.5, which affects the opacity of its blue child rectangle even though the child has not specified an opacity.</p>
<p>Values outside the range of 0 to 1 will be clamped.</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/declarative-item_opacity1.png" alt="" /></p></td><td ><pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
             <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
             <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         }
     }
 }
</pre>
</td></tr>
<tr valign="top" class="even"><td ><p class="centerAlign"><img src="images/declarative-item_opacity2.png" alt="" /></p></td><td ><pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">opacity</span>: <span class="number">0.5</span>
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
             <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
             <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         }
     }
 }
</pre>
</td></tr>
</table></div>
<p>Changing an item's opacity does not affect whether the item receives user input events. (In contrast, setting <a href="qquickitem.html#visible-prop" translate="no">visible</a> property to <code translate="no">false</code> stops mouse events, and setting the <a href="qquickitem.html#enabled-prop" translate="no">enabled</a> property to <code translate="no">false</code> stops mouse and keyboard events, and also removes active focus from the item.)</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>opacity</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setOpacity</b></span>(qreal)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>opacityChanged</b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qquickitem.html#visible-prop" translate="no">visible</a>.</p>
<!-- @@@opacity -->
<!-- $$$parent-prop$$$parentItem$$$setParentItemQQuickItem*$$$parentChangedQQuickItem* -->
<h3 class="fn" translate="no" id="parent-prop"><span class="name">parent</span> : <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span>*</h3>
<p>This property holds the visual parent of the item.</p>
<div class="admonition note">
<p><b>Note: </b>The concept of the <i>visual parent</i> differs from that of the <i><a href="../qtcore/qobject.html" translate="no">QObject</a> parent</i>. An item's visual parent may not necessarily be the same as its object parent. See <a href="qtquick-visualcanvas-visualparent.html" translate="no">Concepts - Visual Parent in Qt Quick</a> for more details.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The notification signal for this property gets emitted during destruction of the visual parent. C++ signal handlers cannot assume that items in the visual parent hierarchy are still fully constructed. Use <a href="../qtcore/qobject.html#qobject_cast" translate="no">qobject_cast</a> to verify that items in the parent hierarchy can be used safely as the expected type.</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><span class="name"><b>parentItem</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setParentItem</b></span>(QQuickItem *<i>parent</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>parentChanged</b></span>(QQuickItem *)</td></tr>
</table></div>
<!-- @@@parent -->
<!-- $$$rotation-prop$$$rotation$$$setRotationqreal$$$rotationChanged -->
<h3 class="fn" translate="no" id="rotation-prop"><span class="name">rotation</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3>
<p>This property holds the rotation of the item in degrees clockwise around its <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>.</p>
<p>The default value is 0 degrees (that is, no rotation).</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/declarative-rotation.png" alt="" /></p></td><td ><pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
     <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         <span class="name">x</span>: <span class="number">25</span>; <span class="name">y</span>: <span class="number">25</span>; <span class="name">width</span>: <span class="number">50</span>; <span class="name">height</span>: <span class="number">50</span>
         <span class="name">rotation</span>: <span class="number">30</span>
     }
 }
</pre>
</td></tr>
</table></div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>rotation</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setRotation</b></span>(qreal)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>rotationChanged</b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qml-qtquick-transform.html" translate="no">Transform</a> and <a href="qml-qtquick-rotation.html" translate="no">Rotation</a>.</p>
<!-- @@@rotation -->
<!-- $$$scale-prop$$$scale$$$setScaleqreal$$$scaleChanged -->
<h3 class="fn" translate="no" id="scale-prop"><span class="name">scale</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3>
<p>This property holds the scale factor for this item.</p>
<p>A scale of less than 1.0 causes the item to be rendered at a smaller size, and a scale greater than 1.0 renders the item at a larger size. A negative scale causes the item to be mirrored when rendered.</p>
<p>The default value is 1.0.</p>
<p>Scaling is applied from the <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>.</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/declarative-scale.png" alt="" /></p></td><td ><pre class="qml" translate="no">
 import QtQuick 2.0

 <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
     <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">color</span>: <span class="string">&quot;green&quot;</span>
         <span class="name">width</span>: <span class="number">25</span>; <span class="name">height</span>: <span class="number">25</span>
     }

     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         <span class="name">x</span>: <span class="number">25</span>; <span class="name">y</span>: <span class="number">25</span>; <span class="name">width</span>: <span class="number">50</span>; <span class="name">height</span>: <span class="number">50</span>
         <span class="name">scale</span>: <span class="number">1.4</span>
     }
 }
</pre>
</td></tr>
</table></div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>scale</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setScale</b></span>(qreal)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>scaleChanged</b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qml-qtquick-transform.html" translate="no">Transform</a> and <a href="qml-qtquick-scale.html" translate="no">Scale</a>.</p>
<!-- @@@scale -->
<!-- $$$smooth-prop$$$smooth$$$setSmoothbool$$$smoothChangedbool -->
<h3 class="fn" translate="no" id="smooth-prop"><span class="name">smooth</span> : <span class="type">bool</span></h3>
<p>Specifies whether the item is smoothed or not</p>
<p>Primarily used in image based items to decide if the item should use smooth sampling or not. Smooth sampling is performed using linear interpolation, while non-smooth is performed using nearest neighbor.</p>
<p>In Qt Quick 2.0, this property has minimal impact on performance.</p>
<p>By default, this property is set to <code translate="no">true</code>.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>smooth</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSmooth</b></span>(bool)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>smoothChanged</b></span>(bool)</td></tr>
</table></div>
<!-- @@@smooth -->
<!-- $$$state-prop$$$state$$$setStateconstQString&$$$stateChangedconstQString& -->
<h3 class="fn" translate="no" id="state-prop"><span class="name">state</span> : <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span></h3>
<p>This property holds the name of the current state of the item.</p>
<p>If the item is in its default state, that is, no explicit state has been set, then this property holds an empty string. Likewise, you can return an item to its default state by setting this property to an empty string.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>state</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setState</b></span>(const QString &amp;)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>stateChanged</b></span>(const QString &amp;)</td></tr>
</table></div>
<p><b>See also </b><a href="qtquick-statesanimations-states.html" translate="no">Qt Quick States</a>.</p>
<!-- @@@state -->
<!-- $$$transformOrigin-prop$$$transformOrigin$$$setTransformOriginQQuickItem::TransformOrigin$$$transformOriginChangedQQuickItem::TransformOrigin -->
<h3 class="fn" translate="no" id="transformOrigin-prop"><span class="name">transformOrigin</span> : <span class="type"><a href="qquickitem.html#TransformOrigin-enum" translate="no">TransformOrigin</a></span></h3>
<p>This property holds the origin point around which scale and rotation transform.</p>
<p>Nine transform origins are available, as shown in the image below. The default transform origin is <code translate="no">Item.Center</code>.</p>
<p class="centerAlign"><img src="images/declarative-transformorigin.png" alt="" /></p><p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QQuickItem::TransformOrigin </td><td class="memItemRight bottomAlign"><span class="name"><b>transformOrigin</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTransformOrigin</b></span>(QQuickItem::TransformOrigin)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>transformOriginChanged</b></span>(QQuickItem::TransformOrigin)</td></tr>
</table></div>
<!-- @@@transformOrigin -->
<!-- $$$visible-prop$$$isVisible$$$setVisiblebool$$$visibleChanged -->
<h3 class="fn" translate="no" id="visible-prop"><span class="name">visible</span> : <span class="type">bool</span></h3>
<p>This property holds whether the item is visible. By default this is true.</p>
<p>Setting this property directly affects the <code translate="no">visible</code> value of child items. When set to <code translate="no">false</code>, the <code translate="no">visible</code> values of all child items also become <code translate="no">false</code>. When set to <code translate="no">true</code>, the <code translate="no">visible</code> values of child items are returned to <code translate="no">true</code>, unless they have explicitly been set to <code translate="no">false</code>.</p>
<p>(Because of this flow-on behavior, using the <code translate="no">visible</code> property may not have the intended effect if a property binding should only respond to explicit property changes. In such cases it may be better to use the <a href="qquickitem.html#opacity-prop" translate="no">opacity</a> property instead.)</p>
<p>If this property is set to <code translate="no">false</code>, the item will no longer receive mouse events, but will continue to receive key events and will retain the keyboard <a href="qquickitem.html#focus-prop" translate="no">focus</a> if it has been set. (In contrast, setting the <a href="qquickitem.html#enabled-prop" translate="no">enabled</a> property to <code translate="no">false</code> stops both mouse and keyboard events, and also removes focus from the item.)</p>
<div class="admonition note">
<p><b>Note: </b>This property's value is only affected by changes to this property or the parent's <code translate="no">visible</code> property. It does not change, for example, if this item moves off-screen, or if the <a href="qquickitem.html#opacity-prop" translate="no">opacity</a> changes to 0. However, for historical reasons, this property is true after the item's construction, even if the item hasn't been added to a scene yet. Changing or reading this property of an item that has not been added to a scene might not produce the expected results.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The notification signal for this property gets emitted during destruction of the visual parent. C++ signal handlers cannot assume that items in the visual parent hierarchy are still fully constructed. Use <a href="../qtcore/qobject.html#qobject_cast" translate="no">qobject_cast</a> to verify that items in the parent hierarchy can be used safely as the expected type.</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isVisible</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setVisible</b></span>(bool)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>visibleChanged</b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qquickitem.html#opacity-prop" translate="no">opacity</a> and <a href="qquickitem.html#enabled-prop" translate="no">enabled</a>.</p>
<!-- @@@visible -->
<!-- $$$width-prop$$$width$$$setWidthqreal$$$resetWidth$$$widthChanged$$$bindableWidth -->
<h3 class="fn" translate="no" id="width-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">width</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="../qtcore/qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds the width of this item.</p>
<!-- @@@width -->
<!-- $$$x-prop$$$x$$$setXqreal$$$xChanged$$$bindableX -->
<h3 class="fn" translate="no" id="x-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">x</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="../qtcore/qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>Defines the item's x position relative to its parent.</p>
<!-- @@@x -->
<!-- $$$y-prop$$$y$$$setYqreal$$$yChanged$$$bindableY -->
<h3 class="fn" translate="no" id="y-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">y</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="../qtcore/qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>Defines the item's y position relative to its parent.</p>
<!-- @@@y -->
<!-- $$$z-prop$$$z$$$setZqreal$$$zChanged -->
<h3 class="fn" translate="no" id="z-prop"><span class="name">z</span> : <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span></h3>
<p>Sets the stacking order of sibling items. By default the stacking order is 0.</p>
<p>Items with a higher stacking value are drawn on top of siblings with a lower stacking order. Items with the same stacking value are drawn bottom up in the order they appear. Items with a negative stacking value are drawn under their parent's content.</p>
<p>The following example shows the various effects of stacking order.</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/declarative-item_stacking1.png" alt="" /></p></td><td >Same <code translate="no">z</code> - later children above earlier children:<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
     }
     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
         <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
     }
 }
</pre>
</td></tr>
<tr valign="top" class="even"><td ><p class="centerAlign"><img src="images/declarative-item_stacking2.png" alt="" /></p></td><td >Higher <code translate="no">z</code> on top:<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">z</span>: <span class="number">1</span>
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
     }
     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
         <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
     }
 }
</pre>
</td></tr>
<tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/declarative-item_stacking3.png" alt="" /></p></td><td >Same <code translate="no">z</code> - children above parents:<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
             <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
             <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         }
     }
 }
</pre>
</td></tr>
<tr valign="top" class="even"><td ><p class="centerAlign"><img src="images/declarative-item_stacking4.png" alt="" /></p></td><td >Lower <code translate="no">z</code> below:<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
         <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
         <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
             <span class="name">z</span>: -<span class="number">1</span>
             <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
             <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
         }
     }
 }
</pre>
</td></tr>
</table></div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>z</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setZ</b></span>(qreal)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>zChanged</b></span>()</td></tr>
</table></div>
<!-- @@@z -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickItem[overload1]$$$QQuickItemQQuickItem* -->
<h3 class="fn" translate="no" id="QQuickItem"><code class="details extra" translate="no">[explicit]</code> QQuickItem::<span class="name">QQuickItem</span>(<span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a QQuickItem with the given <i translate="no">parent</i>.</p>
<p>The <code translate="no">parent</code> will be used as both the <a href="qquickitem.html#parent-prop" translate="no">visual parent</a> and the <a href="../qtcore/qobject.html" translate="no">QObject</a> parent.</p>
<!-- @@@QQuickItem -->
<!-- $$$~QQuickItem[overload1]$$$~QQuickItem -->
<h3 class="fn" translate="no" id="dtor.QQuickItem"><code class="details extra" translate="no">[override virtual noexcept]</code> QQuickItem::<span class="name">~QQuickItem</span>()</h3>
<p>Destroys the <a href="qquickitem.html" translate="no">QQuickItem</a>.</p>
<!-- @@@~QQuickItem -->
<!-- $$$acceptHoverEvents[overload1]$$$acceptHoverEvents -->
<h3 class="fn" translate="no" id="acceptHoverEvents"><span class="type">bool</span> QQuickItem::<span class="name">acceptHoverEvents</span>() const</h3>
<p>Returns whether hover events are accepted by this item.</p>
<p>The default value is false.</p>
<p>If this is false, then the item will not receive any hover events through the <a href="qquickitem.html#hoverEnterEvent" translate="no">hoverEnterEvent</a>(), <a href="qquickitem.html#hoverMoveEvent" translate="no">hoverMoveEvent</a>() and <a href="qquickitem.html#hoverLeaveEvent" translate="no">hoverLeaveEvent</a>() functions.</p>
<p><b>See also </b><a href="qquickitem.html#setAcceptHoverEvents" translate="no">setAcceptHoverEvents</a>().</p>
<!-- @@@acceptHoverEvents -->
<!-- $$$acceptTouchEvents[overload1]$$$acceptTouchEvents -->
<h3 class="fn" translate="no" id="acceptTouchEvents"><span class="type">bool</span> QQuickItem::<span class="name">acceptTouchEvents</span>() const</h3>
<p>Returns whether touch events are accepted by this item.</p>
<p>The default value is <code translate="no">false</code>.</p>
<p>If this is <code translate="no">false</code>, then the item will not receive any touch events through the <a href="qquickitem.html#touchEvent" translate="no">touchEvent</a>() function.</p>
<p><b>See also </b><a href="qquickitem.html#setAcceptTouchEvents" translate="no">setAcceptTouchEvents</a>().</p>
<!-- @@@acceptTouchEvents -->
<!-- $$$acceptedMouseButtons[overload1]$$$acceptedMouseButtons -->
<h3 class="fn" translate="no" id="acceptedMouseButtons"><span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButtons</a></span> QQuickItem::<span class="name">acceptedMouseButtons</span>() const</h3>
<p>Returns the mouse buttons accepted by this item.</p>
<p>The default value is <a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::NoButton</a>; that is, no mouse buttons are accepted.</p>
<p>If an item does not accept the mouse button for a particular mouse event, the mouse event will not be delivered to the item and will be delivered to the next item in the item hierarchy instead.</p>
<p><b>See also </b><a href="qquickitem.html#setAcceptedMouseButtons" translate="no">setAcceptedMouseButtons</a>() and <a href="qquickitem.html#acceptTouchEvents" translate="no">acceptTouchEvents</a>().</p>
<!-- @@@acceptedMouseButtons -->
<!-- $$$boundingRect[overload1]$$$boundingRect -->
<h3 class="fn" translate="no" id="boundingRect"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> QQuickItem::<span class="name">boundingRect</span>() const</h3>
<p>Returns the extents of the item in its own coordinate system: a rectangle from <code translate="no">0, 0</code> to <a href="qquickitem.html#width-prop" translate="no">width</a>() and <a href="qquickitem.html#height-prop" translate="no">height</a>().</p>
<!-- @@@boundingRect -->
<!-- $$$childAt[overload1]$$$childAtqrealqreal -->
<h3 class="fn" translate="no" id="childAt"><code class="details extra" translate="no">[invokable]</code> <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *QQuickItem::<span class="name">childAt</span>(<span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> <i>x</i>, <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> <i>y</i>) const</h3>
<p>Returns the first visible child item found at point (<i translate="no">x</i>, <i translate="no">y</i>) within the coordinate system of this item.</p>
<p>Returns <code translate="no">nullptr</code> if there is no such item.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><!-- @@@childAt -->
<!-- $$$childItems[overload1]$$$childItems -->
<h3 class="fn" translate="no" id="childItems"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *&gt; QQuickItem::<span class="name">childItems</span>() const</h3>
<p>Returns the children of this item.</p>
<!-- @@@childItems -->
<!-- $$$childMouseEventFilter[overload1]$$$childMouseEventFilterQQuickItem*QEvent* -->
<h3 class="fn" translate="no" id="childMouseEventFilter"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">bool</span> QQuickItem::<span class="name">childMouseEventFilter</span>(<span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>item</i>, <span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> *<i>event</i>)</h3>
<p>Reimplement this method to filter the pointer events that are received by this item's children.</p>
<p>This method will only be called if <a href="qquickitem.html#filtersChildMouseEvents" translate="no">filtersChildMouseEvents</a>() is <code translate="no">true</code>.</p>
<p>Return <code translate="no">true</code> if the specified <i translate="no">event</i> should not be passed on to the specified child <i translate="no">item</i>, and <code translate="no">false</code> otherwise. If you return <code translate="no">true</code>, you should also <a href="../qtcore/qevent.html#accept" translate="no">accept</a> or <a href="../qtcore/qevent.html#ignore" translate="no">ignore</a> the <i translate="no">event</i>, to signal if event propagation should stop or continue. The <i translate="no">event</i> will, however, always be sent to all childMouseEventFilters up the parent chain.</p>
<div class="admonition note">
<p><b>Note: </b>Despite the name, this function filters all <a href="../qtgui/qpointerevent.html" translate="no">QPointerEvent</a> instances during delivery to all children (typically mouse, touch, and tablet events). When overriding this function in a subclass, we suggest writing generic event-handling code using only the accessors found in <a href="../qtgui/qpointerevent.html" translate="no">QPointerEvent</a>. Alternatively you can switch on <code translate="no">event-&gt;type()</code> and/or <code translate="no">event-&gt;device()-&gt;type()</code> to handle different event types in different ways.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Filtering is just one way to share responsibility in case of gestural ambiguity (for example on press, you don't know whether the user will tap or drag). Another way is to call <a href="../qtgui/qpointerevent.html#addPassiveGrabber" translate="no">QPointerEvent::addPassiveGrabber</a>() on press, so as to non-exclusively monitor the progress of the <a href="../qtgui/qeventpoint.html" translate="no">QEventPoint</a>. In either case, the item or pointer handler that is monitoring can steal the exclusive grab later on, when it becomes clear that the gesture fits the pattern that it is expecting.</p>
</div>
<p><b>See also </b><a href="qquickitem.html#setFiltersChildMouseEvents" translate="no">setFiltersChildMouseEvents</a>().</p>
<!-- @@@childMouseEventFilter -->
<!-- $$$classBegin[overload1]$$$classBegin -->
<h3 class="fn" translate="no" id="classBegin"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">classBegin</span>()</h3>
<p>Reimplements: <a href="../qtqml/qqmlparserstatus.html#classBegin" translate="no">QQmlParserStatus::classBegin</a>().</p>
<p>Derived classes should call the base class method before adding their own action to perform at classBegin.</p>
<!-- @@@classBegin -->
<!-- $$$clipRect[overload1]$$$clipRect -->
<h3 class="fn" translate="no" id="clipRect"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> QQuickItem::<span class="name">clipRect</span>() const</h3>
<p>Returns the rectangular area within this item that is currently visible in <a href="qquickitem.html#viewportItem" translate="no">viewportItem</a>(), if there is a viewport and the <a href="qquickitem.html#Flag-enum" translate="no">ItemObservesViewport</a> flag is set; otherwise, the extents of this item in its own coordinate system: a rectangle from <code translate="no">0, 0</code> to <a href="qquickitem.html#width-prop" translate="no">width</a>() and <a href="qquickitem.html#height-prop" translate="no">height</a>(). This is the region intended to remain visible if <a href="qquickitem.html#clip-prop" translate="no">clip</a> is <code translate="no">true</code>. It can also be used in <a href="qquickitem.html#updatePaintNode" translate="no">updatePaintNode</a>() to limit the graphics added to the scene graph.</p>
<p>For example, a large drawing or a large text document might be shown in a Flickable that occupies only part of the application's Window: in that case, Flickable is the viewport item, and a custom content-rendering item may choose to omit scene graph nodes that fall outside the area that is currently visible. If the <a href="qquickitem.html#Flag-enum" translate="no">ItemObservesViewport</a> flag is set, this area will change each time the user scrolls the content in the Flickable.</p>
<p>In case of nested viewport items, clipRect() is the intersection of the <code translate="no">boundingRect</code>s of all ancestors that have the <a href="qquickitem.html#Flag-enum" translate="no">ItemIsViewport</a> flag set, mapped to the coordinate system of <i>this</i> item.</p>
<p><b>See also </b><a href="qquickitem.html#boundingRect" translate="no">boundingRect</a>().</p>
<!-- @@@clipRect -->
<!-- $$$componentComplete[overload1]$$$componentComplete -->
<h3 class="fn" translate="no" id="componentComplete"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">componentComplete</span>()</h3>
<p>Reimplements: <a href="../qtqml/qqmlparserstatus.html#componentComplete" translate="no">QQmlParserStatus::componentComplete</a>().</p>
<p>Derived classes should call the base class method before adding their own actions to perform at componentComplete.</p>
<!-- @@@componentComplete -->
<!-- $$$contains[overload1]$$$containsconstQPointF& -->
<h3 class="fn" translate="no" id="contains"><code class="details extra" translate="no">[virtual invokable]</code> <span class="type">bool</span> QQuickItem::<span class="name">contains</span>(const <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>Returns <code translate="no">true</code> if this item contains <i translate="no">point</i>, which is in local coordinates; returns <code translate="no">false</code> otherwise.</p>
<p>This function can be overridden in order to handle point collisions in items with custom shapes. The default implementation checks whether the point is inside <a href="qquickitem.html#containmentMask-prop" translate="no">containmentMask</a>() if it is set, or inside the bounding box otherwise.</p>
<div class="admonition note">
<p><b>Note: </b>This method is used for hit-testing each <a href="../qtgui/qeventpoint.html" translate="no">QEventPoint</a> during event delivery, so the implementation should be kept as lightweight as possible.</p>
</div>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><!-- @@@contains -->
<!-- $$$cursor[overload1]$$$cursor -->
<h3 class="fn" translate="no" id="cursor"><span class="type"><a href="../qtgui/qcursor.html" translate="no">QCursor</a></span> QQuickItem::<span class="name">cursor</span>() const</h3>
<p>Returns the cursor shape for this item.</p>
<p>The mouse cursor will assume this shape when it is over this item, unless an override cursor is set. See the <a href="../qtcore/qt.html#CursorShape-enum" translate="no">list of predefined cursor objects</a> for a range of useful shapes.</p>
<p>If no cursor shape has been set this returns a cursor with the <a href="../qtcore/qt.html#CursorShape-enum" translate="no">Qt::ArrowCursor</a> shape, however another cursor shape may be displayed if an overlapping item has a valid cursor.</p>
<p><b>See also </b><a href="qquickitem.html#setCursor" translate="no">setCursor</a>() and <a href="qquickitem.html#unsetCursor" translate="no">unsetCursor</a>().</p>
<!-- @@@cursor -->
<!-- $$$dragEnterEvent[overload1]$$$dragEnterEventQDragEnterEvent* -->
<h3 class="fn" translate="no" id="dragEnterEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">dragEnterEvent</span>(<span class="type"><a href="../qtgui/qdragenterevent.html" translate="no">QDragEnterEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive drag-enter events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>Drag and drop events are only provided if the <a href="qquickitem.html#Flag-enum" translate="no">ItemAcceptsDrops</a> flag has been set for this item.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<p><b>See also </b><a href="qml-qtquick-drag.html" translate="no">Drag</a> and <a href="../qtgui/dnd.html" translate="no">Drag and Drop</a>.</p>
<!-- @@@dragEnterEvent -->
<!-- $$$dragLeaveEvent[overload1]$$$dragLeaveEventQDragLeaveEvent* -->
<h3 class="fn" translate="no" id="dragLeaveEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">dragLeaveEvent</span>(<span class="type"><a href="../qtgui/qdragleaveevent.html" translate="no">QDragLeaveEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive drag-leave events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>Drag and drop events are only provided if the <a href="qquickitem.html#Flag-enum" translate="no">ItemAcceptsDrops</a> flag has been set for this item.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<p><b>See also </b><a href="qml-qtquick-drag.html" translate="no">Drag</a> and <a href="../qtgui/dnd.html" translate="no">Drag and Drop</a>.</p>
<!-- @@@dragLeaveEvent -->
<!-- $$$dragMoveEvent[overload1]$$$dragMoveEventQDragMoveEvent* -->
<h3 class="fn" translate="no" id="dragMoveEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">dragMoveEvent</span>(<span class="type"><a href="../qtgui/qdragmoveevent.html" translate="no">QDragMoveEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive drag-move events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>Drag and drop events are only provided if the <a href="qquickitem.html#Flag-enum" translate="no">ItemAcceptsDrops</a> flag has been set for this item.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<p><b>See also </b><a href="qml-qtquick-drag.html" translate="no">Drag</a> and <a href="../qtgui/dnd.html" translate="no">Drag and Drop</a>.</p>
<!-- @@@dragMoveEvent -->
<!-- $$$dropEvent[overload1]$$$dropEventQDropEvent* -->
<h3 class="fn" translate="no" id="dropEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">dropEvent</span>(<span class="type"><a href="../qtgui/qdropevent.html" translate="no">QDropEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive drop events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>Drag and drop events are only provided if the <a href="qquickitem.html#Flag-enum" translate="no">ItemAcceptsDrops</a> flag has been set for this item.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<p><b>See also </b><a href="qml-qtquick-drag.html" translate="no">Drag</a> and <a href="../qtgui/dnd.html" translate="no">Drag and Drop</a>.</p>
<!-- @@@dropEvent -->
<!-- $$$dumpItemTree[overload1]$$$dumpItemTree -->
<h3 class="fn" translate="no" id="dumpItemTree"><code class="details extra" translate="no">[invokable, since 6.3]</code> <span class="type">void</span> QQuickItem::<span class="name">dumpItemTree</span>() const</h3>
<p>Dumps some details about the <a href="qtquick-visualcanvas-visualparent.html" translate="no">visual tree of Items</a> starting with this item, recursively.</p>
<div class="admonition note">
<p><b>Note: </b><a href="../qtcore/qobject.html#dumpObjectTree" translate="no">QObject::dumpObjectTree</a>() dumps a similar tree; but, as explained in <a href="qtquick-visualcanvas-visualparent.html" translate="no">Concepts - Visual Parent in Qt Quick</a>, an item's <a href="../qtcore/qobject.html#parent" translate="no">QObject::parent</a>() sometimes differs from its <a href="qquickitem.html#parent-prop" translate="no">QQuickItem::parentItem</a>(). You can dump both trees to see the difference.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The exact output format may change in future versions of Qt.</p>
</div>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="../qtdoc/debug.html" translate="no">Debugging Techniques</a> and <a href="https://doc.qt.io/GammaRay/gammaray-qtquick2-inspector.html" translate="no">GammaRay's Qt Quick Inspector</a>.</p>
<!-- @@@dumpItemTree -->
<!-- $$$ensurePolished[overload1]$$$ensurePolished -->
<h3 class="fn" translate="no" id="ensurePolished"><code class="details extra" translate="no">[invokable, since 6.3]</code> <span class="type">void</span> QQuickItem::<span class="name">ensurePolished</span>()</h3>
<p>Calls <a href="qquickitem.html#updatePolish" translate="no">updatePolish</a>()</p>
<p>This can be useful for items such as Layouts (or Positioners) which delay calculation of their <a href="qquickitem.html#implicitWidth" translate="no">implicitWidth</a> and <a href="qquickitem.html#implicitHeight-prop" translate="no">implicitHeight</a> until they receive a PolishEvent.</p>
<p>Normally, if e.g. a child item is added or removed to a Layout, the implicit size is not immediately calculated (this is an optimization). In some cases it might be desirable to query the implicit size of the layout right after a child item has been added. If this is the case, use this function right before querying the implicit size.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qquickitem.html#updatePolish" translate="no">updatePolish</a>() and <a href="qquickitem.html#polish" translate="no">polish</a>().</p>
<!-- @@@ensurePolished -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" translate="no" id="event"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">bool</span> QQuickItem::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> *<i>ev</i>)</h3>
<p>Reimplements: <a href="../qtcore/qobject.html#event" translate="no">QObject::event</a>(QEvent *e).</p>
<!-- @@@event -->
<!-- $$$filtersChildMouseEvents[overload1]$$$filtersChildMouseEvents -->
<h3 class="fn" translate="no" id="filtersChildMouseEvents"><span class="type">bool</span> QQuickItem::<span class="name">filtersChildMouseEvents</span>() const</h3>
<p>Returns whether pointer events intended for this item's children should be filtered through this item.</p>
<p>If both this item and a child item have <a href="qquickitem.html#acceptTouchEvents" translate="no">acceptTouchEvents</a>() <code translate="no">true</code>, then when a touch interaction occurs, this item will filter the touch event. But if either this item or the child cannot handle touch events, <a href="qquickitem.html#childMouseEventFilter" translate="no">childMouseEventFilter</a>() will be called with a synthesized mouse event.</p>
<p><b>See also </b><a href="qquickitem.html#setFiltersChildMouseEvents" translate="no">setFiltersChildMouseEvents</a>() and <a href="qquickitem.html#childMouseEventFilter" translate="no">childMouseEventFilter</a>().</p>
<!-- @@@filtersChildMouseEvents -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><span class="type"><a href="qquickitem.html#Flag-enum" translate="no">QQuickItem::Flags</a></span> QQuickItem::<span class="name">flags</span>() const</h3>
<p>Returns the item flags for this item.</p>
<p><b>See also </b><a href="qquickitem.html#setFlags" translate="no">setFlags</a>() and <a href="qquickitem.html#setFlag" translate="no">setFlag</a>().</p>
<!-- @@@flags -->
<!-- $$$focusInEvent[overload1]$$$focusInEventQFocusEvent* -->
<h3 class="fn" translate="no" id="focusInEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">focusInEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html" translate="no">QFocusEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive focus-in events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<p>If you do reimplement this function, you should call the base class implementation.</p>
<!-- @@@focusInEvent -->
<!-- $$$focusOutEvent[overload1]$$$focusOutEventQFocusEvent* -->
<h3 class="fn" translate="no" id="focusOutEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">focusOutEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html" translate="no">QFocusEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive focus-out events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@focusOutEvent -->
<!-- $$$forceActiveFocus[overload1]$$$forceActiveFocus -->
<h3 class="fn" translate="no" id="forceActiveFocus"><code class="details extra" translate="no">[invokable]</code> <span class="type">void</span> QQuickItem::<span class="name">forceActiveFocus</span>()</h3>
<p>Forces active focus on the item.</p>
<p>This method sets focus on the item and ensures that all ancestor <a href="qml-qtquick-focusscope.html" translate="no">FocusScope</a> objects in the object hierarchy are also given <a href="qquickitem.html#focus-prop" translate="no">focus</a>.</p>
<p>The reason for the focus change will be <a href="../qtcore/qt.html#FocusReason-enum" translate="no">Qt::OtherFocusReason</a>. Use the overloaded method to specify the focus reason to enable better handling of the focus change.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p><b>See also </b><a href="qquickitem.html#activeFocus-prop" translate="no">activeFocus</a>.</p>
<!-- @@@forceActiveFocus -->
<!-- $$$forceActiveFocus$$$forceActiveFocusQt::FocusReason -->
<h3 class="fn" translate="no" id="forceActiveFocus-1"><code class="details extra" translate="no">[invokable]</code> <span class="type">void</span> QQuickItem::<span class="name">forceActiveFocus</span>(<span class="type"><a href="../qtcore/qt.html#FocusReason-enum" translate="no">Qt::FocusReason</a></span> <i>reason</i>)</h3>
<p>This is an overloaded function.</p>
<p>Forces active focus on the item with the given <i translate="no">reason</i>.</p>
<p>This method sets focus on the item and ensures that all ancestor <a href="qml-qtquick-focusscope.html" translate="no">FocusScope</a> objects in the object hierarchy are also given <a href="qquickitem.html#focus-prop" translate="no">focus</a>.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p><b>See also </b><a href="qquickitem.html#activeFocus-prop" translate="no">activeFocus</a> and <a href="../qtcore/qt.html#FocusReason-enum" translate="no">Qt::FocusReason</a>.</p>
<!-- @@@forceActiveFocus -->
<!-- $$$geometryChange[overload1]$$$geometryChangeconstQRectF&constQRectF& -->
<h3 class="fn" translate="no" id="geometryChange"><code class="details extra" translate="no">[virtual protected, since 6.0]</code> <span class="type">void</span> QQuickItem::<span class="name">geometryChange</span>(const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> &amp;<i>newGeometry</i>, const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> &amp;<i>oldGeometry</i>)</h3>
<p>This function is called to handle this item's changes in geometry from <i translate="no">oldGeometry</i> to <i translate="no">newGeometry</i>. If the two geometries are the same, it doesn't do anything.</p>
<p>Derived classes must call the base class method within their implementation.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@geometryChange -->
<!-- $$$grabToImage$$$grabToImageconstQSize& -->
<h3 class="fn" translate="no" id="grabToImage-1"><span class="type"><a href="../qtcore/qsharedpointer.html" translate="no">QSharedPointer</a></span>&lt;<span class="type"><a href="qquickitemgrabresult.html" translate="no">QQuickItemGrabResult</a></span>&gt; QQuickItem::<span class="name">grabToImage</span>(const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>targetSize</i> = QSize())</h3>
<p>Grabs the item into an in-memory image.</p>
<p>The grab happens asynchronously and the signal <a href="qquickitemgrabresult.html#ready" translate="no">QQuickItemGrabResult::ready</a>() is emitted when the grab has been completed.</p>
<p>Use <i translate="no">targetSize</i> to specify the size of the target image. By default, the result will have the same size as item.</p>
<p>If the grab could not be initiated, the function returns <code translate="no">null</code>.</p>
<div class="admonition note">
<p><b>Note: </b>This function will render the item to an offscreen surface and copy that surface from the GPU's memory into the CPU's memory, which can be quite costly. For &quot;live&quot; preview, use <a href="qml-qtquick-item.html#layer.enabled-prop" translate="no">layers</a> or <a href="qml-qtquick-shadereffectsource.html" translate="no">ShaderEffectSource</a>.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#grabWindow" translate="no">QQuickWindow::grabWindow</a>().</p>
<!-- @@@grabToImage -->
<!-- $$$heightValid[overload1]$$$heightValid -->
<h3 class="fn" translate="no" id="heightValid"><code class="details extra" translate="no">[protected]</code> <span class="type">bool</span> QQuickItem::<span class="name">heightValid</span>() const</h3>
<p>Returns whether the height property has been set explicitly.</p>
<!-- @@@heightValid -->
<!-- $$$hoverEnterEvent[overload1]$$$hoverEnterEventQHoverEvent* -->
<h3 class="fn" translate="no" id="hoverEnterEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">hoverEnterEvent</span>(<span class="type"><a href="../qtgui/qhoverevent.html" translate="no">QHoverEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive hover-enter events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>Hover events are only provided if <a href="qquickitem.html#acceptHoverEvents" translate="no">acceptHoverEvents</a>() is true.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@hoverEnterEvent -->
<!-- $$$hoverLeaveEvent[overload1]$$$hoverLeaveEventQHoverEvent* -->
<h3 class="fn" translate="no" id="hoverLeaveEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">hoverLeaveEvent</span>(<span class="type"><a href="../qtgui/qhoverevent.html" translate="no">QHoverEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive hover-leave events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>Hover events are only provided if <a href="qquickitem.html#acceptHoverEvents" translate="no">acceptHoverEvents</a>() is true.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@hoverLeaveEvent -->
<!-- $$$hoverMoveEvent[overload1]$$$hoverMoveEventQHoverEvent* -->
<h3 class="fn" translate="no" id="hoverMoveEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">hoverMoveEvent</span>(<span class="type"><a href="../qtgui/qhoverevent.html" translate="no">QHoverEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive hover-move events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>Hover events are only provided if <a href="qquickitem.html#acceptHoverEvents" translate="no">acceptHoverEvents</a>() is true.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@hoverMoveEvent -->
<!-- $$$implicitWidth -->
<h3 class="fn" translate="no" id="implicitWidth"><span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> QQuickItem::<span class="name">implicitWidth</span>() const</h3>
<p>Returns the width of the item that is implied by other properties that determine the content.</p>
<div class="admonition note"><p><b>Note: </b>Getter function for property implicitWidth. </p>
</div><p><b>See also </b><a href="qquickitem.html#implicitWidth-prop" translate="no">setImplicitWidth</a>().</p>
<!-- @@@implicitWidth -->
<!-- $$$inputMethodEvent[overload1]$$$inputMethodEventQInputMethodEvent* -->
<h3 class="fn" translate="no" id="inputMethodEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">inputMethodEvent</span>(<span class="type"><a href="../qtgui/qinputmethodevent.html" translate="no">QInputMethodEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive input method events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@inputMethodEvent -->
<!-- $$$inputMethodQuery[overload1]$$$inputMethodQueryQt::InputMethodQuery -->
<h3 class="fn" translate="no" id="inputMethodQuery"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> QQuickItem::<span class="name">inputMethodQuery</span>(<span class="type"><a href="../qtcore/qt.html#InputMethodQuery-enum" translate="no">Qt::InputMethodQuery</a></span> <i>query</i>) const</h3>
<p>This method is only relevant for input items.</p>
<p>If this item is an input item, this method should be reimplemented to return the relevant input method flags for the given <i translate="no">query</i>.</p>
<p><b>See also </b><a href="../qtwidgets/qwidget.html#inputMethodQuery" translate="no">QWidget::inputMethodQuery</a>().</p>
<!-- @@@inputMethodQuery -->
<!-- $$$isAncestorOf[overload1]$$$isAncestorOfconstQQuickItem* -->
<h3 class="fn" translate="no" id="isAncestorOf"><span class="type">bool</span> QQuickItem::<span class="name">isAncestorOf</span>(const <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>child</i>) const</h3>
<p>Returns <code translate="no">true</code> if this item is an ancestor of <i translate="no">child</i> (i.e., if this item is <i translate="no">child</i>'s parent, or one of <i translate="no">child</i>'s parent's ancestors).</p>
<p><b>See also </b><a href="qquickitem.html#parent-prop" translate="no">parentItem</a>().</p>
<!-- @@@isAncestorOf -->
<!-- $$$isComponentComplete[overload1]$$$isComponentComplete -->
<h3 class="fn" translate="no" id="isComponentComplete"><code class="details extra" translate="no">[protected]</code> <span class="type">bool</span> QQuickItem::<span class="name">isComponentComplete</span>() const</h3>
<p>Returns true if construction of the QML component is complete; otherwise returns false.</p>
<p>It is often desirable to delay some processing until the component is completed.</p>
<p><b>See also </b><a href="qquickitem.html#componentComplete" translate="no">componentComplete</a>().</p>
<!-- @@@isComponentComplete -->
<!-- $$$isFocusScope[overload1]$$$isFocusScope -->
<h3 class="fn" translate="no" id="isFocusScope"><span class="type">bool</span> QQuickItem::<span class="name">isFocusScope</span>() const</h3>
<p>Returns true if this item is a focus scope, and false otherwise.</p>
<!-- @@@isFocusScope -->
<!-- $$$isTextureProvider[overload1]$$$isTextureProvider -->
<h3 class="fn" translate="no" id="isTextureProvider"><code class="details extra" translate="no">[virtual]</code> <span class="type">bool</span> QQuickItem::<span class="name">isTextureProvider</span>() const</h3>
<p>Returns true if this item is a texture provider. The default implementation returns false.</p>
<p>This function can be called from any thread.</p>
<!-- @@@isTextureProvider -->
<!-- $$$itemChange[overload1]$$$itemChangeQQuickItem::ItemChangeconstQQuickItem::ItemChangeData& -->
<h3 class="fn" translate="no" id="itemChange"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">itemChange</span>(<span class="type"><a href="qquickitem.html#ItemChange-enum" translate="no">QQuickItem::ItemChange</a></span> <i>change</i>, const <span class="type"><a href="qquickitem-itemchangedata.html" translate="no">QQuickItem::ItemChangeData</a></span> &amp;<i>value</i>)</h3>
<p>Called when <i translate="no">change</i> occurs for this item.</p>
<p><i translate="no">value</i> contains extra information relating to the change, when applicable.</p>
<p>If you re-implement this method in a subclass, be sure to call</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span><span class="operator">::</span>itemChange(change<span class="operator">,</span> value);
</pre>
<p>typically at the end of your implementation, to ensure the <a href="qquickitem.html#windowChanged" translate="no">windowChanged</a>() signal will be emitted.</p>
<!-- @@@itemChange -->
<!-- $$$keepMouseGrab[overload1]$$$keepMouseGrab -->
<h3 class="fn" translate="no" id="keepMouseGrab"><span class="type">bool</span> QQuickItem::<span class="name">keepMouseGrab</span>() const</h3>
<p>Returns whether mouse input should exclusively remain with this item.</p>
<p><b>See also </b><a href="qquickitem.html#setKeepMouseGrab" translate="no">setKeepMouseGrab</a>().</p>
<!-- @@@keepMouseGrab -->
<!-- $$$keepTouchGrab[overload1]$$$keepTouchGrab -->
<h3 class="fn" translate="no" id="keepTouchGrab"><span class="type">bool</span> QQuickItem::<span class="name">keepTouchGrab</span>() const</h3>
<p>Returns whether the touch points grabbed by this item should exclusively remain with this item.</p>
<p><b>See also </b><a href="qquickitem.html#setKeepTouchGrab" translate="no">setKeepTouchGrab</a>() and <a href="qquickitem.html#keepMouseGrab" translate="no">keepMouseGrab</a>().</p>
<!-- @@@keepTouchGrab -->
<!-- $$$keyPressEvent[overload1]$$$keyPressEventQKeyEvent* -->
<h3 class="fn" translate="no" id="keyPressEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">keyPressEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive key press events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@keyPressEvent -->
<!-- $$$keyReleaseEvent[overload1]$$$keyReleaseEventQKeyEvent* -->
<h3 class="fn" translate="no" id="keyReleaseEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">keyReleaseEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive key release events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@keyReleaseEvent -->
<!-- $$$mapFromGlobal$$$mapFromGlobalconstQPointF& -->
<h3 class="fn" translate="no" id="mapFromGlobal-2"><code class="details extra" translate="no">[invokable]</code> <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> QQuickItem::<span class="name">mapFromGlobal</span>(const <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>Maps the given <i translate="no">point</i> in the global screen coordinate system to the equivalent point within this item's coordinate system, and returns the mapped coordinate.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p>For example, this may be helpful to add a popup to a Qt Quick component.</p>
<div class="admonition note">
<p><b>Note: </b>Window positioning is done by the window manager and this value is treated only as a hint. So, the resulting window position may differ from what is expected.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If this item is in a subscene, e.g. mapped onto a 3D <a href="../qtquick3d/qml-qtquick3d-model.html" translate="no">Model</a> object, the UV mapping is incorporated into this transformation, so that it really goes from screen coordinates to this item's coordinates, as long as <i translate="no">point</i> is actually within this item's bounds. The other mapping functions do not yet work that way.</p>
</div>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapFromGlobal -->
<!-- $$$mapFromItem$$$mapFromItemconstQQuickItem*constQPointF& -->
<h3 class="fn" translate="no" id="mapFromItem-1"><code class="details extra" translate="no">[invokable]</code> <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> QQuickItem::<span class="name">mapFromItem</span>(const <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>item</i>, const <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>Maps the given <i translate="no">point</i> in <i translate="no">item</i>'s coordinate system to the equivalent point within this item's coordinate system, and returns the mapped coordinate.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p>If <i translate="no">item</i> is <code translate="no">nullptr</code>, this maps <i translate="no">point</i> from the coordinate system of the scene.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapFromItem -->
<!-- $$$mapFromScene[overload1]$$$mapFromSceneconstQPointF& -->
<h3 class="fn" translate="no" id="mapFromScene"><span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> QQuickItem::<span class="name">mapFromScene</span>(const <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>Maps the given <i translate="no">point</i> in the scene's coordinate system to the equivalent point within this item's coordinate system, and returns the mapped coordinate.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapFromScene -->
<!-- $$$mapRectFromItem[overload1]$$$mapRectFromItemconstQQuickItem*constQRectF& -->
<h3 class="fn" translate="no" id="mapRectFromItem"><span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> QQuickItem::<span class="name">mapRectFromItem</span>(const <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>item</i>, const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> &amp;<i>rect</i>) const</h3>
<p>Maps the given <i translate="no">rect</i> in <i translate="no">item</i>'s coordinate system to the equivalent rectangular area within this item's coordinate system, and returns the mapped rectangle value.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p>If <i translate="no">item</i> is <code translate="no">nullptr</code>, this maps <i translate="no">rect</i> from the coordinate system of the scene.</p>
<p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapRectFromItem -->
<!-- $$$mapRectFromScene[overload1]$$$mapRectFromSceneconstQRectF& -->
<h3 class="fn" translate="no" id="mapRectFromScene"><span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> QQuickItem::<span class="name">mapRectFromScene</span>(const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> &amp;<i>rect</i>) const</h3>
<p>Maps the given <i translate="no">rect</i> in the scene's coordinate system to the equivalent rectangular area within this item's coordinate system, and returns the mapped rectangle value.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapRectFromScene -->
<!-- $$$mapRectToItem[overload1]$$$mapRectToItemconstQQuickItem*constQRectF& -->
<h3 class="fn" translate="no" id="mapRectToItem"><span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> QQuickItem::<span class="name">mapRectToItem</span>(const <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>item</i>, const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> &amp;<i>rect</i>) const</h3>
<p>Maps the given <i translate="no">rect</i> in this item's coordinate system to the equivalent rectangular area within <i translate="no">item</i>'s coordinate system, and returns the mapped rectangle value.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p>If <i translate="no">item</i> is <code translate="no">nullptr</code>, this maps <i translate="no">rect</i> to the coordinate system of the scene.</p>
<p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapRectToItem -->
<!-- $$$mapRectToScene[overload1]$$$mapRectToSceneconstQRectF& -->
<h3 class="fn" translate="no" id="mapRectToScene"><span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> QQuickItem::<span class="name">mapRectToScene</span>(const <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> &amp;<i>rect</i>) const</h3>
<p>Maps the given <i translate="no">rect</i> in this item's coordinate system to the equivalent rectangular area within the scene's coordinate system, and returns the mapped rectangle value.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapRectToScene -->
<!-- $$$mapToGlobal$$$mapToGlobalconstQPointF& -->
<h3 class="fn" translate="no" id="mapToGlobal-2"><code class="details extra" translate="no">[invokable]</code> <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> QQuickItem::<span class="name">mapToGlobal</span>(const <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>Maps the given <i translate="no">point</i> in this item's coordinate system to the equivalent point within global screen coordinate system, and returns the mapped coordinate.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p>For example, this may be helpful to add a popup to a Qt Quick component.</p>
<div class="admonition note">
<p><b>Note: </b>Window positioning is done by the window manager and this value is treated only as a hint. So, the resulting window position may differ from what is expected.</p>
</div>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapToGlobal -->
<!-- $$$mapToItem$$$mapToItemconstQQuickItem*constQPointF& -->
<h3 class="fn" translate="no" id="mapToItem-1"><code class="details extra" translate="no">[invokable]</code> <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> QQuickItem::<span class="name">mapToItem</span>(const <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>item</i>, const <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>Maps the given <i translate="no">point</i> in this item's coordinate system to the equivalent point within <i translate="no">item</i>'s coordinate system, and returns the mapped coordinate.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p>If <i translate="no">item</i> is <code translate="no">nullptr</code>, this maps <i translate="no">point</i> to the coordinate system of the scene.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapToItem -->
<!-- $$$mapToScene[overload1]$$$mapToSceneconstQPointF& -->
<h3 class="fn" translate="no" id="mapToScene"><span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> QQuickItem::<span class="name">mapToScene</span>(const <span class="type"><a href="../qtcore/qpointf.html" translate="no">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>Maps the given <i translate="no">point</i> in this item's coordinate system to the equivalent point within the scene's coordinate system, and returns the mapped coordinate.</p>
<p>The following properties of the item are used in the mapping: <a href="qquickitem.html#x-prop" translate="no">x</a>, <a href="qquickitem.html#y-prop" translate="no">y</a>, <a href="qquickitem.html#scale-prop" translate="no">scale</a>, <a href="qquickitem.html#rotation-prop" translate="no">rotation</a>, <a href="qquickitem.html#transformOrigin-prop" translate="no">transformOrigin</a>, and <a href="qml-qtquick-item.html#transform-prop" translate="no">transform</a>.</p>
<p><b>See also </b><a href="qtquick-visualcanvas-coordinates.html" translate="no">Concepts - Visual Coordinates in Qt Quick</a>.</p>
<!-- @@@mapToScene -->
<!-- $$$mouseDoubleClickEvent[overload1]$$$mouseDoubleClickEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mouseDoubleClickEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive mouse double-click events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@mouseDoubleClickEvent -->
<!-- $$$mouseMoveEvent[overload1]$$$mouseMoveEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mouseMoveEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive mouse move events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>In order to receive mouse movement events, the preceding mouse press event must be accepted (by overriding <a href="qquickitem.html#mousePressEvent" translate="no">mousePressEvent</a>(), for example) and <a href="qquickitem.html#acceptedMouseButtons" translate="no">acceptedMouseButtons</a>() must return the relevant mouse button.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@mouseMoveEvent -->
<!-- $$$mousePressEvent[overload1]$$$mousePressEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mousePressEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">mousePressEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive mouse press events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>In order to receive mouse press events, <a href="qquickitem.html#acceptedMouseButtons" translate="no">acceptedMouseButtons</a>() must return the relevant mouse button.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@mousePressEvent -->
<!-- $$$mouseReleaseEvent[overload1]$$$mouseReleaseEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mouseReleaseEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive mouse release events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>In order to receive mouse release events, the preceding mouse press event must be accepted (by overriding <a href="qquickitem.html#mousePressEvent" translate="no">mousePressEvent</a>(), for example) and <a href="qquickitem.html#acceptedMouseButtons" translate="no">acceptedMouseButtons</a>() must return the relevant mouse button.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@mouseReleaseEvent -->
<!-- $$$mouseUngrabEvent[overload1]$$$mouseUngrabEvent -->
<h3 class="fn" translate="no" id="mouseUngrabEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">mouseUngrabEvent</span>()</h3>
<p>This event handler can be reimplemented in a subclass to be notified when a mouse ungrab event has occurred on this item.</p>
<!-- @@@mouseUngrabEvent -->
<!-- $$$nextItemInFocusChain[overload1]$$$nextItemInFocusChainbool -->
<h3 class="fn" translate="no" id="nextItemInFocusChain"><code class="details extra" translate="no">[invokable]</code> <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *QQuickItem::<span class="name">nextItemInFocusChain</span>(<span class="type">bool</span> <i>forward</i> = true)</h3>
<p>Returns the item in the focus chain which is next to this item. If <i translate="no">forward</i> is <code translate="no">true</code>, or not supplied, it is the next item in the forwards direction. If <i translate="no">forward</i> is <code translate="no">false</code>, it is the next item in the backwards direction.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><!-- @@@nextItemInFocusChain -->
<!-- $$$polish[overload1]$$$polish -->
<h3 class="fn" translate="no" id="polish"><span class="type">void</span> QQuickItem::<span class="name">polish</span>()</h3>
<p>Schedules a polish event for this item.</p>
<p>When the scene graph processes the request, it will call <a href="qquickitem.html#updatePolish" translate="no">updatePolish</a>() on this item.</p>
<p><b>See also </b><a href="qquickitem.html#updatePolish" translate="no">updatePolish</a>(), <a href="../qtqmltest/qquicktest.html#qIsPolishScheduled" translate="no">QQuickTest::qIsPolishScheduled</a>(), and <a href="qquickitem.html#ensurePolished" translate="no">ensurePolished</a>().</p>
<!-- @@@polish -->
<!-- $$$releaseResources[overload1]$$$releaseResources -->
<h3 class="fn" translate="no" id="releaseResources"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">releaseResources</span>()</h3>
<p>This function is called when an item should release graphics resources which are not already managed by the nodes returned from <a href="qquickitem.html#updatePaintNode" translate="no">QQuickItem::updatePaintNode</a>().</p>
<p>This happens when the item is about to be removed from the window it was previously rendering to. The item is guaranteed to have a <a href="qquickitem.html#window" translate="no">window</a> when the function is called.</p>
<p>The function is called on the GUI thread and the state of the rendering thread, when it is used, is unknown. Objects should not be deleted directly, but instead scheduled for cleanup using <a href="qquickwindow.html#scheduleRenderJob" translate="no">QQuickWindow::scheduleRenderJob</a>().</p>
<p><b>See also </b><a href="qquickitem.html#graphics-resource-handling" translate="no">Graphics Resource Handling</a>.</p>
<!-- @@@releaseResources -->
<!-- $$$scopedFocusItem[overload1]$$$scopedFocusItem -->
<h3 class="fn" translate="no" id="scopedFocusItem"><span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *QQuickItem::<span class="name">scopedFocusItem</span>() const</h3>
<p>If this item is a focus scope, this returns the item in its focus chain that currently has focus.</p>
<p>Returns <code translate="no">nullptr</code> if this item is not a focus scope.</p>
<!-- @@@scopedFocusItem -->
<!-- $$$setAcceptHoverEvents[overload1]$$$setAcceptHoverEventsbool -->
<h3 class="fn" translate="no" id="setAcceptHoverEvents"><span class="type">void</span> QQuickItem::<span class="name">setAcceptHoverEvents</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>If <i translate="no">enabled</i> is true, this sets the item to accept hover events; otherwise, hover events are not accepted by this item.</p>
<p><b>See also </b><a href="qquickitem.html#acceptHoverEvents" translate="no">acceptHoverEvents</a>().</p>
<!-- @@@setAcceptHoverEvents -->
<!-- $$$setAcceptTouchEvents[overload1]$$$setAcceptTouchEventsbool -->
<h3 class="fn" translate="no" id="setAcceptTouchEvents"><span class="type">void</span> QQuickItem::<span class="name">setAcceptTouchEvents</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>If <i translate="no">enabled</i> is true, this sets the item to accept touch events; otherwise, touch events are not accepted by this item.</p>
<p><b>See also </b><a href="qquickitem.html#acceptTouchEvents" translate="no">acceptTouchEvents</a>().</p>
<!-- @@@setAcceptTouchEvents -->
<!-- $$$setAcceptedMouseButtons[overload1]$$$setAcceptedMouseButtonsQt::MouseButtons -->
<h3 class="fn" translate="no" id="setAcceptedMouseButtons"><span class="type">void</span> QQuickItem::<span class="name">setAcceptedMouseButtons</span>(<span class="type"><a href="../qtcore/qt.html#MouseButton-enum" translate="no">Qt::MouseButtons</a></span> <i>buttons</i>)</h3>
<p>Sets the mouse buttons accepted by this item to <i translate="no">buttons</i>.</p>
<div class="admonition note">
<p><b>Note: </b>In Qt 5, calling setAcceptedMouseButtons() implicitly caused an item to receive touch events as well as mouse events; but it was recommended to call <a href="qquickitem.html#setAcceptTouchEvents" translate="no">setAcceptTouchEvents</a>() to subscribe for them. In Qt 6, it is necessary to call <a href="qquickitem.html#setAcceptTouchEvents" translate="no">setAcceptTouchEvents</a>() to continue to receive them.</p>
</div>
<p><b>See also </b><a href="qquickitem.html#acceptedMouseButtons" translate="no">acceptedMouseButtons</a>().</p>
<!-- @@@setAcceptedMouseButtons -->
<!-- $$$setCursor[overload1]$$$setCursorconstQCursor& -->
<h3 class="fn" translate="no" id="setCursor"><span class="type">void</span> QQuickItem::<span class="name">setCursor</span>(const <span class="type"><a href="../qtgui/qcursor.html" translate="no">QCursor</a></span> &amp;<i>cursor</i>)</h3>
<p>Sets the <i translate="no">cursor</i> shape for this item.</p>
<p><b>See also </b><a href="qquickitem.html#cursor" translate="no">cursor</a>() and <a href="qquickitem.html#unsetCursor" translate="no">unsetCursor</a>().</p>
<!-- @@@setCursor -->
<!-- $$$setFiltersChildMouseEvents[overload1]$$$setFiltersChildMouseEventsbool -->
<h3 class="fn" translate="no" id="setFiltersChildMouseEvents"><span class="type">void</span> QQuickItem::<span class="name">setFiltersChildMouseEvents</span>(<span class="type">bool</span> <i>filter</i>)</h3>
<p>Sets whether pointer events intended for this item's children should be filtered through this item.</p>
<p>If <i translate="no">filter</i> is true, <a href="qquickitem.html#childMouseEventFilter" translate="no">childMouseEventFilter</a>() will be called when a pointer event is triggered for a child item.</p>
<p><b>See also </b><a href="qquickitem.html#filtersChildMouseEvents" translate="no">filtersChildMouseEvents</a>().</p>
<!-- @@@setFiltersChildMouseEvents -->
<!-- $$$setFlag[overload1]$$$setFlagQQuickItem::Flagbool -->
<h3 class="fn" translate="no" id="setFlag"><span class="type">void</span> QQuickItem::<span class="name">setFlag</span>(<span class="type"><a href="qquickitem.html#Flag-enum" translate="no">QQuickItem::Flag</a></span> <i>flag</i>, <span class="type">bool</span> <i>enabled</i> = true)</h3>
<p>Enables the specified <i translate="no">flag</i> for this item if <i translate="no">enabled</i> is true; if <i translate="no">enabled</i> is false, the flag is disabled.</p>
<p>These provide various hints for the item; for example, the <a href="qquickitem.html#Flag-enum" translate="no">ItemClipsChildrenToShape</a> flag indicates that all children of this item should be clipped to fit within the item area.</p>
<!-- @@@setFlag -->
<!-- $$$setFlags[overload1]$$$setFlagsQQuickItem::Flags -->
<h3 class="fn" translate="no" id="setFlags"><span class="type">void</span> QQuickItem::<span class="name">setFlags</span>(<span class="type"><a href="qquickitem.html#Flag-enum" translate="no">QQuickItem::Flags</a></span> <i>flags</i>)</h3>
<p>Enables the specified <i translate="no">flags</i> for this item.</p>
<p><b>See also </b><a href="qquickitem.html#flags" translate="no">flags</a>() and <a href="qquickitem.html#setFlag" translate="no">setFlag</a>().</p>
<!-- @@@setFlags -->
<!-- $$$setFocusPolicy -->
<h3 class="fn" translate="no" id="setFocusPolicy"><span class="type">void</span> QQuickItem::<span class="name">setFocusPolicy</span>(<span class="type"><a href="../qtcore/qt.html#FocusPolicy-enum" translate="no">Qt::FocusPolicy</a></span> <i>policy</i>)</h3>
<p>Sets the focus policy of this item to <i translate="no">policy</i>.</p>
<div class="admonition note"><p><b>Note: </b>Setter function for property <a href="qquickitem.html#focusPolicy-prop" translate="no">focusPolicy</a>. </p>
</div><p><b>See also </b><a href="qquickitem.html#focusPolicy-prop" translate="no">focusPolicy</a>().</p>
<!-- @@@setFocusPolicy -->
<!-- $$$setKeepMouseGrab[overload1]$$$setKeepMouseGrabbool -->
<h3 class="fn" translate="no" id="setKeepMouseGrab"><span class="type">void</span> QQuickItem::<span class="name">setKeepMouseGrab</span>(<span class="type">bool</span> <i>keep</i>)</h3>
<p>Sets whether the mouse input should remain exclusively with this item.</p>
<p>This is useful for items that wish to grab and keep mouse interaction following a predefined gesture. For example, an item that is interested in horizontal mouse movement may set <a href="qquickitem.html#keepMouseGrab" translate="no">keepMouseGrab</a> to true once a threshold has been exceeded. Once <a href="qquickitem.html#keepMouseGrab" translate="no">keepMouseGrab</a> has been set to true, filtering items will not react to mouse events.</p>
<p>If <i translate="no">keep</i> is false, a filtering item may steal the grab. For example, <a href="qml-qtquick-flickable.html" translate="no">Flickable</a> may attempt to steal a mouse grab if it detects that the user has begun to move the viewport.</p>
<p><b>See also </b><a href="qquickitem.html#keepMouseGrab" translate="no">keepMouseGrab</a>().</p>
<!-- @@@setKeepMouseGrab -->
<!-- $$$setKeepTouchGrab[overload1]$$$setKeepTouchGrabbool -->
<h3 class="fn" translate="no" id="setKeepTouchGrab"><span class="type">void</span> QQuickItem::<span class="name">setKeepTouchGrab</span>(<span class="type">bool</span> <i>keep</i>)</h3>
<p>Sets whether the touch points grabbed by this item should remain exclusively with this item.</p>
<p>This is useful for items that wish to grab and keep specific touch points following a predefined gesture. For example, an item that is interested in horizontal touch point movement may set setKeepTouchGrab to true once a threshold has been exceeded. Once setKeepTouchGrab has been set to true, filtering items will not react to the relevant touch points.</p>
<p>If <i translate="no">keep</i> is false, a filtering item may steal the grab. For example, <a href="qml-qtquick-flickable.html" translate="no">Flickable</a> may attempt to steal a touch point grab if it detects that the user has begun to move the viewport.</p>
<p><b>See also </b><a href="qquickitem.html#keepTouchGrab" translate="no">keepTouchGrab</a>() and <a href="qquickitem.html#setKeepMouseGrab" translate="no">setKeepMouseGrab</a>().</p>
<!-- @@@setKeepTouchGrab -->
<!-- $$$setSize[overload1]$$$setSizeconstQSizeF& -->
<h3 class="fn" translate="no" id="setSize"><span class="type">void</span> QQuickItem::<span class="name">setSize</span>(const <span class="type"><a href="../qtcore/qsizef.html" translate="no">QSizeF</a></span> &amp;<i>size</i>)</h3>
<p>Sets the size of the item to <i translate="no">size</i>. This methods preserves any existing binding on width and height; thus any change that triggers the binding to execute again will override the set values.</p>
<p><b>See also </b><a href="qquickitem.html#size" translate="no">size</a>, <a href="qquickitem.html#width-prop" translate="no">setWidth</a>, and <a href="qquickitem.html#height-prop" translate="no">setHeight</a>.</p>
<!-- @@@setSize -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" translate="no" id="size"><span class="type"><a href="../qtcore/qsizef.html" translate="no">QSizeF</a></span> QQuickItem::<span class="name">size</span>() const</h3>
<p>Returns the size of the item.</p>
<p><b>See also </b><a href="qquickitem.html#setSize" translate="no">setSize</a>, <a href="qquickitem.html#width-prop" translate="no">width</a>, and <a href="qquickitem.html#height-prop" translate="no">height</a>.</p>
<!-- @@@size -->
<!-- $$$stackAfter[overload1]$$$stackAfterconstQQuickItem* -->
<h3 class="fn" translate="no" id="stackAfter"><span class="type">void</span> QQuickItem::<span class="name">stackAfter</span>(const <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>sibling</i>)</h3>
<p>Moves the specified <i translate="no">sibling</i> item to the index after this item within the list of children. The order of children affects both the visual stacking order and tab focus navigation order.</p>
<p>Assuming the z values of both items are the same, this will cause <i translate="no">sibling</i> to be rendered below this item.</p>
<p>If both items have <a href="qquickitem.html#activeFocusOnTab-prop" translate="no">activeFocusOnTab</a> set to <code translate="no">true</code>, this will also cause the tab focus order to change, with <i translate="no">sibling</i> receiving focus before this item.</p>
<p>The given <i translate="no">sibling</i> must be a sibling of this item; that is, they must have the same immediate <a href="qquickitem.html#parent-prop" translate="no">parent</a>.</p>
<p><b>See also </b><a href="qtquick-visualcanvas-visualparent.html" translate="no">Concepts - Visual Parent in Qt Quick</a>.</p>
<!-- @@@stackAfter -->
<!-- $$$stackBefore[overload1]$$$stackBeforeconstQQuickItem* -->
<h3 class="fn" translate="no" id="stackBefore"><span class="type">void</span> QQuickItem::<span class="name">stackBefore</span>(const <span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *<i>sibling</i>)</h3>
<p>Moves the specified <i translate="no">sibling</i> item to the index before this item within the list of children. The order of children affects both the visual stacking order and tab focus navigation order.</p>
<p>Assuming the z values of both items are the same, this will cause <i translate="no">sibling</i> to be rendered above this item.</p>
<p>If both items have <a href="qquickitem.html#activeFocusOnTab-prop" translate="no">activeFocusOnTab</a> set to <code translate="no">true</code>, this will also cause the tab focus order to change, with <i translate="no">sibling</i> receiving focus after this item.</p>
<p>The given <i translate="no">sibling</i> must be a sibling of this item; that is, they must have the same immediate <a href="qquickitem.html#parent-prop" translate="no">parent</a>.</p>
<p><b>See also </b><a href="qtquick-visualcanvas-visualparent.html" translate="no">Concepts - Visual Parent in Qt Quick</a>.</p>
<!-- @@@stackBefore -->
<!-- $$$textureProvider[overload1]$$$textureProvider -->
<h3 class="fn" translate="no" id="textureProvider"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="qsgtextureprovider.html" translate="no">QSGTextureProvider</a></span> *QQuickItem::<span class="name">textureProvider</span>() const</h3>
<p>Returns the texture provider for an item. The default implementation returns <code translate="no">nullptr</code>.</p>
<p>This function may only be called on the rendering thread.</p>
<!-- @@@textureProvider -->
<!-- $$$touchEvent[overload1]$$$touchEventQTouchEvent* -->
<h3 class="fn" translate="no" id="touchEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">touchEvent</span>(<span class="type"><a href="../qtgui/qtouchevent.html" translate="no">QTouchEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive touch events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@touchEvent -->
<!-- $$$touchUngrabEvent[overload1]$$$touchUngrabEvent -->
<h3 class="fn" translate="no" id="touchUngrabEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">touchUngrabEvent</span>()</h3>
<p>This event handler can be reimplemented in a subclass to be notified when a touch ungrab event has occurred on this item.</p>
<!-- @@@touchUngrabEvent -->
<!-- $$$unsetCursor[overload1]$$$unsetCursor -->
<h3 class="fn" translate="no" id="unsetCursor"><span class="type">void</span> QQuickItem::<span class="name">unsetCursor</span>()</h3>
<p>Clears the cursor shape for this item.</p>
<p><b>See also </b><a href="qquickitem.html#cursor" translate="no">cursor</a>() and <a href="qquickitem.html#setCursor" translate="no">setCursor</a>().</p>
<!-- @@@unsetCursor -->
<!-- $$$update[overload1]$$$update -->
<h3 class="fn" translate="no" id="update"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QQuickItem::<span class="name">update</span>()</h3>
<p>Schedules a call to <a href="qquickitem.html#updatePaintNode" translate="no">updatePaintNode</a>() for this item.</p>
<p>The call to <a href="qquickitem.html#updatePaintNode" translate="no">QQuickItem::updatePaintNode</a>() will always happen if the item is showing in a <a href="qquickwindow.html" translate="no">QQuickWindow</a>.</p>
<p>Only items which specify <a href="qquickitem.html#Flag-enum" translate="no">QQuickItem::ItemHasContents</a> are allowed to call QQuickItem::update().</p>
<!-- @@@update -->
<!-- $$$updateInputMethod[overload1]$$$updateInputMethodQt::InputMethodQueries -->
<h3 class="fn" translate="no" id="updateInputMethod"><code class="details extra" translate="no">[protected]</code> <span class="type">void</span> QQuickItem::<span class="name">updateInputMethod</span>(<span class="type"><a href="../qtcore/qt.html#InputMethodQuery-enum" translate="no">Qt::InputMethodQueries</a></span> <i>queries</i> = Qt::ImQueryInput)</h3>
<p>Notify input method on updated query values if needed. <i translate="no">queries</i> indicates the changed attributes.</p>
<!-- @@@updateInputMethod -->
<!-- $$$updatePaintNode[overload1]$$$updatePaintNodeQSGNode*QQuickItem::UpdatePaintNodeData* -->
<h3 class="fn" translate="no" id="updatePaintNode"><code class="details extra" translate="no">[virtual protected]</code> <span class="type"><a href="qsgnode.html" translate="no">QSGNode</a></span> *QQuickItem::<span class="name">updatePaintNode</span>(<span class="type"><a href="qsgnode.html" translate="no">QSGNode</a></span> *<i>oldNode</i>, <span class="type">QQuickItem::UpdatePaintNodeData</span> *<i>updatePaintNodeData</i>)</h3>
<p>Called on the render thread when it is time to sync the state of the item with the scene graph.</p>
<p>The function is called as a result of <a href="qquickitem.html#update" translate="no">QQuickItem::update</a>(), if the user has set the <a href="qquickitem.html#Flag-enum" translate="no">QQuickItem::ItemHasContents</a> flag on the item.</p>
<p>The function should return the root of the scene graph subtree for this item. Most implementations will return a single <a href="qsggeometrynode.html" translate="no">QSGGeometryNode</a> containing the visual representation of this item. <i translate="no">oldNode</i> is the node that was returned the last time the function was called. <i translate="no">updatePaintNodeData</i> provides a pointer to the <a href="qsgtransformnode.html" translate="no">QSGTransformNode</a> associated with this <a href="qquickitem.html" translate="no">QQuickItem</a>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qsgnode.html" translate="no">QSGNode</a></span> <span class="operator">*</span>MyItem<span class="operator">::</span>updatePaintNode(<span class="type"><a href="qsgnode.html" translate="no">QSGNode</a></span> <span class="operator">*</span>node<span class="operator">,</span> UpdatePaintNodeData <span class="operator">*</span>)
 {
     <span class="type"><a href="qsgsimplerectnode.html" translate="no">QSGSimpleRectNode</a></span> <span class="operator">*</span>n <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="qsgsimplerectnode.html" translate="no">QSGSimpleRectNode</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(node);
     <span class="keyword">if</span> (<span class="operator">!</span>n) {
         n <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qsgsimplerectnode.html" translate="no">QSGSimpleRectNode</a></span>();
         n<span class="operator">-</span><span class="operator">&gt;</span>setColor(<span class="type">Qt</span><span class="operator">::</span>red);
     }
     n<span class="operator">-</span><span class="operator">&gt;</span>setRect(boundingRect());
     <span class="keyword">return</span> n;
 }
</pre>
<p>The main thread is blocked while this function is executed so it is safe to read values from the <a href="qquickitem.html" translate="no">QQuickItem</a> instance and other objects in the main thread.</p>
<p>If no call to QQuickItem::updatePaintNode() result in actual scene graph changes, like <a href="qsgnode.html#markDirty" translate="no">QSGNode::markDirty</a>() or adding and removing nodes, then the underlying implementation may decide to not render the scene again as the visual outcome is identical.</p>
<div class="admonition warning">
<p><b>Warning: </b>It is crucial that graphics operations and interaction with the scene graph happens exclusively on the render thread, primarily during the QQuickItem::updatePaintNode() call. The best rule of thumb is to only use classes with the &quot;QSG&quot; prefix inside the QQuickItem::updatePaintNode() function.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function is called on the render thread. This means any QObjects or thread local storage that is created will have affinity to the render thread, so apply caution when doing anything other than rendering in this function. Similarly for signals, these will be emitted on the render thread and will thus often be delivered via queued connections.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a> for more information.</p>
</div>
<p><b>See also </b><a href="qsgmaterial.html" translate="no">QSGMaterial</a>, <a href="qsggeometrynode.html" translate="no">QSGGeometryNode</a>, <a href="qsggeometry.html" translate="no">QSGGeometry</a>, <a href="qsgflatcolormaterial.html" translate="no">QSGFlatColorMaterial</a>, <a href="qsgtexturematerial.html" translate="no">QSGTextureMaterial</a>, <a href="qsgnode.html#markDirty" translate="no">QSGNode::markDirty</a>(), and <a href="qquickitem.html#graphics-resource-handling" translate="no">Graphics Resource Handling</a>.</p>
<!-- @@@updatePaintNode -->
<!-- $$$updatePolish[overload1]$$$updatePolish -->
<h3 class="fn" translate="no" id="updatePolish"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">updatePolish</span>()</h3>
<p>This function should perform any layout as required for this item.</p>
<p>When <a href="qquickitem.html#polish" translate="no">polish</a>() is called, the scene graph schedules a polish event for this item. When the scene graph is ready to render this item, it calls updatePolish() to do any item layout as required before it renders the next frame.</p>
<p><b>See also </b><a href="qquickitem.html#ensurePolished" translate="no">ensurePolished</a>().</p>
<!-- @@@updatePolish -->
<!-- $$$viewportItem[overload1]$$$viewportItem -->
<h3 class="fn" translate="no" id="viewportItem"><span class="type"><a href="qquickitem.html#QQuickItem" translate="no">QQuickItem</a></span> *QQuickItem::<span class="name">viewportItem</span>() const</h3>
<p>If the <a href="qquickitem.html#Flag-enum" translate="no">ItemObservesViewport</a> flag is set, returns the nearest parent with the <a href="qquickitem.html#Flag-enum" translate="no">ItemIsViewport</a> flag. Returns the window's contentItem if the flag is not set, or if no other viewport item is found.</p>
<p>Returns <code translate="no">nullptr</code> only if there is no viewport item and this item is not shown in a window.</p>
<p><b>See also </b><a href="qquickitem.html#clipRect" translate="no">clipRect</a>().</p>
<!-- @@@viewportItem -->
<!-- $$$wheelEvent[overload1]$$$wheelEventQWheelEvent* -->
<h3 class="fn" translate="no" id="wheelEvent"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">void</span> QQuickItem::<span class="name">wheelEvent</span>(<span class="type"><a href="../qtgui/qwheelevent.html" translate="no">QWheelEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive wheel events for an item. The event information is provided by the <i translate="no">event</i> parameter.</p>
<p>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <code translate="no">event-&gt;ignore()</code>.</p>
<!-- @@@wheelEvent -->
<!-- $$$widthValid[overload1]$$$widthValid -->
<h3 class="fn" translate="no" id="widthValid"><code class="details extra" translate="no">[protected]</code> <span class="type">bool</span> QQuickItem::<span class="name">widthValid</span>() const</h3>
<p>Returns whether the width property has been set explicitly.</p>
<!-- @@@widthValid -->
<!-- $$$window[overload1]$$$window -->
<h3 class="fn" translate="no" id="window"><span class="type"><a href="qquickwindow.html" translate="no">QQuickWindow</a></span> *QQuickItem::<span class="name">window</span>() const</h3>
<p>Returns the window in which this item is rendered.</p>
<p>The item does not have a window until it has been assigned into a scene. The <a href="qquickitem.html#windowChanged" translate="no">windowChanged</a>() signal provides a notification both when the item is entered into a scene and when it is removed from a scene.</p>
<!-- @@@window -->
<!-- $$$windowChanged[overload1]$$$windowChangedQQuickWindow* -->
<h3 class="fn" translate="no" id="windowChanged"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QQuickItem::<span class="name">windowChanged</span>(<span class="type"><a href="qquickwindow.html" translate="no">QQuickWindow</a></span> *<i>window</i>)</h3>
<p>This signal is emitted when the item's <i translate="no">window</i> changes.</p>
<!-- @@@windowChanged -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
