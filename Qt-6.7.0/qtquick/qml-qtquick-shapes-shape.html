<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquickshape.cpp -->
  <meta name="description" content="Renders a path.">
  <title>Shape QML Type | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-qmlmodule.html" translate="no">QML Types</a></li>
<li><a href="qtquick-shapes-qmlmodule.html" translate="no">QtQuick.Shapes</a></li>
<li>Shape</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">Shape QML Type</h1>
<!-- $$$Shape-brief -->
<p>Renders a path. <a href="#details">More...</a></p>
<!-- @@@Shape -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Import Statement:</td><td class="memItemRight bottomAlign"> import QtQuick.Shapes 1.7</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <p><a href="qml-qtquick-item.html" translate="no">Item</a></p>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qml-qtquick-particles-ellipseshape.html" translate="no">EllipseShape</a> and <a href="qml-qtquick-particles-maskshape.html" translate="no">MaskShape</a></p>
</td></tr></table></div><ul>
<li><a href="qml-qtquick-shapes-shape-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="properties">Properties</h2>
<ul>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#asynchronous-prop" translate="no">asynchronous</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#boundingRect-prop" translate="no">boundingRect</a></b> : rect <code class="summary extra" translate="no">(since 6.6)</code></li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#containsMode-prop" translate="no">containsMode</a></b> : enumeration <code class="summary extra" translate="no">(since QtQuick.Shapes 1.11)</code></li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#data-prop" translate="no">data</a></b> : list&lt;Object&gt;</li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#fillMode-prop" translate="no">fillMode</a></b> : enumeration <code class="summary extra" translate="no">(since QtQuick.Shapes 6.7)</code></li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#horizontalAlignment-prop" translate="no">horizontalAlignment</a></b> : enumeration <code class="summary extra" translate="no">(since 6.7)</code></li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#preferredRendererType-prop" translate="no">preferredRendererType</a></b> : enumeration <code class="summary extra" translate="no">(since 6.6)</code></li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#rendererType-prop" translate="no">rendererType</a></b> : enumeration</li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#status-prop" translate="no">status</a></b> : enumeration</li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#vendorExtensionsEnabled-prop" translate="no">vendorExtensionsEnabled</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qml-qtquick-shapes-shape.html#verticalAlignment-prop" translate="no">verticalAlignment</a></b> : enumeration <code class="summary extra" translate="no">(since 6.7)</code></li>
</ul>
<!-- $$$Shape-description -->
<h2 id="details">Detailed Description</h2>
<p>Renders a path by triangulating geometry from a <a href="../qtgui/qpainterpath.html" translate="no">QPainterPath</a>.</p>
<p>This approach is different from rendering shapes via <a href="qquickpainteditem.html" translate="no">QQuickPaintedItem</a> or the 2D Canvas because the path never gets rasterized in software. Therefore Shape is suitable for creating shapes spreading over larger areas of the screen, avoiding the performance penalty for texture uploads or framebuffer blits. In addition, the declarative API allows manipulating, binding to, and even animating the path element properties like starting and ending position, the control points, and so on.</p>
<p>The types for specifying path elements are shared between <a href="qml-qtquick-pathview.html" translate="no">PathView</a> and Shape. However, not all Shape implementations support all path element types, while some may not make sense for <a href="qml-qtquick-pathview.html" translate="no">PathView</a>. Shape's currently supported subset is: <a href="qml-qtquick-pathmove.html" translate="no">PathMove</a>, <a href="qml-qtquick-pathline.html" translate="no">PathLine</a>, <a href="qml-qtquick-pathquad.html" translate="no">PathQuad</a>, <a href="qml-qtquick-pathcubic.html" translate="no">PathCubic</a>, <a href="qml-qtquick-patharc.html" translate="no">PathArc</a>, <a href="qml-qtquick-pathtext.html" translate="no">PathText</a> and <a href="qml-qtquick-pathsvg.html" translate="no">PathSvg</a>.</p>
<p>See <a href="qml-qtquick-path.html" translate="no">Path</a> for a detailed overview of the supported path elements.</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-shapes-shape.html" translate="no">Shape</a></span> {
     <span class="name">width</span>: <span class="number">200</span>
     <span class="name">height</span>: <span class="number">150</span>
     <span class="name">anchors</span>.centerIn: <span class="name">parent</span>
     <span class="type"><a href="qml-qtquick-shapes-shapepath.html" translate="no">ShapePath</a></span> {
         <span class="name">strokeWidth</span>: <span class="number">4</span>
         <span class="name">strokeColor</span>: <span class="string">&quot;red&quot;</span>
         <span class="name">fillGradient</span>: <span class="name">LinearGradient</span> {
             <span class="name">x1</span>: <span class="number">20</span>; <span class="name">y1</span>: <span class="number">20</span>
             <span class="name">x2</span>: <span class="number">180</span>; <span class="name">y2</span>: <span class="number">130</span>
             <span class="type"><a href="qml-qtquick-gradientstop.html" translate="no">GradientStop</a></span> { <span class="name">position</span>: <span class="number">0</span>; <span class="name">color</span>: <span class="string">&quot;blue&quot;</span> }
             <span class="type"><a href="qml-qtquick-gradientstop.html" translate="no">GradientStop</a></span> { <span class="name">position</span>: <span class="number">0.2</span>; <span class="name">color</span>: <span class="string">&quot;green&quot;</span> }
             <span class="type"><a href="qml-qtquick-gradientstop.html" translate="no">GradientStop</a></span> { <span class="name">position</span>: <span class="number">0.4</span>; <span class="name">color</span>: <span class="string">&quot;red&quot;</span> }
             <span class="type"><a href="qml-qtquick-gradientstop.html" translate="no">GradientStop</a></span> { <span class="name">position</span>: <span class="number">0.6</span>; <span class="name">color</span>: <span class="string">&quot;yellow&quot;</span> }
             <span class="type"><a href="qml-qtquick-gradientstop.html" translate="no">GradientStop</a></span> { <span class="name">position</span>: <span class="number">1</span>; <span class="name">color</span>: <span class="string">&quot;cyan&quot;</span> }
         }
         <span class="name">strokeStyle</span>: <span class="name">ShapePath</span>.<span class="name">DashLine</span>
         <span class="name">dashPattern</span>: [ <span class="number">1</span>, <span class="number">4</span> ]
         <span class="name">startX</span>: <span class="number">20</span>; <span class="name">startY</span>: <span class="number">20</span>
         <span class="type"><a href="qml-qtquick-pathline.html" translate="no">PathLine</a></span> { <span class="name">x</span>: <span class="number">180</span>; <span class="name">y</span>: <span class="number">130</span> }
         <span class="type"><a href="qml-qtquick-pathline.html" translate="no">PathLine</a></span> { <span class="name">x</span>: <span class="number">20</span>; <span class="name">y</span>: <span class="number">130</span> }
         <span class="type"><a href="qml-qtquick-pathline.html" translate="no">PathLine</a></span> { <span class="name">x</span>: <span class="number">20</span>; <span class="name">y</span>: <span class="number">20</span> }
     }
 }
</pre>
<p class="centerAlign"><img src="images/pathitem-code-example.png" alt="" /></p><p>Like <a href="qml-qtquick-item.html" translate="no">Item</a>, Shape also allows any visual or non-visual objects to be declared as children. <a href="qml-qtquick-shapes-shapepath.html" translate="no">ShapePath</a> objects are handled specially. This is useful since it allows adding visual items, like <a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a> or <a href="qml-qtquick-image.html" translate="no">Image</a>, and non-visual objects, like <a href="../qtqml/qml-qtqml-timer.html" translate="no">Timer</a> directly as children of Shape.</p>
<p>The following list summarizes the available Shape rendering approaches:</p>
<ul>
<li>When Qt Quick is running with the default, hardware-accelerated backend (RHI), the generic shape renderer will be used. This converts the shapes into triangles which are passed to the renderer.</li>
<li>The <code translate="no">software</code> backend is fully supported. The path is rendered via <a href="../qtgui/qpainter.html#strokePath" translate="no">QPainter::strokePath</a>() and <a href="../qtgui/qpainter.html#fillPath" translate="no">QPainter::fillPath</a>() in this case.</li>
<li>The OpenVG backend is not currently supported.</li>
</ul>
<p>When using Shape, it is important to be aware of potential performance implications:</p>
<ul>
<li>When the application is running with the generic, triangulation-based Shape implementation, the geometry generation happens entirely on the CPU. This is potentially expensive. Changing the set of path elements, changing the properties of these elements, or changing certain properties of the Shape itself all lead to retriangulation of the affected paths on every change. Therefore, applying animation to such properties can affect performance on less powerful systems.</li>
<li>However, the data-driven, declarative nature of the Shape API often means better cacheability for the underlying CPU and GPU resources. A property change in one <a href="qml-qtquick-shapes-shapepath.html" translate="no">ShapePath</a> will only lead to reprocessing the affected <a href="qml-qtquick-shapes-shapepath.html" translate="no">ShapePath</a>, leaving other parts of the Shape unchanged. Therefore, a frequently changing property can still result in a lower overall system load than with imperative painting approaches (for example, <a href="../qtgui/qpainter.html" translate="no">QPainter</a>).</li>
<li>At the same time, attention must be paid to the number of Shape elements in the scene. The way such a Shape item is represented in the scene graph is different from an ordinary geometry-based item, and incurs a certain cost when it comes to OpenGL state changes.</li>
<li>As a general rule, scenes should avoid using separate Shape items when it is not absolutely necessary. Prefer using one Shape item with multiple <a href="qml-qtquick-shapes-shapepath.html" translate="no">ShapePath</a> elements over multiple Shape items.</li>
</ul>
<p><b>See also </b><a href="qtquick-quickshapes-shapes-example.html" translate="no">Qt Quick Examples - Shapes</a>, <a href="qtquick-quickshapes-weatherforecast-example.html" translate="no">Weather Forecast Example</a>, <a href="qml-qtquick-path.html" translate="no">Path</a>, <a href="qml-qtquick-pathmove.html" translate="no">PathMove</a>, <a href="qml-qtquick-pathline.html" translate="no">PathLine</a>, <a href="qml-qtquick-pathquad.html" translate="no">PathQuad</a>, <a href="qml-qtquick-pathcubic.html" translate="no">PathCubic</a>, <a href="qml-qtquick-patharc.html" translate="no">PathArc</a>, and <a href="qml-qtquick-pathsvg.html" translate="no">PathSvg</a>.</p>
<!-- @@@Shape -->
<h2>Property Documentation</h2>
<!-- $$$ -->
<div class="qmlitem"><div class="fngroup">
<div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="horizontalAlignment-prop">
<td class="tblQmlPropNode"><p>
<span class="name">horizontalAlignment</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span> <code class="details extra" translate="no">[since 6.7]</code></p></td></tr>
<tr valign="top" class="odd" id="verticalAlignment-prop">
<td class="tblQmlPropNode"><p>
<span class="name">verticalAlignment</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span> <code class="details extra" translate="no">[since 6.7]</code></p></td></tr>
</table></div></div>
</div><div class="qmldoc"><p>Sets the horizontal and vertical alignment of the shape within the item. By default, the shape is aligned with <code translate="no">(0,0)</code> on the top left corner.</p>
<p>The valid values for <code translate="no">horizontalAlignment</code> are <code translate="no">Shape.AlignLeft</code>, <code translate="no">Shape.AlignRight</code> and <code translate="no">Shape.AlignHCenter</code>. The valid values for <code translate="no">verticalAlignment</code> are <code translate="no">Shape.AlignTop</code>, <code translate="no">Shape.AlignBottom</code> and <code translate="no">Shape.AlignVCenter</code>.</p>
<p>This QML property was introduced in Qt 6.7.</p>
</div></div><!-- @@@ -->
<br/>
<!-- $$$asynchronous -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="asynchronous-prop">
<td class="tblQmlPropNode"><p>
<span class="name">asynchronous</span> : <span class="type"><a href="../qtqml/qml-bool.html" translate="no">bool</a></span></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>When <a href="qml-qtquick-shapes-shape.html#rendererType-prop" translate="no">rendererType</a> is <code translate="no">Shape.GeometryRenderer</code> or <code translate="no">Shape.CurveRenderer</code>, a certain amount of preprocessing of the input path is performed on the CPU during the polishing phase of the Shape. This is potentially expensive. To offload this work to separate worker threads, set this property to <code translate="no">true</code>.</p>
<p>When enabled, making a Shape visible will not wait for the content to become available. Instead, the GUI/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</p>
<p>The default value is <code translate="no">false</code>.</p>
</div></div><!-- @@@asynchronous -->
<br/>
<!-- $$$boundingRect -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="boundingRect-prop">
<td class="tblQmlPropNode"><p>
<span class="name">boundingRect</span> : <span class="type"><a href="../qtqml/qml-rect.html" translate="no">rect</a></span> <code class="details extra" translate="no">[since 6.6]</code></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Contains the united bounding rect of all sub paths in the shape.</p>
<p>This property was introduced in Qt 6.6.</p>
</div></div><!-- @@@boundingRect -->
<br/>
<!-- $$$containsMode -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="containsMode-prop">
<td class="tblQmlPropNode"><p>
<span class="name">containsMode</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span> <code class="details extra" translate="no">[since QtQuick.Shapes 1.11]</code></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>This property determines the definition of <a href="qquickitem.html#contains" translate="no">contains</a>() for the Shape. It is useful in case you add <a href="qtquickhandlers-index.html" translate="no">Qt Quick Input Handlers</a> and you want to react only when the mouse or touchpoint is fully inside the Shape.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">Shape.BoundingRectContains</code></td><td class="topAlign">The default implementation of <a href="qquickitem.html#contains" translate="no">QQuickItem::contains</a>() checks only whether the given point is inside the rectangular bounding box. This is the most efficient implementation, which is why it's the default.</td></tr>
<tr><td class="topAlign"><code translate="no">Shape.FillContains</code></td><td class="topAlign">Check whether the interior (the part that would be filled if you are rendering it with fill) of any <a href="qml-qtquick-shapes-shapepath.html" translate="no">ShapePath</a> that makes up this Shape contains the given point. The more complex and numerous ShapePaths you add, the less efficient this is to check, which can potentially slow down event delivery in your application. So it should be used with care.</td></tr>
</table></div>
<p>One way to speed up the <code translate="no">FillContains</code> check is to generate an approximate outline with as few points as possible, place that in a transparent Shape on top, and add your Pointer Handlers to that, so that the containment check is cheaper during event delivery.</p>
<p>This property was introduced in QtQuick.Shapes 1.11.</p>
</div></div><!-- @@@containsMode -->
<br/>
<!-- $$$data -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="data-prop">
<td class="tblQmlPropNode"><p>
<span class="name">data</span> : <span class="type"><a href="../qtqml/qml-list.html" translate="no">list</a></span>&lt;<span class="type">Object</span>&gt; <code class="details extra" translate="no">[default]</code></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>This property holds the <a href="qml-qtquick-shapes-shapepath.html" translate="no">ShapePath</a> objects that define the contents of the Shape. It can also contain any other type of objects, since Shape, like Item, allows adding any visual or non-visual objects as children.</p>
</div></div><!-- @@@data -->
<br/>
<!-- $$$fillMode -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="fillMode-prop">
<td class="tblQmlPropNode"><p>
<span class="name">fillMode</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span> <code class="details extra" translate="no">[since QtQuick.Shapes 6.7]</code></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Set this property to define what happens when the path has a different size than the item.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">Shape.NoResize</code></td><td class="topAlign">the shape is rendered at its native size, independent of the size of the item. This is the default</td></tr>
<tr><td class="topAlign"><code translate="no">Shape.Stretch</code></td><td class="topAlign">the shape is scaled to fit the item, changing the aspect ratio if necessary. Note that non-uniform scaling may cause reduced quality of anti-aliasing when using the curve renderer</td></tr>
<tr><td class="topAlign"><code translate="no">Shape.PreserveAspectFit</code></td><td class="topAlign">the shape is scaled uniformly to fit inside the item</td></tr>
<tr><td class="topAlign"><code translate="no">Shape.PreserveAspectCrop</code></td><td class="topAlign">the shape is scaled uniformly to fill the item fully, extending outside the item if necessary. Note that this only actually crops the content if <a href="qtquick-canvas-example.html#clip" translate="no">clip</a> is true</td></tr>
</table></div>
<p>This property was introduced in QtQuick.Shapes 6.7.</p>
</div></div><!-- @@@fillMode -->
<br/>
<!-- $$$preferredRendererType -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="preferredRendererType-prop">
<td class="tblQmlPropNode"><p>
<span class="name">preferredRendererType</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span> <code class="details extra" translate="no">[since 6.6]</code></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>Requests a specific backend to use for rendering the shape. The possible values are the same as for <a href="qml-qtquick-shapes-shape.html#rendererType-prop" translate="no">rendererType</a>. The default is <code translate="no">Shape.UnknownRenderer</code>, indicating no particular preference.</p>
<p>If the requested renderer type is not supported for the current Qt Quick backend, the default renderer for that backend will be used instead. This will be reflected in the <a href="qml-qtquick-shapes-shape.html#rendererType-prop" translate="no">rendererType</a> when the backend is initialized.</p>
<p><code translate="no">Shape.SoftwareRenderer</code> can currently not be selected without running the scenegraph with the <code translate="no">software</code> backend, in which case it will be selected regardless of the <code translate="no">preferredRendererType</code>.</p>
<p>See <a href="qml-qtquick-shapes-shape.html#rendererType-prop" translate="no">rendererType</a> for more information on the implications.</p>
<p>This property was introduced in Qt 6.6.</p>
</div></div><!-- @@@preferredRendererType -->
<br/>
<!-- $$$rendererType -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="rendererType-prop">
<td class="tblQmlPropNode"><p>
<span class="name">rendererType</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span> <code class="details extra" translate="no">[read-only]</code></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>This property determines which path rendering backend is active.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">Shape.UnknownRenderer</code></td><td class="topAlign">The renderer is unknown.</td></tr>
<tr><td class="topAlign"><code translate="no">Shape.GeometryRenderer</code></td><td class="topAlign">The generic, driver independent solution for GPU rendering. Uses the same CPU-based triangulation approach as <a href="../qtgui/qpainter.html" translate="no">QPainter</a>'s OpenGL 2 paint engine. This is the default when the RHI-based Qt Quick scenegraph backend is in use.</td></tr>
<tr><td class="topAlign"><code translate="no">Shape.SoftwareRenderer</code></td><td class="topAlign">Pure <a href="../qtgui/qpainter.html" translate="no">QPainter</a> drawing using the raster paint engine. This is the default, and only, option when the Qt Quick scenegraph is running with the <code translate="no">software</code> backend.</td></tr>
<tr><td class="topAlign"><code translate="no">Shape.CurveRenderer</code></td><td class="topAlign">GPU-based renderer that aims to preserve curvature at any scale. In contrast to <code translate="no">Shape.GeometryRenderer</code>, curves are not approximated by short straight lines. Instead, curves are rendered using a specialized fragment shader. This improves visual quality and avoids re-tesselation performance hit when zooming. Also, <code translate="no">Shape.CurveRenderer</code> provides native, high-quality anti-aliasing, without the performance cost of multi- or supersampling.</td></tr>
</table></div>
<p>By default, <code translate="no">Shape.GeometryRenderer</code> will be selected unless the Qt Quick scenegraph is running with the <code translate="no">software</code> backend. In that case, <code translate="no">Shape.SoftwareRenderer</code> will be used. <code translate="no">Shape.CurveRenderer</code> may be requested using the <a href="qml-qtquick-shapes-shape.html#preferredRendererType-prop" translate="no">preferredRendererType</a> property.</p>
<div class="admonition note">
<p><b>Note: </b>The <code translate="no">Shape.CurveRenderer</code> will approximate cubic curves with quadratic ones and may therefore diverge slightly from the mathematically correct visualization of the shape. In addition, if the shape is being rendered into a Qt Quick 3D scene and the OpenGL backend for RHI is active, the <code translate="no">GL_OES_standard_derivatives</code> extension to OpenGL is required (this is available by default on OpenGL ES 3 and later, but optional in OpenGL ES 2.)</p>
</div>
</div></div><!-- @@@rendererType -->
<br/>
<!-- $$$status -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="status-prop">
<td class="tblQmlPropNode"><p>
<span class="name">status</span> : <span class="type"><a href="../qtqml/qml-enumeration.html" translate="no">enumeration</a></span> <code class="details extra" translate="no">[read-only]</code></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>This property determines the status of the Shape and is relevant when Shape.asynchronous is set to <code translate="no">true</code>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">Shape.Null</code></td><td class="topAlign">Not yet initialized.</td></tr>
<tr><td class="topAlign"><code translate="no">Shape.Ready</code></td><td class="topAlign">The Shape has finished processing.</td></tr>
<tr><td class="topAlign"><code translate="no">Shape.Processing</code></td><td class="topAlign">The path is being processed.</td></tr>
</table></div>
</div></div><!-- @@@status -->
<br/>
<!-- $$$vendorExtensionsEnabled -->
<div class="qmlitem"><div class="qmlproto" translate="no">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="vendorExtensionsEnabled-prop">
<td class="tblQmlPropNode"><p>
<span class="name">vendorExtensionsEnabled</span> : <span class="type"><a href="../qtqml/qml-bool.html" translate="no">bool</a></span></p></td></tr>
</table></div></div>
<div class="qmldoc"><p>This property controls the usage of non-standard OpenGL extensions.</p>
<p>The default value is <code translate="no">false</code>.</p>
<p>As of Qt 6.0 there are no vendor-specific rendering paths implemented.</p>
</div></div><!-- @@@vendorExtensionsEnabled -->
<br/>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
