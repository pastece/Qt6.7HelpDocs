<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qsgrendererinterface.cpp -->
  <meta name="description" content="An interface providing access to some of the graphics API specific internals of the scenegraph.">
  <title>QSGRendererInterface Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QSGRendererInterface</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QSGRendererInterface Class</h1>
<!-- $$$QSGRendererInterface-brief -->
<p>An interface providing access to some of the graphics API specific internals of the scenegraph. <a href="#details">More...</a></p>
<!-- @@@QSGRendererInterface -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QSGRendererInterface&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Quick) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr>
</table></div>
<ul>
<li><a href="qsgrendererinterface-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#GraphicsApi-enum" translate="no">GraphicsApi</a></b> { Unknown, Software, OpenVG, OpenGL, Direct3D11, &hellip;, Null }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#RenderMode-enum" translate="no">RenderMode</a></b> { RenderMode2D, RenderMode2DNoDepthBuffer, RenderMode3D }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#Resource-enum" translate="no">Resource</a></b> { DeviceResource, CommandQueueResource, CommandListResource, PainterResource, RhiResource, &hellip;, GraphicsQueueIndexResource }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#ShaderCompilationType-enum" translate="no">ShaderCompilationType</a></b> { RuntimeCompilation, OfflineCompilation }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#ShaderCompilationType-enum" translate="no">ShaderCompilationTypes</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#ShaderSourceType-enum" translate="no">ShaderSourceType</a></b> { ShaderSourceString, ShaderSourceFile, ShaderByteCode }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#ShaderSourceType-enum" translate="no">ShaderSourceTypes</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#ShaderType-enum" translate="no">ShaderType</a></b> { UnknownShadingLanguage, GLSL, HLSL, RhiShader }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#getResource" translate="no">getResource</a></b>(QQuickWindow *<i>window</i>, QSGRendererInterface::Resource <i>resource</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#getResource-1" translate="no">getResource</a></b>(QQuickWindow *<i>window</i>, const char *<i>resource</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGRendererInterface::GraphicsApi </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#graphicsApi" translate="no">graphicsApi</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGRendererInterface::ShaderCompilationTypes </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#shaderCompilationType" translate="no">shaderCompilationType</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGRendererInterface::ShaderSourceTypes </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#shaderSourceType" translate="no">shaderSourceType</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGRendererInterface::ShaderType </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#shaderType" translate="no">shaderType</a></b>() const = 0</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsgrendererinterface.html#isApiRhiBased" translate="no">isApiRhiBased</a></b>(QSGRendererInterface::GraphicsApi <i>api</i>)</td></tr>
</table></div>
<!-- $$$QSGRendererInterface-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Renderer interfaces allow accessing graphics API specific functionality in the scenegraph. Such internals are not typically exposed. However, when integrating custom rendering via <a href="qsgrendernode.html" translate="no">QSGRenderNode</a> for example, it may become necessary to query certain values, for instance the graphics device (e.g. the Direct3D or Vulkan device) that is used by the scenegraph.</p>
<p>QSGRendererInterface's functions have varying availability. API and language queries, such as, <a href="qsgrendererinterface.html#graphicsApi" translate="no">graphicsApi</a>() or <a href="qsgrendererinterface.html#shaderType" translate="no">shaderType</a>() are always available, meaning it is sufficient to construct a <a href="qquickwindow.html" translate="no">QQuickWindow</a> or <a href="qquickview.html" translate="no">QQuickView</a>, and the graphics API or shading language in use can be queried right after via <a href="qquickwindow.html#rendererInterface" translate="no">QQuickWindow::rendererInterface</a>(). This guarantees that utilities like the <a href="qml-qtquick-graphicsinfo.html" translate="no">GraphicsInfo</a> QML type are able to report the correct values as early as possible, without having conditional property values - depending on for instance <a href="qsgrendererinterface.html#shaderType" translate="no">shaderType</a>() - evaluate to unexpected values.</p>
<p>Engine-specific accessors, like <a href="qsgrendererinterface.html#getResource" translate="no">getResource</a>(), are however available only after the scenegraph is initialized. Additionally, there may be backend-specific limitations on when such functions can be called. The only way that is guaranteed to succeed is calling them when the rendering of a node (i.e. the preparation of the command list for the next frame) is active. In practice this typically means <a href="qsgrendernode.html#render" translate="no">QSGRenderNode::render</a>().</p>
</div>
<!-- @@@QSGRendererInterface -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$GraphicsApi$$$Unknown$$$Software$$$OpenVG$$$OpenGL$$$Direct3D11$$$Vulkan$$$Metal$$$Null$$$Direct3D12$$$OpenGLRhi$$$Direct3D11Rhi$$$VulkanRhi$$$MetalRhi$$$NullRhi -->
<h3 class="fn" translate="no" id="GraphicsApi-enum">enum QSGRendererInterface::<span class="name">GraphicsApi</span></h3>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::Unknown</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">An unknown graphics API is in use</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::Software</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The Qt Quick 2D Renderer is in use</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::OpenVG</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">OpenVG via EGL</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::OpenGL (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">OpenGL ES 2.0 or higher via a graphics abstraction layer.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::Direct3D11 (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">Direct3D 11 via a graphics abstraction layer.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::Direct3D12 (since Qt 6.6)</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">Direct3D 12 via a graphics abstraction layer.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::Vulkan (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Vulkan 1.0 via a graphics abstraction layer.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::Metal (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">Metal via a graphics abstraction layer.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::Null (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">Null (no output) via a graphics abstraction layer.</td></tr>
</table></div>
<!-- @@@GraphicsApi -->
<!-- $$$RenderMode$$$RenderMode2D$$$RenderMode2DNoDepthBuffer$$$RenderMode3D -->
<h3 class="fn" translate="no" id="RenderMode-enum">enum QSGRendererInterface::<span class="name">RenderMode</span></h3>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RenderMode2D</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Normal 2D rendering</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RenderMode2DNoDepthBuffer</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Normal 2D rendering with depth buffer disabled</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RenderMode3D</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Scene is rendered as part of a 3D graph</td></tr>
</table></div>
<!-- @@@RenderMode -->
<!-- $$$Resource$$$DeviceResource$$$CommandQueueResource$$$CommandListResource$$$PainterResource$$$RhiResource$$$RhiSwapchainResource$$$RhiRedirectCommandBuffer$$$RhiRedirectRenderTarget$$$PhysicalDeviceResource$$$OpenGLContextResource$$$DeviceContextResource$$$CommandEncoderResource$$$VulkanInstanceResource$$$RenderPassResource$$$RedirectPaintDevice$$$GraphicsQueueFamilyIndexResource$$$GraphicsQueueIndexResource -->
<h3 class="fn" translate="no" id="Resource-enum">enum QSGRendererInterface::<span class="name">Resource</span></h3>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::DeviceResource</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The resource is a pointer to the graphics device, when applicable. For example, a <code translate="no">VkDevice *</code>, <code translate="no">MTLDevice *</code> or <code translate="no">ID3D11Device *</code>. Note that with Vulkan the returned value is a pointer to the VkDevice, not the handle itself. This is because Vulkan handles may not be pointers, and may use a different size from the architecture's pointer size so merely casting to/from <code translate="no">void *</code> is wrong.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::CommandQueueResource</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The resource is a pointer to the graphics command queue used by the scenegraph, when applicable. For example, a <code translate="no">VkQueue *</code> or <code translate="no">MTLCommandQueue *</code>. Note that with Vulkan the returned value is a pointer to the VkQueue, not the handle itself.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::CommandListResource</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The resource is a pointer to the command list or buffer used by the scenegraph, when applicable. For example, a <code translate="no">VkCommandBuffer *</code> or <code translate="no">MTLCommandBuffer *</code>. This object has limited validity, and is only valid while the scene graph is preparing the next frame. Note that with Vulkan the returned value is a pointer to the VkCommandBuffer, not the handle itself.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::PainterResource</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The resource is a pointer to the active <a href="../qtgui/qpainter.html" translate="no">QPainter</a> used by the scenegraph, when running with the software backend.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RhiResource (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The resource is a pointer to the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> instance used by the scenegraph, when applicable.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RhiSwapchainResource (since Qt 6.0)</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The resource is a pointer to a QRhiSwapchain instance that is associated with the window. The value is null when the window is used in combination with <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RhiRedirectCommandBuffer (since Qt 6.0)</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The resource is a pointer to a <a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> instance that is associated with the window and its <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>. The value is null when the window is not associated with a <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RhiRedirectRenderTarget (since Qt 6.0)</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">The resource is a pointer to a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> instance that is associated with the window and its <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>. The value is null when the window is not associated with a <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>. Note that the value always reflects the main texture render target and it does not depend on the Qt Quick scene, meaning it does not take any additional texture-targeting render passes generated by <a href="qml-qtquick-shadereffect.html" translate="no">ShaderEffect</a> or <a href="qquickitem.html" translate="no">QQuickItem</a> layers into account.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::PhysicalDeviceResource (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">The resource is a pointer to the pysical device object used by the scenegraph, when applicable. For example, a <code translate="no">VkPhysicalDevice *</code>. Note that with Vulkan the returned value is a pointer to the VkPhysicalDevice, not the handle itself.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::OpenGLContextResource (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">The resource is a pointer to the <a href="../qtgui/qopenglcontext.html" translate="no">QOpenGLContext</a> used by the scenegraph (on the render thread), when applicable.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::DeviceContextResource (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">10</code></td><td class="topAlign">The resource is a pointer to the device context used by the scenegraph, when applicable. For example, a <code translate="no">ID3D11DeviceContext *</code>.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::CommandEncoderResource (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">11</code></td><td class="topAlign">The resource is a pointer to the currently active render command encoder object used by the scenegraph, when applicable. For example, a <code translate="no">MTLRenderCommandEncoder *</code>. This object has limited validity, and is only valid while the scene graph is recording a render pass for the next frame.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::VulkanInstanceResource (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">12</code></td><td class="topAlign">The resource is a pointer to the <a href="../qtgui/qvulkaninstance.html" translate="no">QVulkanInstance</a> used by the scenegraph, when applicable.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RenderPassResource (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">13</code></td><td class="topAlign">The resource is a pointer to the main render pass used by the scenegraph, describing the color and depth/stecil attachments and how they are used. For example, a <code translate="no">VkRenderPass *</code>. Note that the value always reflects the main render target (either the on-screen window or the texture <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a> redirects to) and it does not depend on the Qt Quick scene, meaning it does not take any additional texture-targeting render passes generated by <a href="qml-qtquick-shadereffect.html" translate="no">ShaderEffect</a> or <a href="qquickitem.html" translate="no">QQuickItem</a> layers into account.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RedirectPaintDevice (since Qt 6.4)</code></td><td class="topAlign tblval"><code translate="no">14</code></td><td class="topAlign">The resource is a pointer to <a href="../qtgui/qpaintdevice.html" translate="no">QPaintDevice</a> instance that is associated with the window and its <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>. The value is null when the window is not associated with a <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::GraphicsQueueFamilyIndexResource (since Qt 6.6)</code></td><td class="topAlign tblval"><code translate="no">15</code></td><td class="topAlign">The resource is a pointer to the graphics queue family index used by the scenegraph, when applicable. With Vulkan, this is a pointer to a <code translate="no">uint32_t</code> index value.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::GraphicsQueueIndexResource (since Qt 6.6)</code></td><td class="topAlign tblval"><code translate="no">16</code></td><td class="topAlign">The resource is a pointer to the graphics queue index (uint32_t) used by the scenegraph, when applicable. With Vulkan, this is a pointer to a <code translate="no">uint32_t</code> index value, which in practice is the index of the VkQueue reported for <code translate="no">CommandQueueResource</code>.</td></tr>
</table></div>
<!-- @@@Resource -->
<!-- $$$ShaderCompilationType$$$RuntimeCompilation$$$OfflineCompilation -->
<h3 class="flags" id="ShaderCompilationType-enum">enum QSGRendererInterface::<span class="name">ShaderCompilationType</span><br/>flags QSGRendererInterface::<span class="name">ShaderCompilationTypes</span></h3>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RuntimeCompilation</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Runtime compilation of shader source code is supported</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::OfflineCompilation</code></td><td class="topAlign tblval"><code translate="no">0x02</code></td><td class="topAlign">Pre-compiled bytecode supported</td></tr>
</table></div>
<p>The ShaderCompilationTypes type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;ShaderCompilationType&gt;. It stores an OR combination of ShaderCompilationType values.</p>
<!-- @@@ShaderCompilationType -->
<!-- $$$ShaderSourceType$$$ShaderSourceString$$$ShaderSourceFile$$$ShaderByteCode -->
<h3 class="flags" id="ShaderSourceType-enum">enum QSGRendererInterface::<span class="name">ShaderSourceType</span><br/>flags QSGRendererInterface::<span class="name">ShaderSourceTypes</span></h3>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::ShaderSourceString</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Shader source can be provided as a string in the corresponding properties of <a href="qml-qtquick-shadereffect.html" translate="no">ShaderEffect</a></td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::ShaderSourceFile</code></td><td class="topAlign tblval"><code translate="no">0x02</code></td><td class="topAlign">Local or resource files containing shader source code are supported</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::ShaderByteCode</code></td><td class="topAlign tblval"><code translate="no">0x04</code></td><td class="topAlign">Local or resource files containing shader bytecode are supported</td></tr>
</table></div>
<p>The ShaderSourceTypes type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;ShaderSourceType&gt;. It stores an OR combination of ShaderSourceType values.</p>
<!-- @@@ShaderSourceType -->
<!-- $$$ShaderType$$$UnknownShadingLanguage$$$GLSL$$$HLSL$$$RhiShader -->
<h3 class="fn" translate="no" id="ShaderType-enum">enum QSGRendererInterface::<span class="name">ShaderType</span></h3>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::UnknownShadingLanguage</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Not yet known due to no window and scenegraph associated</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::GLSL</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">GLSL or GLSL ES</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::HLSL</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">HLSL</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRendererInterface::RhiShader (since Qt 5.14)</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Consumes <a href="../qtgui/qshader.html" translate="no">QShader</a> instances containing shader variants for multiple target languages and intermediate formats.</td></tr>
</table></div>
<!-- @@@ShaderType -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$getResource[overload1]$$$getResourceQQuickWindow*QSGRendererInterface::Resource -->
<h3 class="fn" translate="no" id="getResource"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> *QSGRendererInterface::<span class="name">getResource</span>(<span class="type"><a href="qquickwindow.html" translate="no">QQuickWindow</a></span> *<i>window</i>, <span class="type"><a href="qsgrendererinterface.html#Resource-enum" translate="no">QSGRendererInterface::Resource</a></span> <i>resource</i>) const</h3>
<p>Queries a graphics <i translate="no">resource</i> in <i translate="no">window</i>. Returns null when the resource in question is not supported or not available.</p>
<p>When successful, the returned pointer is either a direct pointer to an interface, or a pointer to an opaque handle that needs to be dereferenced first (for example, <code translate="no">VkDevice dev = *static_cast&lt;VkDevice *&gt;(result)</code>). The latter is necessary since such handles may have sizes different from a pointer.</p>
<div class="admonition note">
<p><b>Note: </b>The ownership of the returned pointer is never transferred to the caller.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function must only be called on the render thread.</p>
</div>
<!-- @@@getResource -->
<!-- $$$getResource$$$getResourceQQuickWindow*constchar* -->
<h3 class="fn" translate="no" id="getResource-1"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> *QSGRendererInterface::<span class="name">getResource</span>(<span class="type"><a href="qquickwindow.html" translate="no">QQuickWindow</a></span> *<i>window</i>, const <span class="type">char</span> *<i>resource</i>) const</h3>
<p>Queries a graphics resource. <i translate="no">resource</i> is a backend-specific key. This allows supporting any future resources that are not listed in the Resource enum.</p>
<div class="admonition note">
<p><b>Note: </b>The ownership of the returned pointer is never transferred to the caller.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function must only be called on the render thread.</p>
</div>
<!-- @@@getResource -->
<!-- $$$graphicsApi[overload1]$$$graphicsApi -->
<h3 class="fn" translate="no" id="graphicsApi"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qsgrendererinterface.html#GraphicsApi-enum" translate="no">QSGRendererInterface::GraphicsApi</a></span> QSGRendererInterface::<span class="name">graphicsApi</span>() const</h3>
<p>Returns the graphics API that is in use by the Qt Quick scenegraph.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called on any thread.</p>
</div>
<!-- @@@graphicsApi -->
<!-- $$$isApiRhiBased[overload1]$$$isApiRhiBasedQSGRendererInterface::GraphicsApi -->
<h3 class="fn" translate="no" id="isApiRhiBased"><code class="details extra" translate="no">[static]</code> <span class="type">bool</span> QSGRendererInterface::<span class="name">isApiRhiBased</span>(<span class="type"><a href="qsgrendererinterface.html#GraphicsApi-enum" translate="no">QSGRendererInterface::GraphicsApi</a></span> <i>api</i>)</h3>
<p>Returns true if <i translate="no">api</i> is based on a graphics abstraction layer (<a href="../qtgui/qrhi.html" translate="no">QRhi</a>) instead of directly calling the native graphics API.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called on any thread.</p>
</div>
<!-- @@@isApiRhiBased -->
<!-- $$$shaderCompilationType[overload1]$$$shaderCompilationType -->
<h3 class="fn" translate="no" id="shaderCompilationType"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qsgrendererinterface.html#ShaderCompilationType-enum" translate="no">QSGRendererInterface::ShaderCompilationTypes</a></span> QSGRendererInterface::<span class="name">shaderCompilationType</span>() const</h3>
<p>Returns a bitmask of the shader compilation approaches supported by the Qt Quick backend the application is using.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called on any thread.</p>
</div>
<p><b>See also </b><a href="qml-qtquick-graphicsinfo.html" translate="no">QtQuick::GraphicsInfo</a>.</p>
<!-- @@@shaderCompilationType -->
<!-- $$$shaderSourceType[overload1]$$$shaderSourceType -->
<h3 class="fn" translate="no" id="shaderSourceType"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qsgrendererinterface.html#ShaderSourceType-enum" translate="no">QSGRendererInterface::ShaderSourceTypes</a></span> QSGRendererInterface::<span class="name">shaderSourceType</span>() const</h3>
<p>Returns a bitmask of the supported ways of providing shader sources in <a href="qml-qtquick-shadereffect.html" translate="no">ShaderEffect</a> items.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called on any thread.</p>
</div>
<p><b>See also </b><a href="qml-qtquick-graphicsinfo.html" translate="no">QtQuick::GraphicsInfo</a>.</p>
<!-- @@@shaderSourceType -->
<!-- $$$shaderType[overload1]$$$shaderType -->
<h3 class="fn" translate="no" id="shaderType"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qsgrendererinterface.html#ShaderType-enum" translate="no">QSGRendererInterface::ShaderType</a></span> QSGRendererInterface::<span class="name">shaderType</span>() const</h3>
<p>Returns the shading language supported by the Qt Quick backend the application is using.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called on any thread.</p>
</div>
<p><b>See also </b><a href="qml-qtquick-graphicsinfo.html" translate="no">QtQuick::GraphicsInfo</a>.</p>
<!-- @@@shaderType -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
