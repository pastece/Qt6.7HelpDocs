<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquickwidget.cpp -->
  <meta name="description" content="The QQuickWidget class provides a widget for displaying a Qt Quick user interface.">
  <title>QQuickWidget Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li><a href="qtquickwidgets-module.html" translate="no">QtQuickWidgets</a></li>
<li>QQuickWidget</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#performance-considerations">Performance Considerations</a></li>
<li class="level2"><a href="#graphics-api-support">Graphics API Support</a></li>
<li class="level2"><a href="#scene-graph-and-context-persistency">Scene Graph and Context Persistency</a></li>
<li class="level2"><a href="#limitations">Limitations</a></li>
<li class="level2"><a href="#tab-key-handling">Tab Key Handling</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QQuickWidget Class</h1>
<!-- $$$QQuickWidget-brief -->
<p>The QQuickWidget class provides a widget for displaying a Qt Quick user interface. <a href="#details">More...</a></p>
<!-- @@@QQuickWidget -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QQuickWidget&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS QuickWidgets) <br/>
target_link_libraries(mytarget PRIVATE Qt6::QuickWidgets)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quickwidgets</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></td></tr>
</table></div>
<ul>
<li><a href="qquickwidget-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#ResizeMode-enum" translate="no">ResizeMode</a></b> { SizeViewToRootObject, SizeRootObjectToView }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#Status-enum" translate="no">Status</a></b> { Null, Ready, Loading, Error }</td></tr>
</table></div>
<h2 id="properties">Properties</h2>
<ul>
<li class="fn" translate="no"><b><a href="qquickwidget.html#resizeMode-prop" translate="no">resizeMode</a></b> : ResizeMode</li>
<li class="fn" translate="no"><b><a href="qquickwidget.html#source-prop" translate="no">source</a></b> : QUrl</li>
<li class="fn" translate="no"><b><a href="qquickwidget.html#status-prop" translate="no">status</a></b> : const Status</li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#QQuickWidget" translate="no">QQuickWidget</a></b>(QWidget *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#QQuickWidget-1" translate="no">QQuickWidget</a></b>(QQmlEngine *<i>engine</i>, QWidget *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#QQuickWidget-2" translate="no">QQuickWidget</a></b>(const QUrl &amp;<i>source</i>, QWidget *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dtor.QQuickWidget" translate="no">~QQuickWidget</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlEngine *</td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#engine" translate="no">engine</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QQmlError&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#errors" translate="no">errors</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSurfaceFormat </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#format" translate="no">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#grabFramebuffer" translate="no">grabFramebuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#initialSize" translate="no">initialSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickWindow *</td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#quickWindow" translate="no">quickWindow</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickWidget::ResizeMode </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#resizeMode-prop" translate="no">resizeMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#rootContext" translate="no">rootContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#rootObject" translate="no">rootObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#setClearColor" translate="no">setClearColor</a></b>(const QColor &amp;<i>color</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#setFormat" translate="no">setFormat</a></b>(const QSurfaceFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#resizeMode-prop" translate="no">setResizeMode</a></b>(QQuickWidget::ResizeMode)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrl </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#source" translate="no">source</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickWidget::Status </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#status-prop" translate="no">status</a></b>() const</td></tr>
</table></div>
<h2 id="public-slots">Public Slots</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#setSource" translate="no">setSource</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#sceneGraphError" translate="no">sceneGraphError</a></b>(QQuickWindow::SceneGraphError <i>error</i>, const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#statusChanged" translate="no">statusChanged</a></b>(QQuickWidget::Status <i>status</i>)</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dragEnterEvent" translate="no">dragEnterEvent</a></b>(QDragEnterEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dragLeaveEvent" translate="no">dragLeaveEvent</a></b>(QDragLeaveEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dragMoveEvent" translate="no">dragMoveEvent</a></b>(QDragMoveEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dropEvent" translate="no">dropEvent</a></b>(QDropEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#event" translate="no">event</a></b>(QEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#focusInEvent" translate="no">focusInEvent</a></b>(QFocusEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#focusNextPrevChild" translate="no">focusNextPrevChild</a></b>(bool <i>next</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#focusOutEvent" translate="no">focusOutEvent</a></b>(QFocusEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#hideEvent" translate="no">hideEvent</a></b>(QHideEvent *) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#keyPressEvent" translate="no">keyPressEvent</a></b>(QKeyEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#keyReleaseEvent" translate="no">keyReleaseEvent</a></b>(QKeyEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#mouseDoubleClickEvent" translate="no">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#mouseMoveEvent" translate="no">mouseMoveEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#mousePressEvent" translate="no">mousePressEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#mouseReleaseEvent" translate="no">mouseReleaseEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#paintEvent" translate="no">paintEvent</a></b>(QPaintEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#showEvent" translate="no">showEvent</a></b>(QShowEvent *) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#wheelEvent" translate="no">wheelEvent</a></b>(QWheelEvent *<i>e</i>) override</td></tr>
</table></div>
<!-- $$$QQuickWidget-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>This is a convenience wrapper for <a href="qquickwindow.html" translate="no">QQuickWindow</a> which will automatically load and display a QML scene when given the URL of the main source file. Alternatively, you can instantiate your own objects using <a href="../qtqml/qqmlcomponent.html" translate="no">QQmlComponent</a> and place them in a manually set up QQuickWidget.</p>
<p>Typical usage:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qquickwidget.html#QQuickWidget" translate="no">QQuickWidget</a></span> <span class="operator">*</span>view <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qquickwidget.html#QQuickWidget" translate="no">QQuickWidget</a></span>;
 view<span class="operator">-</span><span class="operator">&gt;</span>setSource(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span><span class="operator">::</span>fromLocalFile(<span class="string">&quot;myqmlfile.qml&quot;</span>));
 view<span class="operator">-</span><span class="operator">&gt;</span>show();
</pre>
<p>To receive errors related to loading and executing QML with QQuickWidget, you can connect to the <a href="qquickwidget.html#statusChanged" translate="no">statusChanged</a>() signal and monitor for <a href="qquickwidget.html#Status-enum" translate="no">QQuickWidget::Error</a>. The errors are available via <a href="qquickwidget.html#errors" translate="no">QQuickWidget::errors</a>().</p>
<p>QQuickWidget also manages sizing of the view and root object. By default, the <a href="qquickwidget.html#resizeMode-prop" translate="no">resizeMode</a> is <a href="qquickwidget.html#ResizeMode-enum" translate="no">SizeViewToRootObject</a>, which will load the component and resize it to the size of the view. Alternatively the <a href="qquickwidget.html#resizeMode-prop" translate="no">resizeMode</a> may be set to <a href="qquickwidget.html#ResizeMode-enum" translate="no">SizeRootObjectToView</a> which will resize the view to the size of the root object.</p>
<h3 id="performance-considerations">Performance Considerations</h3>
<p>QQuickWidget is an alternative to using <a href="qquickview.html" translate="no">QQuickView</a> and <a href="../qtwidgets/qwidget.html#createWindowContainer" translate="no">QWidget::createWindowContainer</a>(). The restrictions on stacking order do not apply, making QQuickWidget the more flexible alternative, behaving more like an ordinary widget.</p>
<p>However, the above mentioned advantages come at the expense of performance:</p>
<ul>
<li>Unlike <a href="qquickwindow.html" translate="no">QQuickWindow</a> and <a href="qquickview.html" translate="no">QQuickView</a>, QQuickWidget involves at least one additional render pass targeting an offscreen color buffer, typically a 2D texture, followed by drawing a texture quad. This means increased load especially for the fragment processing of the GPU.</li>
<li>Using QQuickWidget disables the <a href="qtquick-visualcanvas-scenegraph.html#threaded-render-loop" translate="no">threaded render loop</a> on all platforms. This means that some of the benefits of threaded rendering, for example <a href="qml-qtquick-animator.html" translate="no">Animator</a> classes and vsync driven animations, will not be available.</li>
</ul>
<div class="admonition note">
<p><b>Note: </b>Avoid calling <a href="../qtwidgets/qwidget.html#winId" translate="no">winId</a>() on a QQuickWidget. This function triggers the creation of a native window, resulting in reduced performance and possibly rendering glitches. The entire purpose of QQuickWidget is to render Quick scenes without a separate native window, hence making it a native widget should always be avoided.</p>
</div>
<h3 id="graphics-api-support">Graphics API Support</h3>
<p>QQuickWidget is functional with all the 3D graphics APIs supported by Qt Quick, as well as the <code translate="no">software</code> backend. Other backends, for example OpenVG, are not compatible however and attempting to construct a QQuickWidget will lead to problems.</p>
<p>Overriding the platform's default graphics API is done the same way as with <a href="qquickwindow.html" translate="no">QQuickWindow</a> and <a href="qquickview.html" translate="no">QQuickView</a>: either by calling <a href="qquickwindow.html#setGraphicsApi" translate="no">QQuickWindow::setGraphicsApi</a>() early on before constructing the first QQuickWidget, or by setting the <code translate="no">QSG_RHI_BACKEND</code> environment variable.</p>
<div class="admonition note">
<p><b>Note: </b>One top-level window can only use one single graphics API for rendering. For example, attempting to place a QQuickWidget using Vulkan and a <a href="../qtopengl/qopenglwidget.html" translate="no">QOpenGLWidget</a> in the widget hierarchy of the same top-level window, problems will occur and one of the widgets will not be rendering as expected.</p>
</div>
<h3 id="scene-graph-and-context-persistency">Scene Graph and Context Persistency</h3>
<p>QQuickWidget honors <a href="qquickwindow.html#isPersistentSceneGraph" translate="no">QQuickWindow::isPersistentSceneGraph</a>(), meaning that applications can decide - by calling <a href="qquickwindow.html#setPersistentSceneGraph" translate="no">QQuickWindow::setPersistentSceneGraph</a>() on the window returned from the <a href="qquickwidget.html#quickWindow" translate="no">quickWindow</a>() function - to let scenegraph nodes and other Qt Quick scene related resources be released whenever the widget becomes hidden. By default persistency is enabled, just like with <a href="qquickwindow.html" translate="no">QQuickWindow</a>.</p>
<p>When running with the OpenGL, <a href="qquickwindow.html" translate="no">QQuickWindow</a> offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by QQuickWidget and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a QQuickWidget into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the <a href="../qtopengl/qopenglwidget.html" translate="no">QOpenGLWidget</a> documentation.</p>
<div class="admonition note">
<p><b>Note: </b>QQuickWidget offers less fine-grained control over its internal OpenGL context than <a href="../qtopengl/qopenglwidget.html" translate="no">QOpenGLWidget</a>, and there are subtle differences, most notably that disabling the persistent scene graph will lead to destroying the context on a window change regardless of the presence of QCoreApplication::AA_ShareOpenGLContexts.</p>
</div>
<h3 id="limitations">Limitations</h3>
<p>Putting other widgets underneath and making the QQuickWidget transparent will not lead to the expected results: the widgets underneath will not be visible. This is because in practice the QQuickWidget is drawn before all other regular, non-OpenGL widgets, and so see-through types of solutions are not feasible. Other type of layouts, like having widgets on top of the QQuickWidget, will function as expected.</p>
<p>When absolutely necessary, this limitation can be overcome by setting the <a href="../qtcore/qt.html#WidgetAttribute-enum" translate="no">Qt::WA_AlwaysStackOnTop</a> attribute on the QQuickWidget. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the QQuickWidget, so it should only be used in situations where a semi-transparent QQuickWidget with other widgets visible underneath is required.</p>
<p>This limitation only applies when there are other widgets underneath the QQuickWidget inside the same window. Making the window semi-transparent, with other applications and the desktop visible in the background, is done in the traditional way: Set <a href="../qtcore/qt.html#WidgetAttribute-enum" translate="no">Qt::WA_TranslucentBackground</a> on the top-level window, request an alpha channel, and change the Qt Quick Scenegraph's clear color to <a href="../qtcore/qt.html#GlobalColor-enum" translate="no">Qt::transparent</a> via <a href="qquickwidget.html#setClearColor" translate="no">setClearColor</a>().</p>
<h3 id="tab-key-handling">Tab Key Handling</h3>
<p>On press of the <code translate="no">[TAB]</code> key, the item inside the QQuickWidget gets focus. If this item can handle <code translate="no">[TAB]</code> key press, focus will change accordingly within the item, otherwise the next widget in the focus chain gets focus.</p>
</div>
<p><b>See also </b><a href="../qtqml/qtqml-cppintegration-exposecppattributes.html" translate="no">Exposing Attributes of C++ Types to QML</a>, <a href="qtquick-quickwidgets-quickwidget-example.html" translate="no">Qt Quick Widgets Example</a>, and <a href="qquickview.html" translate="no">QQuickView</a>.</p>
<!-- @@@QQuickWidget -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ResizeMode$$$SizeViewToRootObject$$$SizeRootObjectToView -->
<h3 class="fn" translate="no" id="ResizeMode-enum">enum QQuickWidget::<span class="name">ResizeMode</span></h3>
<p>This enum specifies how to resize the view.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickWidget::SizeViewToRootObject</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The view resizes with the root item in the QML.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWidget::SizeRootObjectToView</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The view will automatically resize the root item to the size of the view.</td></tr>
</table></div>
<!-- @@@ResizeMode -->
<!-- $$$Status$$$Null$$$Ready$$$Loading$$$Error -->
<h3 class="fn" translate="no" id="Status-enum">enum QQuickWidget::<span class="name">Status</span></h3>
<p>Specifies the loading status of the <a href="qquickwidget.html" translate="no">QQuickWidget</a>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickWidget::Null</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">This <a href="qquickwidget.html" translate="no">QQuickWidget</a> has no source set.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWidget::Ready</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">This <a href="qquickwidget.html" translate="no">QQuickWidget</a> has loaded and created the QML component.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWidget::Loading</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">This <a href="qquickwidget.html" translate="no">QQuickWidget</a> is loading network data.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWidget::Error</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">One or more errors occurred. Call <a href="qquickwidget.html#errors" translate="no">errors</a>() to retrieve a list of errors.</td></tr>
</table></div>
<!-- @@@Status -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$resizeMode-prop$$$resizeMode$$$setResizeModeQQuickWidget::ResizeMode -->
<h3 class="fn" translate="no" id="resizeMode-prop"><span class="name">resizeMode</span> : <span class="type"><a href="qquickwidget.html#ResizeMode-enum" translate="no">ResizeMode</a></span></h3>
<p>Determines whether the view should resize the window contents.</p>
<p>If this property is set to <a href="qquickwidget.html#ResizeMode-enum" translate="no">SizeViewToRootObject</a> (the default), the view resizes to the size of the root item in the QML.</p>
<p>If this property is set to <a href="qquickwidget.html#ResizeMode-enum" translate="no">SizeRootObjectToView</a>, the view will automatically resize the root item to the size of the view.</p>
<p>Regardless of this property, the sizeHint of the view is the initial size of the root item. Note though that since QML may load dynamically, that size may change.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QQuickWidget::ResizeMode </td><td class="memItemRight bottomAlign"><span class="name"><b>resizeMode</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setResizeMode</b></span>(QQuickWidget::ResizeMode)</td></tr>
</table></div>
<p><b>See also </b><a href="qquickwidget.html#initialSize" translate="no">initialSize</a>().</p>
<!-- @@@resizeMode -->
<!-- $$$source-prop$$$source$$$setSourceconstQUrl& -->
<h3 class="fn" translate="no" id="source-prop"><span class="name">source</span> : <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span></h3>
<p>This property holds the URL of the source of the QML component.</p>
<p>Ensure that the URL provided is full and correct, in particular, use <a href="../qtcore/qurl.html#fromLocalFile" translate="no">QUrl::fromLocalFile</a>() when loading a file from the local filesystem.</p>
<div class="admonition note">
<p><b>Note: </b>Setting a source URL will result in the QML component being instantiated, even if the URL is unchanged from the current value.</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QUrl </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qquickwidget.html#source" translate="no">source</a></b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qquickwidget.html#setSource" translate="no">setSource</a></b></span>(const QUrl &amp;<i>url</i>)</td></tr>
</table></div>
<!-- @@@source -->
<!-- $$$status-prop$$$status$$$statusChangedQQuickWidget::Status -->
<h3 class="fn" translate="no" id="status-prop"><code class="details extra" translate="no">[read-only]</code> <span class="name">status</span> : const <span class="type"><a href="qquickwidget.html#Status-enum" translate="no">Status</a></span></h3>
<p>The component's current <a href="qquickwidget.html#Status-enum" translate="no">status</a>.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QQuickWidget::Status </td><td class="memItemRight bottomAlign"><span class="name"><b>status</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qquickwidget.html#statusChanged" translate="no">statusChanged</a></b></span>(QQuickWidget::Status <i>status</i>)</td></tr>
</table></div>
<!-- @@@status -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickWidget[overload1]$$$QQuickWidgetQWidget* -->
<h3 class="fn" translate="no" id="QQuickWidget"><code class="details extra" translate="no">[explicit]</code> QQuickWidget::<span class="name">QQuickWidget</span>(<span class="type"><a href="../qtwidgets/qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a QQuickWidget with the given <i translate="no">parent</i>. The default value of <i translate="no">parent</i> is 0.</p>
<!-- @@@QQuickWidget -->
<!-- $$$QQuickWidget$$$QQuickWidgetQQmlEngine*QWidget* -->
<h3 class="fn" translate="no" id="QQuickWidget-1">QQuickWidget::<span class="name">QQuickWidget</span>(<span class="type"><a href="../qtqml/qqmlengine.html" translate="no">QQmlEngine</a></span> *<i>engine</i>, <span class="type"><a href="../qtwidgets/qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>parent</i>)</h3>
<p>Constructs a QQuickWidget with the given QML <i translate="no">engine</i> and <i translate="no">parent</i>.</p>
<p>Note: In this case, the QQuickWidget does not own the given <i translate="no">engine</i> object; it is the caller's responsibility to destroy the engine. If the <i translate="no">engine</i> is deleted before the view, <a href="qquickwidget.html#status-prop" translate="no">status</a>() will return <a href="qquickwidget.html#Status-enum" translate="no">QQuickWidget::Error</a>.</p>
<p><b>See also </b><a href="qquickwidget.html#Status-enum" translate="no">Status</a>, <a href="qquickwidget.html#status-prop" translate="no">status</a>(), and <a href="qquickwidget.html#errors" translate="no">errors</a>().</p>
<!-- @@@QQuickWidget -->
<!-- $$$QQuickWidget$$$QQuickWidgetconstQUrl&QWidget* -->
<h3 class="fn" translate="no" id="QQuickWidget-2"><code class="details extra" translate="no">[explicit]</code> QQuickWidget::<span class="name">QQuickWidget</span>(const <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> &amp;<i>source</i>, <span class="type"><a href="../qtwidgets/qwidget.html#QWidget" translate="no">QWidget</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a QQuickWidget with the given QML <i translate="no">source</i> and <i translate="no">parent</i>. The default value of <i translate="no">parent</i> is 0.</p>
<!-- @@@QQuickWidget -->
<!-- $$$~QQuickWidget[overload1]$$$~QQuickWidget -->
<h3 class="fn" translate="no" id="dtor.QQuickWidget"><code class="details extra" translate="no">[override virtual noexcept]</code> QQuickWidget::<span class="name">~QQuickWidget</span>()</h3>
<p>Destroys the <a href="qquickwidget.html" translate="no">QQuickWidget</a>.</p>
<!-- @@@~QQuickWidget -->
<!-- $$$dragEnterEvent[overload1]$$$dragEnterEventQDragEnterEvent* -->
<h3 class="fn" translate="no" id="dragEnterEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">dragEnterEvent</span>(<span class="type"><a href="../qtgui/qdragenterevent.html" translate="no">QDragEnterEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#dragEnterEvent" translate="no">QWidget::dragEnterEvent</a>(QDragEnterEvent *event).</p>
<!-- @@@dragEnterEvent -->
<!-- $$$dragLeaveEvent[overload1]$$$dragLeaveEventQDragLeaveEvent* -->
<h3 class="fn" translate="no" id="dragLeaveEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">dragLeaveEvent</span>(<span class="type"><a href="../qtgui/qdragleaveevent.html" translate="no">QDragLeaveEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#dragLeaveEvent" translate="no">QWidget::dragLeaveEvent</a>(QDragLeaveEvent *event).</p>
<!-- @@@dragLeaveEvent -->
<!-- $$$dragMoveEvent[overload1]$$$dragMoveEventQDragMoveEvent* -->
<h3 class="fn" translate="no" id="dragMoveEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">dragMoveEvent</span>(<span class="type"><a href="../qtgui/qdragmoveevent.html" translate="no">QDragMoveEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#dragMoveEvent" translate="no">QWidget::dragMoveEvent</a>(QDragMoveEvent *event).</p>
<!-- @@@dragMoveEvent -->
<!-- $$$dropEvent[overload1]$$$dropEventQDropEvent* -->
<h3 class="fn" translate="no" id="dropEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">dropEvent</span>(<span class="type"><a href="../qtgui/qdropevent.html" translate="no">QDropEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#dropEvent" translate="no">QWidget::dropEvent</a>(QDropEvent *event).</p>
<!-- @@@dropEvent -->
<!-- $$$engine[overload1]$$$engine -->
<h3 class="fn" translate="no" id="engine"><span class="type"><a href="../qtqml/qqmlengine.html" translate="no">QQmlEngine</a></span> *QQuickWidget::<span class="name">engine</span>() const</h3>
<p>Returns a pointer to the <a href="../qtqml/qqmlengine.html" translate="no">QQmlEngine</a> used for instantiating QML Components.</p>
<!-- @@@engine -->
<!-- $$$errors[overload1]$$$errors -->
<h3 class="fn" translate="no" id="errors"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtqml/qqmlerror.html" translate="no">QQmlError</a></span>&gt; QQuickWidget::<span class="name">errors</span>() const</h3>
<p>Return the list of errors that occurred during the last compile or create operation. When the status is not <a href="qquickwidget.html#Status-enum" translate="no">Error</a>, an empty list is returned.</p>
<p><b>See also </b><a href="qquickwidget.html#status-prop" translate="no">status</a>.</p>
<!-- @@@errors -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" translate="no" id="event"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">bool</span> QQuickWidget::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#event" translate="no">QWidget::event</a>(QEvent *event).</p>
<!-- @@@event -->
<!-- $$$focusInEvent[overload1]$$$focusInEventQFocusEvent* -->
<h3 class="fn" translate="no" id="focusInEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">focusInEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html" translate="no">QFocusEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#focusInEvent" translate="no">QWidget::focusInEvent</a>(QFocusEvent *event).</p>
<!-- @@@focusInEvent -->
<!-- $$$focusNextPrevChild[overload1]$$$focusNextPrevChildbool -->
<h3 class="fn" translate="no" id="focusNextPrevChild"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">bool</span> QQuickWidget::<span class="name">focusNextPrevChild</span>(<span class="type">bool</span> <i>next</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#focusNextPrevChild" translate="no">QWidget::focusNextPrevChild</a>(bool next).</p>
<!-- @@@focusNextPrevChild -->
<!-- $$$focusOutEvent[overload1]$$$focusOutEventQFocusEvent* -->
<h3 class="fn" translate="no" id="focusOutEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">focusOutEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html" translate="no">QFocusEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#focusOutEvent" translate="no">QWidget::focusOutEvent</a>(QFocusEvent *event).</p>
<!-- @@@focusOutEvent -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" translate="no" id="format"><span class="type"><a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a></span> QQuickWidget::<span class="name">format</span>() const</h3>
<p>Returns the actual surface format.</p>
<p>If the widget has not yet been shown, the requested format is returned.</p>
<p><b>See also </b><a href="qquickwidget.html#setFormat" translate="no">setFormat</a>().</p>
<!-- @@@format -->
<!-- $$$grabFramebuffer[overload1]$$$grabFramebuffer -->
<h3 class="fn" translate="no" id="grabFramebuffer"><span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span> QQuickWidget::<span class="name">grabFramebuffer</span>() const</h3>
<p>Renders a frame and reads it back into an image.</p>
<div class="admonition note">
<p><b>Note: </b>This is a potentially expensive operation.</p>
</div>
<!-- @@@grabFramebuffer -->
<!-- $$$hideEvent[overload1]$$$hideEventQHideEvent* -->
<h3 class="fn" translate="no" id="hideEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">hideEvent</span>(<span class="type"><a href="../qtgui/qhideevent.html" translate="no">QHideEvent</a></span> *)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#hideEvent" translate="no">QWidget::hideEvent</a>(QHideEvent *event).</p>
<!-- @@@hideEvent -->
<!-- $$$initialSize[overload1]$$$initialSize -->
<h3 class="fn" translate="no" id="initialSize"><span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> QQuickWidget::<span class="name">initialSize</span>() const</h3>
<p>Returns the initial size of the root object.</p>
<p>If <a href="qquickwidget.html#resizeMode-prop" translate="no">resizeMode</a> is <a href="qquickwidget.html#ResizeMode-enum" translate="no">SizeRootObjectToView</a>, the root object will be resized to the size of the view. This function returns the size of the root object before it was resized.</p>
<!-- @@@initialSize -->
<!-- $$$keyPressEvent[overload1]$$$keyPressEventQKeyEvent* -->
<h3 class="fn" translate="no" id="keyPressEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">keyPressEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#keyPressEvent" translate="no">QWidget::keyPressEvent</a>(QKeyEvent *event).</p>
<!-- @@@keyPressEvent -->
<!-- $$$keyReleaseEvent[overload1]$$$keyReleaseEventQKeyEvent* -->
<h3 class="fn" translate="no" id="keyReleaseEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">keyReleaseEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#keyReleaseEvent" translate="no">QWidget::keyReleaseEvent</a>(QKeyEvent *event).</p>
<!-- @@@keyReleaseEvent -->
<!-- $$$mouseDoubleClickEvent[overload1]$$$mouseDoubleClickEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mouseDoubleClickEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#mouseDoubleClickEvent" translate="no">QWidget::mouseDoubleClickEvent</a>(QMouseEvent *event).</p>
<!-- @@@mouseDoubleClickEvent -->
<!-- $$$mouseMoveEvent[overload1]$$$mouseMoveEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mouseMoveEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#mouseMoveEvent" translate="no">QWidget::mouseMoveEvent</a>(QMouseEvent *event).</p>
<!-- @@@mouseMoveEvent -->
<!-- $$$mousePressEvent[overload1]$$$mousePressEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mousePressEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">mousePressEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#mousePressEvent" translate="no">QWidget::mousePressEvent</a>(QMouseEvent *event).</p>
<!-- @@@mousePressEvent -->
<!-- $$$mouseReleaseEvent[overload1]$$$mouseReleaseEventQMouseEvent* -->
<h3 class="fn" translate="no" id="mouseReleaseEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html" translate="no">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#mouseReleaseEvent" translate="no">QWidget::mouseReleaseEvent</a>(QMouseEvent *event).</p>
<!-- @@@mouseReleaseEvent -->
<!-- $$$paintEvent[overload1]$$$paintEventQPaintEvent* -->
<h3 class="fn" translate="no" id="paintEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">paintEvent</span>(<span class="type"><a href="../qtgui/qpaintevent.html" translate="no">QPaintEvent</a></span> *<i>event</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#paintEvent" translate="no">QWidget::paintEvent</a>(QPaintEvent *event).</p>
<!-- @@@paintEvent -->
<!-- $$$quickWindow[overload1]$$$quickWindow -->
<h3 class="fn" translate="no" id="quickWindow"><span class="type"><a href="qquickwindow.html" translate="no">QQuickWindow</a></span> *QQuickWidget::<span class="name">quickWindow</span>() const</h3>
<p>Returns the offscreen <a href="qquickwindow.html" translate="no">QQuickWindow</a> which is used by this widget to drive the Qt Quick rendering. This is useful if you want to use <a href="qquickwindow.html" translate="no">QQuickWindow</a> APIs that are not currently exposed by <a href="qquickwidget.html" translate="no">QQuickWidget</a>, for instance connecting to the <a href="qquickwindow.html#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>() signal in order to draw native OpenGL content below Qt Quick's own rendering.</p>
<div class="admonition warning">
<p><b>Warning: </b>Use the return value of this function with caution. In particular, do not ever attempt to show the <a href="qquickwindow.html" translate="no">QQuickWindow</a>, and be very careful when using other <a href="../qtgui/qwindow.html" translate="no">QWindow</a>-only APIs.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>The offscreen window may be deleted (and recreated) during the life time of the <a href="qquickwidget.html" translate="no">QQuickWidget</a>, particularly when the widget is moved to another <a href="qquickwindow.html" translate="no">QQuickWindow</a>. If you need to know when the window has been replaced, connect to its <a href="../qtcore/qobject.html#destroyed" translate="no">destroyed</a>() signal.</p>
</div>
<!-- @@@quickWindow -->
<!-- $$$rootContext[overload1]$$$rootContext -->
<h3 class="fn" translate="no" id="rootContext"><span class="type"><a href="../qtqml/qqmlcontext.html" translate="no">QQmlContext</a></span> *QQuickWidget::<span class="name">rootContext</span>() const</h3>
<p>This function returns the root of the context hierarchy. Each QML component is instantiated in a <a href="../qtqml/qqmlcontext.html" translate="no">QQmlContext</a>. <a href="../qtqml/qqmlcontext.html" translate="no">QQmlContext</a>'s are essential for passing data to QML components. In QML, contexts are arranged hierarchically and this hierarchy is managed by the <a href="../qtqml/qqmlengine.html" translate="no">QQmlEngine</a>.</p>
<!-- @@@rootContext -->
<!-- $$$rootObject[overload1]$$$rootObject -->
<h3 class="fn" translate="no" id="rootObject"><span class="type"><a href="qquickitem.html" translate="no">QQuickItem</a></span> *QQuickWidget::<span class="name">rootObject</span>() const</h3>
<p>Returns the view's root <a href="qquickitem.html" translate="no">item</a>. Can be null when <a href="qquickwidget.html#setSource" translate="no">setSource</a>() has not been called, if it was called with broken <a href="qtquick-module.html" translate="no">QtQuick</a> code or while the <a href="qtquick-module.html" translate="no">QtQuick</a> contents are being created.</p>
<!-- @@@rootObject -->
<!-- $$$sceneGraphError[overload1]$$$sceneGraphErrorQQuickWindow::SceneGraphErrorconstQString& -->
<h3 class="fn" translate="no" id="sceneGraphError"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QQuickWidget::<span class="name">sceneGraphError</span>(<span class="type"><a href="qquickwindow.html#SceneGraphError-enum" translate="no">QQuickWindow::SceneGraphError</a></span> <i>error</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>message</i>)</h3>
<p>This signal is emitted when an <i translate="no">error</i> occurred during scene graph initialization.</p>
<p>Applications should connect to this signal if they wish to handle errors, like OpenGL context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the <i translate="no">message</i>, or show a message box, and terminate the application.</p>
<p>This signal will be emitted from the GUI thread.</p>
<p><b>See also </b><a href="qquickwindow.html#sceneGraphError" translate="no">QQuickWindow::sceneGraphError</a>().</p>
<!-- @@@sceneGraphError -->
<!-- $$$setClearColor[overload1]$$$setClearColorconstQColor& -->
<h3 class="fn" translate="no" id="setClearColor"><span class="type">void</span> QQuickWidget::<span class="name">setClearColor</span>(const <span class="type"><a href="../qtgui/qcolor.html" translate="no">QColor</a></span> &amp;<i>color</i>)</h3>
<p>Sets the clear <i translate="no">color</i>. By default this is an opaque color.</p>
<p>To get a semi-transparent <a href="qquickwidget.html" translate="no">QQuickWidget</a>, call this function with <i translate="no">color</i> set to <a href="../qtcore/qt.html#GlobalColor-enum" translate="no">Qt::transparent</a>, set the <a href="../qtcore/qt.html#WidgetAttribute-enum" translate="no">Qt::WA_TranslucentBackground</a> widget attribute on the top-level window, and request an alpha channel via <a href="qquickwidget.html#setFormat" translate="no">setFormat</a>().</p>
<p><b>See also </b><a href="qquickwindow.html#color-prop" translate="no">QQuickWindow::setColor</a>().</p>
<!-- @@@setClearColor -->
<!-- $$$setFormat[overload1]$$$setFormatconstQSurfaceFormat& -->
<h3 class="fn" translate="no" id="setFormat"><span class="type">void</span> QQuickWidget::<span class="name">setFormat</span>(const <span class="type"><a href="../qtgui/qsurfaceformat.html" translate="no">QSurfaceFormat</a></span> &amp;<i>format</i>)</h3>
<p>Sets the surface <i translate="no">format</i> for the context and offscreen surface used by this widget.</p>
<p>Call this function when there is a need to request a context for a given OpenGL version or profile. The sizes for depth, stencil and alpha buffers are taken care of automatically and there is no need to request those explicitly.</p>
<p><b>See also </b><a href="../qtgui/qwindow.html#setFormat" translate="no">QWindow::setFormat</a>(), <a href="../qtgui/qwindow.html#format" translate="no">QWindow::format</a>(), and <a href="qquickwidget.html#format" translate="no">format</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setSource -->
<h3 class="fn" translate="no" id="setSource"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QQuickWidget::<span class="name">setSource</span>(const <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> &amp;<i>url</i>)</h3>
<p>Sets the source to the <i translate="no">url</i>, loads the QML component and instantiates it.</p>
<p>Ensure that the URL provided is full and correct, in particular, use <a href="../qtcore/qurl.html#fromLocalFile" translate="no">QUrl::fromLocalFile</a>() when loading a file from the local filesystem.</p>
<p>Calling this method multiple times with the same URL will result in the QML component being reinstantiated.</p>
<div class="admonition note"><p><b>Note: </b>Setter function for property <a href="qquickwidget.html#source" translate="no">source</a>. </p>
</div><p><b>See also </b><a href="qquickwidget.html#source" translate="no">source</a>().</p>
<!-- @@@setSource -->
<!-- $$$showEvent[overload1]$$$showEventQShowEvent* -->
<h3 class="fn" translate="no" id="showEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">showEvent</span>(<span class="type"><a href="../qtgui/qshowevent.html" translate="no">QShowEvent</a></span> *)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#showEvent" translate="no">QWidget::showEvent</a>(QShowEvent *event).</p>
<!-- @@@showEvent -->
<!-- $$$source -->
<h3 class="fn" translate="no" id="source"><span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> QQuickWidget::<span class="name">source</span>() const</h3>
<p>Returns the source URL, if set.</p>
<div class="admonition note"><p><b>Note: </b>Getter function for property source. </p>
</div><p><b>See also </b><a href="qquickwidget.html#setSource" translate="no">setSource</a>().</p>
<!-- @@@source -->
<!-- $$$statusChanged -->
<h3 class="fn" translate="no" id="statusChanged"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QQuickWidget::<span class="name">statusChanged</span>(<span class="type"><a href="qquickwidget.html#Status-enum" translate="no">QQuickWidget::Status</a></span> <i>status</i>)</h3>
<p>This signal is emitted when the component's current <i translate="no">status</i> changes.</p>
<div class="admonition note"><p><b>Note: </b>Notifier signal for property <a href="qquickwidget.html#status-prop" translate="no">status</a>. </p>
</div><!-- @@@statusChanged -->
<!-- $$$wheelEvent[overload1]$$$wheelEventQWheelEvent* -->
<h3 class="fn" translate="no" id="wheelEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QQuickWidget::<span class="name">wheelEvent</span>(<span class="type"><a href="../qtgui/qwheelevent.html" translate="no">QWheelEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtwidgets/qwidget.html#wheelEvent" translate="no">QWidget::wheelEvent</a>(QWheelEvent *event).</p>
<!-- @@@wheelEvent -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
