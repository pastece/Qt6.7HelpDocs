<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qsgrendernode.cpp -->
  <meta name="description" content="The QSGRenderNode class represents a set of custom rendering commands targeting the graphics API that is in use by the scenegraph.">
  <title>QSGRenderNode Class | Qt Quick 6.7.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.7</a></li>
<li><a href="qtquick-index.html" translate="no">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QSGRenderNode</li>
<li id="buildversion"><a href="qtquick-index.html" translate="no">Qt 6.7.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QSGRenderNode Class</h1>
<!-- $$$QSGRenderNode-brief -->
<p>The QSGRenderNode class represents a set of custom rendering commands targeting the graphics API that is in use by the scenegraph. <a href="#details">More...</a></p>
<!-- @@@QSGRenderNode -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QSGRenderNode&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Quick) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qsgnode.html" translate="no">QSGNode</a></td></tr>
</table></div>
<ul>
<li><a href="qsgrendernode-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#RenderingFlag-enum" translate="no">RenderingFlag</a></b> { BoundedRectRendering, DepthAwareRendering, OpaqueRendering, NoExternalRendering }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#RenderingFlag-enum" translate="no">RenderingFlags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#StateFlag-enum" translate="no">StateFlag</a></b> { DepthState, StencilState, ScissorState, ColorState, BlendState, &hellip;, RenderTargetState }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#StateFlag-enum" translate="no">StateFlags</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#dtor.QSGRenderNode" translate="no">~QSGRenderNode</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGRenderNode::StateFlags </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#changedStates" translate="no">changedStates</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QSGClipNode *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#clipList" translate="no">clipList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QRhiCommandBuffer *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#commandBuffer" translate="no">commandBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGRenderNode::RenderingFlags </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#inheritedOpacity" translate="no">inheritedOpacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QMatrix4x4 *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#matrix" translate="no">matrix</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.0)</code> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#prepare" translate="no">prepare</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> const QMatrix4x4 *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#projectionMatrix" translate="no">projectionMatrix</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRectF </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#rect" translate="no">rect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#releaseResources" translate="no">releaseResources</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#render" translate="no">render</a></b>(const QSGRenderNode::RenderState *<i>state</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QRhiRenderTarget *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode.html#renderTarget" translate="no">renderTarget</a></b>() const</td></tr>
</table></div>
<!-- $$$QSGRenderNode-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QSGRenderNode allows creating scene graph nodes that perform their own custom rendering via <a href="../qtgui/qrhi.html" translate="no">QRhi</a> (the common approach from Qt 6.6 on), directly via a 3D graphics API such as OpenGL, Vulkan, or Metal, or, when the <code translate="no">software</code> backend is in use, via <a href="../qtgui/qpainter.html" translate="no">QPainter</a>.</p>
<p>QSGRenderNode is the enabler for one of the three ways to integrate custom 2D/3D rendering into a Qt Quick scene. The other two options are to perform the rendering <code translate="no">before</code> or <code translate="no">after</code> the Qt Quick scene's own rendering, or to generate a whole separate render pass targeting a dedicated render target (a texture) and then have an item in the scene display the texture. The QSGRenderNode-based approach is similar to the former, in the sense that no additional render passes or render targets are involved, and allows injecting custom rendering commands &quot;inline&quot; with the Qt Quick scene's own rendering.</p>
</div>
<p><b>See also </b><a href="qtquick-scenegraph-customrendernode-example.html" translate="no">Scene Graph - Custom QSGRenderNode</a>.</p>
<!-- @@@QSGRenderNode -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$RenderingFlag$$$BoundedRectRendering$$$DepthAwareRendering$$$OpaqueRendering$$$NoExternalRendering -->
<h3 class="flags" id="RenderingFlag-enum">enum QSGRenderNode::<span class="name">RenderingFlag</span><br/>flags QSGRenderNode::<span class="name">RenderingFlags</span></h3>
<p>Possible values for the bitmask returned from <a href="qsgrendernode.html#flags" translate="no">flags</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::BoundedRectRendering</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Indicates that the implementation of <a href="qsgrendernode.html#render" translate="no">render</a>() does not render outside the area reported from <a href="qsgrendernode.html#rect" translate="no">rect</a>() in item coordinates. Such node implementations can lead to more efficient rendering, depending on the scenegraph backend. For example, the <code translate="no">software</code> backend can continue to use the more optimal partial update path when all render nodes in the scene have this flag set.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::DepthAwareRendering</code></td><td class="topAlign tblval"><code translate="no">0x02</code></td><td class="topAlign">Indicates that the implementations of <a href="qsgrendernode.html#render" translate="no">render</a>() conforms to scenegraph expectations by only generating a Z value of 0 in scene coordinates which is then transformed by the matrices retrieved from <a href="qsgrendernode-renderstate.html#projectionMatrix" translate="no">RenderState::projectionMatrix</a>() and <a href="qsgrendernode.html#matrix" translate="no">matrix</a>(), as described in the notes for <a href="qsgrendernode.html#render" translate="no">render</a>(). Such node implementations can lead to more efficient rendering, depending on the scenegraph backend. For example, the batching OpenGL renderer can continue to use a more optimal path when all render nodes in the scene have this flag set.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::OpaqueRendering</code></td><td class="topAlign tblval"><code translate="no">0x04</code></td><td class="topAlign">Indicates that the implementation of <a href="qsgrendernode.html#render" translate="no">render</a>() writes out opaque pixels for the entire area reported from <a href="qsgrendernode.html#rect" translate="no">rect</a>(). By default the renderers must assume that <a href="qsgrendernode.html#render" translate="no">render</a>() can also output semi or fully transparent pixels. Setting this flag can improve performance in some cases.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::NoExternalRendering</code></td><td class="topAlign tblval"><code translate="no">0x08</code></td><td class="topAlign">Indicates that the implementation of <a href="qsgrendernode.html#prepare" translate="no">prepare</a>() and <a href="qsgrendernode.html#render" translate="no">render</a>() use the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> family of APIs, instead of directly calling a 3D API such as OpenGL, Vulkan, or Metal.</td></tr>
</table></div>
<p>The RenderingFlags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;RenderingFlag&gt;. It stores an OR combination of RenderingFlag values.</p>
<p><b>See also </b><a href="qsgrendernode.html#render" translate="no">render</a>(), <a href="qsgrendernode.html#prepare" translate="no">prepare</a>(), <a href="qsgrendernode.html#rect" translate="no">rect</a>(), and <a href="../qtgui/qrhi.html" translate="no">QRhi</a>.</p>
<!-- @@@RenderingFlag -->
<!-- $$$StateFlag$$$DepthState$$$StencilState$$$ScissorState$$$ColorState$$$BlendState$$$CullState$$$ViewportState$$$RenderTargetState -->
<h3 class="flags" id="StateFlag-enum">enum QSGRenderNode::<span class="name">StateFlag</span><br/>flags QSGRenderNode::<span class="name">StateFlags</span></h3>
<p>This enum is a bit mask identifying several states.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::DepthState</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Depth</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::StencilState</code></td><td class="topAlign tblval"><code translate="no">0x02</code></td><td class="topAlign">Stencil</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::ScissorState</code></td><td class="topAlign tblval"><code translate="no">0x04</code></td><td class="topAlign">Scissor</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::ColorState</code></td><td class="topAlign tblval"><code translate="no">0x08</code></td><td class="topAlign">Color</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::BlendState</code></td><td class="topAlign tblval"><code translate="no">0x10</code></td><td class="topAlign">Blend</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::CullState</code></td><td class="topAlign tblval"><code translate="no">0x20</code></td><td class="topAlign">Cull</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::ViewportState</code></td><td class="topAlign tblval"><code translate="no">0x40</code></td><td class="topAlign">View poirt</td></tr>
<tr><td class="topAlign"><code translate="no">QSGRenderNode::RenderTargetState</code></td><td class="topAlign tblval"><code translate="no">0x80</code></td><td class="topAlign">Render target</td></tr>
</table></div>
<p>The StateFlags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;StateFlag&gt;. It stores an OR combination of StateFlag values.</p>
<!-- @@@StateFlag -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$~QSGRenderNode[overload1]$$$~QSGRenderNode -->
<h3 class="fn" translate="no" id="dtor.QSGRenderNode"><code class="details extra" translate="no">[override virtual noexcept]</code> QSGRenderNode::<span class="name">~QSGRenderNode</span>()</h3>
<p>Destructs the render node. Derived classes are expected to perform cleanup similar to <a href="qsgrendernode.html#releaseResources" translate="no">releaseResources</a>() in here.</p>
<p>When a low-level graphics API is in use, the scenegraph will make sure there is a CPU-side wait for the GPU to complete all work submitted to the scenegraph's graphics command queue before the scenegraph's nodes are deleted. Therefore there is no need to issue additional waits here, unless the <a href="qsgrendernode.html#render" translate="no">render</a>() implementation is using additional command queues.</p>
<p>With <a href="../qtgui/qrhi.html" translate="no">QRhi</a> and resources such as <a href="../qtgui/qrhibuffer.html" translate="no">QRhiBuffer</a>, <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>, <a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a>, etc., it is often good practice to use smart pointers, such as std::unique_ptr, which can often avoid the need to implement a destructor, and lead to more compact source code. Keep in mind however that implementing <a href="qsgrendernode.html#releaseResources" translate="no">releaseResources</a>(), most likely issuing a number of reset() calls on the unique_ptrs, is still important.</p>
<p><b>See also </b><a href="qsgrendernode.html#releaseResources" translate="no">releaseResources</a>().</p>
<!-- @@@~QSGRenderNode -->
<!-- $$$changedStates[overload1]$$$changedStates -->
<h3 class="fn" translate="no" id="changedStates"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="qsgrendernode.html#StateFlag-enum" translate="no">QSGRenderNode::StateFlags</a></span> QSGRenderNode::<span class="name">changedStates</span>() const</h3>
<p>When the underlying rendering API is OpenGL, this function should return a mask where each bit represents graphics states changed by the <a href="qsgrendernode.html#render" translate="no">render</a>() function:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">DepthState</code></td><td class="topAlign">depth write mask, depth test enabled, depth comparison function</td></tr>
<tr><td class="topAlign"><code translate="no">StencilState</code></td><td class="topAlign">stencil write masks, stencil test enabled, stencil operations, stencil comparison functions</td></tr>
<tr><td class="topAlign"><code translate="no">ScissorState</code></td><td class="topAlign">scissor enabled, scissor test enabled</td></tr>
<tr><td class="topAlign"><code translate="no">ColorState</code></td><td class="topAlign">clear color, color write mask</td></tr>
<tr><td class="topAlign"><code translate="no">BlendState</code></td><td class="topAlign">blend enabled, blend function</td></tr>
<tr><td class="topAlign"><code translate="no">CullState</code></td><td class="topAlign">front face, cull face enabled</td></tr>
<tr><td class="topAlign"><code translate="no">ViewportState</code></td><td class="topAlign">viewport</td></tr>
<tr><td class="topAlign"><code translate="no">RenderTargetState</code></td><td class="topAlign">render target</td></tr>
</table></div>
<p>With APIs other than OpenGL, the only relevant values are the ones that correspond to dynamic state changes recorded on the command list/buffer. For example, RSSetViewports, RSSetScissorRects, OMSetBlendState, OMSetDepthStencilState in case of D3D11, or vkCmdSetViewport, vkCmdSetScissor, vkCmdSetBlendConstants, vkCmdSetStencilRef in case of Vulkan, and only when such commands were added to the scenegraph's command list queried via the QSGRendererInterface::CommandList resource enum. States set in pipeline state objects do not need to be reported here. Similarly, draw call related settings (pipeline states, descriptor sets, vertex or index buffer bindings, root signature, descriptor heaps, etc.) are always set again by the scenegraph so <a href="qsgrendernode.html#render" translate="no">render</a>() can freely change them.</p>
<p><a href="qsgrendernode.html#StateFlag-enum" translate="no">RenderTargetState</a> is no longer supported with APIs like Vulkan. This is by nature. <a href="qsgrendernode.html#render" translate="no">render</a>() is invoked while the Qt Quick scenegraph's main command buffer is recording a renderpass, so there is no possibility of changing the target and starting another renderpass (on that command buffer at least). Therefore returning a value with <a href="qsgrendernode.html#StateFlag-enum" translate="no">RenderTargetState</a> set is not sensible.</p>
<div class="admonition note">
<p><b>Note: </b>The <code translate="no">software</code> backend exposes its <a href="../qtgui/qpainter.html" translate="no">QPainter</a> and saves and restores before and after invoking <a href="qsgrendernode.html#render" translate="no">render</a>(). Therefore reporting any changed states from here is not necessary.</p>
</div>
<p>The function is called by the renderer so it can reset the states after rendering this node. This makes the implementation of <a href="qsgrendernode.html#render" translate="no">render</a>() simpler since it does not have to query and restore these states.</p>
<p>The default implementation returns 0, meaning no relevant state was changed in <a href="qsgrendernode.html#render" translate="no">render</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This function may be called before <a href="qsgrendernode.html#render" translate="no">render</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>With Qt 6 and <a href="../qtgui/qrhi.html" translate="no">QRhi</a>-based rendering the only relevant values are <a href="qsgrendernode.html#StateFlag-enum" translate="no">ViewportState</a> and <a href="qsgrendernode.html#StateFlag-enum" translate="no">ScissorState</a>. Other values can be returned but are ignored in practice.</p>
</div>
<!-- @@@changedStates -->
<!-- $$$clipList[overload1]$$$clipList -->
<h3 class="fn" translate="no" id="clipList">const <span class="type"><a href="qsgclipnode.html" translate="no">QSGClipNode</a></span> *QSGRenderNode::<span class="name">clipList</span>() const</h3>
<p>Returns the current clip list.</p>
<!-- @@@clipList -->
<!-- $$$commandBuffer[overload1]$$$commandBuffer -->
<h3 class="fn" translate="no" id="commandBuffer"><code class="details extra" translate="no">[since 6.6]</code> <span class="type"><a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a></span> *QSGRenderNode::<span class="name">commandBuffer</span>() const</h3>
<p>Returns the current command buffer.</p>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qsgrendernode.html#renderTarget" translate="no">renderTarget</a>().</p>
<!-- @@@commandBuffer -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="qsgrendernode.html#RenderingFlag-enum" translate="no">QSGRenderNode::RenderingFlags</a></span> QSGRenderNode::<span class="name">flags</span>() const</h3>
<p>Returns flags describing the behavior of this render node.</p>
<p>The default implementation returns 0.</p>
<p><b>See also </b><a href="qsgrendernode.html#RenderingFlag-enum" translate="no">RenderingFlag</a> and <a href="qsgrendernode.html#rect" translate="no">rect</a>().</p>
<!-- @@@flags -->
<!-- $$$inheritedOpacity[overload1]$$$inheritedOpacity -->
<h3 class="fn" translate="no" id="inheritedOpacity"><span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> QSGRenderNode::<span class="name">inheritedOpacity</span>() const</h3>
<p>Returns the current effective opacity.</p>
<!-- @@@inheritedOpacity -->
<!-- $$$matrix[overload1]$$$matrix -->
<h3 class="fn" translate="no" id="matrix">const <span class="type"><a href="../qtgui/qmatrix4x4.html" translate="no">QMatrix4x4</a></span> *QSGRenderNode::<span class="name">matrix</span>() const</h3>
<p>Returns pointer to the current model-view matrix.</p>
<!-- @@@matrix -->
<!-- $$$prepare[overload1]$$$prepare -->
<h3 class="fn" translate="no" id="prepare"><code class="details extra" translate="no">[virtual, since 6.0]</code> <span class="type">void</span> QSGRenderNode::<span class="name">prepare</span>()</h3>
<p>Called from the frame preparation phase. There is a call to this function before each invocation of <a href="qsgrendernode.html#render" translate="no">render</a>().</p>
<p>Unlike <a href="qsgrendernode.html#render" translate="no">render</a>(), this function is called before the scenegraph starts recording the render pass for the current frame on the underlying command buffer. This is useful when doing rendering with graphics APIs, such as Vulkan, where copy type of operations will need to be recorded before the render pass.</p>
<p>The default implementation is empty.</p>
<p>When implementing a <a href="qsgrendernode.html" translate="no">QSGRenderNode</a> that uses <a href="../qtgui/qrhi.html" translate="no">QRhi</a> to render, query the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> object from the <a href="qquickwindow.html" translate="no">QQuickWindow</a> via <a href="qquickwindow.html#rhi" translate="no">QQuickWindow::rhi</a>(). To get a <a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> for submitting work to, call <a href="qsgrendernode.html#commandBuffer" translate="no">commandBuffer</a>(). To query information about the active render target, call <a href="qsgrendernode.html#renderTarget" translate="no">renderTarget</a>(). See the <a href="qtquick-scenegraph-customrendernode-example.html" translate="no">{Scene Graph - Custom QSGRenderNode}</a> example for details.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@prepare -->
<!-- $$$projectionMatrix[overload1]$$$projectionMatrix -->
<h3 class="fn" translate="no" id="projectionMatrix"><code class="details extra" translate="no">[since 6.5]</code> const <span class="type"><a href="../qtgui/qmatrix4x4.html" translate="no">QMatrix4x4</a></span> *QSGRenderNode::<span class="name">projectionMatrix</span>() const</h3>
<p>Returns pointer to the current projection matrix.</p>
<p>In <a href="qsgrendernode.html#render" translate="no">render</a>() this is the same matrix that is returned from <a href="qsgrendernode-renderstate.html#projectionMatrix" translate="no">RenderState::projectionMatrix</a>(). This getter exists so that <a href="qsgrendernode.html#prepare" translate="no">prepare</a>() also has a way to query the projection matrix.</p>
<p>When working with a modern graphics API, or Qt's own graphics abstraction layer, it is more than likely that one will want to load <code translate="no">*projectionMatrix() * *matrix()</code> into a uniform buffer. That is however something that needs to be done in <a href="qsgrendernode.html#prepare" translate="no">prepare</a>(), so outside the recording of a render pass. That is why both matrices are queriable directly from the <a href="qsgrendernode.html" translate="no">QSGRenderNode</a>, both in <a href="qsgrendernode.html#prepare" translate="no">prepare</a>() and <a href="qsgrendernode.html#render" translate="no">render</a>().</p>
<p>This function was introduced in Qt 6.5.</p>
<!-- @@@projectionMatrix -->
<!-- $$$rect[overload1]$$$rect -->
<h3 class="fn" translate="no" id="rect"><code class="details extra" translate="no">[virtual]</code> <span class="type"><a href="../qtcore/qrectf.html" translate="no">QRectF</a></span> QSGRenderNode::<span class="name">rect</span>() const</h3>
<p>Returns the bounding rectangle in item coordinates for the area <a href="qsgrendernode.html#render" translate="no">render</a>() touches. The value is only in use when <a href="qsgrendernode.html#flags" translate="no">flags</a>() includes <a href="qsgrendernode.html#RenderingFlag-enum" translate="no">BoundedRectRendering</a>, ignored otherwise.</p>
<p>Reporting the rectangle in combination with <a href="qsgrendernode.html#RenderingFlag-enum" translate="no">BoundedRectRendering</a> is particularly important with the <code translate="no">software</code> backend because otherwise having a rendernode in the scene would trigger fullscreen updates, skipping all partial update optimizations.</p>
<p>For rendernodes covering the entire area of a corresponding <a href="qquickitem.html" translate="no">QQuickItem</a> the return value will be (0, 0, item-&gt;width(), item-&gt;height()).</p>
<div class="admonition note">
<p><b>Note: </b>Nodes are also free to render outside the boundaries specified by the item's width and height, since the scenegraph nodes are not bounded by the <a href="qquickitem.html" translate="no">QQuickItem</a> geometry, as long as this is reported correctly from this function.</p>
</div>
<p><b>See also </b><a href="qsgrendernode.html#flags" translate="no">flags</a>().</p>
<!-- @@@rect -->
<!-- $$$releaseResources[overload1]$$$releaseResources -->
<h3 class="fn" translate="no" id="releaseResources"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QSGRenderNode::<span class="name">releaseResources</span>()</h3>
<p>This function is called when all custom graphics resources allocated by this node have to be freed immediately. In case the node does not directly allocate graphics resources (buffers, textures, render targets, fences, etc.) through the graphics API that is in use, there is nothing to do here.</p>
<p>Failing to release all custom resources can lead to incorrect behavior in graphics device loss scenarios on some systems since subsequent reinitialization of the graphics system may fail.</p>
<div class="admonition note">
<p><b>Note: </b>Some scenegraph backends may choose not to call this function. Therefore it is expected that <a href="qsgrendernode.html" translate="no">QSGRenderNode</a> implementations perform cleanup both in their destructor and in releaseResources().</p>
</div>
<p>Unlike with the destructor, it is expected that <a href="qsgrendernode.html#render" translate="no">render</a>() can reinitialize all resources it needs when called after a call to releaseResources().</p>
<p>With OpenGL, the scenegraph's OpenGL context will be current both when calling the destructor and this function.</p>
<!-- @@@releaseResources -->
<!-- $$$render[overload1]$$$renderconstQSGRenderNode::RenderState* -->
<h3 class="fn" translate="no" id="render"><code class="details extra" translate="no">[pure virtual]</code> <span class="type">void</span> QSGRenderNode::<span class="name">render</span>(const <span class="type">QSGRenderNode::RenderState</span> *<i>state</i>)</h3>
<p>This function is called by the renderer and should paint this node with directly invoking commands in the graphics API (OpenGL, Direct3D, etc.) currently in use.</p>
<p>The effective opacity can be retrieved with <a href="qsgrendernode.html#inheritedOpacity" translate="no">inheritedOpacity</a>().</p>
<p>The projection matrix is available through <i translate="no">state</i>, while the model-view matrix can be fetched with <a href="qsgrendernode.html#matrix" translate="no">matrix</a>(). The combined matrix is then the projection matrix times the model-view matrix. The correct stacking of the items in the scene is ensured by the projection matrix.</p>
<p>When using the provided matrices, the coordinate system for vertex data follows the usual <a href="qquickitem.html" translate="no">QQuickItem</a> conventions: top-left is (0, 0), bottom-right is the corresponding <a href="qquickitem.html" translate="no">QQuickItem</a>'s width() and height() minus one. For example, assuming a two float (x-y) per vertex coordinate layout, a triangle covering half of the item can be specified as (width - 1, height - 1), (0, 0), (0, height - 1) using counter-clockwise direction.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qsgrendernode.html" translate="no">QSGRenderNode</a> is provided as a means to implement custom 2D or 2.5D Qt Quick items. It is not intended for integrating true 3D content into the Qt Quick scene. That use case is better supported by <a href="qquickframebufferobject.html" translate="no">QQuickFramebufferObject</a>, <a href="qquickwindow.html#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>(), or the equivalents of those for APIs other than OpenGL.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qsgrendernode.html" translate="no">QSGRenderNode</a> can perform significantly better than texture-based approaches (such as, <a href="qquickframebufferobject.html" translate="no">QQuickFramebufferObject</a>), especially on systems where the fragment processing power is limited. This is because it avoids rendering to a texture and then drawing a textured quad. Rather, <a href="qsgrendernode.html" translate="no">QSGRenderNode</a> allows recording draw calls in line with the scenegraph's other commands, avoiding an additional render target and the potentially expensive texturing and blending.</p>
</div>
<p>Clip information is calculated before the function is called. Implementations wishing to take clipping into account can set up scissoring or stencil based on the information in <i translate="no">state</i>. The stencil buffer is filled with the necessary clip shapes, but it is up to the implementation to enable stencil testing.</p>
<p>Some scenegraph backends, software in particular, use no scissor or stencil. There the clip region is provided as an ordinary <a href="../qtgui/qregion.html" translate="no">QRegion</a>.</p>
<p>When implementing a <a href="qsgrendernode.html" translate="no">QSGRenderNode</a> that uses <a href="../qtgui/qrhi.html" translate="no">QRhi</a> to render, query the <a href="../qtgui/qrhi.html" translate="no">QRhi</a> object from the <a href="qquickwindow.html" translate="no">QQuickWindow</a> via <a href="qquickwindow.html#rhi" translate="no">QQuickWindow::rhi</a>(). To get a <a href="../qtgui/qrhicommandbuffer.html" translate="no">QRhiCommandBuffer</a> for submitting work to, call <a href="qsgrendernode.html#commandBuffer" translate="no">commandBuffer</a>(). To query information about the active render target, call <a href="qsgrendernode.html#renderTarget" translate="no">renderTarget</a>(). See the <a href="qtquick-scenegraph-customrendernode-example.html" translate="no">{Scene Graph - Custom QSGRenderNode}</a> example for details.</p>
<p>With Qt 6 and its <a href="../qtgui/qrhi.html" translate="no">QRhi</a>-based scene graph renderer, no assumptions should be made about the active (OpenGL) state when this function is called, even when OpenGL is in use. Assume nothing about the pipelines and dynamic states bound on the command list/buffer when this function is called.</p>
<div class="admonition note">
<p><b>Note: </b>Depth writes are expected to be disabled. Enabling depth writes can lead to unexpected results, depending on the scenegraph backend in use and the content in the scene, so exercise caution with this.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>In Qt 6, <a href="qsgrendernode.html#changedStates" translate="no">changedStates</a>() has limited use. See the documentation for <a href="qsgrendernode.html#changedStates" translate="no">changedStates</a>() for more information.</p>
</div>
<p>With some graphics APIs, including when using <a href="../qtgui/qrhi.html" translate="no">QRhi</a> directly, it can be necessary to reimplement <a href="qsgrendernode.html#prepare" translate="no">prepare</a>() in addition, or alternatively connect to the <a href="qquickwindow.html#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>() signal. These are called/emitted before recording the beginning of a renderpass on the command buffer (vkCmdBeginRenderPass with Vulkan, or starting to encode via MTLRenderCommandEncoder in case of Metal. Recording copy operations cannot be done inside render() with such APIs. Rather, do such operations either in <a href="qsgrendernode.html#prepare" translate="no">prepare</a>() or the slot connected to beforeRendering (with DirectConnection).</p>
<p><b>See also </b><a href="qsgrendererinterface.html" translate="no">QSGRendererInterface</a> and <a href="qquickwindow.html#rendererInterface" translate="no">QQuickWindow::rendererInterface</a>().</p>
<!-- @@@render -->
<!-- $$$renderTarget[overload1]$$$renderTarget -->
<h3 class="fn" translate="no" id="renderTarget"><code class="details extra" translate="no">[since 6.6]</code> <span class="type"><a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a></span> *QSGRenderNode::<span class="name">renderTarget</span>() const</h3>
<p>Returns the current render target.</p>
<p>This is provided mainly to enable <a href="qsgrendernode.html#prepare" translate="no">prepare</a>() and <a href="qsgrendernode.html#render" translate="no">render</a>() implementations that use <a href="../qtgui/qrhi.html" translate="no">QRhi</a> accessing the <a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a>'s <a href="../qtgui/qrhirenderpassdescriptor.html" translate="no">renderPassDescriptor</a> or <a href="../qtgui/qrhirendertarget.html#pixelSize" translate="no">pixel size</a>.</p>
<p>To build a <a href="../qtgui/qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a>, which implies having to provide a <a href="../qtgui/qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a>, query the renderPassDescriptor from the render target. Be aware however that the render target may change over the lifetime of the custom <a href="qquickitem.html" translate="no">QQuickItem</a> and the <a href="qsgrendernode.html" translate="no">QSGRenderNode</a>. For example, consider what happens when dynamically setting <code translate="no">layer.enabled: true</code> on the item or an ancestor of it: this triggers rendering into a texture, not directly to the window, which means the <a href="qsgrendernode.html" translate="no">QSGRenderNode</a> is going to work with a different render target from then on. The new render target may then have a different pixel format, which can make already built graphics pipelines incompatible. This can be handled with logic such as the following:</p>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (m_pipeline <span class="operator">&amp;</span><span class="operator">&amp;</span> renderTarget()<span class="operator">-</span><span class="operator">&gt;</span>renderPassDescriptor()<span class="operator">-</span><span class="operator">&gt;</span>serializedFormat() <span class="operator">!</span><span class="operator">=</span> m_renderPassFormat) {
     <span class="keyword">delete</span> m_pipeline;
     m_pipeline <span class="operator">=</span> nullptr;
 }
 <span class="keyword">if</span> (<span class="operator">!</span>m_pipeline) {
     <span class="comment">// Build a new QRhiGraphicsPipeline.</span>
     <span class="comment">// ...</span>
     <span class="comment">// Store the serialized format for fast and simple comparisons later on.</span>
     m_renderPassFormat <span class="operator">=</span> renderTarget()<span class="operator">-</span><span class="operator">&gt;</span>renderPassDescriptor()<span class="operator">-</span><span class="operator">&gt;</span>serializedFormat();
 }
</pre>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qsgrendernode.html#commandBuffer" translate="no">commandBuffer</a>().</p>
<!-- @@@renderTarget -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
